
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>cleanup: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">quizapp/cmd/cleanup/main.go (0.0%)</option>
				
				<option value="file1">quizapp/cmd/cli-worker/main.go (0.0%)</option>
				
				<option value="file2">quizapp/cmd/reset-db/main.go (0.0%)</option>
				
				<option value="file3">quizapp/cmd/server/main.go (0.0%)</option>
				
				<option value="file4">quizapp/cmd/setup-test-db/main.go (0.0%)</option>
				
				<option value="file5">quizapp/cmd/worker/main.go (0.0%)</option>
				
				<option value="file6">quizapp/internal/config/config.go (85.7%)</option>
				
				<option value="file7">quizapp/internal/database/database.go (66.5%)</option>
				
				<option value="file8">quizapp/internal/handlers/admin_handler.go (55.6%)</option>
				
				<option value="file9">quizapp/internal/handlers/auth_handler.go (71.5%)</option>
				
				<option value="file10">quizapp/internal/handlers/error_utils.go (100.0%)</option>
				
				<option value="file11">quizapp/internal/handlers/quiz_handler.go (40.1%)</option>
				
				<option value="file12">quizapp/internal/handlers/route_listing.go (31.4%)</option>
				
				<option value="file13">quizapp/internal/handlers/router_factory.go (82.9%)</option>
				
				<option value="file14">quizapp/internal/handlers/settings_handler.go (84.7%)</option>
				
				<option value="file15">quizapp/internal/handlers/user_admin_handler.go (30.5%)</option>
				
				<option value="file16">quizapp/internal/handlers/utils.go (85.5%)</option>
				
				<option value="file17">quizapp/internal/handlers/worker_admin_handler.go (72.9%)</option>
				
				<option value="file18">quizapp/internal/middleware/auth.go (85.2%)</option>
				
				<option value="file19">quizapp/internal/models/models.go (100.0%)</option>
				
				<option value="file20">quizapp/internal/observability/global_tracer.go (2.5%)</option>
				
				<option value="file21">quizapp/internal/observability/logging.go (70.9%)</option>
				
				<option value="file22">quizapp/internal/observability/metrics.go (54.2%)</option>
				
				<option value="file23">quizapp/internal/observability/middleware.go (100.0%)</option>
				
				<option value="file24">quizapp/internal/observability/setup.go (88.2%)</option>
				
				<option value="file25">quizapp/internal/observability/tracing.go (66.7%)</option>
				
				<option value="file26">quizapp/internal/services/ai_service.go (67.0%)</option>
				
				<option value="file27">quizapp/internal/services/ai_service_templates.go (78.6%)</option>
				
				<option value="file28">quizapp/internal/services/cleanup_service.go (26.2%)</option>
				
				<option value="file29">quizapp/internal/services/learning_service.go (77.5%)</option>
				
				<option value="file30">quizapp/internal/services/oauth_service.go (62.9%)</option>
				
				<option value="file31">quizapp/internal/services/question_service.go (78.6%)</option>
				
				<option value="file32">quizapp/internal/services/test_utils.go (77.4%)</option>
				
				<option value="file33">quizapp/internal/services/user_service.go (71.5%)</option>
				
				<option value="file34">quizapp/internal/services/variety_service.go (80.2%)</option>
				
				<option value="file35">quizapp/internal/services/worker_service.go (72.0%)</option>
				
				<option value="file36">quizapp/internal/utils/errors.go (100.0%)</option>
				
				<option value="file37">quizapp/internal/utils/security.go (100.0%)</option>
				
				<option value="file38">quizapp/internal/worker/worker.go (75.8%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Package main is the main package for the cleanup tool.
package main

import (
        "context"
        "flag"
        "fmt"

        "quizapp/internal/config"
        "quizapp/internal/database"
        "quizapp/internal/observability"
        "quizapp/internal/services"
)

// fatalIfErr logs the error with context and panics with a consistent message
func fatalIfErr(ctx context.Context, logger *observability.Logger, msg string, err error, fields map[string]interface{}) <span class="cov0" title="0">{
        logger.Error(ctx, msg, err, fields)
        panic(msg + ": " + err.Error())</span>
}

func main() <span class="cov0" title="0">{
        ctx := context.Background()
        var (
                statsOnly = flag.Bool("stats", false, "Only show cleanup statistics, don't perform cleanup")
                help      = flag.Bool("help", false, "Show help information")
        )
        flag.Parse()

        if *help </span><span class="cov0" title="0">{
                fmt.Println("Database Cleanup Tool")
                fmt.Println("Usage: cleanup [options]")
                fmt.Println()
                fmt.Println("Options:")
                flag.PrintDefaults()
                fmt.Println()
                fmt.Println("Examples:")
                fmt.Println("  cleanup        # Run full cleanup")
                fmt.Println("  cleanup -stats # Show cleanup statistics only")
                return
        }</span>

        // Load configuration first
        <span class="cov0" title="0">cfg, err := config.NewConfig()
        if err != nil </span><span class="cov0" title="0">{
                panic("Failed to load configuration: " + err.Error())</span>
        }

        // Setup observability (tracing/metrics/logging)
        <span class="cov0" title="0">tp, mp, logger, err := observability.SetupObservability(&amp;cfg.OpenTelemetry, "cleanup")
        if err != nil </span><span class="cov0" title="0">{
                panic("Failed to initialize observability: " + err.Error())</span>
        }
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if tp != nil </span><span class="cov0" title="0">{
                        if err := tp.Shutdown(context.TODO()); err != nil </span><span class="cov0" title="0">{
                                logger.Warn(ctx, "Error shutting down tracer provider", map[string]interface{}{"error": err.Error(), "provider": "tracer"})
                        }</span>
                }
                <span class="cov0" title="0">if mp != nil </span><span class="cov0" title="0">{
                        if err := mp.Shutdown(context.TODO()); err != nil </span><span class="cov0" title="0">{
                                logger.Warn(ctx, "Error shutting down meter provider", map[string]interface{}{"error": err.Error(), "provider": "meter"})
                        }</span>
                }
        }()

        // Initialize database manager with logger
        <span class="cov0" title="0">dbManager := database.NewManager(logger)

        // Initialize database connection
        db, err := dbManager.InitDBWithoutMigrations(cfg.DatabaseURL)
        if err != nil </span><span class="cov0" title="0">{
                fatalIfErr(ctx, logger, "Failed to initialize database", err, map[string]interface{}{"db_url": cfg.DatabaseURL})
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := db.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Warn(ctx, "Error closing database", map[string]interface{}{"error": err.Error(), "db_url": cfg.DatabaseURL})
                }</span>
        }()

        // Initialize services
        <span class="cov0" title="0">cleanupService := services.NewCleanupServiceWithLogger(db, logger)

        if *statsOnly </span><span class="cov0" title="0">{
                // Show cleanup statistics only
                stats, err := cleanupService.GetCleanupStats(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        fatalIfErr(ctx, logger, "Failed to get cleanup stats", err, map[string]interface{}{"stats_only": true})
                }</span>

                <span class="cov0" title="0">fmt.Println("Database Cleanup Statistics:")
                fmt.Printf("  Legacy questions: %d\n", stats["legacy_questions"])
                fmt.Printf("  Orphaned responses: %d\n", stats["orphaned_responses"])

                total := stats["legacy_questions"] + stats["orphaned_responses"]
                if total == 0 </span><span class="cov0" title="0">{
                        fmt.Println("‚úÖ No cleanup needed - database is clean!")
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("‚ö†Ô∏è  Total items that would be cleaned up: %d\n", total)
                }</span>
                <span class="cov0" title="0">return</span>
        }

        // Run full cleanup
        <span class="cov0" title="0">fmt.Println("Starting database cleanup...")
        logger.Info(ctx, "Starting database cleanup", map[string]interface{}{"service": "cleanup"})
        if err := cleanupService.RunFullCleanup(ctx); err != nil </span><span class="cov0" title="0">{
                fatalIfErr(ctx, logger, "Cleanup failed", err, map[string]interface{}{"service": "cleanup"})
        }</span>

        <span class="cov0" title="0">fmt.Println("‚úÖ Database cleanup completed successfully!")
        logger.Info(ctx, "Database cleanup completed successfully", map[string]interface{}{"service": "cleanup"})</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Package main provides a CLI tool for running the worker to generate questions for a specific user.
package main

import (
        "context"
        "flag"
        "fmt"
        "os"
        "strings"
        "time"

        "quizapp/internal/config"
        "quizapp/internal/database"
        "quizapp/internal/models"
        "quizapp/internal/observability"
        "quizapp/internal/services"
        "quizapp/internal/worker"
)

func main() <span class="cov0" title="0">{
        ctx := context.Background()
        // Define command line flags
        var (
                username     = flag.String("username", "", "Username to generate questions for (required)")
                level        = flag.String("level", "", "Override user's current level (optional)")
                language     = flag.String("language", "", "Override user's preferred language (optional)")
                questionType = flag.String("type", "vocabulary", "Question type: vocabulary, fill_blank, qa, reading_comprehension")
                topic        = flag.String("topic", "", "Specific topic for questions (optional)")
                count        = flag.Int("count", 5, "Number of questions to generate")
                aiProvider   = flag.String("ai-provider", "", "Override AI provider (optional)")
                aiModel      = flag.String("ai-model", "", "Override AI model (optional)")
                aiAPIKey     = flag.String("ai-api-key", "", "Override AI API key (optional)")
                help         = flag.Bool("help", false, "Show help message")
        )

        flag.Parse()

        if *help </span><span class="cov0" title="0">{
                printUsage(nil)
                return
        }</span>

        <span class="cov0" title="0">if *username == "" </span><span class="cov0" title="0">{
                panic("Error: --username flag is required")</span>
        }

        // Load configuration
        <span class="cov0" title="0">cfg, err := config.NewConfig()
        if err != nil </span><span class="cov0" title="0">{
                panic("Failed to load configuration: " + err.Error())</span>
        }

        // Setup observability (tracing/metrics/logging)
        <span class="cov0" title="0">tp, mp, logger, err := observability.SetupObservability(&amp;cfg.OpenTelemetry, "quiz-cli-worker")
        if err != nil </span><span class="cov0" title="0">{
                panic("Failed to initialize observability: " + err.Error())</span>
        }
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if tp != nil </span><span class="cov0" title="0">{
                        if err := tp.Shutdown(context.TODO()); err != nil </span><span class="cov0" title="0">{
                                logger.Warn(ctx, "Error shutting down tracer provider", map[string]interface{}{"error": err.Error()})
                        }</span>
                }
                <span class="cov0" title="0">if mp != nil </span><span class="cov0" title="0">{
                        if err := mp.Shutdown(context.TODO()); err != nil </span><span class="cov0" title="0">{
                                logger.Warn(ctx, "Error shutting down meter provider", map[string]interface{}{"error": err.Error()})
                        }</span>
                }
        }()

        <span class="cov0" title="0">logger.Info(ctx, "Starting quiz CLI worker", map[string]interface{}{
                "username":      *username,
                "question_type": *questionType,
                "count":         *count,
        })

        // Validate question type
        validTypes := map[string]models.QuestionType{
                "vocabulary":            models.Vocabulary,
                "fill_blank":            models.FillInBlank,
                "qa":                    models.QuestionAnswer,
                "reading_comprehension": models.ReadingComprehension,
        }

        qType, valid := validTypes[strings.ToLower(*questionType)]
        if !valid </span><span class="cov0" title="0">{
                logger.Error(ctx, "Invalid question type", nil, map[string]interface{}{"question_type": *questionType})
                panic("Error: Invalid question type '")</span>
        }

        // Validate level if provided
        <span class="cov0" title="0">if *level != "" </span><span class="cov0" title="0">{
                if !isValidLevel(*level, cfg.AppConfig.GetAllLevels()) </span><span class="cov0" title="0">{
                        logger.Error(ctx, "Invalid level", nil, map[string]interface{}{"level": *level})
                        panic("Error: Invalid level '")</span>
                }
        }

        // Validate language if provided (use dynamic list from config)
        <span class="cov0" title="0">validLanguages := cfg.AppConfig.GetLanguages()
        if *language != "" </span><span class="cov0" title="0">{
                if !isValidLanguage(*language, validLanguages) </span><span class="cov0" title="0">{
                        logger.Error(ctx, "Invalid language", nil, map[string]interface{}{"language": *language})
                        panic("Error: Invalid language '")</span>
                }
        }

        // Initialize database manager with logger
        <span class="cov0" title="0">dbManager := database.NewManager(logger)

        // Initialize database
        db, err := dbManager.InitDBWithoutMigrations(cfg.DatabaseURL)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error(ctx, "Failed to initialize database", err, nil)
                panic("Failed to initialize database: " + err.Error())</span>
        }
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := db.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Warn(ctx, "Warning: failed to close database", map[string]interface{}{"error": err.Error()})
                }</span>
        }()

        // Initialize services
        <span class="cov0" title="0">userService := services.NewUserServiceWithLogger(db, cfg, logger)
        learningService := services.NewLearningServiceWithLogger(db, cfg, logger)
        // Create question service
        questionService := services.NewQuestionServiceWithLogger(db, learningService, logger)
        aiService := services.NewAIService(cfg, logger)
        workerService := services.NewWorkerServiceWithLogger(db, logger)

        // Get user by username
        user, err := userService.GetUserByUsername(ctx, *username)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error(ctx, "Failed to get user", err, nil)
                panic("Failed to get user: " + err.Error())</span>
        }
        <span class="cov0" title="0">if user == nil </span><span class="cov0" title="0">{
                logger.Error(ctx, "User not found", nil, map[string]interface{}{"username": *username})
                panic("User not found: " + *username)</span>
        }
        <span class="cov0" title="0">logger.Info(ctx, "Found user", map[string]interface{}{"username": user.Username, "user_id": user.ID})

        // Apply AI overrides if provided
        if *aiProvider != "" </span><span class="cov0" title="0">{
                user.AIProvider.String = *aiProvider
                user.AIProvider.Valid = true
                user.AIEnabled.Bool = true
                user.AIEnabled.Valid = true
        }</span>
        <span class="cov0" title="0">if *aiModel != "" </span><span class="cov0" title="0">{
                user.AIModel.String = *aiModel
                user.AIModel.Valid = true
        }</span>
        <span class="cov0" title="0">if *aiAPIKey != "" </span><span class="cov0" title="0">{
                // Set AI provider and API key if provided
                if *aiProvider != "" &amp;&amp; *aiAPIKey != "" </span><span class="cov0" title="0">{
                        if err := userService.SetUserAPIKey(ctx, user.ID, *aiProvider, *aiAPIKey); err != nil </span><span class="cov0" title="0">{
                                logger.Error(ctx, "Failed to set API key", err, nil)
                                panic("Failed to set API key: " + err.Error())</span>
                        }
                } else<span class="cov0" title="0"> if *aiAPIKey != "" </span><span class="cov0" title="0">{
                        // If only API key is provided, use the user's current AI provider
                        if err := userService.SetUserAPIKey(ctx, user.ID, user.AIProvider.String, *aiAPIKey); err != nil </span><span class="cov0" title="0">{
                                logger.Error(ctx, "Failed to set API key", err, nil)
                                panic("Failed to set API key: " + err.Error())</span>
                        }
                }
        }

        // Check if user has AI enabled (after potential overrides)
        <span class="cov0" title="0">if !user.AIEnabled.Valid || !user.AIEnabled.Bool </span><span class="cov0" title="0">{
                logger.Warn(ctx, "User does not have AI enabled", map[string]interface{}{"username": user.Username, "user_id": user.ID})
                logger.Info(ctx, "You may want to enable AI for this user first or use --ai-provider flag")
        }</span>

        // Determine language and level to use
        <span class="cov0" title="0">languageToUse := user.PreferredLanguage.String
        if *language != "" </span><span class="cov0" title="0">{
                languageToUse = *language
        }</span>

        <span class="cov0" title="0">levelToUse := user.CurrentLevel.String
        if *level != "" </span><span class="cov0" title="0">{
                levelToUse = *level
        }</span>

        // Validate that we have required settings
        <span class="cov0" title="0">if languageToUse == "" </span><span class="cov0" title="0">{
                logger.Error(ctx, "No language specified", nil, map[string]interface{}{"username": user.Username, "user_id": user.ID})
                panic("Error: No language specified. User has no preferred language and --language flag not provided")</span>
        }
        <span class="cov0" title="0">if levelToUse == "" </span><span class="cov0" title="0">{
                logger.Error(ctx, "No level specified", nil, map[string]interface{}{"username": user.Username, "user_id": user.ID})
                panic("Error: No level specified. User has no current level and --level flag not provided")</span>
        }

        // Print configuration
        <span class="cov0" title="0">fmt.Printf("=== CLI Worker Configuration ===\n")
        fmt.Printf("User: %s (ID: %d)\n", user.Username, user.ID)
        fmt.Printf("Language: %s\n", languageToUse)
        fmt.Printf("Level: %s\n", levelToUse)
        fmt.Printf("Question Type: %s\n", qType)
        fmt.Printf("Count: %d\n", *count)
        if *topic != "" </span><span class="cov0" title="0">{
                fmt.Printf("Topic: %s\n", *topic)
        }</span>
        <span class="cov0" title="0">if user.AIProvider.Valid &amp;&amp; user.AIProvider.String != "" </span><span class="cov0" title="0">{
                fmt.Printf("AI Provider: %s\n", user.AIProvider.String)
        }</span>
        <span class="cov0" title="0">if user.AIModel.Valid &amp;&amp; user.AIModel.String != "" </span><span class="cov0" title="0">{
                fmt.Printf("AI Model: %s\n", user.AIModel.String)
        }</span>
        <span class="cov0" title="0">fmt.Printf("===============================\n\n")

        // Create a minimal worker instance for question generation
        workerInstance := worker.NewWorker(userService, questionService, aiService, learningService, workerService, "cli", cfg, logger)

        // Create context with timeout
        ctx, cancel := context.WithTimeout(ctx, config.CLIWorkerTimeout)
        defer cancel()

        // Log CLI worker start with structured logging
        logger.Info(ctx, "CLI worker starting question generation", map[string]interface{}{
                "user_id":       user.ID,
                "username":      user.Username,
                "question_type": qType,
                "count":         *count,
                "language":      languageToUse,
                "level":         levelToUse,
        })

        // Generate questions
        fmt.Printf("Starting question generation...\n")
        startTime := time.Now()

        result, err := workerInstance.GenerateQuestionsForUser(ctx, user, languageToUse, levelToUse, qType, *count, *topic)

        duration := time.Since(startTime)

        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("\n‚ùå Question generation failed after %v\n", duration)
                fmt.Printf("Error: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">fmt.Printf("\n‚úÖ Question generation completed successfully in %v\n", duration)
        fmt.Printf("Result: %s\n", result)</span>
}

func isValidLevel(level string, validLevels []string) bool <span class="cov0" title="0">{
        for _, validLevel := range validLevels </span><span class="cov0" title="0">{
                if strings.EqualFold(level, validLevel) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func isValidLanguage(language string, validLanguages []string) bool <span class="cov0" title="0">{
        for _, validLang := range validLanguages </span><span class="cov0" title="0">{
                if strings.EqualFold(language, validLang) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func printUsage(cfg *config.Config) <span class="cov0" title="0">{
        if cfg == nil || cfg.AppConfig == nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error: Configuration is missing or invalid.\n")
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">fmt.Printf("Usage: cli-worker [flags]\n")
        fmt.Printf("Flags:\n")
        fmt.Printf("  -language string\tLanguage to generate questions for\n")
        fmt.Printf("  -level string\tLevel to generate questions for\n")
        fmt.Printf("  -type string\tQuestion type (vocabulary, fill_in_blank, qa, reading_comprehension)\n")
        fmt.Printf("  -count int\tNumber of questions to generate (default 1)\n")
        fmt.Printf("  -topic string\tTopic for question generation\n")
        fmt.Printf("  -provider string\tAI provider to use\n")
        fmt.Printf("  -model string\tAI model to use\n")
        fmt.Printf("  -help\tShow this help message\n\n")

        fmt.Printf("Valid levels: %s\n", strings.Join(cfg.AppConfig.GetAllLevels(), ", "))
        fmt.Printf("Valid languages: %s\n", strings.Join(cfg.AppConfig.GetLanguages(), ", "))
        providerNames := make([]string, 0, len(cfg.AppConfig.Providers))
        for _, p := range cfg.AppConfig.Providers </span><span class="cov0" title="0">{
                providerNames = append(providerNames, p.Code)
        }</span>
        <span class="cov0" title="0">if len(providerNames) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("Valid AI providers: %s\n\n", strings.Join(providerNames, ", "))
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("Valid AI providers: (none configured)\n\n")
        }</span>
        <span class="cov0" title="0">fmt.Printf("Examples:\n")
        fmt.Printf("  cli-worker -language italian -level A1 -type vocabulary -count 5\n")
        fmt.Printf("  cli-worker -language japanese -level N5 -type fill_in_blank -count 3\n")</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">// Package main provides a utility to reset the database to a clean state.
package main

import (
        "bufio"
        "context"
        "fmt"
        "os"
        "strings"

        "quizapp/internal/config"
        "quizapp/internal/database"
        "quizapp/internal/observability"
        "quizapp/internal/services"
)

// fatalIfErr logs the error with context and panics with a consistent message
func fatalIfErr(ctx context.Context, logger *observability.Logger, msg string, err error, fields map[string]interface{}) <span class="cov0" title="0">{
        logger.Error(ctx, msg, err, fields)
        panic(msg + ": " + err.Error())</span>
}

func main() <span class="cov0" title="0">{
        ctx := context.Background()

        // Load configuration first
        cfg, err := config.NewConfig()
        if err != nil </span><span class="cov0" title="0">{
                panic("Failed to load configuration: " + err.Error())</span>
        }

        // Setup observability (tracing/metrics/logging)
        <span class="cov0" title="0">tp, mp, logger, err := observability.SetupObservability(&amp;cfg.OpenTelemetry, "reset-db")
        if err != nil </span><span class="cov0" title="0">{
                panic("Failed to initialize observability: " + err.Error())</span>
        }
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if tp != nil </span><span class="cov0" title="0">{
                        if err := tp.Shutdown(context.TODO()); err != nil </span><span class="cov0" title="0">{
                                logger.Warn(ctx, "Error shutting down tracer provider", map[string]interface{}{"error": err.Error(), "provider": "tracer"})
                        }</span>
                }
                <span class="cov0" title="0">if mp != nil </span><span class="cov0" title="0">{
                        if err := mp.Shutdown(context.TODO()); err != nil </span><span class="cov0" title="0">{
                                logger.Warn(ctx, "Error shutting down meter provider", map[string]interface{}{"error": err.Error(), "provider": "meter"})
                        }</span>
                }
        }()

        <span class="cov0" title="0">fmt.Println("‚ö†Ô∏è  DATABASE RESET UTILITY ‚ö†Ô∏è")
        fmt.Println("=============================")
        fmt.Println("This will PERMANENTLY DELETE ALL DATA in the database!")
        fmt.Println("This includes:")
        fmt.Println("- All users (including admin)")
        fmt.Println("- All questions")
        fmt.Println("- All user responses")
        fmt.Println("- All performance metrics")
        fmt.Println("")

        logger.Info(ctx, "Attempting to reset the database", map[string]interface{}{"service": "reset-db"})

        if cfg.DatabaseURL == "" </span><span class="cov0" title="0">{
                fatalIfErr(ctx, logger, "Database URL is empty", nil, map[string]interface{}{"error": "Database URL is empty. Cannot proceed with reset."})
        }</span>

        <span class="cov0" title="0">fmt.Printf("Database: %s\n", maskDatabaseURL(cfg.DatabaseURL))
        fmt.Println("")

        // Confirm with user
        if !confirmReset() </span><span class="cov0" title="0">{
                fmt.Println("Reset cancelled.")
                return
        }</span>

        // Initialize database manager with logger
        <span class="cov0" title="0">dbManager := database.NewManager(logger)

        // Initialize database
        db, err := dbManager.InitDB(cfg.DatabaseURL)
        if err != nil </span><span class="cov0" title="0">{
                fatalIfErr(ctx, logger, "Failed to connect to database", err, map[string]interface{}{"db_url": cfg.DatabaseURL})
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := db.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Warn(ctx, "Warning: failed to close database", map[string]interface{}{"error": err.Error(), "db_url": cfg.DatabaseURL})
                }</span>
        }()

        // Initialize services
        <span class="cov0" title="0">userService := services.NewUserServiceWithLogger(db, cfg, logger)

        // Perform reset
        fmt.Println("Resetting database...")
        logger.Info(ctx, "Resetting database", map[string]interface{}{"service": "reset-db"})
        // Reset the database
        if err := userService.ResetDatabase(ctx); err != nil </span><span class="cov0" title="0">{
                fatalIfErr(ctx, logger, "Failed to reset database", err, map[string]interface{}{"db_url": cfg.DatabaseURL})
        }</span>

        <span class="cov0" title="0">fmt.Println("‚úÖ Database reset completed successfully!")
        logger.Info(ctx, "Database reset completed successfully", map[string]interface{}{"service": "reset-db"})
        fmt.Println("")

        // Recreate admin user immediately
        fmt.Printf("Recreating admin user '%s'...\n", cfg.AdminUsername)
        logger.Info(ctx, "Recreating admin user", map[string]interface{}{"username": cfg.AdminUsername, "service": "reset-db"})
        // Ensure admin user exists
        if err := userService.EnsureAdminUserExists(ctx, cfg.AdminUsername, cfg.AdminPassword); err != nil </span><span class="cov0" title="0">{
                fatalIfErr(ctx, logger, "Failed to ensure admin user exists", err, map[string]interface{}{"admin_username": cfg.AdminUsername})
        }</span>

        <span class="cov0" title="0">fmt.Println("‚úÖ Admin user recreated successfully!")
        logger.Info(ctx, "Admin user recreated successfully", map[string]interface{}{"username": cfg.AdminUsername, "service": "reset-db"})
        fmt.Println("")
        fmt.Println("üîê Login Credentials:")
        fmt.Printf("   Username: %s\n", cfg.AdminUsername)
        fmt.Printf("   Password: %s\n", cfg.AdminPassword)
        fmt.Println("")
        fmt.Println("‚úÖ Database is now ready to use!")
        fmt.Println("- You can now start the server or use the existing running instance")
        fmt.Println("- Use the credentials above to log into the application")</span>
}

func confirmReset() bool <span class="cov0" title="0">{
        reader := bufio.NewReader(os.Stdin)

        for </span><span class="cov0" title="0">{
                fmt.Print("Are you sure you want to reset the database? (type 'yes' to confirm): ")
                response, err := reader.ReadString('\n')
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println("Error reading input:", err)
                        continue</span>
                }

                <span class="cov0" title="0">response = strings.TrimSpace(strings.ToLower(response))

                switch response </span>{
                case "yes":<span class="cov0" title="0">
                        return true</span>
                case "no", "":<span class="cov0" title="0">
                        return false</span>
                default:<span class="cov0" title="0">
                        fmt.Println("Please type 'yes' to confirm or 'no' to cancel.")</span>
                }
        }
}

func maskDatabaseURL(url string) string <span class="cov0" title="0">{
        // Simple masking for display purposes
        if strings.Contains(url, "@") </span><span class="cov0" title="0">{
                parts := strings.Split(url, "@")
                if len(parts) == 2 </span><span class="cov0" title="0">{
                        return "postgres://***:***@" + parts[1]
                }</span>
        }
        <span class="cov0" title="0">return url</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">// Package main provides the main entry point for the quiz application backend server.
// It sets up the HTTP server, database connections, middleware, and API routes.
package main

import (
        "context"

        "quizapp/internal/config"
        "quizapp/internal/database"
        "quizapp/internal/handlers"
        "quizapp/internal/observability"
        "quizapp/internal/services"
)

// fatalIfErr logs the error with context and panics with a consistent message
func fatalIfErr(ctx context.Context, logger *observability.Logger, msg string, err error, fields map[string]interface{}) <span class="cov0" title="0">{
        logger.Error(ctx, msg, err, fields)
        panic(msg + ": " + err.Error())</span>
}

func main() <span class="cov0" title="0">{
        ctx := context.Background()
        // Load configuration
        cfg, err := config.NewConfig()
        if err != nil </span><span class="cov0" title="0">{
                panic("Failed to load configuration: " + err.Error())</span>
        }

        // Setup observability (tracing/metrics/logging)
        <span class="cov0" title="0">tp, mp, logger, err := observability.SetupObservability(&amp;cfg.OpenTelemetry, "quiz-backend")
        if err != nil </span><span class="cov0" title="0">{
                panic("Failed to initialize observability: " + err.Error())</span>
        }
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if tp != nil </span><span class="cov0" title="0">{
                        if err := tp.Shutdown(context.TODO()); err != nil </span><span class="cov0" title="0">{
                                logger.Warn(ctx, "Error shutting down tracer provider", map[string]interface{}{"error": err.Error(), "provider": "tracer"})
                        }</span>
                }
                <span class="cov0" title="0">if mp != nil </span><span class="cov0" title="0">{
                        if err := mp.Shutdown(context.TODO()); err != nil </span><span class="cov0" title="0">{
                                logger.Warn(ctx, "Error shutting down meter provider", map[string]interface{}{"error": err.Error(), "provider": "meter"})
                        }</span>
                }
        }()

        <span class="cov0" title="0">logger.Info(ctx, "Starting quiz backend service", map[string]interface{}{
                "port":     cfg.Port,
                "logLevel": cfg.LogLevel,
        })

        // Initialize database manager with logger
        dbManager := database.NewManager(logger)

        // Initialize database connection with configuration
        db, err := dbManager.InitDBWithConfig(cfg.DatabaseURL, cfg.Database)
        if err != nil </span><span class="cov0" title="0">{
                fatalIfErr(ctx, logger, "Failed to connect to database", err, map[string]interface{}{"db_url": cfg.DatabaseURL})
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := db.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Warn(ctx, "Warning: failed to close database connection", map[string]interface{}{"error": err.Error(), "db_url": cfg.DatabaseURL})
                }</span>
        }()

        // Initialize services
        <span class="cov0" title="0">userService := services.NewUserServiceWithLogger(db, cfg, logger)
        learningService := services.NewLearningServiceWithLogger(db, cfg, logger)
        // Create question service
        questionService := services.NewQuestionServiceWithLogger(db, learningService, logger)
        aiService := services.NewAIService(cfg, logger)
        workerService := services.NewWorkerServiceWithLogger(db, logger)
        // Create OAuth service
        oauthService := services.NewOAuthServiceWithLogger(cfg, logger)

        // Ensure admin user exists
        if err := userService.EnsureAdminUserExists(ctx, cfg.AdminUsername, cfg.AdminPassword); err != nil </span><span class="cov0" title="0">{
                fatalIfErr(ctx, logger, "Failed to ensure admin user exists", err, map[string]interface{}{"admin_username": cfg.AdminUsername})
        }</span>

        // Use the new router factory
        <span class="cov0" title="0">router := handlers.NewRouter(
                cfg,
                userService,
                questionService,
                learningService,
                aiService,
                workerService,
                oauthService,
                logger,
        )

        logger.Info(ctx, "Starting server", map[string]interface{}{"port": cfg.Port})
        if err := router.Run(":" + cfg.Port); err != nil </span><span class="cov0" title="0">{
                fatalIfErr(ctx, logger, "Failed to start server", err, map[string]interface{}{"port": cfg.Port})
        }</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">// Package main provides a utility to set up the test database with initial data.
package main

import (
        "context"
        "database/sql"
        "fmt"
        "os"
        "path/filepath"
        "strings"
        "time"

        "quizapp/internal/config"
        "quizapp/internal/database"
        "quizapp/internal/models"
        "quizapp/internal/observability"
        "quizapp/internal/services"
        contextutils "quizapp/internal/utils"

        "gopkg.in/yaml.v3"
)

// TestUser represents a user in the test data files
type TestUser struct {
        Username          string `yaml:"username"`
        Email             string `yaml:"email"`
        Password          string `yaml:"password"` // Special field for password creation
        PreferredLanguage string `yaml:"preferred_language"`
        CurrentLevel      string `yaml:"current_level"`
        AIProvider        string `yaml:"ai_provider"`
        AIModel           string `yaml:"ai_model"`
        AIAPIKey          string `yaml:"ai_api_key"`
        APIKey            string `yaml:"api_key"`
}

// TestUsers represents a collection of test users
type TestUsers struct {
        Users []TestUser `yaml:"users"`
}

// TestQuestions represents a collection of test questions
type TestQuestions struct {
        Questions []models.Question `yaml:"questions"`
}

// TestResponses represents a collection of test user responses
type TestResponses struct {
        UserResponses []struct {
                Username       string `yaml:"username"`
                QuestionIndex  int    `yaml:"question_index"`
                UserAnswer     string `yaml:"user_answer"`
                IsCorrect      bool   `yaml:"is_correct"`
                ResponseTimeMs int    `yaml:"response_time_ms"`
        } `yaml:"user_responses"`
}

// TestAnalytics represents analytics test data
type TestAnalytics struct {
        PriorityScores []struct {
                Username         string  `yaml:"username"`
                QuestionIndex    int     `yaml:"question_index"`
                PriorityScore    float64 `yaml:"priority_score"`
                LastCalculatedAt string  `yaml:"last_calculated_at"`
        } `yaml:"priority_scores"`

        LearningPreferences []struct {
                Username             string  `yaml:"username"`
                FocusOnWeakAreas     bool    `yaml:"focus_on_weak_areas"`
                FreshQuestionRatio   float64 `yaml:"fresh_question_ratio"`
                WeakAreaBoost        float64 `yaml:"weak_area_boost"`
                KnownQuestionPenalty float64 `yaml:"known_question_penalty"`
                ReviewIntervalDays   int     `yaml:"review_interval_days"`
        } `yaml:"learning_preferences"`

        PerformanceMetrics []struct {
                Username              string  `yaml:"username"`
                Topic                 string  `yaml:"topic"`
                Language              string  `yaml:"language"`
                Level                 string  `yaml:"level"`
                TotalAttempts         int     `yaml:"total_attempts"`
                CorrectAttempts       int     `yaml:"correct_attempts"`
                AverageResponseTimeMs float64 `yaml:"average_response_time_ms"`
        } `yaml:"performance_metrics"`

        UserQuestionMetadata []struct {
                Username        string  `yaml:"username"`
                QuestionIndex   int     `yaml:"question_index"`
                MarkedAsKnown   bool    `yaml:"marked_as_known"`
                MarkedAsKnownAt *string `yaml:"marked_as_known_at"`
        } `yaml:"user_question_metadata"`
}

func resetTestDatabase(databaseURL, testDB string, logger *observability.Logger) error <span class="cov0" title="0">{
        ctx := context.Background()

        // Create admin connection string by replacing the database name with 'postgres'
        // This connects to the admin database to drop/create the test database
        adminConnStr := strings.Replace(databaseURL, "/"+testDB+"?", "/postgres?", 1)
        if !strings.Contains(adminConnStr, "/postgres?") </span><span class="cov0" title="0">{
                // Handle case where there's no query string
                adminConnStr = strings.Replace(databaseURL, "/"+testDB, "/postgres", 1)
        }</span>

        <span class="cov0" title="0">logger.Info(ctx, "Connecting to admin database", map[string]interface{}{"connection_string": adminConnStr})
        adminDB, err := sql.Open("postgres", adminConnStr)
        if err != nil </span><span class="cov0" title="0">{
                return contextutils.WrapErrorf(contextutils.ErrDatabaseConnection, "failed to connect to postgres database for drop/create: %v", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := adminDB.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Warn(ctx, "Warning: failed to close adminDB", map[string]interface{}{"error": err.Error()})
                }</span>
        }()

        <span class="cov0" title="0">logger.Info(ctx, "Terminating connections to test DB", map[string]interface{}{"database": testDB})
        _, err = adminDB.Exec(fmt.Sprintf(`
                SELECT pg_terminate_backend(pid)
                FROM pg_stat_activity
                WHERE datname = '%s' AND pid &lt;&gt; pg_backend_pid();
        `, testDB))
        if err != nil </span><span class="cov0" title="0">{
                logger.Warn(ctx, "Warning: failed to terminate connections", map[string]interface{}{"error": err.Error()})
        }</span>

        <span class="cov0" title="0">logger.Info(ctx, "Dropping test database", map[string]interface{}{"database": testDB})
        _, err = adminDB.Exec(fmt.Sprintf("DROP DATABASE IF EXISTS %s WITH (FORCE);", testDB))
        if err != nil </span><span class="cov0" title="0">{
                return contextutils.WrapErrorf(contextutils.ErrDatabaseQuery, "failed to drop test database: %v", err)
        }</span>
        <span class="cov0" title="0">logger.Info(ctx, "Successfully dropped test database", map[string]interface{}{"database": testDB})

        logger.Info(ctx, "Creating test database", map[string]interface{}{"database": testDB})
        _, err = adminDB.Exec(fmt.Sprintf("CREATE DATABASE %s;", testDB))
        if err != nil </span><span class="cov0" title="0">{
                return contextutils.WrapErrorf(contextutils.ErrDatabaseQuery, "failed to create test database: %v", err)
        }</span>
        <span class="cov0" title="0">logger.Info(ctx, "Successfully created test database", map[string]interface{}{"database": testDB})

        logger.Info(ctx, "Test database reset complete")
        return nil</span>
}

func main() <span class="cov0" title="0">{
        ctx := context.Background()

        // Load configuration first
        cfg, err := config.NewConfig()
        if err != nil </span><span class="cov0" title="0">{
                panic("Failed to load config: " + err.Error())</span>
        }

        // Setup observability (tracing/metrics/logging)
        <span class="cov0" title="0">tp, mp, logger, err := observability.SetupObservability(&amp;cfg.OpenTelemetry, "setup-test-db")
        if err != nil </span><span class="cov0" title="0">{
                panic("Failed to initialize observability: " + err.Error())</span>
        }
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if tp != nil </span><span class="cov0" title="0">{
                        if err := tp.Shutdown(context.TODO()); err != nil </span><span class="cov0" title="0">{
                                logger.Warn(ctx, "Error shutting down tracer provider", map[string]interface{}{"error": err.Error()})
                        }</span>
                }
                <span class="cov0" title="0">if mp != nil </span><span class="cov0" title="0">{
                        if err := mp.Shutdown(context.TODO()); err != nil </span><span class="cov0" title="0">{
                                logger.Warn(ctx, "Error shutting down meter provider", map[string]interface{}{"error": err.Error()})
                        }</span>
                }
        }()

        // Get DB connection info from env or use defaults
        <span class="cov0" title="0">dbUser := "quiz_user"
        dbPassword := "quiz_password"
        dbHost := "localhost"
        dbPort := "5433"
        testDB := "quiz_test_db"

        // Allow override from DATABASE_URL
        databaseURL := os.Getenv("DATABASE_URL")
        if databaseURL == "" </span><span class="cov0" title="0">{
                databaseURL = fmt.Sprintf("postgres://%s:%s@%s:%s/%s?sslmode=disable", dbUser, dbPassword, dbHost, dbPort, testDB)
        }</span>

        // Debug: Print the DATABASE_URL we're using
        <span class="cov0" title="0">logger.Info(ctx, "DATABASE_URL from environment", map[string]interface{}{"database_url": os.Getenv("DATABASE_URL")})
        logger.Info(ctx, "Using database URL", map[string]interface{}{"database_url": databaseURL})

        // --- Drop and recreate the test database ---
        if err := resetTestDatabase(databaseURL, testDB, logger); err != nil </span><span class="cov0" title="0">{
                logger.Error(ctx, "Failed to reset test database", err, nil)
                panic(err.Error())</span>
        }

        // Now connect to the new test database
        <span class="cov0" title="0">logger.Info(ctx, "Connecting to database", map[string]interface{}{"database_url": databaseURL})

        // Initialize database manager with logger
        dbManager := database.NewManager(logger)
        db, err := dbManager.InitDB(databaseURL)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error(ctx, "Failed to initialize database", err, nil)
                panic("Failed to initialize database: " + err.Error())</span>
        }
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := db.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Warn(ctx, "Warning: failed to close database", map[string]interface{}{"error": err.Error()})
                }</span>
        }()

        // Get the root directory (backend is the working directory)
        <span class="cov0" title="0">rootDir, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                logger.Error(ctx, "Failed to get working directory", err, nil)
                panic("Failed to get working directory: " + err.Error())</span>
        }

        // Apply schema from schema.sql
        <span class="cov0" title="0">schemaPath := filepath.Join(rootDir, "..", "schema.sql")
        if err := applySchema(db, schemaPath, rootDir, logger); err != nil </span><span class="cov0" title="0">{
                logger.Error(ctx, "Failed to apply schema", err, nil)
                panic("Failed to apply schema: " + err.Error())</span>
        }

        // Initialize services
        <span class="cov0" title="0">userService := services.NewUserServiceWithLogger(db, cfg, logger)
        learningService := services.NewLearningServiceWithLogger(db, cfg, logger)
        // Create question service
        questionService := services.NewQuestionServiceWithLogger(db, learningService, logger)

        // Ensure admin user exists
        if err := userService.EnsureAdminUserExists(ctx, "admin", "password"); err != nil </span><span class="cov0" title="0">{
                logger.Error(ctx, "Failed to ensure admin user exists", err, nil)
                panic("Failed to ensure admin user exists: " + err.Error())</span>
        }

        // Load and insert test data
        <span class="cov0" title="0">if err := setupTestData(ctx, rootDir, userService, questionService, learningService, db, logger); err != nil </span><span class="cov0" title="0">{
                logger.Error(ctx, "Failed to setup test data", err, nil)
                panic("Failed to setup test data: " + err.Error())</span>
        }

        <span class="cov0" title="0">logger.Info(ctx, "Test database created successfully")</span>
}

func applySchema(db *sql.DB, schemaPath, _ string, logger *observability.Logger) error <span class="cov0" title="0">{
        ctx := context.Background()

        // First, drop all existing tables and sequences to ensure clean state
        logger.Info(ctx, "Dropping existing tables and sequences")
        dropSQL := `
                -- Drop tables in reverse dependency order
                DROP TABLE IF EXISTS performance_metrics CASCADE;
                DROP TABLE IF EXISTS user_responses CASCADE;
                DROP TABLE IF EXISTS questions CASCADE;
                DROP TABLE IF EXISTS users CASCADE;

                -- Drop any remaining sequences (in case they weren't cleaned up)
                DROP SEQUENCE IF EXISTS users_id_seq CASCADE;
                DROP SEQUENCE IF EXISTS questions_id_seq CASCADE;
                DROP SEQUENCE IF EXISTS user_responses_id_seq CASCADE;
                DROP SEQUENCE IF EXISTS performance_metrics_id_seq CASCADE;
        `

        if _, err := db.Exec(dropSQL); err != nil </span><span class="cov0" title="0">{
                return contextutils.WrapErrorf(contextutils.ErrDatabaseQuery, "failed to drop existing tables: %w", err)
        }</span>

        // Now apply the schema
        <span class="cov0" title="0">logger.Info(ctx, "Applying schema")
        schemaSQL, err := os.ReadFile(schemaPath)
        if err != nil </span><span class="cov0" title="0">{
                return contextutils.WrapErrorf(contextutils.ErrDatabaseQuery, "failed to read schema file: %w", err)
        }</span>

        <span class="cov0" title="0">if _, err := db.Exec(string(schemaSQL)); err != nil </span><span class="cov0" title="0">{
                return contextutils.WrapErrorf(contextutils.ErrDatabaseQuery, "failed to execute schema: %w", err)
        }</span>

        // Priority system tables are already included in the main schema.sql
        // No additional migration needed
        <span class="cov0" title="0">logger.Info(ctx, "Priority system tables already included in main schema")

        return nil</span>
}

func setupTestData(ctx context.Context, rootDir string, userService *services.UserService, questionService *services.QuestionService, learningService *services.LearningService, db *sql.DB, logger *observability.Logger) error <span class="cov0" title="0">{
        dataDir := filepath.Join(rootDir, "data")

        // 1. Load and create users
        users, err := loadAndCreateUsers(ctx, filepath.Join(dataDir, "test_users.yaml"), userService, logger)
        if err != nil </span><span class="cov0" title="0">{
                return contextutils.WrapErrorf(contextutils.ErrDatabaseQuery, "failed to setup users: %w", err)
        }</span>

        // 2. Load and create questions
        <span class="cov0" title="0">questions, err := loadAndCreateQuestions(ctx, filepath.Join(dataDir, "test_questions.yaml"), questionService, users, logger)
        if err != nil </span><span class="cov0" title="0">{
                return contextutils.WrapErrorf(contextutils.ErrDatabaseQuery, "failed to setup questions: %w", err)
        }</span>

        // 3. Load and create user responses
        <span class="cov0" title="0">if err := loadAndCreateResponses(ctx, filepath.Join(dataDir, "test_responses.yaml"), users, questions, learningService, logger); err != nil </span><span class="cov0" title="0">{
                return contextutils.WrapErrorf(contextutils.ErrDatabaseQuery, "failed to setup responses: %w", err)
        }</span>

        // 4. Load and create analytics data
        <span class="cov0" title="0">if err := loadAndCreateAnalytics(ctx, filepath.Join(dataDir, "test_analytics.yaml"), users, questions, learningService, db, logger); err != nil </span><span class="cov0" title="0">{
                return contextutils.WrapErrorf(contextutils.ErrDatabaseQuery, "failed to setup analytics: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func loadAndCreateUsers(ctx context.Context, filePath string, userService *services.UserService, logger *observability.Logger) (result0 map[string]*models.User, err error) <span class="cov0" title="0">{
        data, err := os.ReadFile(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var testUsers TestUsers
        if err := yaml.Unmarshal(data, &amp;testUsers); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">users := make(map[string]*models.User)
        for _, testUser := range testUsers.Users </span><span class="cov0" title="0">{
                // Create user with email and timezone
                user, err := userService.CreateUserWithEmailAndTimezone(
                        ctx,
                        testUser.Username,
                        testUser.Email,
                        "UTC", // Default timezone for test users
                        testUser.PreferredLanguage,
                        testUser.CurrentLevel,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, contextutils.WrapErrorf(err, "failed to create user %s", testUser.Username)
                }</span>

                // Set password separately since CreateUserWithEmailAndTimezone doesn't set password
                <span class="cov0" title="0">if err := userService.UpdateUserPassword(ctx, user.ID, testUser.Password); err != nil </span><span class="cov0" title="0">{
                        return nil, contextutils.WrapErrorf(err, "failed to set password for user %s", testUser.Username)
                }</span>

                // Update additional settings
                <span class="cov0" title="0">settings := &amp;models.UserSettings{
                        Language:   testUser.PreferredLanguage,
                        Level:      testUser.CurrentLevel,
                        AIProvider: testUser.AIProvider,
                        AIModel:    testUser.AIModel,
                        AIAPIKey:   testUser.AIAPIKey,
                        AIEnabled:  testUser.AIProvider != "", // Enable AI if provider is set
                }

                if err := userService.UpdateUserSettings(ctx, user.ID, settings); err != nil </span><span class="cov0" title="0">{
                        return nil, contextutils.WrapErrorf(err, "failed to update settings for user %s", testUser.Username)
                }</span>

                <span class="cov0" title="0">users[testUser.Username] = user
                logger.Info(ctx, "Created user", map[string]interface{}{"username": testUser.Username, "user_id": user.ID, "email": user.Email.String})</span>
        }

        <span class="cov0" title="0">return users, nil</span>
}

func loadAndCreateQuestions(ctx context.Context, filePath string, questionService *services.QuestionService, users map[string]*models.User, logger *observability.Logger) (result0 []*models.Question, err error) <span class="cov0" title="0">{
        data, err := os.ReadFile(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var testQuestions TestQuestions
        if err := yaml.Unmarshal(data, &amp;testQuestions); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var questions []*models.Question
        for i, question := range testQuestions.Questions </span><span class="cov0" title="0">{
                // Set the created time since it's not in YAML
                question.CreatedAt = time.Now()

                // Get the users this question should be assigned to
                questionUsers := question.Users
                var assignedUserIDs []int
                if len(questionUsers) == 0 </span><span class="cov0" title="0">{
                        // Fallback to round-robin if no users specified
                        for _, user := range users </span><span class="cov0" title="0">{
                                assignedUserIDs = append(assignedUserIDs, user.ID)
                        }</span>
                        <span class="cov0" title="0">if len(assignedUserIDs) == 0 </span><span class="cov0" title="0">{
                                return nil, contextutils.ErrorWithContextf("no users available to assign questions to")
                        }</span>
                        // Assign to one user in round-robin
                        <span class="cov0" title="0">assignedUserIDs = []int{assignedUserIDs[i%len(assignedUserIDs)]}</span>
                } else<span class="cov0" title="0"> {
                        for _, username := range questionUsers </span><span class="cov0" title="0">{
                                user, exists := users[username]
                                if !exists </span><span class="cov0" title="0">{
                                        return nil, contextutils.ErrorWithContextf("user not found: %s", username)
                                }</span>
                                <span class="cov0" title="0">assignedUserIDs = append(assignedUserIDs, user.ID)</span>
                        }
                }

                <span class="cov0" title="0">if err := questionService.SaveQuestion(ctx, &amp;question); err != nil </span><span class="cov0" title="0">{
                        return nil, contextutils.WrapErrorf(err, "failed to save question %d", i)
                }</span>

                <span class="cov0" title="0">for _, userID := range assignedUserIDs </span><span class="cov0" title="0">{
                        if err := questionService.AssignQuestionToUser(ctx, question.ID, userID); err != nil </span><span class="cov0" title="0">{
                                return nil, contextutils.WrapErrorf(err, "failed to assign question %d to user %d", question.ID, userID)
                        }</span>
                        <span class="cov0" title="0">logger.Info(ctx, "Created question", map[string]interface{}{"question_type": question.Type, "question_id": question.ID, "assigned_user_id": userID})</span>
                }

                <span class="cov0" title="0">questions = append(questions, &amp;question)</span>
        }

        <span class="cov0" title="0">return questions, nil</span>
}

func loadAndCreateResponses(ctx context.Context, filePath string, users map[string]*models.User, questions []*models.Question, learningService *services.LearningService, logger *observability.Logger) error <span class="cov0" title="0">{
        data, err := os.ReadFile(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var testResponses TestResponses
        if err := yaml.Unmarshal(data, &amp;testResponses); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">for i, responseData := range testResponses.UserResponses </span><span class="cov0" title="0">{
                user, exists := users[responseData.Username]
                if !exists </span><span class="cov0" title="0">{
                        return contextutils.ErrorWithContextf("user not found: %s", responseData.Username)
                }</span>

                <span class="cov0" title="0">if responseData.QuestionIndex &gt;= len(questions) </span><span class="cov0" title="0">{
                        return contextutils.ErrorWithContextf("question index out of range: %d", responseData.QuestionIndex)
                }</span>

                <span class="cov0" title="0">question := questions[responseData.QuestionIndex]

                // Use RecordAnswerWithPriority to ensure priority scores are calculated
                if err := learningService.RecordAnswerWithPriority(
                        ctx,
                        user.ID,
                        question.ID,
                        responseData.UserAnswer,
                        responseData.IsCorrect,
                        responseData.ResponseTimeMs,
                ); err != nil </span><span class="cov0" title="0">{
                        return contextutils.WrapErrorf(err, "failed to record response %d", i)
                }</span>

                <span class="cov0" title="0">logger.Info(ctx, "Created response", map[string]interface{}{"username": responseData.Username, "question_id": question.ID, "is_correct": responseData.IsCorrect})</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func loadAndCreateAnalytics(ctx context.Context, filePath string, users map[string]*models.User, questions []*models.Question, learningService *services.LearningService, db *sql.DB, logger *observability.Logger) error <span class="cov0" title="0">{
        data, err := os.ReadFile(filePath)
        if err != nil </span><span class="cov0" title="0">{
                // Analytics file is optional, so just return if it doesn't exist
                logger.Warn(ctx, "Analytics file not found", map[string]interface{}{"file_path": filePath})
                return nil
        }</span>

        <span class="cov0" title="0">var testAnalytics TestAnalytics
        if err := yaml.Unmarshal(data, &amp;testAnalytics); err != nil </span><span class="cov0" title="0">{
                return contextutils.WrapError(err, "failed to parse analytics data")
        }</span>

        // Load priority scores
        <span class="cov0" title="0">for _, priorityData := range testAnalytics.PriorityScores </span><span class="cov0" title="0">{
                user, exists := users[priorityData.Username]
                if !exists </span><span class="cov0" title="0">{
                        return contextutils.ErrorWithContextf("user not found for priority score: %s", priorityData.Username)
                }</span>

                <span class="cov0" title="0">if priorityData.QuestionIndex &gt;= len(questions) </span><span class="cov0" title="0">{
                        return contextutils.ErrorWithContextf("question index out of range for priority score: %d", priorityData.QuestionIndex)
                }</span>

                <span class="cov0" title="0">question := questions[priorityData.QuestionIndex]

                // Parse the timestamp
                lastCalculatedAt, err := time.Parse(time.RFC3339, priorityData.LastCalculatedAt)
                if err != nil </span><span class="cov0" title="0">{
                        return contextutils.ErrorWithContextf("invalid timestamp format for priority score: %s", priorityData.LastCalculatedAt)
                }</span>

                // Insert priority score directly into database
                <span class="cov0" title="0">_, err = db.Exec(`
                        INSERT INTO question_priority_scores (user_id, question_id, priority_score, last_calculated_at, created_at, updated_at)
                        VALUES ($1, $2, $3, $4, NOW(), NOW())
                        ON CONFLICT (user_id, question_id) DO UPDATE SET
                                priority_score = EXCLUDED.priority_score,
                                last_calculated_at = EXCLUDED.last_calculated_at,
                                updated_at = NOW()
                `, user.ID, question.ID, priorityData.PriorityScore, lastCalculatedAt)
                if err != nil </span><span class="cov0" title="0">{
                        return contextutils.WrapError(err, "failed to insert priority score")
                }</span>

                <span class="cov0" title="0">logger.Info(ctx, "Created priority score", map[string]interface{}{"username": priorityData.Username, "question_id": question.ID, "priority_score": priorityData.PriorityScore})</span>
        }

        // Load learning preferences
        <span class="cov0" title="0">for _, prefData := range testAnalytics.LearningPreferences </span><span class="cov0" title="0">{
                user, exists := users[prefData.Username]
                if !exists </span><span class="cov0" title="0">{
                        return contextutils.ErrorWithContextf("user not found for learning preferences: %s", prefData.Username)
                }</span>

                <span class="cov0" title="0">prefs := &amp;models.UserLearningPreferences{
                        UserID:               user.ID,
                        FocusOnWeakAreas:     prefData.FocusOnWeakAreas,
                        FreshQuestionRatio:   prefData.FreshQuestionRatio,
                        WeakAreaBoost:        prefData.WeakAreaBoost,
                        KnownQuestionPenalty: prefData.KnownQuestionPenalty,
                        ReviewIntervalDays:   prefData.ReviewIntervalDays,
                }

                if _, err := learningService.UpdateUserLearningPreferences(ctx, user.ID, prefs); err != nil </span><span class="cov0" title="0">{
                        return contextutils.WrapErrorf(err, "failed to update learning preferences for user %s", prefData.Username)
                }</span>

                <span class="cov0" title="0">logger.Info(ctx, "Created learning preferences", map[string]interface{}{"username": prefData.Username})</span>
        }

        // Load performance metrics
        <span class="cov0" title="0">for _, metricData := range testAnalytics.PerformanceMetrics </span><span class="cov0" title="0">{
                user, exists := users[metricData.Username]
                if !exists </span><span class="cov0" title="0">{
                        return contextutils.ErrorWithContextf("user not found for performance metrics: %s", metricData.Username)
                }</span>

                // Insert performance metric directly into database
                <span class="cov0" title="0">_, err := db.Exec(`
                        INSERT INTO performance_metrics (user_id, topic, language, level, total_attempts, correct_attempts, average_response_time_ms, last_updated)
                        VALUES ($1, $2, $3, $4, $5, $6, $7, NOW())
                        ON CONFLICT (user_id, topic, language, level) DO UPDATE SET
                                total_attempts = EXCLUDED.total_attempts,
                                correct_attempts = EXCLUDED.correct_attempts,
                                average_response_time_ms = EXCLUDED.average_response_time_ms,
                                last_updated = NOW()
                `, user.ID, metricData.Topic, metricData.Language, metricData.Level,
                        metricData.TotalAttempts, metricData.CorrectAttempts, metricData.AverageResponseTimeMs)
                if err != nil </span><span class="cov0" title="0">{
                        return contextutils.WrapError(err, "failed to insert performance metric")
                }</span>

                <span class="cov0" title="0">logger.Info(ctx, "Created performance metric", map[string]interface{}{"username": metricData.Username, "topic": metricData.Topic, "language": metricData.Language, "level": metricData.Level})</span>
        }

        // Load user question metadata (marked as known)
        <span class="cov0" title="0">for _, metadata := range testAnalytics.UserQuestionMetadata </span><span class="cov0" title="0">{
                user, exists := users[metadata.Username]
                if !exists </span><span class="cov0" title="0">{
                        return contextutils.ErrorWithContextf("user not found for question metadata: %s", metadata.Username)
                }</span>

                <span class="cov0" title="0">if metadata.QuestionIndex &gt;= len(questions) </span><span class="cov0" title="0">{
                        return contextutils.ErrorWithContextf("question index out of range for metadata: %d", metadata.QuestionIndex)
                }</span>

                <span class="cov0" title="0">question := questions[metadata.QuestionIndex]

                if metadata.MarkedAsKnown </span><span class="cov0" title="0">{
                        var markedAt time.Time
                        if metadata.MarkedAsKnownAt != nil </span><span class="cov0" title="0">{
                                var err error
                                markedAt, err = time.Parse(time.RFC3339, *metadata.MarkedAsKnownAt)
                                if err != nil </span><span class="cov0" title="0">{
                                        return contextutils.ErrorWithContextf("invalid timestamp format for marked as known: %s", *metadata.MarkedAsKnownAt)
                                }</span>
                        } else<span class="cov0" title="0"> {
                                markedAt = time.Now()
                        }</span>

                        // Insert into user_question_metadata table
                        <span class="cov0" title="0">_, err := db.Exec(`
                                INSERT INTO user_question_metadata (user_id, question_id, marked_as_known, marked_as_known_at, created_at, updated_at)
                                VALUES ($1, $2, $3, $4, NOW(), NOW())
                                ON CONFLICT (user_id, question_id) DO UPDATE SET
                                        marked_as_known = EXCLUDED.marked_as_known,
                                        marked_as_known_at = EXCLUDED.marked_as_known_at,
                                        updated_at = NOW()
                        `, user.ID, question.ID, metadata.MarkedAsKnown, markedAt)
                        if err != nil </span><span class="cov0" title="0">{
                                return contextutils.WrapError(err, "failed to insert question metadata")
                        }</span>

                        <span class="cov0" title="0">logger.Info(ctx, "Created question metadata", map[string]interface{}{"username": metadata.Username, "question_id": question.ID, "marked_as_known": metadata.MarkedAsKnown})</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">// Package main provides the entry point for the Quiz Application worker service.
package main

import (
        "context"
        "io/fs"
        "net/http"
        "os"
        "os/signal"
        "syscall"
        "time"

        "quizapp/internal/config"
        "quizapp/internal/database"
        "quizapp/internal/handlers"
        "quizapp/internal/observability"
        "quizapp/internal/services"
        "quizapp/internal/version"
        "quizapp/internal/worker"

        "github.com/gin-contrib/sessions"
        "github.com/gin-contrib/sessions/cookie"
        "github.com/gin-gonic/gin"
)

// fatalIfErr logs the error with context and panics with a consistent message
func fatalIfErr(ctx context.Context, logger *observability.Logger, msg string, err error, fields map[string]interface{}) <span class="cov0" title="0">{
        logger.Error(ctx, msg, err, fields)
        panic(msg + ": " + err.Error())</span>
}

func main() <span class="cov0" title="0">{
        ctx := context.Background()

        // Load configuration
        cfg, err := config.NewConfig()
        if err != nil </span><span class="cov0" title="0">{
                panic("Failed to load configuration: " + err.Error())</span>
        }

        // Setup observability (tracing/metrics/logging)
        <span class="cov0" title="0">tp, mp, logger, err := observability.SetupObservability(&amp;cfg.OpenTelemetry, "quiz-worker")
        if err != nil </span><span class="cov0" title="0">{
                panic("Failed to initialize observability: " + err.Error())</span>
        }

        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if tp != nil </span><span class="cov0" title="0">{
                        if err := tp.Shutdown(context.TODO()); err != nil </span><span class="cov0" title="0">{
                                logger.Warn(ctx, "Error shutting down tracer provider", map[string]interface{}{"error": err.Error(), "provider": "tracer"})
                        }</span>
                }
                <span class="cov0" title="0">if mp != nil </span><span class="cov0" title="0">{
                        if err := mp.Shutdown(context.TODO()); err != nil </span><span class="cov0" title="0">{
                                logger.Warn(ctx, "Error shutting down meter provider", map[string]interface{}{"error": err.Error(), "provider": "meter"})
                        }</span>
                }
        }()

        <span class="cov0" title="0">logger.Info(ctx, "Starting quiz worker service", map[string]interface{}{"service": "worker"})

        // Initialize database manager with logger
        dbManager := database.NewManager(logger)

        // Initialize database with configuration
        db, err := dbManager.InitDBWithoutMigrationsWithConfig(cfg.DatabaseURL, cfg.Database)
        if err != nil </span><span class="cov0" title="0">{
                fatalIfErr(ctx, logger, "Failed to initialize database", err, map[string]interface{}{"db_url": cfg.DatabaseURL})
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := db.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Warn(ctx, "Warning: failed to close database", map[string]interface{}{"error": err.Error(), "db_url": cfg.DatabaseURL})
                }</span>
        }()

        // Initialize services
        <span class="cov0" title="0">userService := services.NewUserServiceWithLogger(db, cfg, logger)
        learningService := services.NewLearningServiceWithLogger(db, cfg, logger)
        // Create question service
        questionService := services.NewQuestionServiceWithLogger(db, learningService, logger)
        aiService := services.NewAIService(cfg, logger)
        workerService := services.NewWorkerServiceWithLogger(db, logger)

        // Initialize worker with the observability logger
        workerInstance := worker.NewWorker(userService, questionService, aiService, learningService, workerService, "default", cfg, logger)
        go workerInstance.Start(ctx)

        // Initialize admin handler for worker UI
        adminHandler := handlers.NewWorkerAdminHandlerWithLogger(userService, questionService, aiService, cfg, workerInstance, workerService, learningService, logger)

        // Setup Gin router
        gin.SetMode(gin.ReleaseMode)
        if cfg.Debug </span><span class="cov0" title="0">{
                gin.SetMode(gin.DebugMode)
        }</span>
        <span class="cov0" title="0">router := gin.New()
        router.Use(gin.Recovery())

        // Add HTTP request logging middleware using our observability logger
        router.Use(func(c *gin.Context) </span><span class="cov0" title="0">{
                start := time.Now()

                // Process request
                c.Next()

                // Log request details using our observability logger
                latency := time.Since(start)
                statusCode := c.Writer.Status()
                clientIP := c.ClientIP()
                method := c.Request.Method
                path := c.Request.URL.Path

                // Create structured log entry
                fields := map[string]interface{}{
                        "http.method":      method,
                        "http.path":        path,
                        "http.status_code": statusCode,
                        "http.latency_ms":  latency.Milliseconds(),
                        "http.client_ip":   clientIP,
                        "http.user_agent":  c.Request.UserAgent(),
                }

                // Add error message if present
                if len(c.Errors) &gt; 0 </span><span class="cov0" title="0">{
                        fields["http.error"] = c.Errors.String()
                }</span>

                // Log using our observability logger (goes to both stdout and OTLP)
                // Use appropriate log level based on status code
                <span class="cov0" title="0">if statusCode &gt;= 500 </span><span class="cov0" title="0">{
                        logger.Error(c.Request.Context(), "HTTP request failed", nil, fields)
                }</span> else<span class="cov0" title="0"> if statusCode &gt;= 400 </span><span class="cov0" title="0">{
                        logger.Warn(c.Request.Context(), "HTTP request warning", fields)
                }</span> else<span class="cov0" title="0"> {
                        logger.Info(c.Request.Context(), "HTTP request", fields)
                }</span>
        })

        // Add OpenTelemetry middleware for HTTP tracing with automatic error attributes
        <span class="cov0" title="0">router.Use(observability.GinMiddlewareWithErrorHandling("quiz-worker"))

        // Add CORS middleware
        router.Use(func(c *gin.Context) </span><span class="cov0" title="0">{
                c.Header("Access-Control-Allow-Origin", "*")
                c.Header("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
                c.Header("Access-Control-Allow-Headers", "Origin, Content-Type, Content-Length, Accept-Encoding, X-CSRF-Token, Authorization")

                if c.Request.Method == "OPTIONS" </span><span class="cov0" title="0">{
                        c.AbortWithStatus(204)
                        return
                }</span>

                <span class="cov0" title="0">c.Next()</span>
        })

        // Setup session middleware
        <span class="cov0" title="0">store := cookie.NewStore([]byte(cfg.SessionSecret))
        router.Use(sessions.Sessions("quiz-session", store))

        // Serve static assets (CSS/JS) for worker admin dashboard
        staticFS, _ := fs.Sub(handlers.AssetsFS, "templates/assets")
        router.StaticFS("/assets", http.FS(staticFS))

        // Health check endpoint
        router.GET("/health", func(c *gin.Context) </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{"status": "ok", "service": "worker"})
        }</span>)

        // Version endpoint
        <span class="cov0" title="0">router.GET("/version", func(c *gin.Context) </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "service":   "worker",
                        "version":   version.Version,
                        "commit":    version.Commit,
                        "buildTime": version.BuildTime,
                })
        }</span>)

        // Worker admin interface (shows worker status and controls)
        <span class="cov0" title="0">router.GET("/adminz", adminHandler.GetWorkerAdminPage)

        // Analytics page
        router.GET("/analyticsz", adminHandler.GetAnalyticsPage)

        // Config dump endpoint
        router.GET("/configz", adminHandler.GetConfigz)

        // API routes for worker management
        api := router.Group("/v1")
        </span><span class="cov0" title="0">{
                // Worker control endpoints
                worker := api.Group("/worker")
                </span><span class="cov0" title="0">{
                        worker.GET("/details", adminHandler.GetWorkerDetails)
                        worker.GET("/status", adminHandler.GetWorkerStatus)
                        worker.GET("/logs", adminHandler.GetActivityLogs)
                        worker.POST("/pause", adminHandler.PauseWorker)
                        worker.POST("/resume", adminHandler.ResumeWorker)
                        worker.POST("/trigger", adminHandler.TriggerWorkerRun)
                }</span>

                // User control endpoints for worker
                <span class="cov0" title="0">users := api.Group("/users")
                </span><span class="cov0" title="0">{
                        users.GET("/", adminHandler.GetUsers)
                        users.POST("/pause", adminHandler.PauseUser)
                        users.POST("/resume", adminHandler.ResumeUser)
                }</span>

                // System health for worker
                <span class="cov0" title="0">system := api.Group("/system")
                </span><span class="cov0" title="0">{
                        system.GET("/health", adminHandler.GetSystemHealth)
                }</span>

                // AI concurrency stats
                <span class="cov0" title="0">api.GET("/ai-concurrency", adminHandler.GetAIConcurrencyStats)

                // Analytics endpoints
                analytics := api.Group("/analytics")
                </span><span class="cov0" title="0">{
                        analytics.GET("/priority-scores", adminHandler.GetPriorityAnalytics)
                        analytics.GET("/user-performance", adminHandler.GetUserPerformanceAnalytics)
                        analytics.GET("/generation-intelligence", adminHandler.GetGenerationIntelligence)
                        analytics.GET("/system-health", adminHandler.GetSystemHealthAnalytics)
                        analytics.GET("/comparison", adminHandler.GetUserComparisonAnalytics)
                        analytics.GET("/user/:userID", adminHandler.GetUserPriorityAnalytics)
                }</span>
        }

        // Automatic route listing at root path
        <span class="cov0" title="0">routeListing := handlers.NewRouteListingHandler("Worker")
        routeListing.CollectRoutes(router)

        // Root path shows all available routes
        router.GET("/", func(c *gin.Context) </span><span class="cov0" title="0">{
                // Support JSON output via query parameter
                if c.Query("json") == "true" </span><span class="cov0" title="0">{
                        routeListing.GetRouteListingJSON(c)
                }</span> else<span class="cov0" title="0"> {
                        routeListing.GetRouteListingPage(c)
                }</span>
        })

        // Create HTTP server
        <span class="cov0" title="0">srv := &amp;http.Server{
                Addr:    ":" + cfg.WorkerPort,
                Handler: router,
        }

        // Start server in a goroutine
        go func() </span><span class="cov0" title="0">{
                logger.Info(ctx, "Worker server starting", map[string]interface{}{"port": cfg.WorkerPort})
                if err := srv.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        fatalIfErr(ctx, logger, "Failed to start worker server", err, map[string]interface{}{"port": cfg.WorkerPort})
                }</span>
        }()

        // Wait for interrupt signal to gracefully shutdown
        <span class="cov0" title="0">quit := make(chan os.Signal, 1)
        signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
        &lt;-quit
        logger.Info(ctx, "Worker server shutting down", map[string]interface{}{"service": "worker"})

        // Graceful shutdown with timeout
        shutdownCtx, shutdownCancel := context.WithTimeout(ctx, config.WorkerShutdownTimeout)
        defer shutdownCancel()

        // Shutdown the worker first
        if err := workerInstance.Shutdown(shutdownCtx); err != nil </span><span class="cov0" title="0">{
                logger.Warn(ctx, "Warning: failed to shutdown worker", map[string]interface{}{"error": err.Error(), "service": "worker"})
        }</span>

        // Then shutdown the server
        <span class="cov0" title="0">if err := srv.Shutdown(shutdownCtx); err != nil </span><span class="cov0" title="0">{
                fatalIfErr(ctx, logger, "Worker server forced to shutdown", err, map[string]interface{}{"service": "worker"})
        }</span>

        <span class="cov0" title="0">logger.Info(ctx, "Worker server exited", map[string]interface{}{"service": "worker"})</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">// Package config handles application configuration loading from environment variables.
package config

import (
        "os"
        "sort"
        "strconv"
        "strings"
        "time"

        contextutils "quizapp/internal/utils"

        "gopkg.in/yaml.v3"
)

// ProviderConfig defines the structure for a single provider
type ProviderConfig struct {
        Name              string    `json:"name" yaml:"name"`
        Code              string    `json:"code" yaml:"code"`
        URL               string    `json:"url,omitempty" yaml:"url,omitempty"`
        SupportsGrammar   bool      `json:"supports_grammar,omitempty" yaml:"supports_grammar,omitempty"`
        QuestionBatchSize int       `json:"question_batch_size,omitempty" yaml:"question_batch_size,omitempty"`
        Models            []AIModel `json:"models" yaml:"models"`
}

// AIModel represents an AI model configuration
type AIModel struct {
        Name      string `json:"name" yaml:"name"`
        Code      string `json:"code" yaml:"code"`
        MaxTokens int    `json:"max_tokens,omitempty" yaml:"max_tokens,omitempty"`
}

// QuestionVarietyConfig defines the variety configuration for question generation
type QuestionVarietyConfig struct {
        TopicCategories     []string            `json:"topic_categories" yaml:"topic_categories"`
        GrammarFocusByLevel map[string][]string `json:"grammar_focus_by_level" yaml:"grammar_focus_by_level"`
        GrammarFocus        []string            `json:"grammar_focus" yaml:"grammar_focus"`
        VocabularyDomains   []string            `json:"vocabulary_domains" yaml:"vocabulary_domains"`
        Scenarios           []string            `json:"scenarios" yaml:"scenarios"`
        StyleModifiers      []string            `json:"style_modifiers" yaml:"style_modifiers"`
        DifficultyModifiers []string            `json:"difficulty_modifiers" yaml:"difficulty_modifiers"`
        TimeContexts        []string            `json:"time_contexts" yaml:"time_contexts"`
}

// LanguageLevelConfig represents the levels and descriptions for a specific language
type LanguageLevelConfig struct {
        Levels       []string          `json:"levels" yaml:"levels"`
        Descriptions map[string]string `json:"descriptions" yaml:"descriptions"`
}

// AuthConfig represents authentication-related configuration
type AuthConfig struct {
        SignupsDisabled bool `json:"signups_disabled" yaml:"signups_disabled"`
}

// SystemConfig represents system-wide configuration
type SystemConfig struct {
        Auth AuthConfig `json:"auth" yaml:"auth"`
}

// AppConfig represents the top-level structure of the config.yaml file
type AppConfig struct {
        Providers      []ProviderConfig               `json:"providers" yaml:"providers"`
        LanguageLevels map[string]LanguageLevelConfig `json:"language_levels" yaml:"language_levels"`
        Variety        *QuestionVarietyConfig         `json:"variety,omitempty" yaml:"variety,omitempty"`
        System         *SystemConfig                  `json:"system,omitempty" yaml:"system,omitempty"`
}

// GetLanguages returns a slice of all supported languages (derived from language_levels keys)
func (ap *AppConfig) GetLanguages() []string <span class="cov1" title="2">{
        if ap.LanguageLevels == nil </span><span class="cov0" title="0">{
                return []string{}
        }</span>

        <span class="cov1" title="2">languages := make([]string, 0, len(ap.LanguageLevels))
        for lang := range ap.LanguageLevels </span><span class="cov4" title="12">{
                languages = append(languages, lang)
        }</span>

        // Sort languages to ensure consistent ordering
        <span class="cov1" title="2">sort.Strings(languages)
        return languages</span>
}

// GetLevelsForLanguage returns the levels available for a specific language
func (ap *AppConfig) GetLevelsForLanguage(language string) []string <span class="cov2" title="4">{
        if ap.LanguageLevels == nil </span><span class="cov0" title="0">{
                return []string{}
        }</span>

        <span class="cov2" title="4">if config, exists := ap.LanguageLevels[language]; exists </span><span class="cov2" title="3">{
                return config.Levels
        }</span>
        <span class="cov1" title="1">return []string{}</span>
}

// GetLevelDescriptionsForLanguage returns the level descriptions for a specific language
func (ap *AppConfig) GetLevelDescriptionsForLanguage(language string) map[string]string <span class="cov2" title="3">{
        if ap.LanguageLevels == nil </span><span class="cov0" title="0">{
                return map[string]string{}
        }</span>

        <span class="cov2" title="3">if config, exists := ap.LanguageLevels[language]; exists </span><span class="cov1" title="2">{
                return config.Descriptions
        }</span>
        <span class="cov1" title="1">return map[string]string{}</span>
}

// GetAllLevels returns all levels across all languages (for backward compatibility)
func (ap *AppConfig) GetAllLevels() []string <span class="cov1" title="2">{
        if ap.LanguageLevels == nil </span><span class="cov0" title="0">{
                return []string{}
        }</span>

        <span class="cov1" title="2">levelSet := make(map[string]bool)
        for _, config := range ap.LanguageLevels </span><span class="cov4" title="12">{
                for _, level := range config.Levels </span><span class="cov7" title="86">{
                        levelSet[level] = true
                }</span>
        }

        <span class="cov1" title="2">levels := make([]string, 0, len(levelSet))
        for level := range levelSet </span><span class="cov6" title="38">{
                levels = append(levels, level)
        }</span>

        // Sort levels to ensure consistent ordering
        <span class="cov1" title="2">sort.Strings(levels)
        return levels</span>
}

// GetAllLevelDescriptions returns all level descriptions across all languages (for backward compatibility)
func (ap *AppConfig) GetAllLevelDescriptions() map[string]string <span class="cov1" title="2">{
        if ap.LanguageLevels == nil </span><span class="cov0" title="0">{
                return map[string]string{}
        }</span>

        <span class="cov1" title="2">descriptions := make(map[string]string)
        for _, config := range ap.LanguageLevels </span><span class="cov4" title="12">{
                for level, desc := range config.Descriptions </span><span class="cov7" title="86">{
                        descriptions[level] = desc
                }</span>
        }
        <span class="cov1" title="2">return descriptions</span>
}

// Languages returns the available languages.
func (ap *AppConfig) Languages() []string <span class="cov1" title="1">{
        return ap.GetLanguages()
}</span>

// Levels returns all levels across all languages.
func (ap *AppConfig) Levels() []string <span class="cov1" title="1">{
        return ap.GetAllLevels()
}</span>

// LevelDescriptions returns all level descriptions across all languages.
func (ap *AppConfig) LevelDescriptions() map[string]string <span class="cov1" title="1">{
        return ap.GetAllLevelDescriptions()
}</span>

// IsSignupDisabled returns whether signups are disabled
func (ap *AppConfig) IsSignupDisabled() bool <span class="cov0" title="0">{
        if ap.System == nil </span><span class="cov0" title="0">{
                return false // Default to enabled if no system config
        }</span>
        <span class="cov0" title="0">return ap.System.Auth.SignupsDisabled</span>
}

// OpenTelemetryConfig holds all OpenTelemetry-related configuration
type OpenTelemetryConfig struct {
        Endpoint       string            // Default: "http://localhost:4317"
        Protocol       string            // "grpc" or "http", default: "grpc"
        Insecure       bool              // Default: true (for localhost)
        Headers        map[string]string // For authenticated endpoints
        ServiceName    string            // Default: "quiz-backend" or "quiz-worker"
        ServiceVersion string            // From version package
        EnableTracing  bool              // Default: true
        EnableMetrics  bool              // Default: true
        EnableLogging  bool              // Default: true (future)
        SamplingRate   float64           // Default: 1.0 (100%)
}

// DatabaseConfig holds database-specific configuration
type DatabaseConfig struct {
        MaxOpenConns    int           // Maximum number of open connections to the database
        MaxIdleConns    int           // Maximum number of idle connections in the pool
        ConnMaxLifetime time.Duration // Maximum amount of time a connection may be reused
}

// Config holds all configuration for the application
type Config struct {
        DatabaseURL     string
        SessionSecret   string
        AdminUsername   string
        AdminPassword   string
        Port            string
        WorkerPort      string
        OpenAIAPIKey    string
        OpenAIModel     string
        AnthropicAPIKey string
        OllamaAPIURL    string
        OllamaModel     string
        Debug           bool
        IsTest          bool
        LogLevel        string
        AppConfig       *AppConfig
        CORSOrigins     []string

        // Database configuration
        Database DatabaseConfig

        // AI concurrency limits
        MaxAIConcurrent int // Maximum concurrent AI requests globally
        MaxAIPerUser    int // Maximum concurrent AI requests per user

        // Only set the other service's base URL
        WorkerBaseURL  string // For backend: externally accessible worker base URL (e.g. http://localhost:8181)
        BackendBaseURL string // For worker: externally accessible backend base URL (e.g. http://localhost:8080)

        // OAuth Configuration
        GoogleOAuthClientID     string
        GoogleOAuthClientSecret string
        GoogleOAuthRedirectURL  string
        OpenTelemetry           OpenTelemetryConfig
}

// NewConfig loads configuration from environment variables
func NewConfig() (result0 *Config, err error) <span class="cov4" title="17">{ // Load AI provider configurations from YAML file with potential local overrides
        providerConfig, err := loadConfigWithOverrides()
        if err != nil </span><span class="cov1" title="1">{
                return nil, contextutils.WrapErrorf(contextutils.ErrInternalError, "failed to load AI provider config: %w", err)
        }</span>

        <span class="cov4" title="16">return &amp;Config{
                Port:                    getEnv("PORT", "8080"),
                WorkerPort:              getEnv("WORKER_PORT", "8081"),
                AdminUsername:           getEnv("ADMIN_USERNAME", "admin"),
                AdminPassword:           getEnv("ADMIN_PASSWORD", "password"),
                DatabaseURL:             getEnv("DATABASE_URL", "postgres://quiz_user:quiz_password@localhost:5432/quiz_db?sslmode=disable"),
                OpenAIAPIKey:            getEnv("OPENAI_API_KEY", ""),
                OpenAIModel:             getEnv("OPENAI_MODEL", ""),
                AnthropicAPIKey:         getEnv("ANTHROPIC_API_KEY", ""),
                OllamaAPIURL:            getEnv("OLLAMA_API_URL", ""),
                OllamaModel:             getEnv("OLLAMA_MODEL", ""),
                SessionSecret:           getEnv("SESSION_SECRET", "your-secret-key"),
                Debug:                   getEnvBool("DEBUG", false),
                IsTest:                  getEnvBool("IS_TEST", false),
                LogLevel:                getEnv("LOG_LEVEL", "info"),
                AppConfig:               providerConfig,
                CORSOrigins:             getCORSOrigins(),
                Database:                loadDatabaseConfig(),
                MaxAIConcurrent:         getEnvInt("MAX_AI_CONCURRENT", 10),
                MaxAIPerUser:            getEnvInt("MAX_AI_PER_USER", 3),
                WorkerBaseURL:           getEnv("WORKER_BASE_URL", "http://localhost:8081"),
                BackendBaseURL:          getEnv("BACKEND_BASE_URL", "http://localhost:8080"),
                GoogleOAuthClientID:     getEnv("GOOGLE_OAUTH_CLIENT_ID", ""),
                GoogleOAuthClientSecret: getEnv("GOOGLE_OAUTH_CLIENT_SECRET", ""),
                GoogleOAuthRedirectURL:  getEnv("GOOGLE_OAUTH_REDIRECT_URL", ""),
                OpenTelemetry:           loadOpenTelemetryConfig(),
        }, nil</span>
}

// IsSignupDisabled returns whether signups are disabled based on configuration
func (c *Config) IsSignupDisabled() bool <span class="cov0" title="0">{
        if c.AppConfig == nil </span><span class="cov0" title="0">{
                return false // Default to enabled if no config
        }</span>
        <span class="cov0" title="0">return c.AppConfig.IsSignupDisabled()</span>
}

// loadAppConfigFromEnv loads the config file from the QUIZ_CONFIG_FILE environment variable only
func loadAppConfigFromEnv() (result0 *AppConfig, err error) <span class="cov5" title="20">{
        if envPath := os.Getenv("QUIZ_CONFIG_FILE"); envPath != "" </span><span class="cov5" title="20">{
                if _, err := os.Stat(envPath); err == nil </span><span class="cov5" title="19">{
                        return loadAppConfigFromFile(envPath)
                }</span>
                <span class="cov1" title="1">return nil, contextutils.WrapErrorf(contextutils.ErrInternalError, "config file specified by QUIZ_CONFIG_FILE not found at path: %s", envPath)</span>
        }
        <span class="cov0" title="0">return nil, contextutils.WrapErrorf(contextutils.ErrInternalError, "QUIZ_CONFIG_FILE environment variable is not set")</span>
}

func loadAppConfigFromFile(path string) (result0 *AppConfig, err error) <span class="cov5" title="25">{
        if _, err := os.Stat(path); os.IsNotExist(err) </span><span class="cov1" title="1">{
                return nil, contextutils.WrapErrorf(contextutils.ErrInternalError, "config file not found at path: %s", path)
        }</span>

        <span class="cov5" title="23">yamlFile, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, contextutils.WrapErrorf(contextutils.ErrInternalError, "error reading config file: %w", err)
        }</span>

        <span class="cov5" title="23">var config AppConfig
        err = yaml.Unmarshal(yamlFile, &amp;config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, contextutils.WrapErrorf(contextutils.ErrInternalError, "error unmarshaling yaml: %w", err)
        }</span>

        <span class="cov5" title="23">return &amp;config, nil</span>
}

// loadConfigWithOverrides loads the merged config file
func loadConfigWithOverrides() (result0 *AppConfig, err error) <span class="cov5" title="19">{
        return loadAppConfigFromEnv()
}</span>

func getEnv(key, defaultValue string) string <span class="cov10" title="605">{
        if value := os.Getenv(key); value != "" </span><span class="cov6" title="47">{
                return value
        }</span>
        <span class="cov9" title="558">return defaultValue</span>
}

func getEnvBool(key string, defaultValue bool) bool <span class="cov7" title="127">{
        valStr := getEnv(key, "")
        if valStr == "" </span><span class="cov7" title="106">{
                return defaultValue
        }</span>
        <span class="cov5" title="21">val, err := strconv.ParseBool(valStr) // Handles "1", "t", "true", etc.
        if err != nil </span><span class="cov2" title="3">{
                return defaultValue
        }</span>
        <span class="cov5" title="18">return val</span>
}

func getEnvInt(key string, defaultValue int) int <span class="cov7" title="83">{
        valStr := getEnv(key, "")
        if valStr == "" </span><span class="cov7" title="81">{
                return defaultValue
        }</span>
        <span class="cov1" title="2">val, err := strconv.Atoi(valStr)
        if err != nil </span><span class="cov1" title="1">{
                return defaultValue
        }</span>
        <span class="cov1" title="1">return val</span>
}

func getCORSOrigins() []string <span class="cov5" title="21">{
        // Get CORS origins from environment variable, comma-separated
        corsOrigins := getEnv("CORS_ORIGINS", "")
        if corsOrigins == "" </span><span class="cov4" title="17">{
                // Default origins for development
                return []string{"http://localhost:3000", "http://localhost:3001", "http://localhost:5173"}
        }</span>

        // Special case: if CORS_ORIGINS is set to "localhost", allow any localhost port
        <span class="cov2" title="4">if corsOrigins == "localhost" </span><span class="cov0" title="0">{
                return []string{"http://localhost:*"}
        }</span>

        // Split by comma and trim whitespace
        <span class="cov2" title="4">origins := strings.Split(corsOrigins, ",")
        for i, origin := range origins </span><span class="cov4" title="9">{
                origins[i] = strings.TrimSpace(origin)
        }</span>

        <span class="cov2" title="4">return origins</span>
}

// loadDatabaseConfig loads database configuration from environment variables
func loadDatabaseConfig() DatabaseConfig <span class="cov4" title="16">{
        return DatabaseConfig{
                MaxOpenConns:    getEnvInt("DB_MAX_OPEN_CONNS", 25),
                MaxIdleConns:    getEnvInt("DB_MAX_IDLE_CONNS", 5),
                ConnMaxLifetime: time.Duration(getEnvInt("DB_CONN_MAX_LIFETIME_MINUTES", 5)) * time.Minute,
        }
}</span>

// loadOpenTelemetryConfig loads OpenTelemetry config from environment variables
func loadOpenTelemetryConfig() OpenTelemetryConfig <span class="cov5" title="20">{
        protocol := getEnv("OTEL_PROTOCOL", "grpc")
        endpoint := getEnv("OTEL_ENDPOINT", "localhost:4317")
        // Only add http:// prefix if protocol is http and not already present
        if protocol == "http" &amp;&amp; !strings.HasPrefix(endpoint, "http://") &amp;&amp; !strings.HasPrefix(endpoint, "https://") </span><span class="cov1" title="1">{
                endpoint = "http://" + endpoint
        }</span>

        <span class="cov5" title="20">return OpenTelemetryConfig{
                Endpoint:       endpoint,
                Protocol:       protocol,
                Insecure:       getEnvBool("OTEL_INSECURE", true),
                Headers:        parseHeaders(getEnv("OTEL_HEADERS", "")),
                ServiceName:    getEnv("OTEL_SERVICE_NAME", "quiz-backend"),
                ServiceVersion: getEnv("OTEL_SERVICE_VERSION", "dev"),
                EnableTracing:  getEnvBool("OTEL_ENABLE_TRACING", true),
                EnableMetrics:  getEnvBool("OTEL_ENABLE_METRICS", true),
                EnableLogging:  getEnvBool("OTEL_ENABLE_LOGGING", true),
                SamplingRate:   getEnvFloat("OTEL_SAMPLING_RATE", 1.0),
        }</span>
}

// parseHeaders parses a comma-separated key=value list into a map
func parseHeaders(headerStr string) map[string]string <span class="cov5" title="20">{
        headers := make(map[string]string)
        if headerStr == "" </span><span class="cov5" title="18">{
                return headers
        }</span>
        <span class="cov1" title="1">pairs := strings.Split(headerStr, ",")
        for _, pair := range pairs </span><span class="cov1" title="1">{
                kv := strings.SplitN(pair, "=", 2)
                if len(kv) == 2 </span><span class="cov1" title="1">{
                        headers[strings.TrimSpace(kv[0])] = strings.TrimSpace(kv[1])
                }</span>
        }
        <span class="cov1" title="1">return headers</span>
}

// getEnvFloat gets a float64 from env or returns default
func getEnvFloat(key string, defaultValue float64) float64 <span class="cov5" title="20">{
        val := os.Getenv(key)
        if val == "" </span><span class="cov5" title="18">{
                return defaultValue
        }</span>
        <span class="cov1" title="1">f, err := strconv.ParseFloat(val, 64)
        if err != nil </span><span class="cov0" title="0">{
                return defaultValue
        }</span>
        <span class="cov1" title="1">return f</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">// Package database provides database connection and migration functionality.
package database

import (
        "context"
        "database/sql"
        "errors"
        "fmt"
        "net/url"
        "os"
        "path/filepath"
        "strings"

        "quizapp/internal/config"
        "quizapp/internal/observability"
        contextutils "quizapp/internal/utils"

        // Import PostgreSQL driver for database/sql
        _ "github.com/lib/pq"
        semconv "go.opentelemetry.io/otel/semconv/v1.4.0"

        // Add golang-migrate imports
        "github.com/golang-migrate/migrate/v4"
        _ "github.com/golang-migrate/migrate/v4/database/postgres" // required for golang-migrate postgres driver
        _ "github.com/golang-migrate/migrate/v4/source/file"       // required for golang-migrate file source

        // OpenTelemetry SQL instrumentation
        "go.nhat.io/otelsql"
        "go.opentelemetry.io/otel/attribute"
        "go.opentelemetry.io/otel/codes"
        "go.opentelemetry.io/otel/trace"
)

// Manager handles database operations with proper logging
type Manager struct {
        logger *observability.Logger
}

// NewManager creates a new database manager with the provided logger
func NewManager(logger *observability.Logger) *Manager <span class="cov4" title="12">{
        return &amp;Manager{
                logger: logger,
        }
}</span>

// ErrTableAlreadyExists is returned when trying to create a table that already exists
var ErrTableAlreadyExists = errors.New("table already exists")

// DefaultDatabaseConfig returns the default database configuration
func DefaultDatabaseConfig() config.DatabaseConfig <span class="cov3" title="9">{
        return config.DatabaseConfig{
                MaxOpenConns:    25,
                MaxIdleConns:    5,
                ConnMaxLifetime: config.DatabaseConnMaxLifetime,
        }
}</span>

// InitDB initializes and returns a database connection with migrations
func (dm *Manager) InitDB(databaseURL string) (result0 *sql.DB, err error) <span class="cov2" title="4">{
        dbName := extractDatabaseName(databaseURL)
        _, span := observability.TraceDatabaseFunction(context.Background(), "InitDB",
                attribute.String("db.url", databaseURL),
                attribute.String("db.name", dbName),
                attribute.String("db.system", "postgresql"),
                attribute.Bool("migrations.enabled", true),
        )
        defer func() </span><span class="cov2" title="4">{
                if err != nil </span><span class="cov1" title="1">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov2" title="4">span.End()</span>
        }()
        <span class="cov2" title="4">return dm.InitDBWithConfig(databaseURL, DefaultDatabaseConfig())</span>
}

// InitDBWithConfig initializes and returns a database connection with migrations and custom config
func (dm *Manager) InitDBWithConfig(databaseURL string, config config.DatabaseConfig) (result0 *sql.DB, err error) <span class="cov2" title="4">{
        dbName := extractDatabaseName(databaseURL)
        _, span := observability.TraceDatabaseFunction(context.Background(), "InitDBWithConfig",
                attribute.String("db.url", databaseURL),
                attribute.String("db.name", dbName),
                attribute.String("db.system", "postgresql"),
                attribute.Bool("migrations.enabled", true),
                attribute.Int("db.max_open_conns", config.MaxOpenConns),
                attribute.Int("db.max_idle_conns", config.MaxIdleConns),
                attribute.String("db.conn_max_lifetime", config.ConnMaxLifetime.String()),
        )
        defer func() </span><span class="cov2" title="4">{
                if err != nil </span><span class="cov1" title="1">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov2" title="4">span.End()</span>
        }()
        <span class="cov2" title="4">db, err := dm.InitDBWithoutMigrationsWithConfig(databaseURL, config)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov2" title="3">if err := dm.RunMigrations(db); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="2">return db, nil</span>
}

// extractDatabaseName extracts the database name from a PostgreSQL connection string
func extractDatabaseName(databaseURL string) string <span class="cov5" title="37">{
        // Try to parse as URL first
        if u, err := url.Parse(databaseURL); err == nil &amp;&amp; u.Path != "" </span><span class="cov5" title="36">{
                // Remove leading slash and return the database name
                dbName := strings.TrimPrefix(u.Path, "/")
                if dbName != "" </span><span class="cov5" title="36">{
                        return dbName
                }</span>
        }

        // Fallback: try to extract from connection string format
        // postgres://user:pass@host:port/dbname?sslmode=disable
        <span class="cov1" title="1">if strings.Contains(databaseURL, "/") </span><span class="cov0" title="0">{
                parts := strings.Split(databaseURL, "/")
                if len(parts) &gt; 1 </span><span class="cov0" title="0">{
                        // Get the last part and remove query parameters
                        dbPart := parts[len(parts)-1]
                        if idx := strings.Index(dbPart, "?"); idx != -1 </span><span class="cov0" title="0">{
                                return dbPart[:idx]
                        }</span>
                        <span class="cov0" title="0">return dbPart</span>
                }
        }

        // Default fallback
        <span class="cov1" title="1">return "quiz_db"</span>
}

// InitDBWithoutMigrations initializes and returns a database connection without running migrations
func (dm *Manager) InitDBWithoutMigrations(databaseURL string) (result0 *sql.DB, err error) <span class="cov2" title="5">{
        dbName := extractDatabaseName(databaseURL)
        _, span := observability.TraceDatabaseFunction(context.Background(), "InitDBWithoutMigrations",
                attribute.String("db.url", databaseURL),
                attribute.String("db.name", dbName),
                attribute.String("db.system", "postgresql"),
                attribute.Bool("migrations.enabled", false),
        )
        defer func() </span><span class="cov2" title="5">{
                if err != nil </span><span class="cov0" title="0">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov2" title="5">span.End()</span>
        }()
        <span class="cov2" title="5">return dm.InitDBWithoutMigrationsWithConfig(databaseURL, DefaultDatabaseConfig())</span>
}

// InitDBWithoutMigrationsWithConfig initializes and returns a database connection without running migrations
func (dm *Manager) InitDBWithoutMigrationsWithConfig(databaseURL string, config config.DatabaseConfig) (result0 *sql.DB, err error) <span class="cov3" title="9">{ // Extract database name for OpenTelemetry tracing
        dbName := extractDatabaseName(databaseURL)
        _, span := observability.TraceDatabaseFunction(context.Background(), "InitDBWithoutMigrationsWithConfig",
                attribute.String("db.url", databaseURL),
                attribute.String("db.name", dbName),
                attribute.String("db.system", "postgresql"),
                attribute.Bool("migrations.enabled", false),
                attribute.Int("db.max_open_conns", config.MaxOpenConns),
                attribute.Int("db.max_idle_conns", config.MaxIdleConns),
                attribute.String("db.conn_max_lifetime", config.ConnMaxLifetime.String()),
        )
        defer func() </span><span class="cov3" title="9">{
                if err != nil </span><span class="cov1" title="1">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov3" title="9">span.End()</span>
        }()
        // Extract database name for OpenTelemetry tracing
        <span class="cov3" title="9">dbName = extractDatabaseName(databaseURL)

        // Use OpenTelemetry-instrumented driver for tracing with advanced options
        otelDriverName, err := otelsql.Register("postgres",
                otelsql.WithDatabaseName(dbName),
                otelsql.TraceQueryWithArgs(),
                otelsql.WithSystem(semconv.DBSystemPostgreSQL),
                // otelsql.TraceRowsClose(),
                otelsql.TraceRowsAffected(),
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, contextutils.WrapError(err, "failed to register otelsql driver")
        }</span>

        <span class="cov3" title="9">db, err := sql.Open(otelDriverName, databaseURL)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Set connection pool settings for PostgreSQL
        <span class="cov3" title="9">db.SetMaxOpenConns(config.MaxOpenConns)
        db.SetMaxIdleConns(config.MaxIdleConns)
        db.SetConnMaxLifetime(config.ConnMaxLifetime)

        if err := db.Ping(); err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov3" title="8">return db, nil</span>
}

// RunMigrations executes the application SQL schema and any pending migrations
func (dm *Manager) RunMigrations(db *sql.DB) (err error) <span class="cov2" title="5">{
        _, span := observability.TraceDatabaseFunction(context.Background(), "RunMigrations",
                attribute.String("db.system", "postgresql"),
                attribute.String("migration.type", "application_schema"),
        )
        defer func() </span><span class="cov2" title="5">{
                if err != nil </span><span class="cov0" title="0">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov2" title="5">span.End()</span>
        }()
        <span class="cov2" title="5">dm.logger.Info(context.Background(), "Starting database migrations...")

        // Run the main application schema first
        if err := dm.runApplicationSchema(db); err != nil </span><span class="cov0" title="0">{
                return contextutils.WrapError(err, "failed to run application schema")
        }</span>
        <span class="cov2" title="4">dm.logger.Info(context.Background(), "Application schema applied successfully")

        // Run golang-migrate migrations if directory exists
        if err := dm.runGolangMigrate(); err != nil </span><span class="cov0" title="0">{
                return contextutils.WrapError(err, "failed to run golang-migrate migrations")
        }</span>

        <span class="cov2" title="4">dm.logger.Info(context.Background(), "Database migrations completed successfully")
        return nil</span>
}

// runGolangMigrate runs migrations using golang-migrate from migrations
func (dm *Manager) runGolangMigrate() (err error) <span class="cov2" title="4">{
        migrationsPath, err := dm.GetMigrationsPath()
        if err != nil </span><span class="cov0" title="0">{
                dm.logger.Error(context.Background(), "Could not find migrations path", err)
                return err // HARD FAIL if migrations path is not set
        }</span>

        <span class="cov2" title="4">_, span := observability.TraceDatabaseFunction(context.Background(), "runGolangMigrate",
                attribute.String("db.system", "postgresql"),
                attribute.String("migration.type", "golang_migrate"),
                attribute.String("migration.path", migrationsPath),
        )
        defer func() </span><span class="cov2" title="4">{
                if err != nil </span><span class="cov0" title="0">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov2" title="4">span.End()</span>
        }()

        <span class="cov2" title="4">if migrationsPath == "" </span><span class="cov0" title="0">{
                err = errors.New("no golang-migrate migrations directory found")
                dm.logger.Error(context.Background(), "No golang-migrate migrations directory found, hard fail!", err)
                return err // HARD FAIL
        }</span>

        // Check if migrations directory exists and has migration files
        <span class="cov2" title="4">if _, statErr := os.Stat(migrationsPath); os.IsNotExist(statErr) </span><span class="cov0" title="0">{
                dm.logger.Error(context.Background(), "Migrations directory does not exist", statErr)
                err = statErr // HARD FAIL if directory does not exist
                return err
        }</span>

        // Check if there are any migration files in the directory
        <span class="cov2" title="4">files, err := os.ReadDir(migrationsPath)
        if err != nil </span><span class="cov0" title="0">{
                dm.logger.Error(context.Background(), "Could not read migrations directory", err)
                return err // HARD FAIL
        }</span>

        // Check if there are any .up.sql files
        <span class="cov2" title="4">hasMigrationFiles := false
        migrationFileCount := 0
        for _, file := range files </span><span class="cov2" title="4">{
                if !file.IsDir() &amp;&amp; strings.HasSuffix(file.Name(), ".up.sql") </span><span class="cov0" title="0">{
                        hasMigrationFiles = true
                        migrationFileCount++
                }</span>
        }

        <span class="cov2" title="4">span.SetAttributes(attribute.Int("migration.files.count", migrationFileCount))

        if !hasMigrationFiles </span><span class="cov2" title="4">{
                dm.logger.Info(context.Background(), fmt.Sprintf("No migration files found in %s. Skipping golang-migrate.", migrationsPath))
                return nil
        }</span>

        <span class="cov0" title="0">dbURL := os.Getenv("DATABASE_URL")
        if dbURL == "" </span><span class="cov0" title="0">{
                dbURL = os.Getenv("TEST_DATABASE_URL")
        }</span>
        <span class="cov0" title="0">if dbURL == "" </span><span class="cov0" title="0">{
                err = errors.New("database_url or test_database_url must be set for migrations")
                return err
        }</span>

        <span class="cov0" title="0">m, err := migrate.New(
                migrationsPath,
                dbURL,
        )
        if err != nil </span><span class="cov0" title="0">{
                err = contextutils.WrapError(err, "failed to initialize golang-migrate")
                return err
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if _, closeErr := m.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        dm.logger.Error(context.Background(), "Error closing migration", closeErr)
                }</span>
        }()

        <span class="cov0" title="0">err = m.Up()
        if err != nil &amp;&amp; err != migrate.ErrNoChange </span><span class="cov0" title="0">{
                err = contextutils.WrapError(err, "golang-migrate up failed")
                return err
        }</span>
        <span class="cov0" title="0">if err == migrate.ErrNoChange </span><span class="cov0" title="0">{
                dm.logger.Info(context.Background(), "No new golang-migrate migrations to apply.")
        }</span> else<span class="cov0" title="0"> {
                dm.logger.Info(context.Background(), "golang-migrate migrations applied successfully.")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// runApplicationSchema executes the main application schema.sql
func (dm *Manager) runApplicationSchema(db *sql.DB) (err error) <span class="cov2" title="5">{
        schemaPath, err := dm.getSchemaPath()
        if err != nil </span><span class="cov0" title="0">{
                err = contextutils.WrapError(err, "failed to find schema file")
                return err
        }</span>

        <span class="cov2" title="5">_, span := observability.TraceDatabaseFunction(context.Background(), "runApplicationSchema",
                attribute.String("db.system", "postgresql"),
                attribute.String("migration.type", "application_schema"),
                attribute.String("schema.path", schemaPath),
        )
        defer func() </span><span class="cov2" title="5">{
                if err != nil </span><span class="cov0" title="0">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov2" title="5">span.End()</span>
        }()
        // Get the schema file path relative to the project root
        <span class="cov2" title="5">schemaPath, err = dm.getSchemaPath()
        if err != nil </span><span class="cov0" title="0">{
                err = contextutils.WrapError(err, "failed to find schema file")
                return err
        }</span>

        // Read the schema file
        <span class="cov2" title="5">schemaSQL, err := os.ReadFile(schemaPath)
        if err != nil </span><span class="cov0" title="0">{
                err = contextutils.WrapError(err, "failed to read schema file")
                return err
        }</span>

        <span class="cov2" title="5">span.SetAttributes(attribute.Int("schema.file.size", len(schemaSQL)))

        // Parse SQL statements more carefully to handle comments and multi-line statements
        statements := dm.parseSchemaStatements(string(schemaSQL))

        span.SetAttributes(attribute.Int("schema.statements.count", len(statements)))

        // Execute table creation statements first
        var indexStatements []string
        for _, statement := range statements </span><span class="cov7" title="265">{
                statement = strings.TrimSpace(statement)
                if statement == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Separate index creation from table creation
                <span class="cov7" title="265">if strings.HasPrefix(strings.ToUpper(statement), "CREATE INDEX") </span><span class="cov7" title="155">{
                        indexStatements = append(indexStatements, statement)
                        continue</span>
                }

                <span class="cov6" title="110">_, execErr := db.Exec(statement)
                if execErr != nil </span><span class="cov0" title="0">{
                        // For backwards compatibility, ignore table exists errors
                        if !dm.isTableExistsError(execErr) </span><span class="cov0" title="0">{
                                err = contextutils.WrapErrorf(execErr, "failed to execute schema statement: %s", statement)
                                return err
                        }</span>
                }
        }

        <span class="cov2" title="5">span.SetAttributes(attribute.Int("schema.index_statements.count", len(indexStatements)))

        // Now execute index creation statements
        for _, statement := range indexStatements </span><span class="cov7" title="155">{
                _, execErr := db.Exec(statement)
                if execErr != nil </span><span class="cov0" title="0">{
                        // For backwards compatibility, ignore index exists errors
                        if !dm.isTableExistsError(execErr) </span><span class="cov0" title="0">{
                                err = contextutils.WrapErrorf(execErr, "failed to execute index statement: %s", statement)
                                return err
                        }</span>
                }
        }

        <span class="cov2" title="5">return nil</span>
}

// getSchemaPath finds the schema.sql file relative to the project root
func (dm *Manager) getSchemaPath() (result0 string, err error) <span class="cov4" title="12">{
        _, span := observability.TraceDatabaseFunction(context.Background(), "getSchemaPath",
                attribute.String("file.name", "schema.sql"),
        )
        defer func() </span><span class="cov4" title="12">{
                if err != nil </span><span class="cov0" title="0">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov4" title="12">span.End()</span>
        }()
        // Start from the current directory and work up to find schema.sql
        <span class="cov4" title="12">currentDir, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov4" title="12">span.SetAttributes(attribute.String("search.start_dir", currentDir))

        for </span><span class="cov5" title="48">{
                schemaPath := filepath.Join(currentDir, "schema.sql")
                if _, statErr := os.Stat(schemaPath); statErr == nil </span><span class="cov4" title="12">{
                        span.SetAttributes(attribute.String("schema.found_path", schemaPath))
                        return schemaPath, nil
                }</span>

                // Move up one directory
                <span class="cov5" title="36">parentDir := filepath.Dir(currentDir)
                if parentDir == currentDir </span><span class="cov0" title="0">{
                        // We've reached the root directory
                        span.SetAttributes(attribute.String("search.result", "not_found"))
                        err = contextutils.ErrorWithContextf("schema.sql not found in any parent directory")
                        return "", err
                }</span>
                <span class="cov5" title="36">currentDir = parentDir</span>
        }
}

// parseSchemaStatements parses SQL statements from a schema file
func (dm *Manager) parseSchemaStatements(schemaSQL string) []string <span class="cov3" title="6">{
        _, span := observability.TraceDatabaseFunction(context.Background(), "parseSchemaStatements",
                attribute.Int("input.length", len(schemaSQL)),
        )
        defer span.End()

        // Remove comments and normalize whitespace
        lines := strings.Split(schemaSQL, "\n")
        var cleanedLines []string
        inComment := false

        for _, line := range lines </span><span class="cov10" title="1410">{
                line = strings.TrimSpace(line)

                // Skip empty lines
                if line == "" </span><span class="cov3" title="6">{
                        continue</span>
                }

                // Handle multi-line comments
                <span class="cov9" title="1404">if strings.HasPrefix(line, "/*") </span><span class="cov0" title="0">{
                        inComment = true
                        continue</span>
                }
                <span class="cov9" title="1404">if strings.HasSuffix(line, "*/") </span><span class="cov0" title="0">{
                        inComment = false
                        continue</span>
                }
                <span class="cov9" title="1404">if inComment </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Skip single-line comments
                <span class="cov9" title="1404">if strings.HasPrefix(line, "--") </span><span class="cov7" title="156">{
                        continue</span>
                }

                <span class="cov9" title="1248">cleanedLines = append(cleanedLines, line)</span>
        }

        // Join lines and split by semicolon
        <span class="cov3" title="6">cleanedSQL := strings.Join(cleanedLines, " ")
        statements := strings.Split(cleanedSQL, ";")

        var result []string
        for _, stmt := range statements </span><span class="cov8" title="324">{
                stmt = strings.TrimSpace(stmt)
                if stmt != "" </span><span class="cov8" title="318">{
                        result = append(result, stmt)
                }</span>
        }

        <span class="cov3" title="6">span.SetAttributes(attribute.Int("statements.parsed", len(result)))
        return result</span>
}

// isTableExistsError checks if the error is due to a table already existing
func (dm *Manager) isTableExistsError(err error) bool <span class="cov1" title="1">{
        _, span := observability.TraceDatabaseFunction(context.Background(), "isTableExistsError")
        defer span.End()
        // Check for the sentinel error first
        if errors.Is(err, ErrTableAlreadyExists) </span><span class="cov0" title="0">{
                return true
        }</span>
        // Fallback to string matching for backwards compatibility
        <span class="cov1" title="1">return strings.Contains(err.Error(), "already exists")</span>
}

// GetMigrationsPath returns the path to the migrations directory
func (dm *Manager) GetMigrationsPath() (result0 string, err error) <span class="cov2" title="5">{
        _, span := observability.TraceDatabaseFunction(context.Background(), "GetMigrationsPath",
                attribute.String("migration.dir.name", "migrations"),
        )
        defer func() </span><span class="cov2" title="5">{
                if err != nil </span><span class="cov0" title="0">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov2" title="5">span.End()</span>
        }()
        // Start from the current directory and work up to find migrations directory
        <span class="cov2" title="5">currentDir, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov2" title="5">span.SetAttributes(attribute.String("search.start_dir", currentDir))

        for </span><span class="cov4" title="15">{
                migrationsPath := filepath.Join(currentDir, "migrations")
                if _, statErr := os.Stat(migrationsPath); statErr == nil </span><span class="cov2" title="5">{
                        span.SetAttributes(attribute.String("migration.found_path", migrationsPath))
                        return migrationsPath, nil
                }</span>

                // Move up one directory
                <span class="cov3" title="10">parentDir := filepath.Dir(currentDir)
                if parentDir == currentDir </span><span class="cov0" title="0">{
                        // We've reached the root directory
                        span.SetAttributes(attribute.String("search.result", "not_found"))
                        err = contextutils.ErrorWithContextf("migrations directory not found in any parent directory")
                        return "", err
                }</span>
                <span class="cov3" title="10">currentDir = parentDir</span>
        }
}
</pre>
		
		<pre class="file" id="file8" style="display: none">// Package handlers provides HTTP request handlers for the quiz application API.
package handlers

import (
        "context"
        "embed"
        "encoding/json"
        "html/template"
        "net/http"
        "strconv"
        "time"

        "quizapp/internal/config"
        "quizapp/internal/models"
        "quizapp/internal/observability"
        "quizapp/internal/services"

        "github.com/gin-gonic/gin"
        "github.com/hako/durafmt"
        "go.opentelemetry.io/otel/attribute"
)

//go:embed templates/backend_admin.html templates/dataz.html templates/user_admin.html templates/shared_nav.html templates/assets/js/dataz.js
//go:embed all:templates
//go:embed templates/assets/material-icons/*
var templatesFS embed.FS

// AdminHandler handles administrative HTTP requests and dashboard functionality
type AdminHandler struct {
        userService     services.UserServiceInterface
        questionService services.QuestionServiceInterface
        aiService       services.AIServiceInterface
        config          *config.Config
        templates       *template.Template
        learningService services.LearningServiceInterface
        workerService   services.WorkerServiceInterface
        logger          *observability.Logger
}

// NewAdminHandlerWithLogger creates a new AdminHandler with the provided services and logger.
func NewAdminHandlerWithLogger(userService services.UserServiceInterface, questionService services.QuestionServiceInterface, aiService services.AIServiceInterface, cfg *config.Config, learningService services.LearningServiceInterface, workerService services.WorkerServiceInterface, logger *observability.Logger) *AdminHandler <span class="cov10" title="7">{
        // Custom function to format time
        funcMap := template.FuncMap{
                "timeago": func(t time.Time) string </span><span class="cov6" title="3">{
                        return durafmt.Parse(time.Since(t)).LimitFirstN(1).String() + " ago"
                }</span>,
                "marshal": func(v interface{}) template.JS <span class="cov0" title="0">{
                        a, _ := json.MarshalIndent(v, "", "  ")
                        return template.JS(a)
                }</span>,
                "mul": func(a, b float64) float64 <span class="cov0" title="0">{
                        return a * b
                }</span>,
                "div": func(a, b float64) float64 <span class="cov0" title="0">{
                        if b == 0 </span><span class="cov0" title="0">{
                                return 0
                        }</span>
                        <span class="cov0" title="0">return a / b</span>
                },
                "float64": func(i interface{}) float64 <span class="cov0" title="0">{
                        switch v := i.(type) </span>{
                        case int:<span class="cov0" title="0">
                                return float64(v)</span>
                        case int32:<span class="cov0" title="0">
                                return float64(v)</span>
                        case int64:<span class="cov0" title="0">
                                return float64(v)</span>
                        case float32:<span class="cov0" title="0">
                                return float64(v)</span>
                        case float64:<span class="cov0" title="0">
                                return v</span>
                        default:<span class="cov0" title="0">
                                return 0</span>
                        }
                },
                "gt": func(a, b interface{}) bool <span class="cov0" title="0">{
                        switch av := a.(type) </span>{
                        case int:<span class="cov0" title="0">
                                if bv, ok := b.(int); ok </span><span class="cov0" title="0">{
                                        return av &gt; bv
                                }</span>
                        case int32:<span class="cov0" title="0">
                                if bv, ok := b.(int32); ok </span><span class="cov0" title="0">{
                                        return av &gt; bv
                                }</span>
                        case int64:<span class="cov0" title="0">
                                if bv, ok := b.(int64); ok </span><span class="cov0" title="0">{
                                        return av &gt; bv
                                }</span>
                        case float32:<span class="cov0" title="0">
                                if bv, ok := b.(float32); ok </span><span class="cov0" title="0">{
                                        return av &gt; bv
                                }</span>
                        case float64:<span class="cov0" title="0">
                                if bv, ok := b.(float64); ok </span><span class="cov0" title="0">{
                                        return av &gt; bv
                                }</span>
                        }
                        <span class="cov0" title="0">return false</span>
                },
                "add": func(a, b int) int <span class="cov1" title="1">{
                        return a + b
                }</span>,
                "jsonEscape": func(v interface{}) template.JS <span class="cov0" title="0">{
                        jsonBytes, _ := json.Marshal(v)
                        return template.JS(jsonBytes)
                }</span>,
        }

        <span class="cov10" title="7">tmpl, err := template.New("").Funcs(funcMap).ParseFS(templatesFS, "templates/*.html")
        if err != nil </span><span class="cov0" title="0">{
                logger.Error(context.Background(), "Failed to parse admin templates", err, map[string]interface{}{})
                panic(err)</span> // Use panic for fatal errors in template parsing
        }

        <span class="cov10" title="7">return &amp;AdminHandler{
                userService:     userService,
                questionService: questionService,
                aiService:       aiService,
                config:          cfg,
                templates:       tmpl,
                learningService: learningService,
                workerService:   workerService,
                logger:          logger,
        }</span>
}

// GetBackendAdminPage renders the backend administration dashboard
func (h *AdminHandler) GetBackendAdminPage(c *gin.Context) <span class="cov6" title="3">{
        ctx, span := observability.TraceHandlerFunction(c.Request.Context(), "get_backend_admin_page")
        defer span.End()

        // Get all users with progress and question stats
        users, err := h.userService.GetAllUsers(ctx)
        if err != nil </span><span class="cov0" title="0">{
                span.SetAttributes(attribute.String("error", err.Error()))
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get users"})
                return
        }</span>

        <span class="cov6" title="3">type UserWithProgress struct {
                User               models.User
                Progress           *models.UserProgress
                QuestionStats      *services.UserQuestionStats
                UserQuestionCounts map[string]interface{}
        }

        var usersWithProgress []UserWithProgress
        for _, user := range users </span><span class="cov6" title="3">{
                progress, err := h.learningService.GetUserProgress(ctx, user.ID)
                if err != nil </span><span class="cov0" title="0">{
                        h.logger.Warn(ctx, "Failed to get progress for user", map[string]interface{}{"user_id": user.ID, "error": err.Error()})
                        progress = &amp;models.UserProgress{
                                CurrentLevel:   "A1",
                                TotalQuestions: 0,
                                CorrectAnswers: 0,
                                AccuracyRate:   0,
                        }
                }</span>

                <span class="cov6" title="3">questionStats, err := h.learningService.GetUserQuestionStats(ctx, user.ID)
                if err != nil </span><span class="cov0" title="0">{
                        h.logger.Warn(ctx, "Failed to get question stats for user", map[string]interface{}{"user_id": user.ID, "error": err.Error()})
                        questionStats = &amp;services.UserQuestionStats{
                                UserID:        user.ID,
                                TotalAnswered: 0,
                        }
                }</span>

                // Get per-user question counts by type and level
                <span class="cov6" title="3">userQuestionCounts := make(map[string]interface{})

                // Use the available stats from UserQuestionStats
                if questionStats != nil </span><span class="cov6" title="3">{
                        userQuestionCounts["total_answered"] = questionStats.TotalAnswered
                        userQuestionCounts["answered_by_type"] = questionStats.AnsweredByType
                        userQuestionCounts["answered_by_level"] = questionStats.AnsweredByLevel
                        userQuestionCounts["accuracy_by_type"] = questionStats.AccuracyByType
                        userQuestionCounts["accuracy_by_level"] = questionStats.AccuracyByLevel
                        userQuestionCounts["available_by_type"] = questionStats.AvailableByType
                        userQuestionCounts["available_by_level"] = questionStats.AvailableByLevel
                }</span>

                <span class="cov6" title="3">usersWithProgress = append(usersWithProgress, UserWithProgress{
                        User:               user,
                        Progress:           progress,
                        QuestionStats:      questionStats,
                        UserQuestionCounts: userQuestionCounts,
                })</span>
        }

        // Get question statistics
        <span class="cov6" title="3">questionStats, err := h.questionService.GetDetailedQuestionStats(ctx)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Warn(ctx, "Failed to get question stats", map[string]interface{}{"error": err.Error()})
                questionStats = make(map[string]interface{})
        }</span>

        // Get worker health if available
        <span class="cov6" title="3">var workerHealth map[string]interface{}
        if h.workerService != nil </span><span class="cov6" title="3">{
                workerHealth, err = h.workerService.GetWorkerHealth(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        h.logger.Warn(ctx, "Failed to get worker health", map[string]interface{}{"error": err.Error()})
                        workerHealth = map[string]interface{}{
                                "error": "Failed to get worker health",
                        }
                }</span>
        }

        // Get AI concurrency stats
        <span class="cov6" title="3">aiStatsStruct := h.aiService.GetConcurrencyStats()
        aiConcurrencyStats := map[string]interface{}{
                "active_requests":   aiStatsStruct.ActiveRequests,
                "max_concurrent":    aiStatsStruct.MaxConcurrent,
                "queued_requests":   aiStatsStruct.QueuedRequests,
                "total_requests":    aiStatsStruct.TotalRequests,
                "user_active_count": aiStatsStruct.UserActiveCount,
                "max_per_user":      aiStatsStruct.MaxPerUser,
        }

        data := gin.H{
                "Title":              "Backend Administration",
                "Users":              usersWithProgress,
                "QuestionStats":      questionStats,
                "WorkerHealth":       workerHealth,
                "AIConcurrencyStats": aiConcurrencyStats,
                "IsBackend":          true,
                "WorkerPort":         h.config.WorkerPort,
                "CurrentPage":        "backend_admin",
                "WorkerBaseURL":      h.config.WorkerBaseURL,
        }

        // Try to render template, fallback to JSON if template fails
        if h.templates != nil </span><span class="cov6" title="3">{
                // Add no-cache headers
                c.Header("Content-Type", "text/html; charset=utf-8")
                c.Header("Cache-Control", "no-cache, no-store, must-revalidate")
                c.Header("Pragma", "no-cache")
                c.Header("Expires", "0")

                if err := h.templates.ExecuteTemplate(c.Writer, "backend_admin.html", data); err != nil </span><span class="cov0" title="0">{
                        h.logger.Error(ctx, "Template execution failed", err, map[string]interface{}{})
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to render template"})
                        return
                }</span>
        } else<span class="cov0" title="0"> {
                c.JSON(http.StatusOK, data)
        }</span>
}

// GetUsers returns all users in the system
func (h *AdminHandler) GetUsers(c *gin.Context) <span class="cov0" title="0">{
        users, err := h.userService.GetAllUsers(c.Request.Context())
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get users"})
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"users": users})</span>
}

// UserData represents user information combined with their progress data
type UserData struct {
        User     models.User
        Progress *models.UserProgress
}

// UserDataWithQuestions represents user information with questions and responses
type UserDataWithQuestions struct {
        User            models.User
        Progress        *models.UserProgress
        QuestionStats   *services.UserQuestionStats
        TotalQuestions  int
        TotalResponses  int
        RecentQuestions []string
        Questions       []*services.QuestionWithStats // Actual question objects with stats
}

// ReportedQuestionsData represents the structure for reported questions page data
type ReportedQuestionsData struct {
        Users             []UserDataWithQuestions
        ReportedQuestions []*services.ReportedQuestionWithUser
}

// ShowDatazPage renders the data visualization page for admins
func (h *AdminHandler) ShowDatazPage(c *gin.Context) <span class="cov1" title="1">{
        users, err := h.userService.GetAllUsers(c.Request.Context())
        if err != nil </span><span class="cov0" title="0">{
                c.String(http.StatusInternalServerError, "failed to get users: %v", err)
                return
        }</span>

        // Get reported questions
        <span class="cov1" title="1">reportedQuestions, err := h.questionService.GetReportedQuestions(c.Request.Context())
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Warn(c.Request.Context(), "Failed to get reported questions", map[string]interface{}{"error": err.Error()})
                reportedQuestions = []*services.ReportedQuestionWithUser{}
        }</span>

        <span class="cov1" title="1">data := ReportedQuestionsData{
                Users:             make([]UserDataWithQuestions, 0),
                ReportedQuestions: reportedQuestions,
        }

        for _, user := range users </span><span class="cov1" title="1">{
                progress, err := h.learningService.GetUserProgress(c.Request.Context(), user.ID)
                if err != nil </span><span class="cov0" title="0">{
                        // It's possible for a user to have no progress yet, so don't fail hard
                        progress = &amp;models.UserProgress{} // Assign an empty struct
                }</span>

                <span class="cov1" title="1">questionStats, err := h.learningService.GetUserQuestionStats(c.Request.Context(), user.ID)
                if err != nil </span><span class="cov0" title="0">{
                        questionStats = &amp;services.UserQuestionStats{
                                UserID:        user.ID,
                                TotalAnswered: 0,
                        }
                }</span>

                // Get user-specific counts
                <span class="cov1" title="1">totalQuestions, err := h.questionService.GetUserQuestionCount(c.Request.Context(), user.ID)
                if err != nil </span><span class="cov0" title="0">{
                        h.logger.Warn(c.Request.Context(), "Failed to get question count for user", map[string]interface{}{"user_id": user.ID, "error": err.Error()})
                        totalQuestions = 0
                }</span>

                <span class="cov1" title="1">totalResponses, err := h.questionService.GetUserResponseCount(c.Request.Context(), user.ID)
                if err != nil </span><span class="cov0" title="0">{
                        h.logger.Warn(c.Request.Context(), "Failed to get response count for user", map[string]interface{}{"user_id": user.ID, "error": err.Error()})
                        totalResponses = 0
                }</span>

                // Get recent question content samples
                <span class="cov1" title="1">recentQuestions, err := h.questionService.GetRecentQuestionContentsForUser(c.Request.Context(), user.ID, 5)
                if err != nil </span><span class="cov0" title="0">{
                        recentQuestions = []string{}
                }</span>

                // Get actual questions for this user (get all questions to include reported ones)
                <span class="cov1" title="1">questions, err := h.questionService.GetUserQuestionsWithStats(c.Request.Context(), user.ID, 1000)
                if err != nil </span><span class="cov0" title="0">{
                        questions = []*services.QuestionWithStats{}
                }</span>

                <span class="cov1" title="1">data.Users = append(data.Users, UserDataWithQuestions{
                        User:            user,
                        Progress:        progress,
                        QuestionStats:   questionStats,
                        TotalQuestions:  totalQuestions,
                        TotalResponses:  totalResponses,
                        RecentQuestions: recentQuestions,
                        Questions:       questions,
                })</span>
        }

        // Add no-cache headers
        <span class="cov1" title="1">c.Header("Content-Type", "text/html; charset=utf-8")
        c.Header("Cache-Control", "no-cache, no-store, must-revalidate")
        c.Header("Pragma", "no-cache")
        c.Header("Expires", "0")

        // Add navigation data
        templateData := gin.H{
                "Users":             data.Users,
                "ReportedQuestions": data.ReportedQuestions,
                "CurrentPage":       "dataz",
                "WorkerPort":        h.config.WorkerPort,
                "IsBackend":         true,
                "WorkerBaseURL":     h.config.WorkerBaseURL,
        }

        // Use the pre-loaded templates with all functions available
        err = h.templates.ExecuteTemplate(c.Writer, "dataz.html", templateData)
        if err != nil </span><span class="cov0" title="0">{
                c.String(http.StatusInternalServerError, "failed to render template: %v", err)
        }</span>
}

// MarkQuestionAsFixed marks a reported question as fixed and puts it back in rotation
func (h *AdminHandler) MarkQuestionAsFixed(c *gin.Context) <span class="cov1" title="1">{
        questionIDStr := c.Param("id")
        questionID, err := strconv.Atoi(questionIDStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid question ID"})
                return
        }</span>

        <span class="cov1" title="1">if err := h.questionService.MarkQuestionAsFixed(c.Request.Context(), questionID); err != nil </span><span class="cov0" title="0">{
                h.logger.Error(c.Request.Context(), "Failed to mark question as fixed", err, map[string]interface{}{"question_id": questionID})
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to mark question as fixed"})
                return
        }</span>

        <span class="cov1" title="1">c.JSON(http.StatusOK, gin.H{"message": "Question marked as fixed successfully"})</span>
}

// UpdateQuestion updates a question's content, correct answer, and explanation
func (h *AdminHandler) UpdateQuestion(c *gin.Context) <span class="cov4" title="2">{
        questionIDStr := c.Param("id")
        questionID, err := strconv.Atoi(questionIDStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid question ID"})
                return
        }</span>

        <span class="cov4" title="2">var req struct {
                Content       map[string]interface{} `json:"content" binding:"required"`
                CorrectAnswer int                    `json:"correct_answer" binding:"gte=0,lte=3"`
                Explanation   string                 `json:"explanation" binding:"required"`
        }

        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request format: " + err.Error()})
                return
        }</span>

        <span class="cov1" title="1">if err := h.questionService.UpdateQuestion(c.Request.Context(), questionID, req.Content, req.CorrectAnswer, req.Explanation); err != nil </span><span class="cov0" title="0">{
                h.logger.Error(c.Request.Context(), "Failed to update question", err, map[string]interface{}{"question_id": questionID})
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update question"})
                return
        }</span>

        <span class="cov1" title="1">c.JSON(http.StatusOK, gin.H{"success": true, "message": "Question updated successfully"})</span>
}

// FixQuestionWithAI uses AI to suggest fixes for a problematic question
func (h *AdminHandler) FixQuestionWithAI(c *gin.Context) <span class="cov1" title="1">{
        questionIDStr := c.Param("id")
        questionID, err := strconv.Atoi(questionIDStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid question ID"})
                return
        }</span>

        // Get the original question
        <span class="cov1" title="1">question, err := h.questionService.GetQuestionByID(c.Request.Context(), questionID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get question"})
                return
        }</span>

        // TODO: Create an AI prompt to fix the question when AIService is integrated

        // For now, return a placeholder response since we need to integrate with the AI service
        // TODO: Integrate with AIService once we have access to it in AdminHandler
        <span class="cov1" title="1">c.JSON(http.StatusOK, gin.H{
                "message": "AI fix functionality coming soon",
                "suggestion": gin.H{
                        "content":        question.Content,
                        "correct_answer": question.CorrectAnswer,
                        "explanation":    question.Explanation,
                },
        })</span>
}

// ServeDatazJS serves the JavaScript file for the dataz page
func (h *AdminHandler) ServeDatazJS(c *gin.Context) <span class="cov0" title="0">{
        jsContent, err := templatesFS.ReadFile("templates/assets/js/dataz.js")
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": "JavaScript file not found"})
                return
        }</span>

        <span class="cov0" title="0">c.Header("Content-Type", "application/javascript")
        c.String(http.StatusOK, string(jsContent))</span>
}

// GetAIConcurrencyStats returns AI service concurrency metrics
func (h *AdminHandler) GetAIConcurrencyStats(c *gin.Context) <span class="cov0" title="0">{
        // Get stats from the local AI service instance
        stats := h.aiService.GetConcurrencyStats()
        c.JSON(http.StatusOK, gin.H{
                "ai_concurrency": stats,
        })
}</span>

// ClearUserData removes all user activity data but keeps the users themselves
func (h *AdminHandler) ClearUserData(c *gin.Context) <span class="cov1" title="1">{
        err := h.userService.ClearUserData(c.Request.Context())
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error(c.Request.Context(), "Failed to clear user data", err, map[string]interface{}{})
                c.JSON(http.StatusInternalServerError, gin.H{"success": false, "error": "Failed to clear user data"})
                return
        }</span>

        <span class="cov1" title="1">c.JSON(http.StatusOK, gin.H{"success": true, "message": "User data cleared successfully (users preserved)"})</span>
}

// ClearDatabase completely resets the database to an empty state
func (h *AdminHandler) ClearDatabase(c *gin.Context) <span class="cov1" title="1">{
        err := h.userService.ResetDatabase(c.Request.Context())
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error(c.Request.Context(), "Failed to clear database", err, map[string]interface{}{})
                c.JSON(http.StatusInternalServerError, gin.H{"success": false, "error": "Failed to clear database"})
                return
        }</span>

        <span class="cov1" title="1">c.JSON(http.StatusOK, gin.H{"success": true, "message": "Database cleared successfully"})</span>
}

// GetQuestion returns a single question by ID for editing
func (h *AdminHandler) GetQuestion(c *gin.Context) <span class="cov4" title="2">{
        questionIDStr := c.Param("id")
        questionID, err := strconv.Atoi(questionIDStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid question ID"})
                return
        }</span>

        <span class="cov4" title="2">question, err := h.questionService.GetQuestionByID(c.Request.Context(), questionID)
        if err != nil </span><span class="cov1" title="1">{
                h.logger.Error(c.Request.Context(), "Failed to get question", err, map[string]interface{}{"question_id": questionID})
                c.JSON(http.StatusNotFound, gin.H{"error": "Question not found"})
                return
        }</span>

        <span class="cov1" title="1">c.JSON(http.StatusOK, question)</span>
}

// DeleteQuestion deletes a question by ID
func (h *AdminHandler) DeleteQuestion(c *gin.Context) <span class="cov1" title="1">{
        questionIDStr := c.Param("id")
        questionID, err := strconv.Atoi(questionIDStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid question ID"})
                return
        }</span>

        <span class="cov1" title="1">err = h.questionService.DeleteQuestion(c.Request.Context(), questionID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error(c.Request.Context(), "Failed to delete question", err, map[string]interface{}{"question_id": questionID})
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to delete question"})
                return
        }</span>

        <span class="cov1" title="1">c.JSON(http.StatusOK, gin.H{"message": "Question deleted successfully"})</span>
}

// GetQuestionsPaginated returns paginated questions with response statistics
func (h *AdminHandler) GetQuestionsPaginated(c *gin.Context) <span class="cov1" title="1">{
        userIDStr := c.Query("user_id")
        if userIDStr == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "user_id parameter is required"})
                return
        }</span>

        <span class="cov1" title="1">userID, err := strconv.Atoi(userIDStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid user_id parameter"})
                return
        }</span>

        // Parse pagination parameters
        <span class="cov1" title="1">pageStr := c.DefaultQuery("page", "1")
        pageSizeStr := c.DefaultQuery("page_size", "10")
        search := c.Query("search")
        typeFilter := c.Query("type")
        statusFilter := c.Query("status")

        page, err := strconv.Atoi(pageStr)
        if err != nil || page &lt; 1 </span><span class="cov0" title="0">{
                page = 1
        }</span>

        <span class="cov1" title="1">pageSize, err := strconv.Atoi(pageSizeStr)
        if err != nil || pageSize &lt; 1 </span><span class="cov0" title="0">{
                pageSize = 10
        }</span>
        <span class="cov1" title="1">if pageSize &gt; 100 </span><span class="cov0" title="0">{
                pageSize = 100 // Cap at 100 for performance
        }</span>

        <span class="cov1" title="1">questions, totalCount, err := h.questionService.GetQuestionsPaginated(c.Request.Context(), userID, page, pageSize, search, typeFilter, statusFilter)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get questions"})
                return
        }</span>

        <span class="cov1" title="1">totalPages := (totalCount + pageSize - 1) / pageSize

        c.JSON(http.StatusOK, gin.H{
                "success":      true,
                "questions":    questions,
                "total_count":  totalCount,
                "total_pages":  totalPages,
                "current_page": page,
                "page_size":    pageSize,
        })</span>
}

// ClearUserDataForUser removes all user activity data for a specific user but keeps the user record
func (h *AdminHandler) ClearUserDataForUser(c *gin.Context) <span class="cov1" title="1">{
        ctx, span := observability.TraceHandlerFunction(c.Request.Context(), "clear_user_data_for_user")
        defer span.End()
        userIDStr := c.Param("id")
        userID, err := strconv.Atoi(userIDStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"success": false, "error": "Invalid user ID"})
                return
        }</span>
        <span class="cov1" title="1">err = h.userService.ClearUserDataForUser(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error(ctx, "Failed to clear user data for user", err, map[string]interface{}{"user_id": userID})
                c.JSON(http.StatusInternalServerError, gin.H{"success": false, "error": "Failed to clear user data for user"})
                return
        }</span>
        <span class="cov1" title="1">c.JSON(http.StatusOK, gin.H{"success": true, "message": "User data cleared successfully (user preserved)"})</span>
}

// GetEmbeddedFS exposes embedded FS for static file serving
func GetEmbeddedFS() embed.FS <span class="cov10" title="7">{
        return templatesFS
}</span>

// GetConfigz returns the merged config as pretty-printed JSON
func (h *AdminHandler) GetConfigz(c *gin.Context) <span class="cov1" title="1">{
        _, span := observability.TraceHandlerFunction(c.Request.Context(), "get_configz")
        defer span.End()
        c.IndentedJSON(http.StatusOK, h.config)
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package handlers

import (
        "crypto/rand"
        "errors"
        "net/http"
        "regexp"
        "strings"
        "time"

        "quizapp/internal/api"
        "quizapp/internal/config"
        "quizapp/internal/middleware"
        "quizapp/internal/observability"
        "quizapp/internal/services"

        "github.com/gin-contrib/sessions"
        "github.com/gin-gonic/gin"
        openapi_types "github.com/oapi-codegen/runtime/types"
        "go.opentelemetry.io/otel/attribute"
)

// AuthHandler handles authentication related HTTP requests
type AuthHandler struct {
        userService  services.UserServiceInterface
        oauthService *services.OAuthService
        config       *config.Config
        logger       *observability.Logger
}

// NewAuthHandler creates a new AuthHandler instance
func NewAuthHandler(userService services.UserServiceInterface, oauthService *services.OAuthService, cfg *config.Config, logger *observability.Logger) *AuthHandler <span class="cov4" title="39">{
        return &amp;AuthHandler{
                userService:  userService,
                oauthService: oauthService,
                config:       cfg,
                logger:       logger,
        }
}</span>

// Login handles user login requests
func (h *AuthHandler) Login(c *gin.Context) <span class="cov4" title="59">{
        _, span := observability.TraceHandlerFunction(c.Request.Context(), "login")
        defer span.End()

        var req api.LoginRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov1" title="2">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request body"})
                return
        }</span>

        // Set span attributes for observability
        <span class="cov4" title="57">span.SetAttributes(
                attribute.String("auth.username", req.Username),
                attribute.Bool("auth.password_provided", req.Password != ""),
        )

        // Authenticate user against database
        user, err := h.userService.AuthenticateUser(c.Request.Context(), req.Username, req.Password)
        if err != nil </span><span class="cov2" title="8">{
                h.logger.Error(c.Request.Context(), "Authentication failed for user", err, map[string]interface{}{"username": req.Username})
                c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid credentials"})
                return
        }</span>

        <span class="cov4" title="49">if user == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid credentials"})
                return
        }</span>

        // Update span attributes with user info
        <span class="cov4" title="49">span.SetAttributes(
                attribute.Int("user.id", user.ID),
                attribute.String("user.username", user.Username),
                attribute.Bool("user.email_provided", user.Email.Valid),
                attribute.String("user.language", user.PreferredLanguage.String),
                attribute.String("user.level", user.CurrentLevel.String),
        )

        // Update last active
        if err := h.userService.UpdateLastActive(c.Request.Context(), user.ID); err != nil </span><span class="cov0" title="0">{
                // Log error but don't fail login
                // In production, you'd want proper logging here
                h.logger.Warn(c.Request.Context(), "Failed to update last active for user", map[string]interface{}{"user_id": user.ID, "error": err.Error()})
        }</span>

        // Create session
        <span class="cov4" title="49">session := sessions.Default(c)
        session.Set(middleware.UserIDKey, user.ID)
        session.Set(middleware.UsernameKey, user.Username)

        if err := session.Save(); err != nil </span><span class="cov0" title="0">{
                h.logger.Error(c.Request.Context(), "Failed to save session", err, map[string]interface{}{"error": err.Error()})
                c.JSON(http.StatusServiceUnavailable, api.ErrorResponse{
                        Error: stringPtr("Failed to create session"),
                })
                return
        }</span>

        // Convert models.User to api.User with proper API key checking
        <span class="cov4" title="49">apiUser := convertUserToAPIWithService(c.Request.Context(), user, h.userService)

        // Return user info (without API key)
        c.JSON(http.StatusOK, api.LoginResponse{
                Success: boolPtr(true),
                Message: stringPtr("Login successful"),
                User:    &amp;apiUser,
        })</span>
}

// Logout handles user logout requests
func (h *AuthHandler) Logout(c *gin.Context) <span class="cov2" title="4">{
        _, span := observability.TraceHandlerFunction(c.Request.Context(), "logout")
        defer span.End()

        // Get user info before clearing session for tracing
        session := sessions.Default(c)
        userID := session.Get(middleware.UserIDKey)
        username := session.Get(middleware.UsernameKey)

        // Set span attributes
        if userID != nil </span><span class="cov1" title="1">{
                span.SetAttributes(attribute.Int("user.id", userID.(int)))
        }</span>
        <span class="cov2" title="4">if username != nil </span><span class="cov0" title="0">{
                span.SetAttributes(attribute.String("user.username", username.(string)))
        }</span>

        <span class="cov2" title="4">session.Clear()

        if err := session.Save(); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusServiceUnavailable, api.ErrorResponse{
                        Error: stringPtr("Failed to clear session"),
                })
                return
        }</span>

        <span class="cov2" title="4">c.JSON(http.StatusOK, api.SuccessResponse{
                Success: boolPtr(true),
                Message: stringPtr("Logout successful"),
        })</span>
}

// Status returns the current authentication status
func (h *AuthHandler) Status(c *gin.Context) <span class="cov2" title="9">{
        _, span := observability.TraceHandlerFunction(c.Request.Context(), "status")
        defer span.End()

        session := sessions.Default(c)
        userID := session.Get(middleware.UserIDKey)

        if userID == nil </span><span class="cov2" title="6">{
                span.SetAttributes(attribute.Bool("auth.authenticated", false))
                c.JSON(http.StatusOK, gin.H{
                        "authenticated": false,
                        "user":          nil,
                })
                return
        }</span>

        <span class="cov1" title="3">span.SetAttributes(
                attribute.Bool("auth.authenticated", true),
                attribute.Int("user.id", userID.(int)),
        )

        user, err := h.userService.GetUserByID(c.Request.Context(), userID.(int))
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error(c.Request.Context(), "Error getting user by ID", err, map[string]interface{}{"user_id": userID.(int)})
                c.JSON(http.StatusServiceUnavailable, api.ErrorResponse{
                        Error: stringPtr("Internal server error"),
                })
                return
        }</span>

        <span class="cov1" title="3">if user == nil </span><span class="cov0" title="0">{
                // User not found, clear session
                session.Clear()
                if err := session.Save(); err != nil </span><span class="cov0" title="0">{
                        h.logger.Error(c.Request.Context(), "Error saving session", err, map[string]interface{}{"error": err.Error()})
                }</span>
                <span class="cov0" title="0">span.SetAttributes(attribute.Bool("auth.user_found", false))
                c.JSON(http.StatusOK, gin.H{
                        "authenticated": false,
                        "user":          nil,
                })
                return</span>
        }

        // Update span attributes with user info
        <span class="cov1" title="3">span.SetAttributes(
                attribute.Bool("auth.user_found", true),
                attribute.String("user.username", user.Username),
                attribute.Bool("user.email_provided", user.Email.Valid),
                attribute.String("user.language", user.PreferredLanguage.String),
                attribute.String("user.level", user.CurrentLevel.String),
                attribute.Bool("user.ai_enabled", user.AIEnabled.Bool),
                attribute.String("user.ai_provider", user.AIProvider.String),
                attribute.String("user.ai_model", user.AIModel.String),
        )

        // Update last active timestamp
        if err := h.userService.UpdateLastActive(c.Request.Context(), user.ID); err != nil </span><span class="cov0" title="0">{
                h.logger.Error(c.Request.Context(), "Error updating last active", err, map[string]interface{}{"user_id": user.ID})
                // Don't fail the request for this error
        }</span>

        // Convert models.User to api.User with proper API key checking
        <span class="cov1" title="3">apiUser := convertUserToAPIWithService(c.Request.Context(), user, h.userService)

        c.JSON(http.StatusOK, gin.H{
                "authenticated": true,
                "user":          &amp;apiUser,
        })</span>
}

// Signup handles user registration requests
func (h *AuthHandler) Signup(c *gin.Context) <span class="cov3" title="26">{
        _, span := observability.TraceHandlerFunction(c.Request.Context(), "signup")
        defer span.End()

        // Check if signups are disabled
        if h.config != nil &amp;&amp; h.config.IsSignupDisabled() </span><span class="cov1" title="1">{
                span.SetAttributes(attribute.Bool("auth.signups_disabled", true))
                c.JSON(http.StatusForbidden, api.ErrorResponse{
                        Error: stringPtr("User registration is currently disabled"),
                })
                return
        }</span>

        <span class="cov3" title="24">span.SetAttributes(attribute.Bool("auth.signups_disabled", false))

        var req api.UserCreateRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov1" title="1">{
                if errors.Is(err, openapi_types.ErrValidationEmail) </span><span class="cov1" title="1">{
                        c.JSON(http.StatusBadRequest, api.ErrorResponse{
                                Error: stringPtr("Please enter a valid email address"),
                        })
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusBadRequest, api.ErrorResponse{
                        Error: stringPtr("Invalid request body"),
                })
                return</span>
        }

        // Set span attributes for request data
        <span class="cov3" title="22">span.SetAttributes(
                attribute.String("signup.username", req.Username),
                attribute.Bool("signup.password_provided", req.Password != ""),
                attribute.Bool("signup.email_provided", req.Email != nil &amp;&amp; *req.Email != ""),
                attribute.Bool("signup.language_provided", req.PreferredLanguage != nil &amp;&amp; *req.PreferredLanguage != ""),
                attribute.Bool("signup.level_provided", req.CurrentLevel != nil &amp;&amp; *req.CurrentLevel != ""),
                attribute.Bool("signup.timezone_provided", req.Timezone != nil &amp;&amp; *req.Timezone != ""),
        )

        // Validate required fields
        if req.Username == "" </span><span class="cov1" title="3">{
                c.JSON(http.StatusBadRequest, api.ErrorResponse{
                        Error: stringPtr("Username is required"),
                })
                return
        }</span>

        <span class="cov3" title="19">if req.Password == "" </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, api.ErrorResponse{
                        Error: stringPtr("Password is required"),
                })
                return
        }</span>

        <span class="cov3" title="17">if req.Email == nil || *req.Email == "" </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, api.ErrorResponse{
                        Error: stringPtr("Email is required"),
                })
                return
        }</span>

        // Validate username format (3-50 characters, alphanumeric + underscore)
        <span class="cov3" title="15">if len(req.Username) &lt; 3 || len(req.Username) &gt; 50 </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, api.ErrorResponse{
                        Error: stringPtr("Username must be between 3 and 50 characters"),
                })
                return
        }</span>

        <span class="cov3" title="13">usernameRegex := regexp.MustCompile(`^[a-zA-Z0-9_]+$`)
        if !usernameRegex.MatchString(req.Username) </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, api.ErrorResponse{
                        Error: stringPtr("Username can only contain letters, numbers, and underscores"),
                })
                return
        }</span>

        // Validate password (minimum 8 characters)
        <span class="cov3" title="11">if len(req.Password) &lt; 8 </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, api.ErrorResponse{
                        Error: stringPtr("Password must be at least 8 characters long"),
                })
                return
        }</span>

        // Validate email format (convert to string)
        <span class="cov2" title="9">emailRegex := regexp.MustCompile(`^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$`)
        if !emailRegex.MatchString(string(*req.Email)) </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, api.ErrorResponse{
                        Error: stringPtr("Please enter a valid email address"),
                })
                return
        }</span>

        // Normalize email to lowercase
        <span class="cov2" title="9">email := strings.ToLower(string(*req.Email))

        h.logger.Info(c.Request.Context(), "Attempting signup for user", map[string]interface{}{"username": req.Username, "email": email})

        // Check if username already exists
        existingUser, err := h.userService.GetUserByUsername(c.Request.Context(), req.Username)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error(c.Request.Context(), "Error checking username uniqueness", err, map[string]interface{}{"username": req.Username})
                c.JSON(http.StatusServiceUnavailable, api.ErrorResponse{
                        Error: stringPtr("Internal server error"),
                })
                return
        }</span>

        <span class="cov2" title="9">if existingUser != nil </span><span class="cov1" title="3">{
                span.SetAttributes(attribute.Bool("signup.username_exists", true))
                c.JSON(http.StatusConflict, api.ErrorResponse{
                        Error: stringPtr("Username already exists"),
                })
                return
        }</span>

        // Check if email already exists
        <span class="cov2" title="6">existingUserByEmail, err := h.userService.GetUserByEmail(c.Request.Context(), email)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error(c.Request.Context(), "Error checking email uniqueness", err, map[string]interface{}{"email": email})
                c.JSON(http.StatusServiceUnavailable, api.ErrorResponse{
                        Error: stringPtr("Internal server error"),
                })
                return
        }</span>

        <span class="cov2" title="6">if existingUserByEmail != nil </span><span class="cov1" title="1">{
                span.SetAttributes(attribute.Bool("signup.email_exists", true))
                c.JSON(http.StatusConflict, api.ErrorResponse{
                        Error: stringPtr("Email address already registered"),
                })
                return
        }</span>

        // Set default values for optional fields
        <span class="cov2" title="4">language := "italian" // Default to first language in the list
        if h.config != nil </span><span class="cov2" title="4">{
                languages := h.config.AppConfig.GetLanguages()
                if len(languages) &gt; 0 </span><span class="cov2" title="4">{
                        language = languages[0]
                }</span>
        }
        <span class="cov2" title="4">if req.PreferredLanguage != nil &amp;&amp; *req.PreferredLanguage != "" </span><span class="cov1" title="2">{
                language = *req.PreferredLanguage
        }</span>

        <span class="cov2" title="4">level := "beginner" // Default level
        if req.CurrentLevel != nil &amp;&amp; *req.CurrentLevel != "" </span><span class="cov1" title="2">{
                level = *req.CurrentLevel
        }</span>

        <span class="cov2" title="4">timezone := "UTC" // Default timezone
        if req.Timezone != nil &amp;&amp; *req.Timezone != "" </span><span class="cov1" title="2">{
                timezone = *req.Timezone
        }</span>

        // Update span attributes with final values
        <span class="cov2" title="4">span.SetAttributes(
                attribute.String("signup.language", language),
                attribute.String("signup.level", level),
                attribute.String("signup.timezone", timezone),
        )

        // Create user with email and timezone (no AI settings)
        user, err := h.userService.CreateUserWithEmailAndTimezone(c.Request.Context(), req.Username, email, timezone, language, level)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error(c.Request.Context(), "Error creating user", err, map[string]interface{}{"username": req.Username, "email": email})
                c.JSON(http.StatusServiceUnavailable, api.ErrorResponse{
                        Error: stringPtr("Failed to create user account"),
                })
                return
        }</span>

        // Now set the password hash
        <span class="cov2" title="4">if err := h.userService.UpdateUserPassword(c.Request.Context(), user.ID, req.Password); err != nil </span><span class="cov0" title="0">{
                h.logger.Error(c.Request.Context(), "Error setting user password", err, map[string]interface{}{"user_id": user.ID})
                // Try to clean up the user we just created
                if deleteErr := h.userService.DeleteUser(c.Request.Context(), user.ID); deleteErr != nil </span><span class="cov0" title="0">{
                        h.logger.Error(c.Request.Context(), "Error cleaning up user after password set failure", err, map[string]interface{}{"user_id": user.ID, "error": deleteErr.Error()})
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusServiceUnavailable, api.ErrorResponse{
                        Error: stringPtr("Failed to create user account"),
                })
                return</span>
        }

        // Update span attributes with created user info
        <span class="cov2" title="4">span.SetAttributes(
                attribute.Int("user.id", user.ID),
                attribute.String("user.username", user.Username),
                attribute.String("user.email", email),
        )

        h.logger.Info(c.Request.Context(), "Successfully created user", map[string]interface{}{"username": req.Username, "user_id": user.ID})

        // Return success response (no session created, no auto-login)
        c.JSON(http.StatusCreated, api.SuccessResponse{
                Success: boolPtr(true),
                Message: stringPtr("Account created successfully. Please log in."),
        })</span>
}

// GoogleLogin initiates Google OAuth flow
func (h *AuthHandler) GoogleLogin(c *gin.Context) <span class="cov3" title="15">{
        _, span := observability.TraceHandlerFunction(c.Request.Context(), "google_login")
        defer span.End()

        // Generate a state parameter for security
        state := generateRandomState()

        // Set span attributes
        span.SetAttributes(
                attribute.String("oauth.provider", "google"),
                attribute.String("oauth.state", state),
        )

        // Store state in session for verification
        session := sessions.Default(c)
        session.Set("oauth_state", state)
        if err := session.Save(); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusServiceUnavailable, api.ErrorResponse{
                        Error: stringPtr("Failed to save session"),
                })
                return
        }</span>

        // Generate Google OAuth URL
        <span class="cov3" title="15">authURL := h.oauthService.GetGoogleAuthURL(c.Request.Context(), state)

        c.JSON(http.StatusOK, gin.H{
                "auth_url": authURL,
        })</span>
}

// GoogleCallback handles the OAuth callback from Google
func (h *AuthHandler) GoogleCallback(c *gin.Context) <span class="cov3" title="15">{
        _, span := observability.TraceHandlerFunction(c.Request.Context(), "google_callback")
        defer span.End()

        // Get the authorization code and state from query parameters
        code := c.Query("code")
        state := c.Query("state")

        // Set span attributes
        span.SetAttributes(
                attribute.String("oauth.provider", "google"),
                attribute.Bool("oauth.code_provided", code != ""),
                attribute.String("oauth.state", state),
        )

        h.logger.Info(c.Request.Context(), "Google OAuth callback received", map[string]interface{}{"code": code, "state": state})

        if code == "" </span><span class="cov2" title="4">{
                c.JSON(http.StatusBadRequest, api.ErrorResponse{
                        Error: stringPtr("Authorization code is required"),
                })
                return
        }</span>

        // Verify state parameter for OAuth security (CSRF protection)
        <span class="cov3" title="11">session := sessions.Default(c)
        storedState := session.Get("oauth_state")

        h.logger.Info(c.Request.Context(), "OAuth state verification", map[string]interface{}{"stored_state": storedState, "received_state": state})

        // Enforce strict state verification for security
        if storedState == nil </span><span class="cov2" title="5">{
                h.logger.Error(c.Request.Context(), "No OAuth state found in session - possible CSRF attack or session issue", nil, map[string]interface{}{"state": state})
                span.SetAttributes(attribute.Bool("oauth.state_valid", false))
                c.JSON(http.StatusBadRequest, api.ErrorResponse{
                        Error: stringPtr("Invalid OAuth state - please try signing in again"),
                })
                return
        }</span>

        <span class="cov2" title="6">if storedState.(string) != state </span><span class="cov2" title="4">{
                h.logger.Error(c.Request.Context(), "OAuth state mismatch - possible CSRF attack", nil, map[string]interface{}{"stored_state": storedState.(string), "received_state": state})
                span.SetAttributes(attribute.Bool("oauth.state_valid", false))
                c.JSON(http.StatusBadRequest, api.ErrorResponse{
                        Error: stringPtr("Invalid OAuth state - please try signing in again"),
                })
                return
        }</span>

        <span class="cov1" title="1">span.SetAttributes(attribute.Bool("oauth.state_valid", true))
        h.logger.Info(c.Request.Context(), "OAuth state verification successful")

        // Clear the state from session (if it exists)
        session.Delete("oauth_state")
        if err := session.Save(); err != nil </span><span class="cov0" title="0">{
                h.logger.Error(c.Request.Context(), "Failed to save session", err, map[string]interface{}{"error": err.Error()})
                c.JSON(http.StatusServiceUnavailable, api.ErrorResponse{
                        Error: stringPtr("Failed to save session"),
                })
                return
        }</span>

        // Authenticate user with Google OAuth
        <span class="cov1" title="1">user, err := h.oauthService.AuthenticateGoogleUser(c.Request.Context(), code, h.userService)
        if err != nil </span><span class="cov1" title="1">{
                h.logger.Error(c.Request.Context(), "Google OAuth authentication failed", err, map[string]interface{}{"error": err.Error()})

                // Check if this is a signup disabled error (structured)
                if errors.Is(err, services.ErrSignupsDisabled) </span><span class="cov1" title="1">{
                        span.SetAttributes(attribute.Bool("oauth.signups_disabled", true))
                        c.JSON(http.StatusForbidden, api.ErrorResponse{
                                Error: stringPtr("User registration is currently disabled"),
                        })
                        return
                }</span>

                // Provide better error messages to the frontend using structured error checking
                <span class="cov0" title="0">errorMessage := "Authentication failed"
                if errors.Is(err, services.ErrOAuthCodeAlreadyUsed) </span><span class="cov0" title="0">{
                        errorMessage = "This authentication link has already been used. Please try signing in again."
                }</span> else<span class="cov0" title="0"> if errors.Is(err, services.ErrOAuthClientConfig) </span><span class="cov0" title="0">{
                        errorMessage = "OAuth configuration error. Please contact support."
                }</span> else<span class="cov0" title="0"> if errors.Is(err, services.ErrOAuthInvalidRequest) </span><span class="cov0" title="0">{
                        errorMessage = "Invalid authentication request. Please try again."
                }</span> else<span class="cov0" title="0"> if errors.Is(err, services.ErrOAuthUnauthorized) </span><span class="cov0" title="0">{
                        errorMessage = "OAuth client is not authorized. Please contact support."
                }</span> else<span class="cov0" title="0"> if errors.Is(err, services.ErrOAuthUnsupportedGrant) </span><span class="cov0" title="0">{
                        errorMessage = "Unsupported OAuth grant type. Please contact support."
                }</span>

                <span class="cov0" title="0">c.JSON(http.StatusServiceUnavailable, api.ErrorResponse{
                        Error: stringPtr(errorMessage),
                })
                return</span>
        }

        // Update span attributes with user info
        <span class="cov0" title="0">span.SetAttributes(
                attribute.Int("user.id", user.ID),
                attribute.String("user.username", user.Username),
                attribute.Bool("user.email_provided", user.Email.Valid),
                attribute.String("user.language", user.PreferredLanguage.String),
                attribute.String("user.level", user.CurrentLevel.String),
                attribute.Bool("user.is_new", user.CreatedAt.After(time.Now().Add(-5*time.Minute))), // Rough check if user was just created
        )

        // Update last active
        if err := h.userService.UpdateLastActive(c.Request.Context(), user.ID); err != nil </span><span class="cov0" title="0">{
                h.logger.Warn(c.Request.Context(), "Failed to update last active for user", map[string]interface{}{"user_id": user.ID, "error": err.Error()})
        }</span>

        // Create session
        <span class="cov0" title="0">session.Set(middleware.UserIDKey, user.ID)
        session.Set(middleware.UsernameKey, user.Username)

        h.logger.Info(c.Request.Context(), "Setting session for user", map[string]interface{}{"user_id": user.ID, "username": user.Username})

        if err := session.Save(); err != nil </span><span class="cov0" title="0">{
                h.logger.Error(c.Request.Context(), "Failed to save session", err, map[string]interface{}{"error": err.Error()})
                c.JSON(http.StatusServiceUnavailable, api.ErrorResponse{
                        Error: stringPtr("Failed to create session"),
                })
                return
        }</span>

        // Convert models.User to api.User with proper API key checking
        <span class="cov0" title="0">apiUser := convertUserToAPIWithService(c.Request.Context(), user, h.userService)

        h.logger.Info(c.Request.Context(), "Google OAuth successful for user", map[string]interface{}{"username": user.Username, "user_id": user.ID})

        // Return user info
        c.JSON(http.StatusOK, api.LoginResponse{
                Success: boolPtr(true),
                Message: stringPtr("Google authentication successful"),
                User:    &amp;apiUser,
        })</span>
}

// generateRandomState generates a cryptographically secure random state parameter for OAuth security
func generateRandomState() string <span class="cov7" title="1118">{
        const charset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
        b := make([]byte, 32)

        // Use crypto/rand for cryptographically secure random generation
        for i := range b </span><span class="cov10" title="35776">{
                // Generate a random byte and map it to charset
                randomByte := make([]byte, 1)
                if _, err := rand.Read(randomByte); err != nil </span><span class="cov0" title="0">{
                        // If crypto/rand fails, we have a serious system issue - don't fallback to weaker randomness
                        panic("Cryptographic random number generation failed: " + err.Error())</span>
                }
                <span class="cov10" title="35776">b[i] = charset[randomByte[0]%byte(len(charset))]</span>
        }
        <span class="cov7" title="1118">return string(b)</span>
}

// SignupStatus returns whether signups are enabled or disabled
func (h *AuthHandler) SignupStatus(c *gin.Context) <span class="cov1" title="3">{
        _, span := observability.TraceHandlerFunction(c.Request.Context(), "signup_status")
        defer span.End()

        signupsDisabled := false
        if h.config != nil </span><span class="cov1" title="3">{
                signupsDisabled = h.config.IsSignupDisabled()
        }</span>

        <span class="cov1" title="3">span.SetAttributes(
                attribute.Bool("auth.signups_disabled", signupsDisabled),
                attribute.Bool("auth.config_available", h.config != nil),
        )

        c.JSON(http.StatusOK, gin.H{
                "signups_disabled": signupsDisabled,
        })</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package handlers

import (
        "fmt"
        "net/http"

        "github.com/gin-gonic/gin"
)

// StandardizeHTTPError creates consistent HTTP error responses
func StandardizeHTTPError(c *gin.Context, statusCode int, message, details string) <span class="cov10" title="21">{
        c.JSON(statusCode, gin.H{
                "error":   message,
                "details": details,
        })
}</span>

// HandleValidationError handles input validation errors consistently
func HandleValidationError(c *gin.Context, field string, value interface{}, reason string) <span class="cov7" title="10">{
        StandardizeHTTPError(c, http.StatusBadRequest,
                fmt.Sprintf("Invalid %s", field),
                fmt.Sprintf("Value '%v' is invalid: %s", value, reason))
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package handlers

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "math/rand"
        "net/http"
        "strconv"
        "strings"

        "quizapp/internal/api"
        "quizapp/internal/middleware"
        "quizapp/internal/models"
        "quizapp/internal/observability"
        "quizapp/internal/services"

        "quizapp/internal/config"

        "github.com/gin-contrib/sessions"
        "github.com/gin-gonic/gin"
        "go.opentelemetry.io/otel/attribute"
)

// QuizHandler handles quiz-related HTTP requests including questions and answers
type QuizHandler struct {
        userService     services.UserServiceInterface
        questionService services.QuestionServiceInterface
        aiService       services.AIServiceInterface
        learningService services.LearningServiceInterface
        workerService   services.WorkerServiceInterface
        cfg             *config.Config
        logger          *observability.Logger
}

// NewQuizHandler creates a new QuizHandler
func NewQuizHandler(
        userService services.UserServiceInterface,
        questionService services.QuestionServiceInterface,
        aiService services.AIServiceInterface,
        learningService services.LearningServiceInterface,
        workerService services.WorkerServiceInterface,
        config *config.Config,
        logger *observability.Logger,
) *QuizHandler <span class="cov5" title="7">{
        return &amp;QuizHandler{
                userService:     userService,
                questionService: questionService,
                aiService:       aiService,
                learningService: learningService,
                workerService:   workerService,
                cfg:             config,
                logger:          logger,
        }
}</span>

// getUserIDFromSession gets the user ID from the session without requiring auth middleware
func (h *QuizHandler) getUserIDFromSession(c *gin.Context) (int, bool) <span class="cov10" title="43">{
        session := sessions.Default(c)
        userID := session.Get(middleware.UserIDKey)
        if userID == nil </span><span class="cov0" title="0">{
                return 0, false
        }</span>
        <span class="cov10" title="43">return userID.(int), true</span>
}

// GetQuestion handles requests for quiz questions
func (h *QuizHandler) GetQuestion(c *gin.Context) <span class="cov5" title="7">{
        _, span := observability.TraceHandlerFunction(c.Request.Context(), "get_question")
        defer span.End()

        userID, exists := h.getUserIDFromSession(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, api.ErrorResponse{Error: stringPtr("User not found")})
                return
        }</span>

        // Add span attributes for observability
        <span class="cov5" title="7">span.SetAttributes(observability.AttributeUserID(userID))

        // Check if a specific question ID is requested
        questionIDStr := c.Param("id")
        if questionIDStr != "" </span><span class="cov4" title="4">{
                span.SetAttributes(attribute.String("question.id", questionIDStr))
                h.getSpecificQuestion(c, userID, questionIDStr)
                return
        }</span>

        <span class="cov3" title="3">h.getNextQuestion(c, userID)</span>
}

// getSpecificQuestion improves error handling with centralized utilities
func (h *QuizHandler) getSpecificQuestion(c *gin.Context, userID int, questionIDStr string) <span class="cov4" title="4">{
        ctx, span := observability.TraceHandlerFunction(c.Request.Context(), "get_specific_question",
                observability.AttributeUserID(userID),
                attribute.String("question.id_str", questionIDStr),
        )
        defer span.End()

        questionID, err := strconv.Atoi(questionIDStr)
        if err != nil </span><span class="cov1" title="1">{
                HandleValidationError(c, "question_id", questionIDStr, "must be a valid integer")
                return
        }</span>

        <span class="cov3" title="3">questionWithStats, err := h.questionService.GetQuestionWithStats(ctx, questionID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error(ctx, "Failed to get question with stats", err, map[string]interface{}{
                        "question_id": questionID,
                        "user_id":     userID,
                })
                StandardizeHTTPError(c, http.StatusNotFound, "Question not found", "The requested question could not be found")
                return
        }</span>

        // Convert and hide sensitive information
        <span class="cov3" title="3">apiQuestion := convertQuestionToAPI(questionWithStats.Question)
        apiQuestion.Explanation = nil // Hide explanation

        // Add response statistics to the API question
        apiQuestion.CorrectCount = &amp;questionWithStats.CorrectCount
        apiQuestion.IncorrectCount = &amp;questionWithStats.IncorrectCount
        apiQuestion.TotalResponses = &amp;questionWithStats.TotalResponses

        c.JSON(http.StatusOK, apiQuestion)</span>
}

// getNextQuestion improves error handling with centralized utilities
func (h *QuizHandler) getNextQuestion(c *gin.Context, userID int) <span class="cov3" title="3">{
        ctx, span := observability.TraceHandlerFunction(c.Request.Context(), "get_next_question",
                observability.AttributeUserID(userID),
        )
        defer span.End()

        user, err := h.userService.GetUserByID(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error(ctx, "Failed to get user by ID", err, map[string]interface{}{
                        "user_id": userID,
                })
                StandardizeHTTPError(c, http.StatusNotFound, "User not found", "The user could not be found")
                return
        }</span>
        <span class="cov3" title="3">if user == nil </span><span class="cov0" title="0">{
                span.SetAttributes(attribute.String("error.type", "user_nil"))
                StandardizeHTTPError(c, http.StatusNotFound, "User not found", "The user could not be found")
                return
        }</span>

        // Check if user has required preferences set
        <span class="cov3" title="3">if !user.PreferredLanguage.Valid || user.PreferredLanguage.String == "" </span><span class="cov0" title="0">{
                span.SetAttributes(attribute.String("error.type", "missing_language_preference"))
                StandardizeHTTPError(c, http.StatusBadRequest, "Language preference not set", "Please set your preferred language in settings")
                return
        }</span>

        <span class="cov3" title="3">if !user.CurrentLevel.Valid || user.CurrentLevel.String == "" </span><span class="cov0" title="0">{
                span.SetAttributes(attribute.String("error.type", "missing_level_preference"))
                StandardizeHTTPError(c, http.StatusBadRequest, "Level preference not set", "Please set your current level in settings")
                return
        }</span>

        <span class="cov3" title="3">language := c.DefaultQuery("language", user.PreferredLanguage.String)
        level := c.DefaultQuery("level", user.CurrentLevel.String)

        // Handle question type selection based on query parameters
        var qType models.QuestionType
        requestedTypes := c.Query("type")
        strictTypeRequested := false

        if requestedTypes != "" </span><span class="cov0" title="0">{
                strictTypeRequested = true
                types := strings.Split(requestedTypes, ",")
                // Use the first valid type from the list
                for _, t := range types </span><span class="cov0" title="0">{
                        if t = strings.TrimSpace(t); t != "" </span><span class="cov0" title="0">{
                                qType = models.QuestionType(t)
                                break</span>
                        }
                }
        } else<span class="cov3" title="3"> {
                // Check if we need to exclude certain types (comma-separated list)
                excludeTypes := c.Query("exclude_type")
                if excludeTypes != "" </span><span class="cov0" title="0">{
                        excludeList := strings.Split(excludeTypes, ",")
                        var excludeSet []models.QuestionType
                        for _, t := range excludeList </span><span class="cov0" title="0">{
                                if t = strings.TrimSpace(t); t != "" </span><span class="cov0" title="0">{
                                        excludeSet = append(excludeSet, models.QuestionType(t))
                                }</span>
                        }
                        <span class="cov0" title="0">qType = h.selectRandomQuestionTypeExcluding(excludeSet...)</span>
                } else<span class="cov3" title="3"> {
                        // Default random selection
                        qType = h.selectRandomQuestionType()
                }</span>
        }

        // Add span attributes for observability
        <span class="cov3" title="3">span.SetAttributes(
                attribute.String("language", language),
                attribute.String("level", level),
                attribute.String("question.type", string(qType)),
                attribute.Bool("strict.type.requested", strictTypeRequested),
        )

        // Get next question with fallback logic
        questionWithStats, err := h.questionService.GetNextQuestion(ctx, userID, language, level, qType)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error(ctx, "Failed to get next question", err, map[string]interface{}{
                        "user_id":       userID,
                        "language":      language,
                        "level":         level,
                        "question_type": string(qType),
                })

                // Fallback: try without question type if strict type was requested
                if strictTypeRequested </span><span class="cov0" title="0">{
                        h.logger.Info(ctx, "Attempting fallback without question type", map[string]interface{}{
                                "user_id":  userID,
                                "language": language,
                                "level":    level,
                        })
                        questionWithStats, err = h.questionService.GetNextQuestion(ctx, userID, language, level, "")
                        if err != nil </span><span class="cov0" title="0">{
                                h.logger.Error(ctx, "Fallback also failed", err, map[string]interface{}{
                                        "user_id":  userID,
                                        "language": language,
                                        "level":    level,
                                })
                                StandardizeHTTPError(c, http.StatusServiceUnavailable, "No questions available", "No questions are currently available for your preferences")
                                return
                        }</span>
                } else<span class="cov0" title="0"> {
                        StandardizeHTTPError(c, http.StatusServiceUnavailable, "No questions available", "No questions are currently available for your preferences")
                        return
                }</span>
        }

        // Check if we got a valid question
        <span class="cov3" title="3">if questionWithStats == nil || questionWithStats.Question == nil </span><span class="cov3" title="3">{
                h.logger.Error(ctx, "GetNextQuestion returned nil question", nil, map[string]interface{}{
                        "user_id":       userID,
                        "language":      language,
                        "level":         level,
                        "question_type": string(qType),
                })
                c.JSON(http.StatusAccepted, api.GeneratingResponse{
                        Status:  stringPtr("generating"),
                        Message: stringPtr("No questions available. Questions are generated by a separate service. Please try again in a moment."),
                })
                return
        }</span>

        // Convert to API format and hide sensitive information
        <span class="cov0" title="0">apiQuestion := convertQuestionToAPI(questionWithStats.Question)
        apiQuestion.Explanation = nil // Hide explanation

        // Add response statistics to the API question
        apiQuestion.CorrectCount = &amp;questionWithStats.CorrectCount
        apiQuestion.IncorrectCount = &amp;questionWithStats.IncorrectCount
        apiQuestion.TotalResponses = &amp;questionWithStats.TotalResponses

        c.JSON(http.StatusOK, apiQuestion)</span>
}

// SubmitAnswer improves error handling with centralized utilities
func (h *QuizHandler) SubmitAnswer(c *gin.Context) <span class="cov7" title="14">{
        ctx, span := observability.TraceHandlerFunction(c.Request.Context(), "submit_answer")
        defer span.End()

        userID, exists := h.getUserIDFromSession(c)
        if !exists </span><span class="cov0" title="0">{
                StandardizeHTTPError(c, http.StatusUnauthorized, "User not found", "Please log in to submit answers")
                return
        }</span>

        <span class="cov7" title="14">var req api.AnswerRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov1" title="1">{
                h.logger.Error(ctx, "Invalid answer request format", err, map[string]interface{}{
                        "user_id": userID,
                })
                StandardizeHTTPError(c, http.StatusBadRequest, "Invalid request format", err.Error())
                return
        }</span>

        // Get the question
        <span class="cov7" title="13">question, err := h.questionService.GetQuestionByID(ctx, int(req.QuestionId))
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error(ctx, "Failed to get question by ID", err, map[string]interface{}{
                        "question_id": req.QuestionId,
                        "user_id":     userID,
                })
                StandardizeHTTPError(c, http.StatusNotFound, "Question not found", "The requested question could not be found")
                return
        }</span>

        // Check if answer is correct
        <span class="cov7" title="13">isCorrect := h.checkAnswer(req.UserAnswer, question.GetCorrectAnswerText())

        // Record user response
        responseTimeMs := 0
        if req.ResponseTimeMs != nil </span><span class="cov0" title="0">{
                responseTimeMs = int(*req.ResponseTimeMs)
        }</span>

        // Use priority-aware recording to ensure priority scores are updated
        <span class="cov7" title="13">if err := h.learningService.RecordAnswerWithPriority(ctx, userID, int(req.QuestionId), req.UserAnswer, isCorrect, responseTimeMs); err != nil </span><span class="cov0" title="0">{
                h.logger.Error(ctx, "Failed to record user response", err, map[string]interface{}{
                        "user_id":     userID,
                        "question_id": req.QuestionId,
                        "is_correct":  isCorrect,
                })
                StandardizeHTTPError(c, http.StatusServiceUnavailable, "Failed to record response", "Your answer could not be saved. Please try again.")
                return
        }</span>

        // Prepare response
        <span class="cov7" title="13">correctAnswerText := question.GetCorrectAnswerText()
        answerResponse := &amp;api.AnswerResponse{
                IsCorrect:          &amp;isCorrect,
                CorrectAnswer:      &amp;correctAnswerText,
                UserAnswer:         &amp;req.UserAnswer,
                Explanation:        &amp;question.Explanation,
                CorrectAnswerIndex: &amp;question.CorrectAnswer,
        }

        c.JSON(http.StatusOK, answerResponse)

        // Add span attributes for observability
        span.SetAttributes(
                attribute.Int("user.id", userID),
                attribute.Int("question.id", int(req.QuestionId)),
                attribute.Bool("answer.is_correct", isCorrect),
                attribute.Int("response.time_ms", responseTimeMs),
        )</span>
}

// GetProgress improves error handling with centralized utilities
func (h *QuizHandler) GetProgress(c *gin.Context) <span class="cov6" title="12">{
        ctx, span := observability.TraceHandlerFunction(c.Request.Context(), "get_progress")
        defer span.End()

        userID, exists := h.getUserIDFromSession(c)
        if !exists </span><span class="cov0" title="0">{
                StandardizeHTTPError(c, http.StatusUnauthorized, "User not found", "Please log in to view progress")
                return
        }</span>

        <span class="cov6" title="12">span.SetAttributes(observability.AttributeUserID(userID))

        progress, err := h.learningService.GetUserProgress(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error(ctx, "Failed to get user progress", err, map[string]interface{}{
                        "user_id": userID,
                })
                StandardizeHTTPError(c, http.StatusServiceUnavailable, "Failed to get progress", "Unable to retrieve your learning progress")
                return
        }</span>

        // Convert models.UserProgress to api.UserProgress
        <span class="cov6" title="12">apiProgress := convertUserProgressToAPI(progress)
        c.JSON(http.StatusOK, apiProgress)</span>
}

// ReportQuestion improves error handling with centralized utilities
func (h *QuizHandler) ReportQuestion(c *gin.Context) <span class="cov3" title="3">{
        ctx, span := observability.TraceHandlerFunction(c.Request.Context(), "report_question")
        defer span.End()

        userID, exists := h.getUserIDFromSession(c)
        if !exists </span><span class="cov0" title="0">{
                StandardizeHTTPError(c, http.StatusUnauthorized, "User not found", "Please log in to report questions")
                return
        }</span>

        <span class="cov3" title="3">questionIDStr := c.Param("id")
        questionID, err := strconv.Atoi(questionIDStr)
        if err != nil </span><span class="cov0" title="0">{
                HandleValidationError(c, "question_id", questionIDStr, "must be a valid integer")
                return
        }</span>

        <span class="cov3" title="3">span.SetAttributes(
                observability.AttributeUserID(userID),
                observability.AttributeQuestionID(questionID),
        )

        err = h.questionService.ReportQuestion(ctx, questionID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error(ctx, "Failed to report question", err, map[string]interface{}{
                        "question_id": questionID,
                        "user_id":     userID,
                })
                StandardizeHTTPError(c, http.StatusServiceUnavailable, "Failed to report question", "Unable to report the question at this time")
                return
        }</span>

        <span class="cov3" title="3">c.JSON(http.StatusOK, api.SuccessResponse{Message: stringPtr("Question reported successfully")})</span>
}

// MarkQuestionAsKnown improves error handling with centralized utilities
func (h *QuizHandler) MarkQuestionAsKnown(c *gin.Context) <span class="cov4" title="5">{
        ctx, span := observability.TraceHandlerFunction(c.Request.Context(), "mark_question_as_known")
        defer span.End()

        userID, exists := h.getUserIDFromSession(c)
        if !exists </span><span class="cov0" title="0">{
                StandardizeHTTPError(c, http.StatusUnauthorized, "User not found", "Please log in to mark questions as known")
                return
        }</span>

        <span class="cov4" title="5">questionIDStr := c.Param("id")
        questionID, err := strconv.Atoi(questionIDStr)
        if err != nil </span><span class="cov1" title="1">{
                HandleValidationError(c, "question_id", questionIDStr, "must be a valid integer")
                return
        }</span>

        // Optional: Parse confidence level from request body
        <span class="cov4" title="4">var req struct {
                ConfidenceLevel *int `json:"confidence_level"`
        }

        // Bind JSON if present (optional)
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov3" title="3">{
                // Ignore binding errors for optional request body
                req.ConfidenceLevel = nil
        }</span>

        <span class="cov4" title="4">span.SetAttributes(
                observability.AttributeUserID(userID),
                observability.AttributeQuestionID(questionID),
        )

        // Mark question as known
        err = h.learningService.MarkQuestionAsKnown(ctx, userID, questionID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error(ctx, "Failed to mark question as known for user", err, map[string]interface{}{
                        "question_id": questionID,
                        "user_id":     userID,
                })
                if errors.Is(err, services.ErrQuestionNotFound) </span><span class="cov0" title="0">{
                        StandardizeHTTPError(c, http.StatusNotFound, "Question not found", "The requested question could not be found")
                        return
                }</span>
                <span class="cov0" title="0">StandardizeHTTPError(c, http.StatusServiceUnavailable, "Failed to mark question as known", "Unable to mark the question as known at this time")
                return</span>
        }

        <span class="cov4" title="4">c.JSON(http.StatusOK, api.SuccessResponse{Message: stringPtr("Question marked as known successfully")})</span>
}

// ChatStream handles requests for AI-powered streaming chat about a question
func (h *QuizHandler) ChatStream(c *gin.Context) <span class="cov0" title="0">{
        ctx, span := observability.TraceHandlerFunction(c.Request.Context(), "chat_stream")
        defer span.End()

        userID, exists := h.getUserIDFromSession(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, api.ErrorResponse{Error: stringPtr("User not found")})
                return
        }</span>

        <span class="cov0" title="0">var req api.QuizChatRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, api.ErrorResponse{
                        Error:   stringPtr("Invalid request format"),
                        Details: stringPtr(err.Error()),
                })
                return
        }</span>

        <span class="cov0" title="0">user, err := h.userService.GetUserByID(ctx, userID)
        if err != nil || user == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, api.ErrorResponse{Error: stringPtr("User not found")})
                return
        }</span>

        <span class="cov0" title="0">span.SetAttributes(
                observability.AttributeUserID(userID),
                attribute.String("ai.provider", user.AIProvider.String),
                attribute.String("ai.model", user.AIModel.String),
        )

        // Prepare the request for the AI service
        aiReq := &amp;models.AIChatRequest{
                Language:    string(*req.Question.Language),
                Level:       string(*req.Question.Level),
                UserMessage: req.UserMessage,
        }

        if req.Question.Content != nil </span><span class="cov0" title="0">{
                aiReq.Question = req.Question.Content.Question
                aiReq.Options = req.Question.Content.Options
                if req.Question.Content.Passage != nil </span><span class="cov0" title="0">{
                        aiReq.Passage = *req.Question.Content.Passage
                }</span>
        }

        <span class="cov0" title="0">if req.AnswerContext != nil </span><span class="cov0" title="0">{
                if req.AnswerContext.UserAnswer != nil </span><span class="cov0" title="0">{
                        aiReq.UserAnswer = *req.AnswerContext.UserAnswer
                }</span>
                <span class="cov0" title="0">if req.AnswerContext.CorrectAnswer != nil </span><span class="cov0" title="0">{
                        aiReq.CorrectAnswer = *req.AnswerContext.CorrectAnswer
                }</span>
                <span class="cov0" title="0">if req.AnswerContext.IsCorrect != nil </span><span class="cov0" title="0">{
                        aiReq.IsCorrect = req.AnswerContext.IsCorrect
                }</span>
        }

        // Include conversation history if provided
        <span class="cov0" title="0">if req.ConversationHistory != nil </span><span class="cov0" title="0">{
                aiReq.ConversationHistory = make([]models.ChatMessage, len(*req.ConversationHistory))
                for i, msg := range *req.ConversationHistory </span><span class="cov0" title="0">{
                        aiReq.ConversationHistory[i] = models.ChatMessage{
                                Role:    msg.Role,
                                Content: msg.Content,
                        }
                }</span>
        }

        // Create user AI configuration
        <span class="cov0" title="0">userConfig := &amp;services.UserAIConfig{
                Provider: "", // will be set from user settings
                Model:    "", // use service default
                APIKey:   "",
                Username: user.Username,
        }
        if user.AIProvider.Valid &amp;&amp; user.AIProvider.String != "" </span><span class="cov0" title="0">{
                userConfig.Provider = user.AIProvider.String
        }</span>
        <span class="cov0" title="0">if user.AIModel.Valid &amp;&amp; user.AIModel.String != "" </span><span class="cov0" title="0">{
                userConfig.Model = user.AIModel.String
        }</span>
        // Use the new per-provider API key system instead of the old user.AIAPIKey field
        <span class="cov0" title="0">if userConfig.Provider != "" </span><span class="cov0" title="0">{
                savedKey, err := h.userService.GetUserAPIKey(c.Request.Context(), userID, userConfig.Provider)
                if err == nil &amp;&amp; savedKey != "" </span><span class="cov0" title="0">{
                        userConfig.APIKey = savedKey
                }</span>
        }

        // Set up Server-Sent Events headers
        <span class="cov0" title="0">c.Header("Content-Type", "text/event-stream")
        c.Header("Cache-Control", "no-cache")
        c.Header("Connection", "keep-alive")
        c.Header("Access-Control-Allow-Origin", "*")
        c.Header("Access-Control-Allow-Headers", "Cache-Control")

        // Create a channel for streaming chunks
        chunks := make(chan string, 10)

        // Use the request context to detect client disconnect
        reqCtx := c.Request.Context()

        // Create a timeout context, but also watch for client disconnect
        timeoutCtx, cancel := context.WithTimeout(reqCtx, config.QuizStreamTimeout)
        defer cancel()

        // Combine both contexts - cancel if either times out or client disconnects
        ctx, combinedCancel := context.WithCancel(timeoutCtx)
        defer combinedCancel()

        // Watch for client disconnect
        go func() </span><span class="cov0" title="0">{
                defer func() </span><span class="cov0" title="0">{
                        if r := recover(); r != nil </span><span class="cov0" title="0">{
                                h.logger.Error(ctx, "Panic in client disconnect watcher", nil, map[string]interface{}{
                                        "panic": r,
                                })
                        }</span>
                }()
                <span class="cov0" title="0">select </span>{
                case &lt;-reqCtx.Done():<span class="cov0" title="0">
                        combinedCancel()</span> // Cancel if client disconnects
                case &lt;-ctx.Done():<span class="cov0" title="0"></span>
                        // Context already cancelled
                }
        }()

        // Start the AI streaming in a goroutine
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                defer func() </span><span class="cov0" title="0">{
                        if r := recover(); r != nil </span><span class="cov0" title="0">{
                                h.logger.Error(ctx, "Panic in AI streaming goroutine", nil, map[string]interface{}{
                                        "panic": r,
                                })
                        }</span>
                        <span class="cov0" title="0">close(chunks)</span> // Close the channel when the goroutine completes
                }()
                <span class="cov0" title="0">if err := h.aiService.GenerateChatResponseStream(ctx, userConfig, aiReq, chunks); err != nil </span><span class="cov0" title="0">{
                        h.logger.Error(ctx, "AI chat streaming failed for user", err, map[string]interface{}{
                                "user_id": userID,
                        })
                        // Only send error if context is not cancelled (avoid sending to closed channel)
                        if ctx.Err() == nil </span><span class="cov0" title="0">{
                                select </span>{
                                case chunks &lt;- fmt.Sprintf("ERROR: %v", err):<span class="cov0" title="0"></span>
                                default:<span class="cov0" title="0"></span>
                                        // Channel full, skip sending error
                                }
                        }
                }
        }()

        // Stream the response chunks
        <span class="cov0" title="0">c.Stream(func(w io.Writer) bool </span><span class="cov0" title="0">{
                select </span>{
                case chunk, ok := &lt;-chunks:<span class="cov0" title="0">
                        if !ok </span><span class="cov0" title="0">{
                                // Channel closed, end streaming
                                return false
                        }</span>

                        // Handle error messages
                        <span class="cov0" title="0">if strings.HasPrefix(chunk, "ERROR: ") </span><span class="cov0" title="0">{
                                c.SSEvent("error", chunk[7:]) // Remove "ERROR: " prefix
                                return false
                        }</span>

                        // Marshal the chunk to JSON to ensure newlines and special characters are preserved.
                        <span class="cov0" title="0">jsonChunk, err := json.Marshal(chunk)
                        if err != nil </span><span class="cov0" title="0">{
                                h.logger.Error(ctx, "Failed to marshal chat stream chunk to JSON", err, nil)
                                return true // Continue streaming, skip this chunk
                        }</span>

                        // Send normal content chunk in proper SSE format
                        <span class="cov0" title="0">if _, err := fmt.Fprintf(w, "data: %s\n\n", jsonChunk); err != nil </span><span class="cov0" title="0">{
                                h.logger.Error(ctx, "Failed to write chat stream data", err, nil)
                                return false
                        }</span>
                        <span class="cov0" title="0">c.Writer.Flush()
                        return true</span>
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        c.SSEvent("error", "Request timeout")
                        return false</span>
                }
        })
}

// Helper methods

func (h *QuizHandler) selectRandomQuestionType() models.QuestionType <span class="cov3" title="3">{
        // Note: This is a pure function that doesn't need tracing since it doesn't make external calls
        types := []models.QuestionType{
                models.Vocabulary,
                models.FillInBlank,
                models.QuestionAnswer,
                models.ReadingComprehension,
        }
        return types[rand.Intn(len(types))]
}</span>

func (h *QuizHandler) selectRandomQuestionTypeExcluding(excludeTypes ...models.QuestionType) models.QuestionType <span class="cov0" title="0">{
        // Note: This is a pure function that doesn't need tracing since it doesn't make external calls
        allTypes := []models.QuestionType{
                models.Vocabulary,
                models.FillInBlank,
                models.QuestionAnswer,
                models.ReadingComprehension,
        }

        // Create a map of excluded types for efficient lookup
        excludeMap := make(map[models.QuestionType]bool)
        for _, excludeType := range excludeTypes </span><span class="cov0" title="0">{
                excludeMap[excludeType] = true
        }</span>

        // Filter out excluded types
        <span class="cov0" title="0">var availableTypes []models.QuestionType
        for _, t := range allTypes </span><span class="cov0" title="0">{
                if !excludeMap[t] </span><span class="cov0" title="0">{
                        availableTypes = append(availableTypes, t)
                }</span>
        }

        // If no types are available, return the first type (fallback)
        <span class="cov0" title="0">if len(availableTypes) == 0 </span><span class="cov0" title="0">{
                return allTypes[0]
        }</span>

        <span class="cov0" title="0">return availableTypes[rand.Intn(len(availableTypes))]</span>
}

func (h *QuizHandler) checkAnswer(userAnswer, correctAnswer string) bool <span class="cov7" title="13">{
        // Note: This is a pure function that doesn't need tracing since it doesn't make external calls
        // Simple case-insensitive comparison for now
        return strings.TrimSpace(strings.ToLower(userAnswer)) == strings.TrimSpace(strings.ToLower(correctAnswer))
}</span>

// GetWorkerStatus returns worker status and error information for the current user
func (h *QuizHandler) GetWorkerStatus(c *gin.Context) <span class="cov2" title="2">{
        ctx, span := observability.TraceHandlerFunction(c.Request.Context(), "get_worker_status")
        defer span.End()

        userID, exists := h.getUserIDFromSession(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, api.ErrorResponse{Error: stringPtr("User not found")})
                return
        }</span>

        <span class="cov2" title="2">span.SetAttributes(observability.AttributeUserID(userID))

        // Get worker health information
        workerHealth, err := h.workerService.GetWorkerHealth(ctx)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error(ctx, "Failed to get worker health", err, nil)
                c.JSON(http.StatusServiceUnavailable, api.ErrorResponse{Error: stringPtr("Failed to get worker status")})
                return
        }</span>

        // Check if user is paused
        <span class="cov2" title="2">userPaused, err := h.workerService.IsUserPaused(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error(ctx, "Failed to check user pause status", err, nil)
                userPaused = false // Default to not paused if check fails
        }</span>

        // Check if global pause is active
        <span class="cov2" title="2">globalPaused, err := h.workerService.IsGlobalPaused(ctx)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error(ctx, "Failed to check global pause status", err, nil)
                globalPaused = false // Default to not paused if check fails
        }</span>

        // Extract relevant information for the user
        <span class="cov2" title="2">response := gin.H{
                "has_errors":         false,
                "error_message":      "",
                "global_paused":      globalPaused,
                "user_paused":        userPaused,
                "healthy_workers":    workerHealth["healthy_count"],
                "total_workers":      workerHealth["total_count"],
                "last_error_details": "",
                "worker_running":     false,
        }

        // Check for worker errors
        if workerInstances, ok := workerHealth["worker_instances"].([]map[string]interface{}); ok </span><span class="cov2" title="2">{
                for _, instance := range workerInstances </span><span class="cov0" title="0">{
                        if lastError, hasError := instance["last_run_error"]; hasError &amp;&amp; lastError != nil </span><span class="cov0" title="0">{
                                // Only handle string type
                                if errorStr, ok := lastError.(string); ok &amp;&amp; errorStr != "" </span><span class="cov0" title="0">{
                                        response["has_errors"] = true
                                        response["error_message"] = "Worker encountered errors during question generation"
                                        response["last_error_details"] = errorStr
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if isRunning, ok := instance["is_running"].(bool); ok &amp;&amp; isRunning </span><span class="cov0" title="0">{
                                response["worker_running"] = true
                        }</span>
                }
        }

        <span class="cov2" title="2">c.JSON(http.StatusOK, response)</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package handlers

import (
        "fmt"
        "net/http"
        "sort"
        "strings"
        "time"

        "quizapp/internal/observability"

        "github.com/gin-gonic/gin"
)

// RouteInfo represents information about a single route
type RouteInfo struct {
        Method      string `json:"method"`
        Path        string `json:"path"`
        HandlerName string `json:"handler_name"`
}

// RouteListingHandler generates automatic route listings
type RouteListingHandler struct {
        serviceName string
        routes      []RouteInfo
}

// NewRouteListingHandler creates a new route listing handler
func NewRouteListingHandler(serviceName string) *RouteListingHandler <span class="cov4" title="23">{
        return &amp;RouteListingHandler{
                serviceName: serviceName,
                routes:      []RouteInfo{},
        }
}</span>

// CollectRoutes extracts all routes from a Gin engine
func (h *RouteListingHandler) CollectRoutes(engine *gin.Engine) <span class="cov4" title="21">{
        h.routes = []RouteInfo{}

        // Get all routes from the Gin engine
        routes := engine.Routes()

        for _, route := range routes </span><span class="cov8" title="475">{
                // Skip internal Gin routes
                if strings.HasPrefix(route.Path, "/debug/") </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="475">h.routes = append(h.routes, RouteInfo{
                        Method:      route.Method,
                        Path:        route.Path,
                        HandlerName: route.Handler,
                })</span>
        }

        // Sort routes by path for better organization
        <span class="cov4" title="21">sort.Slice(h.routes, func(i, j int) bool </span><span class="cov10" title="2469">{
                return h.routes[i].Path &lt; h.routes[j].Path
        }</span>)
}

// GetRouteListingPage shows all available routes as HTML
func (h *RouteListingHandler) GetRouteListingPage(c *gin.Context) <span class="cov0" title="0">{
        _, span := observability.TraceHandlerFunction(c.Request.Context(), "get_route_listing_page")
        defer span.End()
        html := h.generateHTML()
        // Add no-cache headers
        c.Header("Content-Type", "text/html; charset=utf-8")
        c.Header("Cache-Control", "no-cache, no-store, must-revalidate")
        c.Header("Pragma", "no-cache")
        c.Header("Expires", "0")
        c.String(http.StatusOK, html)
}</span>

// GetRouteListingJSON returns the route listing as JSON
func (h *RouteListingHandler) GetRouteListingJSON(c *gin.Context) <span class="cov1" title="2">{
        _, span := observability.TraceHandlerFunction(c.Request.Context(), "get_route_listing_json")
        defer span.End()
        c.JSON(http.StatusOK, h.routes)
}</span>

// generateHTML creates an HTML page listing all routes
func (h *RouteListingHandler) generateHTML() string <span class="cov0" title="0">{
        var html strings.Builder

        html.WriteString(`&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;title&gt;` + h.serviceName + ` - Available Routes&lt;/title&gt;
    &lt;style&gt;
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; line-height: 1.6; padding: 20px; background-color: #f8f9fa; color: #212529; }
        .container { max-width: 1200px; margin: auto; background: #fff; padding: 30px; border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.05); }
        h1 { color: #0056b3; border-bottom: 2px solid #dee2e6; padding-bottom: 10px; margin-bottom: 30px; }
        .service-info { background: #e7f3ff; padding: 15px; border-radius: 5px; margin-bottom: 30px; }
        .route-table { width: 100%; border-collapse: collapse; margin-bottom: 30px; }
        .route-table th, .route-table td { padding: 12px; text-align: left; border-bottom: 1px solid #dee2e6; }
        .route-table th { background-color: #f8f9fa; font-weight: 600; color: #495057; }
        .route-table tr:nth-child(even) { background-color: #f8f9fa; }
        .route-table tr:hover { background-color: #e9ecef; }
        .method { display: inline-block; padding: 4px 8px; border-radius: 4px; font-size: 12px; font-weight: bold; min-width: 60px; text-align: center; }
        .method-get { background-color: #d4edda; color: #155724; }
        .method-post { background-color: #cce5ff; color: #004085; }
        .method-put { background-color: #fff3cd; color: #856404; }
        .method-delete { background-color: #f8d7da; color: #721c24; }
        .method-patch { background-color: #e2e3e5; color: #383d41; }
        .path { font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace; font-size: 14px; color: #6f42c1; }
        .clickable-path { cursor: pointer; text-decoration: underline; }
        .clickable-path:hover { background-color: #f8f9fa; }
        .footer { margin-top: 30px; text-align: center; color: #6c757d; font-size: 14px; }
        .stats { display: flex; gap: 20px; margin-bottom: 20px; }
        .stat-box { background: #ffffff; border: 1px solid #dee2e6; padding: 15px; border-radius: 5px; text-align: center; flex: 1; }
        .stat-number { font-size: 24px; font-weight: bold; color: #0056b3; }
        .stat-label { color: #6c757d; font-size: 14px; }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class="container"&gt;
        &lt;h1&gt;` + h.serviceName + ` Service - Available Routes&lt;/h1&gt;

        &lt;div class="service-info"&gt;
            &lt;strong&gt;Service:&lt;/strong&gt; ` + h.serviceName + `&lt;br&gt;
            &lt;strong&gt;Generated:&lt;/strong&gt; ` + time.Now().Format("2006-01-02 15:04:05") + `&lt;br&gt;
            &lt;strong&gt;Total Routes:&lt;/strong&gt; ` + fmt.Sprintf("%d", len(h.routes)) + `
        &lt;/div&gt;

        &lt;div class="stats"&gt;
            &lt;div class="stat-box"&gt;
                &lt;div class="stat-number"&gt;` + fmt.Sprintf("%d", len(h.routes)) + `&lt;/div&gt;
                &lt;div class="stat-label"&gt;Total Routes&lt;/div&gt;
            &lt;/div&gt;
            &lt;div class="stat-box"&gt;
                &lt;div class="stat-number"&gt;` + fmt.Sprintf("%d", h.countMethods("GET")) + `&lt;/div&gt;
                &lt;div class="stat-label"&gt;GET Routes&lt;/div&gt;
            &lt;/div&gt;
            &lt;div class="stat-box"&gt;
                &lt;div class="stat-number"&gt;` + fmt.Sprintf("%d", h.countMethods("POST")) + `&lt;/div&gt;
                &lt;div class="stat-label"&gt;POST Routes&lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;

        &lt;table class="route-table"&gt;
            &lt;thead&gt;
                &lt;tr&gt;
                    &lt;th&gt;Method&lt;/th&gt;
                    &lt;th&gt;Path&lt;/th&gt;
                    &lt;th&gt;Handler&lt;/th&gt;
                &lt;/tr&gt;
            &lt;/thead&gt;
            &lt;tbody&gt;`)

        for _, route := range h.routes </span><span class="cov0" title="0">{
                methodClass := "method-" + strings.ToLower(route.Method)
                pathClass := "path"

                // Make paths clickable for GET routes
                if route.Method == "GET" </span><span class="cov0" title="0">{
                        pathClass += " clickable-path"
                }</span>

                <span class="cov0" title="0">html.WriteString(fmt.Sprintf(`
                &lt;tr&gt;
                    &lt;td&gt;&lt;span class="method %s"&gt;%s&lt;/span&gt;&lt;/td&gt;
                    &lt;td&gt;&lt;span class="%s" onclick="navigateToRoute('%s', '%s')"&gt;%s&lt;/span&gt;&lt;/td&gt;
                    &lt;td&gt;%s&lt;/td&gt;
                &lt;/tr&gt;`,
                        methodClass, route.Method,
                        pathClass, route.Method, route.Path, route.Path,
                        route.HandlerName,
                ))</span>
        }

        <span class="cov0" title="0">html.WriteString(`
            &lt;/tbody&gt;
        &lt;/table&gt;

        &lt;div class="footer"&gt;
            &lt;p&gt;Click on any GET route path to navigate to it | &lt;a href="/?json=true"&gt;View as JSON&lt;/a&gt;&lt;/p&gt;
        &lt;/div&gt;
    &lt;/div&gt;

    &lt;script&gt;
        function navigateToRoute(method, path) {
            if (method === 'GET') {
                window.location.href = path;
            } else {
                alert('Only GET routes can be navigated to directly. Use API client for ' + method + ' requests.');
            }
        }
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;`)

        return html.String()</span>
}

// countMethods counts routes by HTTP method
func (h *RouteListingHandler) countMethods(method string) int <span class="cov0" title="0">{
        count := 0
        for _, route := range h.routes </span><span class="cov0" title="0">{
                if route.Method == method </span><span class="cov0" title="0">{
                        count++
                }</span>
        }
        <span class="cov0" title="0">return count</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package handlers

import (
        "encoding/json"
        "io/fs"
        "net/http"
        "os"
        "time"

        "github.com/gin-contrib/cors"
        "github.com/gin-contrib/secure"
        "github.com/gin-contrib/sessions"
        "github.com/gin-contrib/sessions/cookie"
        "github.com/gin-gonic/gin"
        "go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp"

        "quizapp/internal/config"
        "quizapp/internal/middleware"
        "quizapp/internal/observability"
        "quizapp/internal/services"
        "quizapp/internal/version"
)

// NewRouter returns a fully configured Gin engine for the backend server.
func NewRouter(
        cfg *config.Config,
        userService services.UserServiceInterface,
        questionService services.QuestionServiceInterface,
        learningService services.LearningServiceInterface,
        aiService services.AIServiceInterface,
        workerService services.WorkerServiceInterface,
        oauthService *services.OAuthService,
        logger *observability.Logger,
) *gin.Engine <span class="cov4" title="7">{
        // Setup Gin router
        router := gin.New()
        router.Use(gin.Recovery())

        // Add HTTP request logging middleware using our observability logger
        router.Use(func(c *gin.Context) </span><span class="cov10" title="201">{
                start := time.Now()

                // Process request
                c.Next()

                // Log request details using our observability logger
                latency := time.Since(start)
                statusCode := c.Writer.Status()
                clientIP := c.ClientIP()
                method := c.Request.Method
                path := c.Request.URL.Path

                // Create structured log entry
                fields := map[string]interface{}{
                        "http.method":      method,
                        "http.path":        path,
                        "http.status_code": statusCode,
                        "http.latency_ms":  latency.Milliseconds(),
                        "http.client_ip":   clientIP,
                        "http.user_agent":  c.Request.UserAgent(),
                }

                // Add error message if present
                if len(c.Errors) &gt; 0 </span><span class="cov0" title="0">{
                        fields["http.error"] = c.Errors.String()
                }</span>

                // Log using our observability logger (goes to both stdout and OTLP)
                // Use appropriate log level based on status code
                <span class="cov10" title="201">if statusCode &gt;= 500 </span><span class="cov0" title="0">{
                        logger.Error(c.Request.Context(), "HTTP request failed", nil, fields)
                }</span> else<span class="cov10" title="201"> if statusCode &gt;= 400 </span><span class="cov7" title="58">{
                        logger.Warn(c.Request.Context(), "HTTP request warning", fields)
                }</span> else<span class="cov9" title="143"> {
                        logger.Info(c.Request.Context(), "HTTP request", fields)
                }</span>
        })

        // Add OpenTelemetry middleware for HTTP tracing and context propagation with automatic error attributes
        <span class="cov4" title="7">router.Use(observability.GinMiddlewareWithErrorHandling("quiz-backend"))

        // Health check endpoint (defined before any security middleware)
        router.GET("/health", func(c *gin.Context) </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{"status": "ok", "service": "backend"})
        }</span>)

        // Version endpoint
        <span class="cov4" title="7">router.GET("/version", func(c *gin.Context) </span><span class="cov1" title="1">{
                c.JSON(http.StatusOK, gin.H{
                        "service":   "backend",
                        "version":   version.Version,
                        "commit":    version.Commit,
                        "buildTime": version.BuildTime,
                })
        }</span>)

        // Disable automatic redirection for trailing slashes, which is better for APIs
        <span class="cov4" title="7">router.RedirectTrailingSlash = false

        // CORS middleware configuration
        router.Use(cors.New(cors.Config{
                AllowOrigins:     cfg.CORSOrigins,
                AllowMethods:     []string{"GET", "POST", "PUT", "DELETE", "OPTIONS"},
                AllowHeaders:     []string{"Origin", "Content-Type", "Accept", "Authorization"},
                ExposeHeaders:    []string{"Content-Length"},
                AllowCredentials: true,
                MaxAge:           config.CORSMaxAge,
        }))

        // Security middleware
        secureConfig := secure.DefaultConfig()
        secureConfig.SSLRedirect = false
        secureConfig.ContentSecurityPolicy = config.DefaultCSP
        router.Use(secure.New(secureConfig))

        // Setup session middleware
        store := cookie.NewStore([]byte(cfg.SessionSecret))
        // Configure session options for OAuth compatibility
        sessionOpts := sessions.Options{
                Path:     config.SessionPath,
                MaxAge:   int(config.SessionMaxAge.Seconds()),
                HttpOnly: config.SessionHTTPOnly,
                Secure:   config.SessionSecure, // Set to true in production with HTTPS
        }
        if cfg.Debug </span><span class="cov0" title="0">{
                sessionOpts.SameSite = http.SameSiteDefaultMode
        }</span> else<span class="cov4" title="7"> {
                sessionOpts.SameSite = http.SameSiteLaxMode
                sessionOpts.Secure = true
        }</span>
        <span class="cov4" title="7">store.Options(sessionOpts)
        router.Use(sessions.Sessions("quiz-session", store))

        // Serve all static assets (JS, fonts, CSS, etc.) from /static/*filepath
        assetsFS := GetEmbeddedFS()
        staticFS, _ := fs.Sub(assetsFS, "templates/assets")
        router.StaticFS("/static", http.FS(staticFS))

        // Initialize handlers
        authHandler := NewAuthHandler(userService, oauthService, cfg, logger)
        settingsHandler := NewSettingsHandler(userService, aiService, learningService, cfg, logger)
        quizHandler := NewQuizHandler(userService, questionService, aiService, learningService, workerService, cfg, logger)
        adminHandler := NewAdminHandlerWithLogger(userService, questionService, aiService, cfg, learningService, workerService, logger)
        userAdminHandler := NewUserAdminHandler(userService, cfg, logger)

        // V1 routes (matching swagger spec)
        v1 := router.Group("/v1")
        </span><span class="cov4" title="7">{
                // Version aggregation endpoint (no auth)
                v1.GET("/version", func(c *gin.Context) </span><span class="cov0" title="0">{
                        backendVersion := gin.H{
                                "service":   "backend",
                                "version":   version.Version,
                                "commit":    version.Commit,
                                "buildTime": version.BuildTime,
                        }
                        workerInternalURL := os.Getenv("WORKER_INTERNAL_URL")
                        if workerInternalURL == "" </span><span class="cov0" title="0">{
                                workerInternalURL = config.DefaultWorkerInternalURL // fallback
                        }</span>
                        // Use instrumented HTTP client for tracing
                        <span class="cov0" title="0">client := &amp;http.Client{
                                Transport: otelhttp.NewTransport(http.DefaultTransport),
                        }
                        req, err := http.NewRequest("GET", workerInternalURL+"/version", nil)
                        var workerResp *http.Response
                        if err == nil </span><span class="cov0" title="0">{
                                req = req.WithContext(c.Request.Context())
                                workerResp, err = client.Do(req)
                        }</span>
                        <span class="cov0" title="0">var workerVersion interface{}
                        if err == nil &amp;&amp; workerResp.StatusCode == config.HTTPStatusOK </span><span class="cov0" title="0">{
                                defer func() </span><span class="cov0" title="0">{ _ = workerResp.Body.Close() }</span>()
                                <span class="cov0" title="0">if err := json.NewDecoder(workerResp.Body).Decode(&amp;workerVersion); err != nil </span><span class="cov0" title="0">{
                                        workerVersion = gin.H{"error": "Failed to decode worker version"}
                                }</span>
                        } else<span class="cov0" title="0"> {
                                workerVersion = gin.H{"error": "Worker unavailable"}
                        }</span>
                        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                                "backend": backendVersion,
                                "worker":  workerVersion,
                        })</span>
                })
                <span class="cov4" title="7">auth := v1.Group("/auth")
                </span><span class="cov4" title="7">{
                        auth.POST("/login", authHandler.Login)
                        auth.POST("/logout", authHandler.Logout)
                        auth.GET("/status", authHandler.Status)
                        auth.POST("/signup", authHandler.Signup)
                        auth.GET("/signup/status", authHandler.SignupStatus)
                        auth.GET("/google/login", authHandler.GoogleLogin)
                        auth.GET("/google/callback", authHandler.GoogleCallback)
                }</span>
                <span class="cov4" title="7">quiz := v1.Group("/quiz")
                quiz.Use(middleware.RequireAuth())
                </span><span class="cov4" title="7">{
                        quiz.GET("/question", quizHandler.GetQuestion)
                        quiz.GET("/question/:id", quizHandler.GetQuestion)
                        quiz.POST("/question/:id/report", quizHandler.ReportQuestion)
                        quiz.POST("/question/:id/mark-known", quizHandler.MarkQuestionAsKnown)
                        quiz.POST("/answer", quizHandler.SubmitAnswer)
                        quiz.GET("/progress", quizHandler.GetProgress)
                        quiz.GET("/worker-status", quizHandler.GetWorkerStatus)
                        quiz.POST("/chat/stream", quizHandler.ChatStream)
                }</span>
                <span class="cov4" title="7">settings := v1.Group("/settings")
                </span><span class="cov4" title="7">{
                        settings.GET("/ai-providers", middleware.RequireAuth(), settingsHandler.GetProviders)
                        settings.GET("/levels", settingsHandler.GetLevels)
                        settings.GET("/languages", settingsHandler.GetLanguages)
                        settings.POST("/test-ai", middleware.RequireAuth(), settingsHandler.TestAIConnection)
                        settings.PUT("", middleware.RequireAuth(), settingsHandler.UpdateUserSettings)
                        settings.GET("/api-key/:provider", middleware.RequireAuth(), settingsHandler.CheckAPIKeyAvailability)
                }</span>
                <span class="cov4" title="7">preferences := v1.Group("/preferences")
                preferences.Use(middleware.RequireAuth())
                </span><span class="cov4" title="7">{
                        preferences.GET("/learning", settingsHandler.GetLearningPreferences)
                        preferences.PUT("/learning", settingsHandler.UpdateLearningPreferences)
                }</span>
                <span class="cov4" title="7">userz := v1.Group("/userz")
                </span><span class="cov4" title="7">{
                        userz.GET("/profile", middleware.RequireAuth(), userAdminHandler.GetCurrentUserProfile)
                        userz.PUT("/profile", middleware.RequireAuth(), userAdminHandler.UpdateCurrentUserProfile)
                        userz.GET("", middleware.RequireAuth(), userAdminHandler.GetAllUsers)
                        userz.POST("", middleware.RequireAuth(), userAdminHandler.CreateUser)
                        userz.PUT(":id", middleware.RequireAuth(), userAdminHandler.UpdateUser)
                        userz.DELETE(":id", middleware.RequireAuth(), userAdminHandler.DeleteUser)
                        userz.POST(":id/reset-password", middleware.RequireAuth(), userAdminHandler.ResetUserPassword)
                }</span>
                <span class="cov4" title="7">admin := v1.Group("/admin")
                admin.Use(middleware.RequireAuth())
                </span><span class="cov4" title="7">{
                        admin.GET("/users", adminHandler.GetUsers)
                }</span>
        }

        // Backend admin interface (shows user stats and worker health)
        <span class="cov4" title="7">router.GET("/adminz", adminHandler.GetBackendAdminPage)
        router.GET("/adminz/ai-concurrency", adminHandler.GetAIConcurrencyStats)
        router.GET("/dataz/dataz.js", adminHandler.ServeDatazJS)
        router.GET("/dataz", adminHandler.ShowDatazPage)
        router.GET("/userz/userz.js", userAdminHandler.ServeUserzJS)
        router.POST("/dataz/fix-question/:id", adminHandler.MarkQuestionAsFixed)
        router.PUT("/dataz/update-question/:id", adminHandler.UpdateQuestion)
        router.POST("/dataz/ai-fix-question/:id", adminHandler.FixQuestionWithAI)
        router.GET("/adminz/questions/:id", adminHandler.GetQuestion)
        router.PUT("/adminz/questions/:id", adminHandler.UpdateQuestion)
        router.DELETE("/adminz/questions/:id", adminHandler.DeleteQuestion)
        router.GET("/adminz/questions/paginated", adminHandler.GetQuestionsPaginated)
        router.POST("/dataz/clear-user-data", adminHandler.ClearUserData)
        router.POST("/dataz/clear-database", adminHandler.ClearDatabase)
        router.POST("/adminz/users/:id/clear", adminHandler.ClearUserDataForUser)

        // Direct /userz routes (convenience routes that mirror /v1/userz) - No auth for testing
        userz := router.Group("/userz")
        </span><span class="cov4" title="7">{
                userz.GET("/profile", userAdminHandler.GetCurrentUserProfile)
                userz.PUT("/profile", userAdminHandler.UpdateCurrentUserProfile)
                userz.GET("", userAdminHandler.GetUserManagementPage)
                userz.POST("", userAdminHandler.CreateUser)
                userz.PUT(":id", userAdminHandler.UpdateUser)
                userz.DELETE(":id", userAdminHandler.DeleteUser)
                userz.POST(":id/reset-password", userAdminHandler.ResetUserPassword)
        }</span>

        // Config dump endpoint
        <span class="cov4" title="7">router.GET("/configz", adminHandler.GetConfigz)

        // Automatic route listing at root path
        routeListing := NewRouteListingHandler("Backend")
        routeListing.CollectRoutes(router)

        // Root path shows all available routes
        router.GET("/", func(c *gin.Context) </span><span class="cov0" title="0">{
                if c.Query("json") == "true" </span><span class="cov0" title="0">{
                        routeListing.GetRouteListingJSON(c)
                }</span> else<span class="cov0" title="0"> {
                        routeListing.GetRouteListingPage(c)
                }</span>
        })

        // Swagger documentation
        <span class="cov4" title="7">router.StaticFile("/swagger.yaml", "./swagger.yaml")
        router.StaticFile("/swaggerz", "./swaggerz.html")

        return router</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package handlers

import (
        "fmt"
        "net/http"
        "strings"

        "quizapp/internal/api"
        "quizapp/internal/config"
        "quizapp/internal/middleware"
        "quizapp/internal/models"
        "quizapp/internal/observability"
        "quizapp/internal/services"

        "github.com/gin-contrib/sessions"
        "github.com/gin-gonic/gin"
        "go.opentelemetry.io/otel/attribute"
)

// SettingsHandler handles user settings related HTTP requests
type SettingsHandler struct {
        userService     services.UserServiceInterface
        aiService       services.AIServiceInterface
        learningService services.LearningServiceInterface
        cfg             *config.Config
        logger          *observability.Logger
}

// NewSettingsHandler creates a new SettingsHandler instance
func NewSettingsHandler(userService services.UserServiceInterface, aiService services.AIServiceInterface, learningService services.LearningServiceInterface, cfg *config.Config, logger *observability.Logger) *SettingsHandler <span class="cov7" title="19">{
        return &amp;SettingsHandler{
                userService:     userService,
                aiService:       aiService,
                learningService: learningService,
                cfg:             cfg,
                logger:          logger,
        }
}</span>

// UpdateUserSettings handles updating user settings
func (h *SettingsHandler) UpdateUserSettings(c *gin.Context) <span class="cov5" title="8">{
        _, span := observability.TraceHandlerFunction(c.Request.Context(), "update_user_settings")
        defer span.End()
        session := sessions.Default(c)
        userID, ok := session.Get(middleware.UserIDKey).(int)
        if !ok </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, api.ErrorResponse{Error: stringPtr("User not authenticated")})
                return
        }</span>

        <span class="cov5" title="8">var settings api.UserSettings
        if err := c.ShouldBindJSON(&amp;settings); err != nil </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, api.ErrorResponse{Error: stringPtr("Invalid request body")})
                return
        }</span>

        // Convert api.UserSettings to models.UserSettings
        <span class="cov5" title="7">modelSettings := models.UserSettings{}
        if settings.Language != nil </span><span class="cov5" title="7">{
                modelSettings.Language = string(*settings.Language)
                span.SetAttributes(attribute.String("settings.language", modelSettings.Language))
        }</span>
        <span class="cov5" title="7">if settings.Level != nil </span><span class="cov4" title="6">{
                modelSettings.Level = string(*settings.Level)
                span.SetAttributes(attribute.String("settings.level", modelSettings.Level))
        }</span>
        <span class="cov5" title="7">if settings.AiProvider != nil </span><span class="cov3" title="3">{
                modelSettings.AIProvider = *settings.AiProvider
                span.SetAttributes(attribute.String("settings.ai_provider", modelSettings.AIProvider))
        }</span>
        <span class="cov5" title="7">if settings.AiModel != nil </span><span class="cov3" title="3">{
                modelSettings.AIModel = *settings.AiModel
                span.SetAttributes(attribute.String("settings.ai_model", modelSettings.AIModel))
        }</span>
        <span class="cov5" title="7">if settings.ApiKey != nil </span><span class="cov3" title="3">{
                modelSettings.AIAPIKey = *settings.ApiKey
                span.SetAttributes(attribute.Bool("settings.api_key_provided", true))
        }</span>
        <span class="cov5" title="7">if settings.AiEnabled != nil </span><span class="cov3" title="3">{
                modelSettings.AIEnabled = *settings.AiEnabled
                span.SetAttributes(attribute.Bool("settings.ai_enabled", modelSettings.AIEnabled))
        }</span>

        // Validate level if provided (including empty string)
        <span class="cov5" title="7">if settings.Level != nil </span><span class="cov4" title="6">{
                validLevels := h.cfg.AppConfig.GetAllLevels()
                isValidLevel := false
                for _, level := range validLevels </span><span class="cov10" title="64">{
                        if modelSettings.Level == level </span><span class="cov3" title="3">{
                                isValidLevel = true
                                break</span>
                        }
                }

                <span class="cov4" title="6">if !isValidLevel </span><span class="cov3" title="3">{
                        c.JSON(http.StatusBadRequest, api.ErrorResponse{
                                Error: stringPtr("Invalid level. Must be one of: " + strings.Join(validLevels, ", ")),
                        })
                        return
                }</span>
        }

        // Validate language if provided (including empty string)
        <span class="cov4" title="4">if settings.Language != nil </span><span class="cov4" title="4">{
                validLanguages := h.cfg.AppConfig.GetLanguages()
                isValidLanguage := false
                for _, language := range validLanguages </span><span class="cov6" title="12">{
                        if modelSettings.Language == language </span><span class="cov3" title="3">{
                                isValidLanguage = true
                                break</span>
                        }
                }

                <span class="cov4" title="4">if !isValidLanguage </span><span class="cov1" title="1">{
                        c.JSON(http.StatusBadRequest, api.ErrorResponse{
                                Error: stringPtr("Invalid language. Must be one of: " + strings.Join(validLanguages, ", ")),
                        })
                        return
                }</span>
        }

        <span class="cov3" title="3">if err := h.userService.UpdateUserSettings(c.Request.Context(), userID, &amp;modelSettings); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusServiceUnavailable, api.ErrorResponse{Error: stringPtr("Failed to update settings")})
                return
        }</span>

        <span class="cov3" title="3">c.JSON(http.StatusOK, api.SuccessResponse{Success: boolPtr(true)})</span>
}

// TestAIConnection tests the AI service connection with provided settings
func (h *SettingsHandler) TestAIConnection(c *gin.Context) <span class="cov3" title="3">{
        _, span := observability.TraceHandlerFunction(c.Request.Context(), "test_ai_connection")
        defer span.End()
        session := sessions.Default(c)
        userID, ok := session.Get(middleware.UserIDKey).(int)
        if !ok </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, api.ErrorResponse{Error: stringPtr("User not authenticated")})
                return
        }</span>

        <span class="cov3" title="3">var req api.TestAIRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov2" title="2">{
                c.JSON(http.StatusBadRequest, api.ErrorResponse{Error: stringPtr("Invalid request format")})
                return
        }</span>

        // Extract values from API request
        <span class="cov1" title="1">provider := req.Provider
        model := req.Model
        apiKey := ""
        if req.ApiKey != nil </span><span class="cov1" title="1">{
                apiKey = *req.ApiKey
        }</span>

        // If API key is empty, try to use the saved one from the new user_api_keys table
        <span class="cov1" title="1">if apiKey == "" </span><span class="cov0" title="0">{
                savedKey, err := h.userService.GetUserAPIKey(c.Request.Context(), userID, provider)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusServiceUnavailable, api.ErrorResponse{Error: stringPtr("Failed to get saved API key")})
                        return
                }</span>
                <span class="cov0" title="0">apiKey = savedKey</span>
        }

        <span class="cov1" title="1">err := h.aiService.TestConnection(c.Request.Context(), provider, model, apiKey)
        if err != nil </span><span class="cov1" title="1">{
                c.JSON(http.StatusOK, gin.H{
                        "success": false,
                        "message": fmt.Sprintf("Model '%s': %s", model, err.Error()),
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"success": true, "message": "Connection successful"})</span>
}

// GetProviders returns the available AI provider configurations
func (h *SettingsHandler) GetProviders(c *gin.Context) <span class="cov3" title="3">{
        _, span := observability.TraceHandlerFunction(c.Request.Context(), "get_providers")
        defer span.End()
        // Create response with backward compatibility
        response := gin.H{
                "providers": h.cfg.AppConfig.Providers,
                "levels":    h.cfg.AppConfig.GetAllLevels(),
                "languages": h.cfg.AppConfig.GetLanguages(),
        }
        c.JSON(http.StatusOK, response)
}</span>

// GetLevels returns the available levels and their descriptions.
func (h *SettingsHandler) GetLevels(c *gin.Context) <span class="cov4" title="6">{
        _, span := observability.TraceHandlerFunction(c.Request.Context(), "get_levels")
        defer span.End()
        language := c.Query("language")
        if language != "" </span><span class="cov4" title="4">{
                levels := h.cfg.AppConfig.GetLevelsForLanguage(language)
                descriptions := h.cfg.AppConfig.GetLevelDescriptionsForLanguage(language)
                c.JSON(http.StatusOK, gin.H{
                        "levels":             levels,
                        "level_descriptions": descriptions,
                })
                return
        }</span>
        <span class="cov2" title="2">c.JSON(http.StatusOK, gin.H{
                "levels":             h.cfg.AppConfig.GetAllLevels(),
                "level_descriptions": h.cfg.AppConfig.GetAllLevelDescriptions(),
        })</span>
}

// GetLanguages returns the available languages.
func (h *SettingsHandler) GetLanguages(c *gin.Context) <span class="cov1" title="1">{
        _, span := observability.TraceHandlerFunction(c.Request.Context(), "get_languages")
        defer span.End()
        c.JSON(http.StatusOK, h.cfg.AppConfig.GetLanguages())
}</span>

// CheckAPIKeyAvailability checks if the user has a saved API key for the specified provider
func (h *SettingsHandler) CheckAPIKeyAvailability(c *gin.Context) <span class="cov2" title="2">{
        _, span := observability.TraceHandlerFunction(c.Request.Context(), "check_api_key_availability")
        defer span.End()
        session := sessions.Default(c)
        userID, ok := session.Get(middleware.UserIDKey).(int)
        if !ok </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, api.ErrorResponse{Error: stringPtr("User not authenticated")})
                return
        }</span>

        <span class="cov2" title="2">provider := c.Param("provider")
        if provider == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, api.ErrorResponse{Error: stringPtr("Provider parameter is required")})
                return
        }</span>

        // Check if user has a saved API key for this provider
        <span class="cov2" title="2">hasAPIKey, err := h.userService.HasUserAPIKey(c.Request.Context(), userID, provider)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusServiceUnavailable, api.ErrorResponse{Error: stringPtr("Failed to check API key availability")})
                return
        }</span>

        <span class="cov2" title="2">c.JSON(http.StatusOK, gin.H{"has_api_key": hasAPIKey})</span>
}

// GetLearningPreferences retrieves user learning preferences
func (h *SettingsHandler) GetLearningPreferences(c *gin.Context) <span class="cov4" title="5">{
        _, span := observability.TraceHandlerFunction(c.Request.Context(), "get_learning_preferences")
        defer span.End()
        session := sessions.Default(c)
        userID, ok := session.Get(middleware.UserIDKey).(int)
        if !ok </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, api.ErrorResponse{Error: stringPtr("User not authenticated")})
                return
        }</span>

        <span class="cov4" title="5">preferences, err := h.learningService.GetUserLearningPreferences(c.Request.Context(), userID)
        if err != nil </span><span class="cov1" title="1">{
                c.JSON(http.StatusServiceUnavailable, api.ErrorResponse{Error: stringPtr("Failed to get learning preferences")})
                return
        }</span>

        <span class="cov3" title="3">c.JSON(http.StatusOK, preferences)</span>
}

// UpdateLearningPreferences updates user learning preferences
func (h *SettingsHandler) UpdateLearningPreferences(c *gin.Context) <span class="cov5" title="9">{
        _, span := observability.TraceHandlerFunction(c.Request.Context(), "update_learning_preferences")
        defer span.End()
        session := sessions.Default(c)
        userID, ok := session.Get(middleware.UserIDKey).(int)
        if !ok </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, api.ErrorResponse{Error: stringPtr("User not authenticated")})
                return
        }</span>

        <span class="cov5" title="9">var req models.UserLearningPreferences
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov4" title="4">{
                c.JSON(http.StatusBadRequest, api.ErrorResponse{Error: stringPtr("Invalid request body")})
                return
        }</span>

        // Set the user ID
        <span class="cov4" title="5">req.UserID = userID

        // Set span attributes for updated preferences
        span.SetAttributes(
                attribute.Bool("learning.focus_on_weak_areas", req.FocusOnWeakAreas),
                attribute.Bool("learning.include_review_questions", req.IncludeReviewQuestions),
                attribute.Float64("learning.fresh_question_ratio", req.FreshQuestionRatio),
                attribute.Float64("learning.known_question_penalty", req.KnownQuestionPenalty),
                attribute.Int("learning.review_interval_days", req.ReviewIntervalDays),
                attribute.Float64("learning.weak_area_boost", req.WeakAreaBoost),
        )

        // Update preferences in database
        _, err := h.learningService.UpdateUserLearningPreferences(c.Request.Context(), userID, &amp;req)
        if err != nil </span><span class="cov1" title="1">{
                c.JSON(http.StatusServiceUnavailable, api.ErrorResponse{Error: stringPtr("Failed to update learning preferences")})
                return
        }</span>

        <span class="cov3" title="3">c.JSON(http.StatusOK, api.SuccessResponse{Message: stringPtr("Learning preferences updated successfully")})</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package handlers

import (
        "context"
        "database/sql"
        "embed"
        "html/template"
        "net/http"
        "strconv"
        "strings"
        "time"

        "quizapp/internal/config"
        "quizapp/internal/models"
        "quizapp/internal/observability"
        "quizapp/internal/services"

        "github.com/gin-gonic/gin"
)

//go:embed templates/user_admin.html templates/shared_nav.html templates/assets/js/userz.js
var userAdminTemplateFS embed.FS

// UserAdminHandler handles user management operations
type UserAdminHandler struct {
        userService services.UserServiceInterface
        cfg         *config.Config
        templates   *template.Template
        logger      *observability.Logger
}

// NewUserAdminHandler creates a new UserAdminHandler instance
func NewUserAdminHandler(userService services.UserServiceInterface, cfg *config.Config, logger *observability.Logger) *UserAdminHandler <span class="cov6" title="7">{
        // Parse templates from embedded filesystem
        templates, err := template.New("user_admin.html").Funcs(template.FuncMap{
                "timeago": func(t time.Time) string </span><span class="cov0" title="0">{
                        if !t.After(time.Time{}) </span><span class="cov0" title="0">{
                                return "Never"
                        }</span>
                        <span class="cov0" title="0">duration := time.Since(t)
                        if duration.Hours() &lt; 1 </span><span class="cov0" title="0">{
                                return "Just now"
                        }</span>
                        <span class="cov0" title="0">if duration.Hours() &lt; 24 </span><span class="cov0" title="0">{
                                return strconv.Itoa(int(duration.Hours())) + " hours ago"
                        }</span>
                        <span class="cov0" title="0">if duration.Hours() &lt; 24*7 </span><span class="cov0" title="0">{
                                return strconv.Itoa(int(duration.Hours()/24)) + " days ago"
                        }</span>
                        <span class="cov0" title="0">return t.Format("Jan 2, 2006")</span>
                },
        }).ParseFS(userAdminTemplateFS, "templates/*.html")
        <span class="cov6" title="7">if err != nil </span><span class="cov0" title="0">{
                logger.Error(context.Background(), "Failed to parse embedded user admin templates - binary cannot continue", err, nil)
                panic(err)</span>
        }
        <span class="cov6" title="7">logger.Info(context.Background(), "Successfully loaded embedded user admin template")

        return &amp;UserAdminHandler{
                userService: userService,
                cfg:         cfg,
                templates:   templates,
                logger:      logger,
        }</span>
}

// UserCreateRequest represents a request to create a new user
type UserCreateRequest struct {
        Username          string `json:"username" binding:"required"`
        Email             string `json:"email"`
        Timezone          string `json:"timezone"`
        Password          string `json:"password" binding:"required"`
        PreferredLanguage string `json:"preferred_language"`
        CurrentLevel      string `json:"current_level"`
}

// UserUpdateRequest represents a request to update user profile
type UserUpdateRequest struct {
        Username          string `json:"username"`
        Email             string `json:"email"`
        Timezone          string `json:"timezone"`
        PreferredLanguage string `json:"preferred_language"`
        CurrentLevel      string `json:"current_level"`
        AIEnabled         *bool  `json:"ai_enabled"`
        AIProvider        string `json:"ai_provider"`
        AIModel           string `json:"ai_model"`
        APIKey            string `json:"api_key"`
}

// PasswordResetRequest represents a request to reset user password
type PasswordResetRequest struct {
        NewPassword string `json:"new_password" binding:"required"`
}

// ProfileResponse represents user profile data
type ProfileResponse struct {
        ID                int        `json:"id"`
        Username          string     `json:"username"`
        Email             *string    `json:"email"`
        Timezone          *string    `json:"timezone"`
        LastActive        *time.Time `json:"last_active"`
        PreferredLanguage *string    `json:"preferred_language"`
        CurrentLevel      *string    `json:"current_level"`
        CreatedAt         time.Time  `json:"created_at"`
        UpdatedAt         time.Time  `json:"updated_at"`
        AIEnabled         bool       `json:"ai_enabled"`
        AIProvider        *string    `json:"ai_provider"`
        AIModel           *string    `json:"ai_model"`
}

// GetUserManagementPage handles GET /userz - serves HTML page for user management (admin only)
func (h *UserAdminHandler) GetUserManagementPage(c *gin.Context) <span class="cov1" title="1">{
        // Check if request accepts HTML (from browser)
        accept := c.GetHeader("Accept")
        if strings.Contains(accept, "application/json") </span><span class="cov1" title="1">{
                // API request - return JSON
                h.GetAllUsers(c)
                return
        }</span>

        <span class="cov0" title="0">users, err := h.userService.GetAllUsers(c.Request.Context())
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error(c.Request.Context(), "Error retrieving users", err, nil)
                c.HTML(http.StatusInternalServerError, "", "&lt;h1&gt;Error loading users&lt;/h1&gt;")
                return
        }</span>

        // Calculate stats
        <span class="cov0" title="0">activeUsers := 0
        recentSignups := 0
        now := time.Now()
        for _, user := range users </span><span class="cov0" title="0">{
                if user.LastActive.Valid &amp;&amp; user.LastActive.Time.After(now.AddDate(0, 0, -7)) </span><span class="cov0" title="0">{
                        activeUsers++
                }</span>
                <span class="cov0" title="0">if user.CreatedAt.After(now.AddDate(0, 0, -30)) </span><span class="cov0" title="0">{
                        recentSignups++
                }</span>
        }

        <span class="cov0" title="0">data := gin.H{
                "Users":         users,
                "ActiveUsers":   activeUsers,
                "RecentSignups": recentSignups,
                "CurrentPage":   "userz",
                "WorkerPort":    h.cfg.WorkerPort,
                "IsBackend":     true,
                "WorkerBaseURL": h.cfg.WorkerBaseURL,
                "AIProviders":   h.cfg.AppConfig,
        }

        // Use embedded template
        c.Header("Content-Type", "text/html; charset=utf-8")
        c.Header("Cache-Control", "no-cache, no-store, must-revalidate")
        c.Header("Pragma", "no-cache")
        c.Header("Expires", "0")

        if err := h.templates.ExecuteTemplate(c.Writer, "user_admin.html", data); err != nil </span><span class="cov0" title="0">{
                h.logger.Error(c.Request.Context(), "Template execution failed", err, nil)
                c.HTML(http.StatusInternalServerError, "", "&lt;h1&gt;Template error&lt;/h1&gt;")
        }</span>
}

// GetAllUsers handles GET /userz - list all users (admin only) - JSON API
func (h *UserAdminHandler) GetAllUsers(c *gin.Context) <span class="cov1" title="1">{
        users, err := h.userService.GetAllUsers(c.Request.Context())
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error(c.Request.Context(), "Error retrieving users", err, nil)
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to retrieve users"})
                return
        }</span>

        // Convert to response format
        <span class="cov1" title="1">var userResponses []ProfileResponse
        for _, user := range users </span><span class="cov2" title="2">{
                userResponses = append(userResponses, h.convertUserToProfileResponse(&amp;user))
        }</span>

        <span class="cov1" title="1">c.JSON(http.StatusOK, gin.H{"users": userResponses})</span>
}

// CreateUser handles POST /userz - create new user (admin only)
func (h *UserAdminHandler) CreateUser(c *gin.Context) <span class="cov4" title="4">{
        var req UserCreateRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov2" title="2">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request data"})
                return
        }</span>

        // Validate timezone if provided
        <span class="cov2" title="2">if req.Timezone != "" &amp;&amp; !h.isValidTimezone(req.Timezone) </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid timezone"})
                return
        }</span>

        // Set default values
        <span class="cov2" title="2">if req.PreferredLanguage == "" </span><span class="cov1" title="1">{
                req.PreferredLanguage = "italian"
        }</span>
        <span class="cov2" title="2">if req.CurrentLevel == "" </span><span class="cov1" title="1">{
                req.CurrentLevel = "A1"
        }</span>
        <span class="cov2" title="2">if req.Timezone == "" </span><span class="cov1" title="1">{
                req.Timezone = "UTC"
        }</span>

        // Check if username already exists
        <span class="cov2" title="2">existingUser, err := h.userService.GetUserByUsername(c.Request.Context(), req.Username)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error(c.Request.Context(), "Error checking existing username", err, nil)
                c.JSON(http.StatusConflict, gin.H{"error": "Username already exists"})
                return
        }</span>
        <span class="cov2" title="2">if existingUser != nil </span><span class="cov1" title="1">{
                c.JSON(http.StatusConflict, gin.H{"error": "Username already exists"})
                return
        }</span>

        // Check if email already exists (if provided)
        <span class="cov1" title="1">if req.Email != "" </span><span class="cov1" title="1">{
                existingUser, err := h.userService.GetUserByEmail(c.Request.Context(), req.Email)
                if err != nil </span><span class="cov0" title="0">{
                        h.logger.Error(c.Request.Context(), "Error checking existing email", err, nil)
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to check email uniqueness"})
                        return
                }</span>
                <span class="cov1" title="1">if existingUser != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusConflict, gin.H{"error": "Email already exists"})
                        return
                }</span>
        }

        // Create user
        <span class="cov1" title="1">user, err := h.userService.CreateUserWithEmailAndTimezone(
                c.Request.Context(),
                req.Username,
                req.Email,
                req.Timezone,
                req.PreferredLanguage,
                req.CurrentLevel,
        )
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error(c.Request.Context(), "Error creating user", err, nil)
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create user"})
                return
        }</span>

        // Set password
        <span class="cov1" title="1">err = h.userService.UpdateUserPassword(c.Request.Context(), user.ID, req.Password)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error(c.Request.Context(), "Error setting user password", err, nil)
                // Try to clean up the created user
                _ = h.userService.DeleteUser(c.Request.Context(), user.ID)
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to set user password"})
                return
        }</span>

        // Return the created user profile
        <span class="cov1" title="1">c.JSON(http.StatusCreated, gin.H{
                "message": "User created successfully",
                "user":    h.convertUserToProfileResponse(user),
        })</span>
}

// UpdateUser handles PUT /userz/:id - update user details (admin or self)
func (h *UserAdminHandler) UpdateUser(c *gin.Context) <span class="cov1" title="1">{
        userIDStr := c.Param("id")
        userID, err := strconv.Atoi(userIDStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid user ID"})
                return
        }</span>

        // Check if user exists
        <span class="cov1" title="1">user, err := h.userService.GetUserByID(c.Request.Context(), userID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error(c.Request.Context(), "Error retrieving user", err, nil)
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Database error"})
                return
        }</span>
        <span class="cov1" title="1">if user == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": "User not found"})
                return
        }</span>

        // Check authorization (admin or self) - skip for direct routes (testing)
        <span class="cov1" title="1">currentUserID, exists := c.Get("user_id")
        if exists </span><span class="cov0" title="0">{
                currentUserIDInt, ok := currentUserID.(int)
                if !ok </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "Invalid user ID type"})
                        return
                }</span>

                // Only allow users to update their own profile
                <span class="cov0" title="0">if currentUserIDInt != userID </span><span class="cov0" title="0">{
                        c.JSON(http.StatusForbidden, gin.H{"error": "You can only update your own profile"})
                        return
                }</span>
        }

        <span class="cov1" title="1">var req UserUpdateRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request data"})
                return
        }</span>

        // Validate timezone if provided
        <span class="cov1" title="1">if req.Timezone != "" &amp;&amp; !h.isValidTimezone(req.Timezone) </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid timezone"})
                return
        }</span>

        // Use existing values if not provided in request
        <span class="cov1" title="1">username := req.Username
        if username == "" </span><span class="cov0" title="0">{
                username = user.Username
        }</span>

        <span class="cov1" title="1">email := req.Email
        if email == "" &amp;&amp; user.Email.Valid </span><span class="cov0" title="0">{
                email = user.Email.String
        }</span>

        <span class="cov1" title="1">timezone := req.Timezone
        if timezone == "" &amp;&amp; user.Timezone.Valid </span><span class="cov0" title="0">{
                timezone = user.Timezone.String
        }</span>

        <span class="cov1" title="1">preferredLanguage := req.PreferredLanguage
        if preferredLanguage == "" &amp;&amp; user.PreferredLanguage.Valid </span><span class="cov1" title="1">{
                preferredLanguage = user.PreferredLanguage.String
        }</span>

        <span class="cov1" title="1">currentLevel := req.CurrentLevel
        if currentLevel == "" &amp;&amp; user.CurrentLevel.Valid </span><span class="cov1" title="1">{
                currentLevel = user.CurrentLevel.String
        }</span>

        // Check if new username already exists (if changed)
        <span class="cov1" title="1">if username != user.Username </span><span class="cov1" title="1">{
                existingUser, err := h.userService.GetUserByUsername(c.Request.Context(), username)
                if err != nil </span><span class="cov0" title="0">{
                        h.logger.Error(c.Request.Context(), "Error checking existing username", err, nil)
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to check username uniqueness"})
                        return
                }</span>
                <span class="cov1" title="1">if existingUser != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusConflict, gin.H{"error": "Username already exists"})
                        return
                }</span>
        }

        // Check if new email already exists (if changed)
        <span class="cov1" title="1">if email != "" &amp;&amp; user.Email.Valid &amp;&amp; email != user.Email.String </span><span class="cov1" title="1">{
                existingUser, err := h.userService.GetUserByEmail(c.Request.Context(), email)
                if err != nil </span><span class="cov0" title="0">{
                        h.logger.Error(c.Request.Context(), "Error checking existing email", err, nil)
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to check email uniqueness"})
                        return
                }</span>
                <span class="cov1" title="1">if existingUser != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusConflict, gin.H{"error": "Email already exists"})
                        return
                }</span>
        }

        // Update user profile
        <span class="cov1" title="1">err = h.userService.UpdateUserProfile(c.Request.Context(), userID, username, email, timezone)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error(c.Request.Context(), "Error updating user profile", err, nil)
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update user profile"})
                return
        }</span>

        // Handle AI settings update if provided
        <span class="cov1" title="1">needsAIUpdate := req.AIEnabled != nil || req.AIProvider != "" || req.AIModel != "" || req.APIKey != ""
        if needsAIUpdate </span><span class="cov0" title="0">{
                // Prepare AI settings
                aiSettings := &amp;models.UserSettings{
                        Language:  preferredLanguage,
                        Level:     currentLevel,
                        AIEnabled: req.AIEnabled != nil &amp;&amp; *req.AIEnabled,
                }

                // Set AI provider and model
                if req.AIProvider != "" </span><span class="cov0" title="0">{
                        aiSettings.AIProvider = req.AIProvider
                }</span> else<span class="cov0" title="0"> if user.AIProvider.Valid </span><span class="cov0" title="0">{
                        aiSettings.AIProvider = user.AIProvider.String
                }</span>

                <span class="cov0" title="0">if req.AIModel != "" </span><span class="cov0" title="0">{
                        aiSettings.AIModel = req.AIModel
                }</span> else<span class="cov0" title="0"> if user.AIModel.Valid </span><span class="cov0" title="0">{
                        aiSettings.AIModel = user.AIModel.String
                }</span>

                // Set API key if provided
                <span class="cov0" title="0">if req.APIKey != "" </span><span class="cov0" title="0">{
                        aiSettings.AIAPIKey = req.APIKey
                }</span>

                // Update AI settings
                <span class="cov0" title="0">err = h.userService.UpdateUserSettings(c.Request.Context(), userID, aiSettings)
                if err != nil </span><span class="cov0" title="0">{
                        h.logger.Error(c.Request.Context(), "Error updating user AI settings", err, nil)
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update AI settings"})
                        return
                }</span>
        }

        // Get updated user
        <span class="cov1" title="1">updatedUser, err := h.userService.GetUserByID(c.Request.Context(), userID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error(c.Request.Context(), "Error retrieving updated user", err, nil)
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to retrieve updated user"})
                return
        }</span>

        <span class="cov1" title="1">c.JSON(http.StatusOK, gin.H{
                "message": "User updated successfully",
                "user":    h.convertUserToProfileResponse(updatedUser),
        })</span>
}

// DeleteUser handles DELETE /userz/:id - delete user (admin only)
func (h *UserAdminHandler) DeleteUser(c *gin.Context) <span class="cov1" title="1">{
        userIDStr := c.Param("id")
        userID, err := strconv.Atoi(userIDStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid user ID"})
                return
        }</span>

        // Check if user exists
        <span class="cov1" title="1">user, err := h.userService.GetUserByID(c.Request.Context(), userID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error(c.Request.Context(), "Error retrieving user", err, nil)
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Database error"})
                return
        }</span>
        <span class="cov1" title="1">if user == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": "User not found"})
                return
        }</span>

        // Delete user
        <span class="cov1" title="1">err = h.userService.DeleteUser(c.Request.Context(), userID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error(c.Request.Context(), "Error deleting user", err, nil)
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to delete user"})
                return
        }</span>

        <span class="cov1" title="1">c.JSON(http.StatusOK, gin.H{"message": "User deleted successfully"})</span>
}

// ResetUserPassword handles POST /userz/:id/reset-password - reset user password (admin only)
func (h *UserAdminHandler) ResetUserPassword(c *gin.Context) <span class="cov1" title="1">{
        userIDStr := c.Param("id")
        userID, err := strconv.Atoi(userIDStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid user ID"})
                return
        }</span>

        // Check if user exists
        <span class="cov1" title="1">user, err := h.userService.GetUserByID(c.Request.Context(), userID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error(c.Request.Context(), "Error retrieving user", err, nil)
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Database error"})
                return
        }</span>
        <span class="cov1" title="1">if user == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": "User not found"})
                return
        }</span>

        <span class="cov1" title="1">var req PasswordResetRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request data"})
                return
        }</span>

        // Update password
        <span class="cov1" title="1">err = h.userService.UpdateUserPassword(c.Request.Context(), userID, req.NewPassword)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error(c.Request.Context(), "Error updating user password", err, nil)
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update password"})
                return
        }</span>

        <span class="cov1" title="1">c.JSON(http.StatusOK, gin.H{"message": "Password reset successfully"})</span>
}

// GetCurrentUserProfile handles GET /userz/profile - get current user profile
func (h *UserAdminHandler) GetCurrentUserProfile(c *gin.Context) <span class="cov0" title="0">{
        // Get user ID from session
        userID, exists := c.Get("user_id")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "User not authenticated"})
                return
        }</span>

        <span class="cov0" title="0">user, err := h.userService.GetUserByID(c.Request.Context(), userID.(int))
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error(c.Request.Context(), "Error retrieving user profile", err, nil)
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to retrieve profile"})
                return
        }</span>
        <span class="cov0" title="0">if user == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": "User not found"})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, h.convertUserToProfileResponse(user))</span>
}

// UpdateCurrentUserProfile handles PUT /userz/profile - update current user profile
func (h *UserAdminHandler) UpdateCurrentUserProfile(c *gin.Context) <span class="cov0" title="0">{
        // Get user ID from session
        userID, exists := c.Get("user_id")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "User not authenticated"})
                return
        }</span>

        <span class="cov0" title="0">var req UserUpdateRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request data"})
                return
        }</span>

        // Validate timezone if provided
        <span class="cov0" title="0">if req.Timezone != "" &amp;&amp; !h.isValidTimezone(req.Timezone) </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid timezone"})
                return
        }</span>

        // Get current user
        <span class="cov0" title="0">user, err := h.userService.GetUserByID(c.Request.Context(), userID.(int))
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error(c.Request.Context(), "Error retrieving user", err, nil)
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Database error"})
                return
        }</span>
        <span class="cov0" title="0">if user == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": "User not found"})
                return
        }</span>

        // Check authorization (admin or self)
        <span class="cov0" title="0">currentUserID, exists := c.Get("user_id")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "User not authenticated"})
                return
        }</span>

        <span class="cov0" title="0">currentUserIDInt, ok := currentUserID.(int)
        if !ok </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Invalid user ID type"})
                return
        }</span>

        // Only allow users to update their own profile
        <span class="cov0" title="0">if currentUserIDInt != userID.(int) </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, gin.H{"error": "You can only update your own profile"})
                return
        }</span>

        // Use existing values if not provided in request
        <span class="cov0" title="0">username := req.Username
        if username == "" </span><span class="cov0" title="0">{
                username = user.Username
        }</span>

        <span class="cov0" title="0">email := req.Email
        if email == "" &amp;&amp; user.Email.Valid </span><span class="cov0" title="0">{
                email = user.Email.String
        }</span>

        <span class="cov0" title="0">timezone := req.Timezone
        if timezone == "" &amp;&amp; user.Timezone.Valid </span><span class="cov0" title="0">{
                timezone = user.Timezone.String
        }</span>

        // Check if new username already exists (if changed)
        <span class="cov0" title="0">if username != user.Username </span><span class="cov0" title="0">{
                existingUser, err := h.userService.GetUserByUsername(c.Request.Context(), username)
                if err != nil </span><span class="cov0" title="0">{
                        h.logger.Error(c.Request.Context(), "Error checking existing username", err, nil)
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to check username uniqueness"})
                        return
                }</span>
                <span class="cov0" title="0">if existingUser != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusConflict, gin.H{"error": "Username already exists"})
                        return
                }</span>
        }

        // Check if new email already exists (if changed)
        <span class="cov0" title="0">if email != "" &amp;&amp; user.Email.Valid &amp;&amp; email != user.Email.String </span><span class="cov0" title="0">{
                existingUser, err := h.userService.GetUserByEmail(c.Request.Context(), email)
                if err != nil </span><span class="cov0" title="0">{
                        h.logger.Error(c.Request.Context(), "Error checking existing email", err, nil)
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to check email uniqueness"})
                        return
                }</span>
                <span class="cov0" title="0">if existingUser != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusConflict, gin.H{"error": "Email already exists"})
                        return
                }</span>
        }

        // Use existing AI values if not provided in request
        <span class="cov0" title="0">preferredLanguage := req.PreferredLanguage
        if preferredLanguage == "" &amp;&amp; user.PreferredLanguage.Valid </span><span class="cov0" title="0">{
                preferredLanguage = user.PreferredLanguage.String
        }</span>

        <span class="cov0" title="0">currentLevel := req.CurrentLevel
        if currentLevel == "" &amp;&amp; user.CurrentLevel.Valid </span><span class="cov0" title="0">{
                currentLevel = user.CurrentLevel.String
        }</span>

        // Update user profile
        <span class="cov0" title="0">err = h.userService.UpdateUserProfile(c.Request.Context(), userID.(int), username, email, timezone)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error(c.Request.Context(), "Error updating user profile", err, nil)
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update user profile"})
                return
        }</span>

        // Handle AI settings update if provided
        <span class="cov0" title="0">needsAIUpdate := req.AIEnabled != nil || req.AIProvider != "" || req.AIModel != "" || req.APIKey != "" || req.PreferredLanguage != "" || req.CurrentLevel != ""

        if needsAIUpdate </span><span class="cov0" title="0">{
                // Prepare AI settings
                aiSettings := &amp;models.UserSettings{
                        Language:  preferredLanguage,
                        Level:     currentLevel,
                        AIEnabled: req.AIEnabled != nil &amp;&amp; *req.AIEnabled,
                }

                // Set AI provider and model
                if req.AIProvider != "" </span><span class="cov0" title="0">{
                        aiSettings.AIProvider = req.AIProvider
                }</span> else<span class="cov0" title="0"> if user.AIProvider.Valid </span><span class="cov0" title="0">{
                        aiSettings.AIProvider = user.AIProvider.String
                }</span>

                <span class="cov0" title="0">if req.AIModel != "" </span><span class="cov0" title="0">{
                        aiSettings.AIModel = req.AIModel
                }</span> else<span class="cov0" title="0"> if user.AIModel.Valid </span><span class="cov0" title="0">{
                        aiSettings.AIModel = user.AIModel.String
                }</span>

                // Set API key if provided
                <span class="cov0" title="0">if req.APIKey != "" </span><span class="cov0" title="0">{
                        aiSettings.AIAPIKey = req.APIKey
                }</span>

                // Update AI settings
                <span class="cov0" title="0">err = h.userService.UpdateUserSettings(c.Request.Context(), userID.(int), aiSettings)
                if err != nil </span><span class="cov0" title="0">{
                        h.logger.Error(c.Request.Context(), "Error updating user AI settings", err, nil)
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update AI settings"})
                        return
                }</span>
        }

        // Get updated user
        <span class="cov0" title="0">updatedUser, err := h.userService.GetUserByID(c.Request.Context(), userID.(int))
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error(c.Request.Context(), "Error retrieving updated user", err, nil)
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to retrieve updated profile"})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "message": "Profile updated successfully",
                "user":    h.convertUserToProfileResponse(updatedUser),
        })</span>
}

// Helper functions

// convertUserToProfileResponse converts a User model to ProfileResponse
func (h *UserAdminHandler) convertUserToProfileResponse(user *models.User) ProfileResponse <span class="cov4" title="4">{
        return ProfileResponse{
                ID:                user.ID,
                Username:          user.Username,
                Email:             nullStringToPointer(user.Email),
                Timezone:          nullStringToPointer(user.Timezone),
                LastActive:        nullTimeToPointer(user.LastActive),
                PreferredLanguage: nullStringToPointer(user.PreferredLanguage),
                CurrentLevel:      nullStringToPointer(user.CurrentLevel),
                CreatedAt:         user.CreatedAt,
                UpdatedAt:         user.UpdatedAt,
                AIEnabled:         user.AIEnabled.Valid &amp;&amp; user.AIEnabled.Bool,
                AIProvider:        nullStringToPointer(user.AIProvider),
                AIModel:           nullStringToPointer(user.AIModel),
        }
}</span>

// isValidTimezone checks if a timezone string is valid
func (h *UserAdminHandler) isValidTimezone(tz string) bool <span class="cov2" title="2">{
        // Common timezone validation - check if it can be loaded
        _, err := time.LoadLocation(tz)
        if err != nil </span><span class="cov0" title="0">{
                // Also allow UTC as fallback
                return strings.ToUpper(tz) == "UTC"
        }</span>
        <span class="cov2" title="2">return true</span>
}

// Helper function to convert sql.NullString to *string (if not already available)
func nullStringToPointer(ns sql.NullString) *string <span class="cov10" title="24">{
        if ns.Valid </span><span class="cov8" title="16">{
                return &amp;ns.String
        }</span>
        <span class="cov6" title="8">return nil</span>
}

// Helper function to convert sql.NullTime to *time.Time (if not already available)
func nullTimeToPointer(nt sql.NullTime) *time.Time <span class="cov4" title="4">{
        if nt.Valid </span><span class="cov4" title="4">{
                return &amp;nt.Time
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// ServeUserzJS serves the JavaScript file for the userz page
func (h *UserAdminHandler) ServeUserzJS(c *gin.Context) <span class="cov0" title="0">{
        jsContent, err := userAdminTemplateFS.ReadFile("templates/assets/js/userz.js")
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": "JavaScript file not found"})
                return
        }</span>

        <span class="cov0" title="0">c.Header("Content-Type", "application/javascript")
        c.String(http.StatusOK, string(jsContent))</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package handlers

import (
        "context"

        "quizapp/internal/api"
        "quizapp/internal/models"
        "quizapp/internal/services"
)

// Helper functions for pointer conversion
func stringPtr(s string) *string <span class="cov10" title="180">{
        return &amp;s
}</span>

func boolPtr(b bool) *bool <span class="cov8" title="61">{
        return &amp;b
}</span>

func int64Ptr(i int) *int64 <span class="cov8" title="80">{
        i64 := int64(i)
        return &amp;i64
}</span>

func float32Ptr(f float32) *float32 <span class="cov6" title="24">{
        return &amp;f
}</span>

func intPtr(i int) *int <span class="cov7" title="42">{
        return &amp;i
}</span>

// Convert models.User to api.User
func convertUserToAPI(user *models.User) api.User <span class="cov7" title="52">{
        apiUser := api.User{
                Id:       int64Ptr(user.ID),
                Username: stringPtr(user.Username),
        }

        if !user.CreatedAt.IsZero() </span><span class="cov7" title="46">{
                apiUser.CreatedAt = &amp;user.CreatedAt
        }</span>

        <span class="cov7" title="52">if user.LastActive.Valid </span><span class="cov7" title="45">{
                apiUser.LastActive = &amp;user.LastActive.Time
        }</span>

        <span class="cov7" title="52">if user.Email.Valid </span><span class="cov0" title="0">{
                s := user.Email.String
                apiUser.Email = &amp;s
        }</span>

        <span class="cov7" title="52">if user.Timezone.Valid </span><span class="cov0" title="0">{
                s := user.Timezone.String
                apiUser.Timezone = &amp;s
        }</span>

        <span class="cov7" title="52">if user.PreferredLanguage.Valid </span><span class="cov7" title="50">{
                s := user.PreferredLanguage.String
                apiUser.PreferredLanguage = &amp;s
        }</span>

        <span class="cov7" title="52">if user.CurrentLevel.Valid </span><span class="cov7" title="50">{
                s := user.CurrentLevel.String
                apiUser.CurrentLevel = &amp;s
        }</span>

        <span class="cov7" title="52">if user.AIProvider.Valid </span><span class="cov0" title="0">{
                s := user.AIProvider.String
                apiUser.AiProvider = &amp;s
        }</span>

        <span class="cov7" title="52">if user.AIModel.Valid </span><span class="cov0" title="0">{
                s := user.AIModel.String
                apiUser.AiModel = &amp;s
        }</span>

        // Always set ai_enabled as a boolean (never null)
        <span class="cov7" title="52">aiEnabled := user.AIEnabled.Valid &amp;&amp; user.AIEnabled.Bool
        apiUser.AiEnabled = &amp;aiEnabled

        // For backwards compatibility, we'll set has_api_key to false here
        // The proper check should be done using convertUserToAPIWithService
        hasAPIKey := false
        apiUser.HasApiKey = &amp;hasAPIKey

        return apiUser</span>
}

// convertUserToAPIWithService converts a models.User to api.User with proper API key checking
func convertUserToAPIWithService(ctx context.Context, user *models.User, userService services.UserServiceInterface) api.User <span class="cov7" title="52">{
        apiUser := convertUserToAPI(user)

        // Check if user has a valid API key for their current provider using the new table
        hasAPIKey := false
        if user.AIProvider.Valid &amp;&amp; user.AIProvider.String != "" </span><span class="cov0" title="0">{
                // Use the new per-provider API key system instead of the old user.AIAPIKey field
                if userService != nil </span><span class="cov0" title="0">{
                        savedKey, err := userService.GetUserAPIKey(ctx, user.ID, user.AIProvider.String)
                        if err == nil &amp;&amp; savedKey != "" </span><span class="cov0" title="0">{
                                // API key is available but not exposed in the API response for security
                                hasAPIKey = true
                        }</span>
                }
        }
        // If user doesn't have an AI provider set, hasAPIKey remains false (default)
        <span class="cov7" title="52">apiUser.HasApiKey = &amp;hasAPIKey

        return apiUser</span>
}

// Convert models.Question to api.Question
func convertQuestionToAPI(question *models.Question) api.Question <span class="cov2" title="3">{
        apiQuestion := api.Question{
                Id:              int64Ptr(question.ID),
                DifficultyScore: float32Ptr(float32(question.DifficultyScore)),
                // UsageCount removed; use total_responses instead
        }

        if !question.CreatedAt.IsZero() </span><span class="cov2" title="3">{
                apiQuestion.CreatedAt = &amp;question.CreatedAt
        }</span>

        <span class="cov2" title="3">if question.Type != "" </span><span class="cov2" title="3">{
                qType := api.QuestionType(question.Type)
                apiQuestion.Type = &amp;qType
        }</span>

        <span class="cov2" title="3">if question.Language != "" </span><span class="cov2" title="3">{
                lang := api.Language(question.Language)
                apiQuestion.Language = &amp;lang
        }</span>

        <span class="cov2" title="3">if question.Level != "" </span><span class="cov2" title="3">{
                level := api.Level(question.Level)
                apiQuestion.Level = &amp;level
        }</span>

        <span class="cov2" title="3">if question.Explanation != "" </span><span class="cov2" title="3">{
                apiQuestion.Explanation = &amp;question.Explanation
        }</span>

        <span class="cov2" title="3">if question.Status != "" </span><span class="cov2" title="3">{
                status := api.QuestionStatus(question.Status)
                apiQuestion.Status = &amp;status
        }</span>

        // Convert content map to api.QuestionContent
        <span class="cov2" title="3">if question.Content != nil </span><span class="cov2" title="3">{
                content := &amp;api.QuestionContent{}

                if q, ok := question.Content["question"].(string); ok </span><span class="cov2" title="3">{
                        content.Question = q
                }</span>
                <span class="cov2" title="3">if hint, ok := question.Content["hint"].(string); ok </span><span class="cov0" title="0">{
                        content.Hint = &amp;hint
                }</span>
                <span class="cov2" title="3">if passage, ok := question.Content["passage"].(string); ok </span><span class="cov0" title="0">{
                        content.Passage = &amp;passage
                }</span>
                <span class="cov2" title="3">if sentence, ok := question.Content["sentence"].(string); ok </span><span class="cov0" title="0">{
                        content.Sentence = &amp;sentence
                }</span>
                <span class="cov2" title="3">if opts, ok := question.Content["options"].([]interface{}); ok </span><span class="cov2" title="3">{
                        var options []string
                        for _, opt := range opts </span><span class="cov5" title="12">{
                                if o, ok := opt.(string); ok </span><span class="cov5" title="12">{
                                        options = append(options, o)
                                }</span>
                        }
                        <span class="cov2" title="3">if len(options) &gt; 0 </span><span class="cov2" title="3">{
                                content.Options = options
                        }</span>
                }
                <span class="cov2" title="3">apiQuestion.Content = content</span>
        }

        // Add variety elements to the API response
        <span class="cov2" title="3">if question.TopicCategory != "" </span><span class="cov2" title="2">{
                apiQuestion.TopicCategory = &amp;question.TopicCategory
        }</span>
        <span class="cov2" title="3">if question.GrammarFocus != "" </span><span class="cov1" title="1">{
                apiQuestion.GrammarFocus = &amp;question.GrammarFocus
        }</span>
        <span class="cov2" title="3">if question.VocabularyDomain != "" </span><span class="cov1" title="1">{
                apiQuestion.VocabularyDomain = &amp;question.VocabularyDomain
        }</span>
        <span class="cov2" title="3">if question.Scenario != "" </span><span class="cov1" title="1">{
                apiQuestion.Scenario = &amp;question.Scenario
        }</span>
        <span class="cov2" title="3">if question.StyleModifier != "" </span><span class="cov1" title="1">{
                apiQuestion.StyleModifier = &amp;question.StyleModifier
        }</span>
        <span class="cov2" title="3">if question.DifficultyModifier != "" </span><span class="cov1" title="1">{
                apiQuestion.DifficultyModifier = &amp;question.DifficultyModifier
        }</span>
        <span class="cov2" title="3">if question.TimeContext != "" </span><span class="cov1" title="1">{
                apiQuestion.TimeContext = &amp;question.TimeContext
        }</span>

        <span class="cov2" title="3">return apiQuestion</span>
}

// Convert models.UserProgress to api.UserProgress
func convertUserProgressToAPI(progress *models.UserProgress) api.UserProgress <span class="cov5" title="12">{
        apiProgress := api.UserProgress{
                TotalQuestions: intPtr(progress.TotalQuestions),
                CorrectAnswers: intPtr(progress.CorrectAnswers),
                AccuracyRate:   float32Ptr(float32(progress.AccuracyRate)),
        }

        if progress.CurrentLevel != "" </span><span class="cov5" title="12">{
                level := api.Level(progress.CurrentLevel)
                apiProgress.CurrentLevel = &amp;level
        }</span>

        <span class="cov5" title="12">if progress.SuggestedLevel != "" </span><span class="cov0" title="0">{
                level := api.Level(progress.SuggestedLevel)
                apiProgress.SuggestedLevel = &amp;level
        }</span>

        <span class="cov5" title="12">if progress.WeakAreas != nil </span><span class="cov3" title="4">{
                apiProgress.WeakAreas = &amp;progress.WeakAreas
        }</span>

        // Convert performance metrics
        <span class="cov5" title="12">if progress.PerformanceByTopic != nil </span><span class="cov5" title="12">{
                perfMap := make(map[string]api.PerformanceMetrics)
                for topic, metrics := range progress.PerformanceByTopic </span><span class="cov4" title="9">{
                        if metrics != nil </span><span class="cov4" title="9">{
                                perfMap[topic] = api.PerformanceMetrics{
                                        TotalAttempts:         intPtr(metrics.TotalAttempts),
                                        CorrectAttempts:       intPtr(metrics.CorrectAttempts),
                                        AverageResponseTimeMs: float32Ptr(float32(metrics.AverageResponseTimeMs)),
                                        LastUpdated:           &amp;metrics.LastUpdated,
                                }
                        }</span>
                }
                <span class="cov5" title="12">apiProgress.PerformanceByTopic = &amp;perfMap</span>
        }

        // Convert recent activity
        <span class="cov5" title="12">if progress.RecentActivity != nil </span><span class="cov4" title="9">{
                var recentActivity []api.UserResponse
                for _, activity := range progress.RecentActivity </span><span class="cov6" title="25">{
                        apiActivity := api.UserResponse{
                                QuestionId: int64Ptr(activity.QuestionID),
                                IsCorrect:  &amp;activity.IsCorrect,
                        }
                        if !activity.CreatedAt.IsZero() </span><span class="cov6" title="25">{
                                apiActivity.CreatedAt = &amp;activity.CreatedAt
                        }</span>
                        <span class="cov6" title="25">recentActivity = append(recentActivity, apiActivity)</span>
                }
                <span class="cov4" title="9">apiProgress.RecentActivity = &amp;recentActivity</span>
        }

        <span class="cov5" title="12">return apiProgress</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package handlers

import (
        "context"
        "embed"
        "fmt"
        "html/template"
        "net/http"
        "strconv"
        "strings"

        "quizapp/internal/config"
        "quizapp/internal/observability"
        "quizapp/internal/services"
        "quizapp/internal/worker"

        "github.com/gin-gonic/gin"
)

//go:embed templates/worker_admin.html templates/shared_nav.html templates/worker_analytics.html
var workerAdminTemplateFS embed.FS

// WorkerAdminHandler handles worker administration endpoints
type WorkerAdminHandler struct {
        userService     services.UserServiceInterface
        questionService services.QuestionServiceInterface
        aiService       services.AIServiceInterface
        config          *config.Config
        worker          *worker.Worker
        workerService   services.WorkerServiceInterface
        templates       *template.Template
        learningService services.LearningServiceInterface
        logger          *observability.Logger
}

// NewWorkerAdminHandlerWithLogger creates a new WorkerAdminHandler
func NewWorkerAdminHandlerWithLogger(
        userService services.UserServiceInterface,
        questionService services.QuestionServiceInterface,
        aiService services.AIServiceInterface,
        cfg *config.Config,
        worker *worker.Worker,
        workerService services.WorkerServiceInterface,
        learningService services.LearningServiceInterface,
        logger *observability.Logger,
) *WorkerAdminHandler <span class="cov10" title="11">{
        // Parse templates from embedded filesystem
        templates, err := template.New("worker_admin.html").ParseFS(workerAdminTemplateFS, "templates/*.html")
        if err != nil </span><span class="cov0" title="0">{
                logger.Error(context.Background(), "Failed to parse embedded worker admin templates", err, map[string]interface{}{})
                panic(err)</span> // Use panic for fatal errors in template parsing
        }
        <span class="cov10" title="11">logger.Info(context.Background(), "Successfully loaded embedded worker admin template", map[string]interface{}{})

        return &amp;WorkerAdminHandler{
                userService:     userService,
                questionService: questionService,
                aiService:       aiService,
                config:          cfg,
                worker:          worker,
                workerService:   workerService,
                templates:       templates,
                learningService: learningService,
                logger:          logger,
        }</span>
}

// GetWorkerAdminPage shows the worker admin interface
func (h *WorkerAdminHandler) GetWorkerAdminPage(c *gin.Context) <span class="cov5" title="3">{
        // Get worker health information - continue even if it fails
        workerHealth, err := h.workerService.GetWorkerHealth(c.Request.Context())
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Warn(c.Request.Context(), "Failed to get worker health", map[string]interface{}{"error": err.Error()})
                // Provide default/empty health data instead of failing
                globalPaused, _ := h.workerService.IsGlobalPaused(c.Request.Context()) // Try to get just this value
                workerHealth = map[string]any{
                        "global_paused":    globalPaused,
                        "healthy_count":    0,
                        "total_count":      0,
                        "worker_instances": []any{},
                        "error":            "Worker health service unavailable",
                }
        }</span>

        // Get worker status from local instance if available
        <span class="cov5" title="3">var localStatus worker.Status
        var localHistory []worker.RunRecord
        workerInstance := "default"
        if h.worker != nil </span><span class="cov5" title="3">{
                localStatus = h.worker.GetStatus()
                localHistory = h.worker.GetHistory()
                // Get the worker instance name from the worker
                workerInstance = h.worker.GetInstance()
        }</span>

        <span class="cov5" title="3">data := gin.H{
                "Title":          "Worker Administration",
                "WorkerHealth":   workerHealth,
                "LocalStatus":    localStatus,
                "LocalHistory":   localHistory,
                "HasLocalWorker": h.worker != nil,
                "WorkerInstance": workerInstance,
                "CurrentPage":    "worker_admin",
                "WorkerPort":     h.config.WorkerPort,
                "IsBackend":      false,
                "BackendBaseURL": h.config.BackendBaseURL,
        }

        // Try to render template, fallback to JSON if template fails
        if h.templates != nil </span><span class="cov5" title="3">{
                // Add no-cache headers
                c.Header("Content-Type", "text/html; charset=utf-8")
                c.Header("Cache-Control", "no-cache, no-store, must-revalidate")
                c.Header("Pragma", "no-cache")
                c.Header("Expires", "0")

                if err := h.templates.ExecuteTemplate(c.Writer, "worker_admin.html", data); err != nil </span><span class="cov0" title="0">{
                        h.logger.Error(c.Request.Context(), "Template execution failed", err, map[string]interface{}{})
                        c.JSON(http.StatusOK, data)
                        return
                }</span>

                // Add schema validation failures section
                <span class="cov5" title="3">if err := renderSchemaValidationFailures(c.Writer); err != nil </span><span class="cov0" title="0">{
                        h.logger.Warn(c.Request.Context(), "Failed to render schema validation failures", map[string]interface{}{"error": err.Error()})
                }</span>
        } else<span class="cov0" title="0"> {
                c.JSON(http.StatusOK, data)
        }</span>
}

// GetWorkerDetails returns detailed worker information
func (h *WorkerAdminHandler) GetWorkerDetails(c *gin.Context) <span class="cov5" title="3">{
        // Get worker status from local instance if available
        var localStatus worker.Status
        var localHistory []worker.RunRecord
        if h.worker != nil </span><span class="cov5" title="3">{
                localStatus = h.worker.GetStatus()
                localHistory = h.worker.GetHistory()
        }</span>

        <span class="cov5" title="3">response := gin.H{
                "status":  localStatus,
                "history": localHistory,
        }

        c.JSON(http.StatusOK, response)</span>
}

// GetActivityLogs returns recent activity logs from the worker
func (h *WorkerAdminHandler) GetActivityLogs(c *gin.Context) <span class="cov1" title="1">{
        if h.worker == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusServiceUnavailable, gin.H{"error": "Worker not available in this service"})
                return
        }</span>

        <span class="cov1" title="1">logs := h.worker.GetActivityLogs()
        c.JSON(http.StatusOK, gin.H{"logs": logs})</span>
}

// PauseWorker pauses the worker globally
func (h *WorkerAdminHandler) PauseWorker(c *gin.Context) <span class="cov5" title="3">{
        if err := h.workerService.SetGlobalPause(c.Request.Context(), true); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusServiceUnavailable, gin.H{"error": "Failed to pause worker globally"})
                return
        }</span>

        // Also pause the local worker instance if available
        <span class="cov5" title="3">if h.worker != nil </span><span class="cov3" title="2">{
                h.worker.Pause(c.Request.Context())
        }</span>

        <span class="cov5" title="3">c.JSON(http.StatusOK, gin.H{"message": "Worker paused globally"})</span>
}

// ResumeWorker resumes the worker globally
func (h *WorkerAdminHandler) ResumeWorker(c *gin.Context) <span class="cov5" title="3">{
        _, span := observability.TraceHandlerFunction(c.Request.Context(), "resume_worker")
        defer span.End()
        if err := h.workerService.SetGlobalPause(c.Request.Context(), false); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusServiceUnavailable, gin.H{"error": "Failed to resume worker globally"})
                return
        }</span>

        // Also resume the local worker instance if available
        <span class="cov5" title="3">if h.worker != nil </span><span class="cov3" title="2">{
                h.worker.Resume(c.Request.Context())
        }</span>

        <span class="cov5" title="3">c.JSON(http.StatusOK, gin.H{"message": "Worker resumed globally"})</span>
}

// GetWorkerStatus returns current worker status
func (h *WorkerAdminHandler) GetWorkerStatus(c *gin.Context) <span class="cov3" title="2">{
        _, span := observability.TraceHandlerFunction(c.Request.Context(), "get_worker_status")
        defer span.End()
        instance := c.DefaultQuery("instance", "default")

        status, err := h.workerService.GetWorkerStatus(c.Request.Context(), instance)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusServiceUnavailable, gin.H{"error": "Failed to get worker status"})
                return
        }</span>

        <span class="cov3" title="2">c.JSON(http.StatusOK, status)</span>
}

// TriggerWorkerRun triggers a manual worker run
func (h *WorkerAdminHandler) TriggerWorkerRun(c *gin.Context) <span class="cov3" title="2">{
        _, span := observability.TraceHandlerFunction(c.Request.Context(), "trigger_worker_run")
        defer span.End()
        if h.worker != nil </span><span class="cov3" title="2">{
                h.worker.TriggerManualRun()
                c.JSON(http.StatusOK, gin.H{"message": "Worker run triggered"})
        }</span> else<span class="cov0" title="0"> {
                c.JSON(http.StatusServiceUnavailable, gin.H{"error": "Worker not available in this service"})
        }</span>
}

// PauseUser pauses question generation for a specific user
func (h *WorkerAdminHandler) PauseUser(c *gin.Context) <span class="cov5" title="3">{
        _, span := observability.TraceHandlerFunction(c.Request.Context(), "pause_user")
        defer span.End()
        var req struct {
                UserID int `json:"user_id" binding:"required"`
        }

        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request"})
                return
        }</span>

        <span class="cov3" title="2">if err := h.workerService.SetUserPause(c.Request.Context(), req.UserID, true); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusServiceUnavailable, gin.H{"error": "Failed to pause user"})
                return
        }</span>

        <span class="cov3" title="2">c.JSON(http.StatusOK, gin.H{"message": "User paused successfully"})</span>
}

// ResumeUser resumes question generation for a specific user
func (h *WorkerAdminHandler) ResumeUser(c *gin.Context) <span class="cov3" title="2">{
        _, span := observability.TraceHandlerFunction(c.Request.Context(), "resume_user")
        defer span.End()
        var req struct {
                UserID int `json:"user_id" binding:"required"`
        }

        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request"})
                return
        }</span>

        <span class="cov1" title="1">if err := h.workerService.SetUserPause(c.Request.Context(), req.UserID, false); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusServiceUnavailable, gin.H{"error": "Failed to resume user"})
                return
        }</span>

        <span class="cov1" title="1">c.JSON(http.StatusOK, gin.H{"message": "User resumed successfully"})</span>
}

// GetUsers returns basic user list for worker controls
func (h *WorkerAdminHandler) GetUsers(c *gin.Context) <span class="cov1" title="1">{
        users, err := h.userService.GetAllUsers(c.Request.Context())
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusServiceUnavailable, gin.H{"error": "Failed to get users"})
                return
        }</span>

        // Add pause status for each user
        <span class="cov1" title="1">var userList []gin.H
        for _, user := range users </span><span class="cov1" title="1">{
                isPaused, _ := h.workerService.IsUserPaused(c.Request.Context(), user.ID)
                userList = append(userList, gin.H{
                        "id":        user.ID,
                        "username":  user.Username,
                        "is_paused": isPaused,
                })
        }</span>

        <span class="cov1" title="1">c.JSON(http.StatusOK, gin.H{"users": userList})</span>
}

// GetSystemHealth returns comprehensive system health
func (h *WorkerAdminHandler) GetSystemHealth(c *gin.Context) <span class="cov3" title="2">{
        health, err := h.workerService.GetWorkerHealth(c.Request.Context())
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusServiceUnavailable, gin.H{"error": "Failed to get system health"})
                return
        }</span>

        <span class="cov3" title="2">c.JSON(http.StatusOK, health)</span>
}

// GetAIConcurrencyStats returns AI service concurrency metrics from the worker
func (h *WorkerAdminHandler) GetAIConcurrencyStats(c *gin.Context) <span class="cov1" title="1">{
        if h.aiService == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusServiceUnavailable, gin.H{"error": "AI service not available in this worker"})
                return
        }</span>

        <span class="cov1" title="1">stats := h.aiService.GetConcurrencyStats()
        c.JSON(http.StatusOK, gin.H{
                "ai_concurrency": stats,
        })</span>
}

// GetPriorityAnalytics returns priority system analytics
func (h *WorkerAdminHandler) GetPriorityAnalytics(c *gin.Context) <span class="cov6" title="4">{
        // Get priority score distribution
        distribution, err := h.learningService.GetPriorityScoreDistribution(c.Request.Context())
        if err != nil </span><span class="cov1" title="1">{
                h.logger.Error(c.Request.Context(), "Error getting priority score distribution", err, map[string]interface{}{})
                distribution = map[string]interface{}{
                        "high":    0,
                        "medium":  0,
                        "low":     0,
                        "average": 0.0,
                }
        }</span>

        // Get high priority questions
        <span class="cov6" title="4">highPriorityQuestions, err := h.learningService.GetHighPriorityQuestions(c.Request.Context(), 5)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error(c.Request.Context(), "Error getting high priority questions", err, map[string]interface{}{})
                highPriorityQuestions = []map[string]interface{}{}
        }</span>

        <span class="cov6" title="4">response := gin.H{
                "distribution":          distribution,
                "highPriorityQuestions": highPriorityQuestions,
        }

        c.JSON(http.StatusOK, response)</span>
}

// GetUserPriorityAnalytics returns priority analytics for a specific user
func (h *WorkerAdminHandler) GetUserPriorityAnalytics(c *gin.Context) <span class="cov5" title="3">{
        userIDStr := c.Param("userID")
        userID, err := strconv.Atoi(userIDStr)
        if err != nil </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid user ID"})
                return
        }</span>

        // Verify user exists
        <span class="cov3" title="2">user, err := h.userService.GetUserByID(c.Request.Context(), userID)
        if err != nil || user == nil </span><span class="cov1" title="1">{
                c.JSON(http.StatusNotFound, gin.H{"error": "User not found"})
                return
        }</span>

        // Get user-specific priority score distribution
        <span class="cov1" title="1">distribution, err := h.learningService.GetUserPriorityScoreDistribution(c.Request.Context(), userID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error(c.Request.Context(), "Error getting user priority score distribution", err, map[string]interface{}{})
                distribution = map[string]interface{}{
                        "high":    0,
                        "medium":  0,
                        "low":     0,
                        "average": 0.0,
                }
        }</span>

        // Get user's high priority questions
        <span class="cov1" title="1">highPriorityQuestions, err := h.learningService.GetUserHighPriorityQuestions(c.Request.Context(), userID, 10)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error(c.Request.Context(), "Error getting user high priority questions", err, map[string]interface{}{})
                highPriorityQuestions = []map[string]interface{}{}
        }</span>

        // Get user's weak areas
        <span class="cov1" title="1">weakAreas, err := h.learningService.GetUserWeakAreas(c.Request.Context(), userID, 5)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error(c.Request.Context(), "Error getting user weak areas", err, map[string]interface{}{})
                weakAreas = []map[string]interface{}{}
        }</span>

        // Get user's learning preferences
        <span class="cov1" title="1">preferences, err := h.learningService.GetUserLearningPreferences(c.Request.Context(), userID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error(c.Request.Context(), "Error getting user learning preferences", err, map[string]interface{}{})
                preferences = nil
        }</span>

        <span class="cov1" title="1">response := gin.H{
                "user": gin.H{
                        "id":       user.ID,
                        "username": user.Username,
                },
                "distribution":          distribution,
                "highPriorityQuestions": highPriorityQuestions,
                "weakAreas":             weakAreas,
                "learningPreferences":   preferences,
        }

        c.JSON(http.StatusOK, response)</span>
}

// GetUserPerformanceAnalytics returns user performance analytics
func (h *WorkerAdminHandler) GetUserPerformanceAnalytics(c *gin.Context) <span class="cov5" title="3">{
        // Get weak areas by topic
        weakAreas, err := h.learningService.GetWeakAreasByTopic(c.Request.Context(), 5)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error(c.Request.Context(), "Error getting weak areas", err, map[string]interface{}{})
                weakAreas = []map[string]interface{}{}
        }</span>

        // Get learning preferences usage
        <span class="cov5" title="3">learningPreferences, err := h.learningService.GetLearningPreferencesUsage(c.Request.Context())
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error(c.Request.Context(), "Error getting learning preferences usage", err, map[string]interface{}{})
                learningPreferences = map[string]interface{}{}
        }</span>

        <span class="cov5" title="3">response := gin.H{
                "weakAreas":           weakAreas,
                "learningPreferences": learningPreferences,
        }

        c.JSON(http.StatusOK, response)</span>
}

// GetGenerationIntelligence returns question generation intelligence
func (h *WorkerAdminHandler) GetGenerationIntelligence(c *gin.Context) <span class="cov5" title="3">{
        // Get gap analysis
        gapAnalysis, err := h.learningService.GetQuestionTypeGaps(c.Request.Context())
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error(c.Request.Context(), "Error getting gap analysis", err, map[string]interface{}{})
                gapAnalysis = []map[string]interface{}{}
        }</span>

        // Get generation suggestions
        <span class="cov5" title="3">generationSuggestions, err := h.learningService.GetGenerationSuggestions(c.Request.Context())
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error(c.Request.Context(), "Error getting generation suggestions", err, map[string]interface{}{})
                generationSuggestions = []map[string]interface{}{}
        }</span>

        // Ensure we always return arrays, not nil
        <span class="cov5" title="3">if gapAnalysis == nil </span><span class="cov3" title="2">{
                gapAnalysis = []map[string]interface{}{}
        }</span>
        <span class="cov5" title="3">if generationSuggestions == nil </span><span class="cov1" title="1">{
                generationSuggestions = []map[string]interface{}{}
        }</span>

        <span class="cov5" title="3">response := gin.H{
                "gapAnalysis":           gapAnalysis,
                "generationSuggestions": generationSuggestions,
        }

        c.JSON(http.StatusOK, response)</span>
}

// GetSystemHealthAnalytics returns system health analytics
func (h *WorkerAdminHandler) GetSystemHealthAnalytics(c *gin.Context) <span class="cov5" title="3">{
        // Get performance metrics
        performance, err := h.learningService.GetPrioritySystemPerformance(c.Request.Context())
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error(c.Request.Context(), "Error getting performance metrics", err, map[string]interface{}{})
                performance = map[string]interface{}{}
        }</span>

        // Get background jobs status
        <span class="cov5" title="3">backgroundJobs, err := h.learningService.GetBackgroundJobsStatus(c.Request.Context())
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error(c.Request.Context(), "Error getting background jobs status", err, map[string]interface{}{})
                backgroundJobs = map[string]interface{}{}
        }</span>

        <span class="cov5" title="3">response := gin.H{
                "performance":    performance,
                "backgroundJobs": backgroundJobs,
        }

        c.JSON(http.StatusOK, response)</span>
}

// GetUserComparisonAnalytics returns comparison analytics between users
func (h *WorkerAdminHandler) GetUserComparisonAnalytics(c *gin.Context) <span class="cov7" title="6">{
        userIDsParam := c.Query("user_ids")
        if userIDsParam == "" </span><span class="cov1" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "No user IDs provided"})
                return
        }</span>

        // Split comma-separated user IDs
        <span class="cov7" title="5">userIDsStr := strings.Split(userIDsParam, ",")
        if len(userIDsStr) == 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "No user IDs provided"})
                return
        }</span>

        <span class="cov7" title="5">var userIDs []int
        for _, idStr := range userIDsStr </span><span class="cov7" title="6">{
                idStr = strings.TrimSpace(idStr) // Remove whitespace
                if idStr == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov7" title="6">id, err := strconv.Atoi(idStr)
                if err != nil </span><span class="cov3" title="2">{
                        c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid user ID: " + idStr})
                        return
                }</span>
                <span class="cov6" title="4">userIDs = append(userIDs, id)</span>
        }

        <span class="cov5" title="3">if len(userIDs) == 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "No valid user IDs provided"})
                return
        }</span>

        // Get comparison data for each user
        <span class="cov5" title="3">var comparisonData []gin.H
        for _, userID := range userIDs </span><span class="cov6" title="4">{
                user, err := h.userService.GetUserByID(c.Request.Context(), userID)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span> // Skip invalid users
                }

                <span class="cov6" title="4">distribution, _ := h.learningService.GetUserPriorityScoreDistribution(c.Request.Context(), userID)
                weakAreas, _ := h.learningService.GetUserWeakAreas(c.Request.Context(), userID, 3)

                userData := gin.H{
                        "user": gin.H{
                                "id":       user.ID,
                                "username": user.Username,
                        },
                        "distribution": distribution,
                        "weakAreas":    weakAreas,
                }
                comparisonData = append(comparisonData, userData)</span>
        }

        <span class="cov5" title="3">c.JSON(http.StatusOK, gin.H{"comparison": comparisonData})</span>
}

// GetConfigz returns the merged config as pretty-printed JSON
func (h *WorkerAdminHandler) GetConfigz(c *gin.Context) <span class="cov1" title="1">{
        c.IndentedJSON(http.StatusOK, h.config)
}</span>

// GetAnalyticsPage serves the analytics dashboard page
func (h *WorkerAdminHandler) GetAnalyticsPage(c *gin.Context) <span class="cov1" title="1">{
        // Add no-cache headers
        c.Header("Content-Type", "text/html; charset=utf-8")
        c.Header("Cache-Control", "no-cache, no-store, must-revalidate")
        c.Header("Pragma", "no-cache")
        c.Header("Expires", "0")

        data := gin.H{
                "Title":          "Priority System Analytics",
                "CurrentPage":    "analyticsz",
                "IsBackend":      false,
                "BackendBaseURL": h.config.BackendBaseURL,
        }

        // Try to render template, fallback to JSON if template fails
        if h.templates != nil </span><span class="cov1" title="1">{
                if err := h.templates.ExecuteTemplate(c.Writer, "worker_analytics.html", data); err != nil </span><span class="cov0" title="0">{
                        h.logger.Error(c.Request.Context(), "Template execution failed", err, map[string]interface{}{})
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to render analytics page"})
                        return
                }</span>
        } else<span class="cov0" title="0"> {
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Analytics template not available"})
        }</span>
}

// In the admin handler, add a section to show schema validation failures by type
func renderSchemaValidationFailures(w http.ResponseWriter) error <span class="cov6" title="4">{
        if _, err := w.Write([]byte("&lt;h3&gt;Schema Validation Failures&lt;/h3&gt;")); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov6" title="4">if _, err := w.Write([]byte("&lt;ul&gt;")); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov6" title="4">services.SchemaValidationMu.Lock()
        defer services.SchemaValidationMu.Unlock()
        for qType, count := range services.SchemaValidationFailures </span><span class="cov8" title="8">{
                details := services.SchemaValidationFailureDetails[qType]
                title := ""
                if len(details) &gt; 0 </span><span class="cov6" title="4">{
                        title = " title=\"" + template.HTMLEscapeString(strings.Join(details, "\n")) + "\""
                }</span>
                <span class="cov8" title="8">if _, err := fmt.Fprintf(w, "&lt;li&gt;%s: &lt;span%s&gt;%d&lt;/span&gt;&lt;/li&gt;", qType, title, count); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov6" title="4">if _, err := w.Write([]byte("&lt;/ul&gt;")); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov6" title="4">return nil</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">// Package middleware provides authentication and authorization middleware for the Gin web framework.
package middleware

import (
        "net/http"

        "github.com/gin-contrib/sessions"
        "github.com/gin-gonic/gin"
)

// Session keys for storing user information
const (
        // UserIDKey is the key used to store user ID in session
        UserIDKey = "user_id"
        // UsernameKey is the key used to store username in session
        UsernameKey = "username"
)

// RequireAuth returns a middleware that requires authentication
func RequireAuth() gin.HandlerFunc <span class="cov8" title="7">{
        return func(c *gin.Context) </span><span class="cov10" title="9">{
                session := sessions.Default(c)
                userID := session.Get(UserIDKey)

                if userID == nil </span><span class="cov3" title="2">{
                        c.JSON(http.StatusUnauthorized, gin.H{
                                "error": "Authentication required",
                                "code":  "UNAUTHORIZED",
                        })
                        c.Abort()
                        return
                }</span>

                // Validate user_id is an integer
                <span class="cov8" title="7">userIDInt, ok := userID.(int)
                if !ok </span><span class="cov1" title="1">{
                        // Try to convert from float64 (JSON numbers are often stored as float64)
                        if userIDFloat, ok := userID.(float64); ok </span><span class="cov0" title="0">{
                                userIDInt = int(userIDFloat)
                        }</span> else<span class="cov1" title="1"> {
                                c.JSON(http.StatusUnauthorized, gin.H{
                                        "error": "Authentication required",
                                        "code":  "UNAUTHORIZED",
                                })
                                c.Abort()
                                return
                        }</span>
                }

                // Validate username is a string and not empty
                <span class="cov8" title="6">username := session.Get(UsernameKey)
                if username == nil </span><span class="cov1" title="1">{
                        c.JSON(http.StatusUnauthorized, gin.H{
                                "error": "Authentication required",
                                "code":  "UNAUTHORIZED",
                        })
                        c.Abort()
                        return
                }</span>

                <span class="cov7" title="5">usernameStr, ok := username.(string)
                if !ok || usernameStr == "" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{
                                "error": "Authentication required",
                                "code":  "UNAUTHORIZED",
                        })
                        c.Abort()
                        return
                }</span>

                // Store user info in context for handlers to use
                <span class="cov7" title="5">c.Set(UserIDKey, userIDInt)
                c.Set(UsernameKey, usernameStr)

                c.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file19" style="display: none">// Package models defines data structures used throughout the quiz application.
package models

import (
        "database/sql"
        "encoding/json"
        "time"

        "quizapp/internal/api"
)

// User represents a user in the system
type User struct {
        ID                int            `json:"id" yaml:"id"`
        Username          string         `json:"username" yaml:"username"`
        Email             sql.NullString `json:"email" yaml:"email"`
        Timezone          sql.NullString `json:"timezone" yaml:"timezone"`
        PasswordHash      sql.NullString `json:"-" yaml:"-"` // Omit from JSON responses
        LastActive        sql.NullTime   `json:"last_active" yaml:"last_active"`
        PreferredLanguage sql.NullString `json:"preferred_language" yaml:"preferred_language"`
        CurrentLevel      sql.NullString `json:"current_level" yaml:"current_level"`
        AIProvider        sql.NullString `json:"ai_provider" yaml:"ai_provider"`
        AIModel           sql.NullString `json:"ai_model" yaml:"ai_model"`
        AIEnabled         sql.NullBool   `json:"ai_enabled" yaml:"ai_enabled"`
        AIAPIKey          sql.NullString `json:"-" yaml:"ai_api_key"` // Omit from JSON responses
        APIKey            sql.NullString `json:"-" yaml:"api_key"`    // Legacy, omit from JSON
        CreatedAt         time.Time      `json:"created_at" yaml:"created_at"`
        UpdatedAt         time.Time      `json:"updated_at" yaml:"updated_at"`
}

// MarshalJSON customizes JSON marshaling for User to handle sql.NullString and sql.NullTime properly
func (u User) MarshalJSON() (result0 []byte, err error) <span class="cov5" title="10">{ // Create a struct with the desired JSON structure
        return json.Marshal(&amp;struct {
                ID                int        `json:"id"`
                Username          string     `json:"username"`
                Email             *string    `json:"email"`
                Timezone          *string    `json:"timezone"`
                LastActive        *time.Time `json:"last_active"`
                PreferredLanguage *string    `json:"preferred_language"`
                CurrentLevel      *string    `json:"current_level"`
                AIProvider        *string    `json:"ai_provider"`
                AIModel           *string    `json:"ai_model"`
                AIEnabled         *bool      `json:"ai_enabled"`
                CreatedAt         time.Time  `json:"created_at"`
                UpdatedAt         time.Time  `json:"updated_at"`
        }{
                ID:                u.ID,
                Username:          u.Username,
                Email:             nullStringToPointer(u.Email),
                Timezone:          nullStringToPointer(u.Timezone),
                LastActive:        nullTimeToPointer(u.LastActive),
                PreferredLanguage: nullStringToPointer(u.PreferredLanguage),
                CurrentLevel:      nullStringToPointer(u.CurrentLevel),
                AIProvider:        nullStringToPointer(u.AIProvider),
                AIModel:           nullStringToPointer(u.AIModel),
                AIEnabled:         nullBoolToPointer(u.AIEnabled),
                CreatedAt:         u.CreatedAt,
                UpdatedAt:         u.UpdatedAt,
        })
}</span>

// Helper functions for converting sql.Null types to pointers
func nullStringToPointer(ns sql.NullString) *string <span class="cov10" title="74">{
        if ns.Valid </span><span class="cov8" title="29">{
                return &amp;ns.String
        }</span>
        <span class="cov8" title="45">return nil</span>
}

func nullTimeToPointer(nt sql.NullTime) *time.Time <span class="cov8" title="32">{
        if nt.Valid </span><span class="cov6" title="16">{
                return &amp;nt.Time
        }</span>
        <span class="cov6" title="16">return nil</span>
}

func nullBoolToPointer(nb sql.NullBool) *bool <span class="cov6" title="17">{
        if nb.Valid </span><span class="cov5" title="9">{
                return &amp;nb.Bool
        }</span>
        <span class="cov5" title="8">return nil</span>
}

func nullInt32ToPointer(ni sql.NullInt32) *int32 <span class="cov3" title="4">{
        if ni.Valid </span><span class="cov2" title="2">{
                return &amp;ni.Int32
        }</span>
        <span class="cov2" title="2">return nil</span>
}

// UserAPIKey represents an API key for a specific provider for a user
type UserAPIKey struct {
        ID        int       `json:"id"`
        UserID    int       `json:"user_id"`
        Provider  string    `json:"provider"`
        APIKey    string    `json:"-"` // Omit from JSON responses for security
        CreatedAt time.Time `json:"created_at"`
        UpdatedAt time.Time `json:"updated_at"`
}

// Question represents a quiz question
type Question struct {
        ID              int                    `json:"id" yaml:"id"`
        Type            QuestionType           `json:"type" yaml:"type"`
        Language        string                 `json:"language" yaml:"language"`
        Level           string                 `json:"level" yaml:"level"`
        DifficultyScore float64                `json:"difficulty_score" yaml:"difficulty_score"`
        Content         map[string]interface{} `json:"content" yaml:"content"`
        CorrectAnswer   int                    `json:"correct_answer" yaml:"correct_answer"`
        Explanation     string                 `json:"explanation,omitempty" yaml:"explanation"`
        CreatedAt       time.Time              `json:"created_at" yaml:"created_at"`
        Status          QuestionStatus         `json:"status" yaml:"status"`
        // Test data field for specifying which users should have this question
        Users []string `json:"users,omitempty" yaml:"users,omitempty"`
        // Variety elements for question generation diversity
        TopicCategory      string `json:"topic_category,omitempty" yaml:"topic_category"`
        GrammarFocus       string `json:"grammar_focus,omitempty" yaml:"grammar_focus"`
        VocabularyDomain   string `json:"vocabulary_domain,omitempty" yaml:"vocabulary_domain"`
        Scenario           string `json:"scenario,omitempty" yaml:"scenario"`
        StyleModifier      string `json:"style_modifier,omitempty" yaml:"style_modifier"`
        DifficultyModifier string `json:"difficulty_modifier,omitempty" yaml:"difficulty_modifier"`
        TimeContext        string `json:"time_context,omitempty" yaml:"time_context"`
}

// UserQuestion represents the mapping between users and questions
type UserQuestion struct {
        ID         int       `json:"id"`
        UserID     int       `json:"user_id"`
        QuestionID int       `json:"question_id"`
        CreatedAt  time.Time `json:"created_at"`
}

// QuestionType represents the type of question
type QuestionType string

// QuestionStatus represents the status of a question
type QuestionStatus string

const (
        // QuestionStatusActive is for questions that are in active use
        QuestionStatusActive QuestionStatus = "active"
        // QuestionStatusReported is for questions that have been reported as incorrect
        QuestionStatusReported QuestionStatus = "reported"
)

// Question types supported by the system
const (
        // Vocabulary represents vocabulary in context questions
        Vocabulary QuestionType = "vocabulary"
        // FillInBlank represents fill-in-the-blank questions
        FillInBlank QuestionType = "fill_blank"
        // QuestionAnswer represents simple Q&amp;A questions
        QuestionAnswer QuestionType = "qa"
        // ReadingComprehension represents reading comprehension questions
        ReadingComprehension QuestionType = "reading_comprehension"
)

// UserResponse represents a user's answer to a question
type UserResponse struct {
        ID              int           `json:"id" yaml:"id"`
        UserID          int           `json:"user_id" yaml:"user_id"`
        QuestionID      int           `json:"question_id" yaml:"question_id"`
        UserAnswer      string        `json:"user_answer" yaml:"user_answer"`
        IsCorrect       bool          `json:"is_correct" yaml:"is_correct"`
        ResponseTimeMs  int           `json:"response_time_ms" yaml:"response_time_ms"`
        ConfidenceLevel sql.NullInt32 `json:"confidence_level" yaml:"confidence_level"`
        CreatedAt       time.Time     `json:"created_at" yaml:"created_at"`
}

// MarshalJSON customizes JSON marshaling for UserResponse to handle sql.NullInt32 properly
func (ur UserResponse) MarshalJSON() (result0 []byte, err error) <span class="cov2" title="2">{
        return json.Marshal(&amp;struct {
                ID              int       `json:"id"`
                UserID          int       `json:"user_id"`
                QuestionID      int       `json:"question_id"`
                UserAnswer      string    `json:"user_answer"`
                IsCorrect       bool      `json:"is_correct"`
                ResponseTimeMs  int       `json:"response_time_ms"`
                ConfidenceLevel *int32    `json:"confidence_level"`
                CreatedAt       time.Time `json:"created_at"`
        }{
                ID:              ur.ID,
                UserID:          ur.UserID,
                QuestionID:      ur.QuestionID,
                UserAnswer:      ur.UserAnswer,
                IsCorrect:       ur.IsCorrect,
                ResponseTimeMs:  ur.ResponseTimeMs,
                ConfidenceLevel: nullInt32ToPointer(ur.ConfidenceLevel),
                CreatedAt:       ur.CreatedAt,
        })
}</span>

// PerformanceMetrics tracks user performance across different categories
type PerformanceMetrics struct {
        ID                    int       `json:"id"`
        UserID                int       `json:"user_id"`
        Topic                 string    `json:"topic"`
        Language              string    `json:"language"`
        Level                 string    `json:"level"`
        TotalAttempts         int       `json:"total_attempts"`
        CorrectAttempts       int       `json:"correct_attempts"`
        AverageResponseTimeMs float64   `json:"average_response_time_ms"`
        DifficultyAdjustment  float64   `json:"difficulty_adjustment"`
        LastUpdated           time.Time `json:"last_updated"`
}

// AccuracyRate calculates the accuracy percentage
func (pm *PerformanceMetrics) AccuracyRate() float64 <span class="cov4" title="5">{
        if pm.TotalAttempts == 0 </span><span class="cov1" title="1">{
                return 0.0
        }</span>
        <span class="cov3" title="4">return float64(pm.CorrectAttempts) / float64(pm.TotalAttempts) * 100</span>
}

// QuestionRequest represents a request for a new question
type QuestionRequest struct {
        UserID       int          `json:"user_id"`
        Language     string       `json:"language"`
        Level        string       `json:"level"`
        QuestionType QuestionType `json:"question_type,omitempty"`
}

// AnswerRequest represents a user's answer submission
type AnswerRequest struct {
        QuestionID     int    `json:"question_id"`
        UserAnswer     string `json:"user_answer"`
        ResponseTimeMs int    `json:"response_time_ms"`
}

// AnswerResponse represents the response to an answer submission
type AnswerResponse struct {
        IsCorrect      bool   `json:"is_correct"`
        CorrectAnswer  string `json:"correct_answer"`
        UserAnswer     string `json:"user_answer"`
        Explanation    string `json:"explanation"`
        NextDifficulty string `json:"next_difficulty,omitempty"`
}

// GetCorrectAnswerText returns the text of the correct answer from the question content
func (q *Question) GetCorrectAnswerText() string <span class="cov7" title="22">{
        if optionsRaw, ok := q.Content["options"]; ok </span><span class="cov6" title="17">{
                if options, ok := optionsRaw.([]interface{}); ok </span><span class="cov6" title="15">{
                        if q.CorrectAnswer &gt;= 0 &amp;&amp; q.CorrectAnswer &lt; len(options) </span><span class="cov6" title="12">{
                                if optStr, ok := options[q.CorrectAnswer].(string); ok </span><span class="cov6" title="12">{
                                        return optStr
                                }</span>
                        }
                }
        }
        <span class="cov5" title="10">return ""</span>
}

// UserSettings represents user preference settings
type UserSettings struct {
        Language   string `json:"language" yaml:"language"`
        Level      string `json:"level" yaml:"level"`
        AIProvider string `json:"ai_provider" yaml:"ai_provider"`
        AIModel    string `json:"ai_model" yaml:"ai_model"`
        AIEnabled  bool   `json:"ai_enabled" yaml:"ai_enabled"`
        AIAPIKey   string `json:"api_key" yaml:"ai_api_key"`
}

// UserLearningPreferences represents user learning preferences and settings
type UserLearningPreferences struct {
        ID                        int       `json:"id" db:"id"`
        UserID                    int       `json:"user_id" db:"user_id"`
        PreferredLanguage         string    `json:"preferred_language" db:"preferred_language"`
        CurrentLevel              string    `json:"current_level" db:"current_level"`
        AIProvider                string    `json:"ai_provider" db:"ai_provider"`
        AIModel                   string    `json:"ai_model" db:"ai_model"`
        AIEnabled                 bool      `json:"ai_enabled" db:"ai_enabled"`
        AIAPIKey                  string    `json:"-" db:"ai_api_key"` // Omit from JSON for security
        DailyGoal                 int       `json:"daily_goal" db:"daily_goal"`
        WeeklyGoal                int       `json:"weekly_goal" db:"weekly_goal"`
        PreferredQuestionType     string    `json:"preferred_question_type" db:"preferred_question_type"`
        PreferredQuestionTypes    []string  `json:"preferred_question_types" db:"preferred_question_types"`
        PreferredDifficultyLevel  string    `json:"preferred_difficulty_level" db:"preferred_difficulty_level"`
        PreferredTopics           []string  `json:"preferred_topics" db:"preferred_topics"`
        PreferredQuestionCount    int       `json:"preferred_question_count" db:"preferred_question_count"`
        SpacedRepetitionEnabled   bool      `json:"spaced_repetition_enabled" db:"spaced_repetition_enabled"`
        AdaptiveDifficultyEnabled bool      `json:"adaptive_difficulty_enabled" db:"adaptive_difficulty_enabled"`
        FocusOnWeakAreas          bool      `json:"focus_on_weak_areas" db:"focus_on_weak_areas"`
        IncludeReviewQuestions    bool      `json:"include_review_questions" db:"include_review_questions"`
        FreshQuestionRatio        float64   `json:"fresh_question_ratio" db:"fresh_question_ratio"`
        KnownQuestionPenalty      float64   `json:"known_question_penalty" db:"known_question_penalty"`
        ReviewIntervalDays        int       `json:"review_interval_days" db:"review_interval_days"`
        WeakAreaBoost             float64   `json:"weak_area_boost" db:"weak_area_boost"`
        StudyTime                 string    `json:"study_time" db:"study_time"`
        CreatedAt                 time.Time `json:"created_at" db:"created_at"`
        UpdatedAt                 time.Time `json:"updated_at" db:"updated_at"`
}

// UserProgress represents a user's overall progress
type UserProgress struct {
        CurrentLevel       string                         `json:"current_level"`
        TotalQuestions     int                            `json:"total_questions"`
        CorrectAnswers     int                            `json:"correct_answers"`
        AccuracyRate       float64                        `json:"accuracy_rate"`
        PerformanceByTopic map[string]*PerformanceMetrics `json:"performance_by_topic"`
        WeakAreas          []string                       `json:"weak_areas"`
        RecentActivity     []UserResponse                 `json:"recent_activity"`
        SuggestedLevel     string                         `json:"suggested_level,omitempty"`
}

// AIQuestionGenRequest represents a request to the AI service for question generation
type AIQuestionGenRequest struct {
        Language              string       `json:"language"`
        Level                 string       `json:"level"`
        QuestionType          QuestionType `json:"question_type"`
        Count                 int          `json:"count"`
        RecentQuestionHistory []string     `json:"-"` // Don't include in JSON, internal use
}

// AIChatRequest represents a request to the AI service for a new chat feature
type AIChatRequest struct {
        Language              string
        Level                 string
        Question              string
        Options               []string
        Passage               string // For reading comprehension
        UserAnswer            string // Optional
        CorrectAnswer         string // Optional
        IsCorrect             *bool  // Optional
        UserMessage           string
        ConversationHistory   []ChatMessage `json:"conversation_history,omitempty"`
        RecentQuestionHistory []string      `json:"-"` // Don't include in JSON, internal use
}

// ChatMessage represents a single message in the chat conversation
type ChatMessage struct {
        Role    api.ChatMessageRole `json:"role"`    // "user" or "assistant"
        Content string              `json:"content"` // The message content
}

// AIExplanationRequest represents a request for an explanation of a wrong answer
type AIExplanationRequest struct {
        Question      string `json:"question"`
        UserAnswer    string `json:"user_answer"`
        CorrectAnswer string `json:"correct_answer"`
        Language      string `json:"language"`
        Level         string `json:"level"`
}

// MarshalContentToJSON serializes the question content to JSON string
func (q *Question) MarshalContentToJSON() (result0 string, err error) <span class="cov5" title="10">{
        data, err := json.Marshal(q.Content)
        return string(data), err
}</span>

// UnmarshalContentFromJSON deserializes JSON string into question content
func (q *Question) UnmarshalContentFromJSON(data string) error <span class="cov6" title="12">{
        return json.Unmarshal([]byte(data), &amp;q.Content)
}</span>

// WorkerSettings represents worker configuration settings stored in database
type WorkerSettings struct {
        ID           int       `json:"id" db:"id"`
        SettingKey   string    `json:"setting_key" db:"setting_key"`
        SettingValue string    `json:"setting_value" db:"setting_value"`
        CreatedAt    time.Time `json:"created_at" db:"created_at"`
        UpdatedAt    time.Time `json:"updated_at" db:"updated_at"`
}

// WorkerStatus represents worker health and activity status
type WorkerStatus struct {
        ID                      int            `json:"id" db:"id"`
        WorkerInstance          string         `json:"worker_instance" db:"worker_instance"`
        IsRunning               bool           `json:"is_running" db:"is_running"`
        IsPaused                bool           `json:"is_paused" db:"is_paused"`
        CurrentActivity         sql.NullString `json:"current_activity" db:"current_activity"`
        LastHeartbeat           sql.NullTime   `json:"last_heartbeat" db:"last_heartbeat"`
        LastRunStart            sql.NullTime   `json:"last_run_start" db:"last_run_start"`
        LastRunEnd              sql.NullTime   `json:"last_run_end" db:"last_run_end"`
        LastRunFinish           sql.NullTime   `json:"last_run_finish" db:"last_run_finish"`
        LastRunError            sql.NullString `json:"last_run_error" db:"last_run_error"`
        TotalQuestionsProcessed int            `json:"total_questions_processed" db:"total_questions_processed"`
        TotalQuestionsGenerated int            `json:"total_questions_generated" db:"total_questions_generated"`
        TotalRuns               int            `json:"total_runs" db:"total_runs"`
        CreatedAt               time.Time      `json:"created_at" db:"created_at"`
        UpdatedAt               time.Time      `json:"updated_at" db:"updated_at"`
}

// MarshalJSON customizes JSON marshaling for WorkerStatus to handle sql.NullString and sql.NullTime properly
func (ws WorkerStatus) MarshalJSON() (result0 []byte, err error) <span class="cov2" title="2">{
        return json.Marshal(&amp;struct {
                ID                      int        `json:"id"`
                WorkerInstance          string     `json:"worker_instance"`
                IsRunning               bool       `json:"is_running"`
                IsPaused                bool       `json:"is_paused"`
                CurrentActivity         *string    `json:"current_activity"`
                LastHeartbeat           *time.Time `json:"last_heartbeat"`
                LastRunStart            *time.Time `json:"last_run_start"`
                LastRunEnd              *time.Time `json:"last_run_end"`
                LastRunFinish           *time.Time `json:"last_run_finish"`
                LastRunError            *string    `json:"last_run_error"`
                TotalQuestionsProcessed int        `json:"total_questions_processed"`
                TotalQuestionsGenerated int        `json:"total_questions_generated"`
                TotalRuns               int        `json:"total_runs"`
                CreatedAt               time.Time  `json:"created_at"`
                UpdatedAt               time.Time  `json:"updated_at"`
        }{
                ID:                      ws.ID,
                WorkerInstance:          ws.WorkerInstance,
                IsRunning:               ws.IsRunning,
                IsPaused:                ws.IsPaused,
                CurrentActivity:         nullStringToPointer(ws.CurrentActivity),
                LastHeartbeat:           nullTimeToPointer(ws.LastHeartbeat),
                LastRunStart:            nullTimeToPointer(ws.LastRunStart),
                LastRunEnd:              nullTimeToPointer(ws.LastRunEnd),
                LastRunFinish:           nullTimeToPointer(ws.LastRunFinish),
                LastRunError:            nullStringToPointer(ws.LastRunError),
                TotalQuestionsProcessed: ws.TotalQuestionsProcessed,
                TotalQuestionsGenerated: ws.TotalQuestionsGenerated,
                TotalRuns:               ws.TotalRuns,
                CreatedAt:               ws.CreatedAt,
                UpdatedAt:               ws.UpdatedAt,
        })
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package observability

import (
        "context"
        "fmt"

        "quizapp/internal/models"

        "go.opentelemetry.io/otel"
        "go.opentelemetry.io/otel/attribute"
        "go.opentelemetry.io/otel/trace"
)

var globalTracer trace.Tracer

// InitGlobalTracer initializes the global tracer for the application.
func InitGlobalTracer() <span class="cov8" title="1">{
        globalTracer = otel.Tracer("quiz-app")
}</span>

// GetGlobalTracer returns the global tracer instance for the application.
func GetGlobalTracer() trace.Tracer <span class="cov0" title="0">{
        if globalTracer == nil </span><span class="cov0" title="0">{
                // Fallback to default tracer if not initialized
                globalTracer = otel.Tracer("quiz-app")
        }</span>
        <span class="cov0" title="0">return globalTracer</span>
}

// TraceFunction starts a new span with a descriptive name for the given service and function.
func TraceFunction(ctx context.Context, serviceName, functionName string, attributes ...attribute.KeyValue) (context.Context, trace.Span) <span class="cov0" title="0">{
        tracer := GetGlobalTracer()
        spanName := fmt.Sprintf("%s.%s", serviceName, functionName)
        return tracer.Start(ctx, spanName, trace.WithAttributes(attributes...))
}</span>

// TraceFunctionWithErrorHandling starts a new span and automatically adds error attributes if the function panics or returns an error.
func TraceFunctionWithErrorHandling(ctx context.Context, serviceName, functionName string, fn func() error, attributes ...attribute.KeyValue) error <span class="cov0" title="0">{
        _, span := TraceFunction(ctx, serviceName, functionName, attributes...)
        defer func() </span><span class="cov0" title="0">{
                if err := recover(); err != nil </span><span class="cov0" title="0">{
                        span.SetAttributes(
                                attribute.Bool("error", true),
                                attribute.String("error.type", "panic"),
                                attribute.String("error.message", fmt.Sprintf("%v", err)),
                        )
                        span.End()
                        panic(err)</span> // re-panic
                }
        }()

        <span class="cov0" title="0">err := fn()
        if err != nil </span><span class="cov0" title="0">{
                span.SetAttributes(
                        attribute.Bool("error", true),
                        attribute.String("error.message", err.Error()),
                )
        }</span>
        <span class="cov0" title="0">span.End()
        return err</span>
}

// TraceAIFunction starts a new span for an AI service function.
func TraceAIFunction(ctx context.Context, functionName string, attributes ...attribute.KeyValue) (context.Context, trace.Span) <span class="cov0" title="0">{
        return TraceFunction(ctx, "ai", functionName, attributes...)
}</span>

// TraceUserFunction starts a new span for a user service function.
func TraceUserFunction(ctx context.Context, functionName string, attributes ...attribute.KeyValue) (context.Context, trace.Span) <span class="cov0" title="0">{
        return TraceFunction(ctx, "user", functionName, attributes...)
}</span>

// TraceQuestionFunction starts a new span for a question service function.
func TraceQuestionFunction(ctx context.Context, functionName string, attributes ...attribute.KeyValue) (context.Context, trace.Span) <span class="cov0" title="0">{
        return TraceFunction(ctx, "question", functionName, attributes...)
}</span>

// TraceWorkerFunction starts a new span for a worker service function.
func TraceWorkerFunction(ctx context.Context, functionName string, attributes ...attribute.KeyValue) (context.Context, trace.Span) <span class="cov0" title="0">{
        return TraceFunction(ctx, "worker", functionName, attributes...)
}</span>

// TraceLearningFunction starts a new span for a learning service function.
func TraceLearningFunction(ctx context.Context, functionName string, attributes ...attribute.KeyValue) (context.Context, trace.Span) <span class="cov0" title="0">{
        return TraceFunction(ctx, "learning", functionName, attributes...)
}</span>

// TraceHandlerFunction starts a new span for a handler function.
func TraceHandlerFunction(ctx context.Context, functionName string, attributes ...attribute.KeyValue) (context.Context, trace.Span) <span class="cov0" title="0">{
        return TraceFunction(ctx, "handler", functionName, attributes...)
}</span>

// TraceVarietyFunction starts a new span for a variety service function.
func TraceVarietyFunction(ctx context.Context, functionName string, attributes ...attribute.KeyValue) (context.Context, trace.Span) <span class="cov0" title="0">{
        return TraceFunction(ctx, "variety", functionName, attributes...)
}</span>

// TraceOAuthFunction starts a new span for an OAuth service function.
func TraceOAuthFunction(ctx context.Context, functionName string, attributes ...attribute.KeyValue) (context.Context, trace.Span) <span class="cov0" title="0">{
        return TraceFunction(ctx, "oauth", functionName, attributes...)
}</span>

// TraceCleanupFunction starts a new span for a cleanup service function.
func TraceCleanupFunction(ctx context.Context, functionName string, attributes ...attribute.KeyValue) (context.Context, trace.Span) <span class="cov0" title="0">{
        return TraceFunction(ctx, "cleanup", functionName, attributes...)
}</span>

// TraceDatabaseFunction starts a new span for a database function.
func TraceDatabaseFunction(ctx context.Context, functionName string, attributes ...attribute.KeyValue) (context.Context, trace.Span) <span class="cov0" title="0">{
        return TraceFunction(ctx, "database", functionName, attributes...)
}</span>

// AttributeQuestion returns a tracing attribute for a question's ID.
func AttributeQuestion(q *models.Question) attribute.KeyValue <span class="cov0" title="0">{
        return attribute.String("question.id", fmt.Sprintf("%d", q.ID))
}</span>

// AttributeQuestionID returns a tracing attribute for a question ID.
func AttributeQuestionID(id int) attribute.KeyValue <span class="cov0" title="0">{
        return attribute.Int("question.id", id)
}</span>

// AttributeUserID returns a tracing attribute for a user ID.
func AttributeUserID(id int) attribute.KeyValue <span class="cov0" title="0">{
        return attribute.Int("user.id", id)
}</span>

// AttributeLanguage returns a tracing attribute for a language.
func AttributeLanguage(lang string) attribute.KeyValue <span class="cov0" title="0">{
        return attribute.String("language", lang)
}</span>

// AttributeLevel returns a tracing attribute for a level.
func AttributeLevel(level string) attribute.KeyValue <span class="cov0" title="0">{
        return attribute.String("level", level)
}</span>

// AttributeQuestionType returns a tracing attribute for a question type.
func AttributeQuestionType(qType interface{}) attribute.KeyValue <span class="cov0" title="0">{
        return attribute.String("question.type", fmt.Sprintf("%v", qType))
}</span>

// AttributeLimit returns a tracing attribute for a limit value.
func AttributeLimit(limit int) attribute.KeyValue <span class="cov0" title="0">{
        return attribute.Int("limit", limit)
}</span>

// AttributePage returns a tracing attribute for a page value.
func AttributePage(page int) attribute.KeyValue <span class="cov0" title="0">{
        return attribute.Int("page", page)
}</span>

// AttributePageSize returns a tracing attribute for a page size value.
func AttributePageSize(size int) attribute.KeyValue <span class="cov0" title="0">{
        return attribute.Int("page_size", size)
}</span>

// AttributeSearch returns a tracing attribute for a search value.
func AttributeSearch(search string) attribute.KeyValue <span class="cov0" title="0">{
        return attribute.String("search", search)
}</span>

// AttributeTypeFilter returns a tracing attribute for a type filter value.
func AttributeTypeFilter(typeFilter string) attribute.KeyValue <span class="cov0" title="0">{
        return attribute.String("type_filter", typeFilter)
}</span>

// AttributeStatusFilter returns a tracing attribute for a status filter value.
func AttributeStatusFilter(statusFilter string) attribute.KeyValue <span class="cov0" title="0">{
        return attribute.String("status_filter", statusFilter)
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">// Package observability provides OpenTelemetry tracing, metrics, and structured logging
// with trace correlation for the quiz application.
package observability

import (
        "context"
        "os"

        "quizapp/internal/config"

        "go.opentelemetry.io/contrib/bridges/otelzap"
        "go.opentelemetry.io/otel/exporters/otlp/otlplog/otlploggrpc"
        "go.opentelemetry.io/otel/sdk/log"
        "go.uber.org/zap"
        "go.uber.org/zap/zapcore"
)

// Logger wraps the zap logger with OpenTelemetry context support
type Logger struct {
        *zap.Logger
}

// NewLogger creates a new logger with OpenTelemetry context support and OTLP export
func NewLogger(cfg *config.OpenTelemetryConfig) *Logger <span class="cov5" title="2">{
        // Create a basic zap logger for stdout
        zapConfig := zap.NewProductionConfig()
        zapConfig.EncoderConfig.TimeKey = "timestamp"
        zapConfig.EncoderConfig.EncodeTime = zapcore.ISO8601TimeEncoder
        zapConfig.EncoderConfig.StacktraceKey = "stacktrace"

        // Use development config if in development mode
        if os.Getenv("ENV") == "development" </span><span class="cov0" title="0">{
                zapConfig = zap.NewDevelopmentConfig()
        }</span>

        <span class="cov5" title="2">zapLogger, err := zapConfig.Build()
        if err != nil </span><span class="cov0" title="0">{
                // Fallback to a basic logger if config fails
                zapLogger = zap.NewExample()
        }</span>

        // If OTLP logging is enabled, set up the OTLP exporter
        <span class="cov5" title="2">if cfg != nil &amp;&amp; cfg.EnableLogging &amp;&amp; cfg.Endpoint != "" </span><span class="cov1" title="1">{
                // Log that we're attempting to set up OTLP export
                zapLogger.Info("Setting up OTLP logging", zap.String("endpoint", cfg.Endpoint), zap.String("protocol", cfg.Protocol))

                // Create OTLP exporter with proper endpoint format
                endpoint := cfg.Endpoint

                exporter, err := otlploggrpc.New(context.Background(),
                        otlploggrpc.WithEndpoint(endpoint),
                        otlploggrpc.WithInsecure(),
                )
                if err != nil </span><span class="cov0" title="0">{
                        // Log the error but continue with stdout logging
                        zapLogger.Error("Failed to create OTLP exporter", zap.Error(err), zap.String("endpoint", endpoint))
                }</span> else<span class="cov1" title="1"> {
                        zapLogger.Info("Successfully created OTLP exporter", zap.String("endpoint", endpoint))

                        // Create batch processor
                        processor := log.NewBatchProcessor(exporter)

                        // Create logger provider
                        provider := log.NewLoggerProvider(
                                log.WithProcessor(processor),
                        )

                        // Create OpenTelemetry core
                        otelCore := otelzap.NewCore("quizapp", otelzap.WithLoggerProvider(provider))

                        // Create a new zap logger with both stdout and OTLP cores
                        cores := []zapcore.Core{
                                zapLogger.Core(),
                                otelCore,
                        }

                        // Create a new logger with multiple cores
                        multiCore := zapcore.NewTee(cores...)
                        zapLogger = zap.New(multiCore)

                        zapLogger.Info("OTLP logging successfully configured", zap.String("endpoint", endpoint))
                }</span>
        } else<span class="cov1" title="1"> {
                endpoint := "not set"
                if cfg != nil </span><span class="cov1" title="1">{
                        endpoint = cfg.Endpoint
                }</span>
                <span class="cov1" title="1">zapLogger.Info("OTLP logging not enabled", zap.Bool("enable_logging", cfg != nil &amp;&amp; cfg.EnableLogging), zap.String("endpoint", endpoint))</span>
        }

        <span class="cov5" title="2">return &amp;Logger{Logger: zapLogger}</span>
}

// Debug logs a debug message with context
func (l *Logger) Debug(ctx context.Context, msg string, fields ...map[string]interface{}) <span class="cov0" title="0">{
        l.logWithContext(ctx, zap.DebugLevel, msg, fields...)
}</span>

// Info logs an info message with context
func (l *Logger) Info(ctx context.Context, msg string, fields ...map[string]interface{}) <span class="cov5" title="2">{
        l.logWithContext(ctx, zap.InfoLevel, msg, fields...)
}</span>

// Warn logs a warning message with context
func (l *Logger) Warn(ctx context.Context, msg string, fields ...map[string]interface{}) <span class="cov0" title="0">{
        l.logWithContext(ctx, zap.WarnLevel, msg, fields...)
}</span>

// Error logs an error message with context
func (l *Logger) Error(ctx context.Context, msg string, err error, fields ...map[string]interface{}) <span class="cov1" title="1">{
        // Merge fields with error information
        allFields := l.mergeFields(fields...)
        if err != nil </span><span class="cov0" title="0">{
                allFields["error"] = err.Error()
        }</span>
        <span class="cov1" title="1">l.logWithContext(ctx, zap.ErrorLevel, msg, allFields)</span>
}

// logWithContext logs a message with OpenTelemetry context correlation
func (l *Logger) logWithContext(_ context.Context, level zapcore.Level, msg string, fields ...map[string]interface{}) <span class="cov8" title="3">{
        // Merge all fields into a single map
        allFields := l.mergeFields(fields...)

        // Convert fields to zap fields
        zapFields := make([]zap.Field, 0, len(allFields))
        for k, v := range allFields </span><span class="cov0" title="0">{
                zapFields = append(zapFields, zap.Any(k, v))
        }</span>

        // Log with the appropriate level
        <span class="cov8" title="3">switch level </span>{
        case zap.DebugLevel:<span class="cov0" title="0">
                l.Logger.Debug(msg, zapFields...)</span>
        case zap.InfoLevel:<span class="cov5" title="2">
                l.Logger.Info(msg, zapFields...)</span>
        case zap.WarnLevel:<span class="cov0" title="0">
                l.Logger.Warn(msg, zapFields...)</span>
        case zap.ErrorLevel:<span class="cov1" title="1">
                l.Logger.Error(msg, zapFields...)</span>
        default:<span class="cov0" title="0">
                l.Logger.Info(msg, zapFields...)</span>
        }
}

// mergeFields merges multiple field maps into a single map
func (l *Logger) mergeFields(fields ...map[string]interface{}) map[string]interface{} <span class="cov10" title="4">{
        if len(fields) == 0 </span><span class="cov8" title="3">{
                return map[string]interface{}{}
        }</span>

        <span class="cov1" title="1">if len(fields) == 1 </span><span class="cov1" title="1">{
                return fields[0]
        }</span>

        // Merge multiple field maps
        <span class="cov0" title="0">merged := make(map[string]interface{})
        for _, fieldMap := range fields </span><span class="cov0" title="0">{
                for k, v := range fieldMap </span><span class="cov0" title="0">{
                        merged[k] = v
                }</span>
        }
        <span class="cov0" title="0">return merged</span>
}

// Sync flushes any buffered log entries
func (l *Logger) Sync() error <span class="cov0" title="0">{
        return l.Logger.Sync()
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">package observability

import (
        "context"

        "quizapp/internal/config"
        contextutils "quizapp/internal/utils"

        "go.opentelemetry.io/otel/exporters/otlp/otlpmetric/otlpmetricgrpc"
        "go.opentelemetry.io/otel/exporters/otlp/otlpmetric/otlpmetrichttp"
        "go.opentelemetry.io/otel/sdk/metric"
        "go.opentelemetry.io/otel/sdk/resource"
        semconv "go.opentelemetry.io/otel/semconv/v1.21.0"
)

// InitMetrics initializes OpenTelemetry metrics
func InitMetrics(cfg *config.OpenTelemetryConfig) (result0 *metric.MeterProvider, err error) <span class="cov8" title="1">{
        ctx := context.Background()

        // Set up resource attributes
        res, err := resource.New(ctx,
                resource.WithAttributes(
                        semconv.ServiceName(cfg.ServiceName),
                        semconv.ServiceVersion(cfg.ServiceVersion),
                ),
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, contextutils.WrapErrorf(contextutils.ErrInternalError, "failed to create otel resource: %w", err)
        }</span>

        // Set up exporter
        <span class="cov8" title="1">var exporter metric.Exporter
        switch cfg.Protocol </span>{
        case "grpc":<span class="cov8" title="1">
                // For gRPC, strip http:// prefix if present, otherwise use endpoint as-is
                endpoint := cfg.Endpoint
                exp, err := otlpmetricgrpc.New(ctx,
                        otlpmetricgrpc.WithEndpoint(endpoint),
                        func() otlpmetricgrpc.Option </span><span class="cov8" title="1">{
                                if cfg.Insecure </span><span class="cov8" title="1">{
                                        return otlpmetricgrpc.WithInsecure()
                                }</span>
                                <span class="cov0" title="0">return nil</span>
                        }(),
                        otlpmetricgrpc.WithHeaders(cfg.Headers),
                )
                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        return nil, contextutils.WrapErrorf(contextutils.ErrInternalError, "failed to create otlp grpc metric exporter: %w", err)
                }</span>
                <span class="cov8" title="1">exporter = exp</span>
        case "http":<span class="cov0" title="0">
                exp, err := otlpmetrichttp.New(ctx,
                        otlpmetrichttp.WithEndpoint(cfg.Endpoint),
                        func() otlpmetrichttp.Option </span><span class="cov0" title="0">{
                                if cfg.Insecure </span><span class="cov0" title="0">{
                                        return otlpmetrichttp.WithInsecure()
                                }</span>
                                <span class="cov0" title="0">return nil</span>
                        }(),
                        otlpmetrichttp.WithHeaders(cfg.Headers),
                )
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return nil, contextutils.WrapErrorf(contextutils.ErrInternalError, "failed to create otlp http metric exporter: %w", err)
                }</span>
                <span class="cov0" title="0">exporter = exp</span>
        default:<span class="cov0" title="0">
                return nil, contextutils.WrapErrorf(contextutils.ErrInternalError, "unsupported otel protocol: %s", cfg.Protocol)</span>
        }

        // Set up meter provider
        <span class="cov8" title="1">mp := metric.NewMeterProvider(
                metric.WithReader(metric.NewPeriodicReader(exporter)),
                metric.WithResource(res),
        )
        return mp, nil</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package observability

import (
        "errors"

        "github.com/gin-gonic/gin"
        "go.opentelemetry.io/contrib/instrumentation/github.com/gin-gonic/gin/otelgin"
        "go.opentelemetry.io/otel/codes"
        "go.opentelemetry.io/otel/trace"
)

// GinMiddleware creates OpenTelemetry middleware for Gin HTTP requests
func GinMiddleware(serviceName string) gin.HandlerFunc <span class="cov5" title="3">{
        return otelgin.Middleware(serviceName)
}</span>

// GinMiddlewareWithErrorHandling creates OpenTelemetry middleware with automatic error attribute addition
func GinMiddlewareWithErrorHandling(serviceName string) gin.HandlerFunc <span class="cov5" title="3">{
        return func(c *gin.Context) </span><span class="cov10" title="9">{
                // Use the existing OpenTelemetry middleware
                otelgin.Middleware(serviceName)(c)

                // After the request is processed, check for errors
                c.Next()

                // Get the span from context and add error attributes for failed requests
                if span := trace.SpanFromContext(c.Request.Context()); span != nil </span><span class="cov10" title="9">{
                        statusCode := c.Writer.Status()
                        if statusCode &gt;= 400 </span><span class="cov8" title="6">{
                                span.RecordError(errors.New("request failed"), trace.WithStackTrace(true))
                                span.SetStatus(codes.Error, "request failed")
                        }</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package observability

import (
        "quizapp/internal/config"

        "go.opentelemetry.io/otel/sdk/metric"
        "go.opentelemetry.io/otel/sdk/trace"
)

// SetupObservability initializes tracing, metrics, and logging for a service
func SetupObservability(cfg *config.OpenTelemetryConfig, serviceName string) (result0 *trace.TracerProvider, result1 *metric.MeterProvider, result2 *Logger, err error) <span class="cov10" title="2">{
        if serviceName != "" </span><span class="cov10" title="2">{
                cfg.ServiceName = serviceName
        }</span>

        <span class="cov10" title="2">var tp *trace.TracerProvider
        var mp *metric.MeterProvider
        var logger *Logger

        if cfg.EnableTracing </span><span class="cov1" title="1">{
                tp, err = InitTracing(cfg)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, nil, err
                }</span>
                // Initialize the global tracer
                <span class="cov1" title="1">InitGlobalTracer()</span>
        }

        <span class="cov10" title="2">if cfg.EnableMetrics </span><span class="cov1" title="1">{
                mp, err = InitMetrics(cfg)
                if err != nil </span><span class="cov0" title="0">{
                        return tp, nil, nil, err
                }</span>
        }

        <span class="cov10" title="2">if cfg.EnableLogging </span><span class="cov1" title="1">{
                logger = NewLogger(cfg)
        }</span>

        <span class="cov10" title="2">return tp, mp, logger, nil</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package observability

import (
        "context"

        "quizapp/internal/config"
        contextutils "quizapp/internal/utils"

        "go.opentelemetry.io/otel"
        "go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc"
        "go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracehttp"
        "go.opentelemetry.io/otel/propagation"
        "go.opentelemetry.io/otel/sdk/resource"
        "go.opentelemetry.io/otel/sdk/trace"
        semconv "go.opentelemetry.io/otel/semconv/v1.21.0"
)

// InitTracing initializes OpenTelemetry tracing
func InitTracing(cfg *config.OpenTelemetryConfig) (result0 *trace.TracerProvider, err error) <span class="cov8" title="1">{
        ctx := context.Background()

        // Set up resource attributes
        res, err := resource.New(ctx,
                resource.WithAttributes(
                        semconv.ServiceName(cfg.ServiceName),
                        semconv.ServiceVersion(cfg.ServiceVersion),
                ),
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, contextutils.WrapErrorf(contextutils.ErrInternalError, "failed to create otel resource: %w", err)
        }</span>

        // Set up exporter
        <span class="cov8" title="1">var exporter trace.SpanExporter
        switch cfg.Protocol </span>{
        case "grpc":<span class="cov8" title="1">
                // For gRPC, strip http:// prefix if present, otherwise use endpoint as-is
                endpoint := cfg.Endpoint
                exp, err := otlptracegrpc.New(ctx,
                        otlptracegrpc.WithEndpoint(endpoint),
                        func() otlptracegrpc.Option </span><span class="cov8" title="1">{
                                if cfg.Insecure </span><span class="cov8" title="1">{
                                        return otlptracegrpc.WithInsecure()
                                }</span>
                                <span class="cov0" title="0">return nil</span>
                        }(),
                        otlptracegrpc.WithHeaders(cfg.Headers),
                )
                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        return nil, contextutils.WrapErrorf(contextutils.ErrInternalError, "failed to create otlp grpc exporter: %w", err)
                }</span>
                <span class="cov8" title="1">exporter = exp</span>
        case "http":<span class="cov0" title="0">
                exp, err := otlptracehttp.New(ctx,
                        otlptracehttp.WithEndpoint(cfg.Endpoint),
                        otlptracehttp.WithInsecure(),
                        otlptracehttp.WithHeaders(cfg.Headers),
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, contextutils.WrapErrorf(contextutils.ErrInternalError, "failed to create otlp http exporter: %w", err)
                }</span>
                <span class="cov0" title="0">exporter = exp</span>
        default:<span class="cov0" title="0">
                return nil, contextutils.WrapErrorf(contextutils.ErrInternalError, "unsupported otel protocol: %s", cfg.Protocol)</span>
        }

        // Set up sampler
        <span class="cov8" title="1">sampler := trace.ParentBased(trace.TraceIDRatioBased(cfg.SamplingRate))

        // Set up tracer provider
        tp := trace.NewTracerProvider(
                trace.WithBatcher(exporter),
                trace.WithResource(res),
                trace.WithSampler(sampler),
        )
        otel.SetTracerProvider(tp)

        // Set up text map propagator for trace context propagation
        // This enables the backend to receive and process trace headers from NGINX
        otel.SetTextMapPropagator(propagation.NewCompositeTextMapPropagator(
                propagation.TraceContext{},
                propagation.Baggage{},
        ))

        return tp, nil</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">// Package services provides business logic services for the quiz application.
package services

import (
        "bufio"
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "io"
        "math/rand"
        "net/http"
        "runtime/debug"
        "strconv"
        "strings"
        "sync"
        "time"

        "quizapp/internal/config"
        "quizapp/internal/models"
        "quizapp/internal/observability"
        contextutils "quizapp/internal/utils"

        "github.com/xeipuuv/gojsonschema"
        "go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp"
        "go.opentelemetry.io/otel/attribute"
        "go.opentelemetry.io/otel/codes"
        "go.opentelemetry.io/otel/trace"
)

// JSON Schema definitions for grammar field
// These schemas are used with the 'grammar' field in OpenAI-compatible API requests
// to enforce specific JSON structure validation. This ensures that AI models return
// exactly the expected format, eliminating parsing errors and improving reliability.
//
// The grammar field is conditionally included based on provider support (see supportsGrammarField).
// Providers that don't support grammar (like Google) will fall back to prompt-based structure guidance.
const (
        // Batch questions schema (array of single questions)
        BatchQuestionsSchema = `{
                "type": "array",
                "items": {
                        "type": "object",
                        "properties": {
                                "question": {"type": "string"},
                                "options": {"type": "array", "items": {"type": "string"}, "minItems": 4, "maxItems": 4},
                                "correct_answer": {"type": "integer"},
                                "explanation": {"type": "string"},
                                "topic": {"type": "string"}
                        },
                        "required": ["question", "options", "correct_answer", "explanation", "topic"]
                }
        }`

        // Batch reading comprehension schema
        BatchReadingComprehensionSchema = `{
                "type": "array",
                "items": {
                        "type": "object",
                        "properties": {
                                "passage": {"type": "string"},
                                "question": {"type": "string"},
                                "options": {"type": "array", "items": {"type": "string"}, "minItems": 4, "maxItems": 4},
                                "correct_answer": {"type": "integer"},
                                "explanation": {"type": "string"},
                                "topic": {"type": "string"}
                        },
                        "required": ["passage", "question", "options", "correct_answer", "explanation", "topic"]
                }
        }`

        // Batch vocabulary question schema (array of vocabulary questions)
        BatchVocabularyQuestionSchema = `{
                "type": "array",
                "items": {
                        "type": "object",
                        "properties": {
                                "sentence": {"type": "string"},
                                "question": {"type": "string"},
                                "options": {"type": "array", "items": {"type": "string"}, "minItems": 4, "maxItems": 4},
                                "correct_answer": {"type": "integer"},
                                "explanation": {"type": "string"},
                                "topic": {"type": "string"}
                        },
                        "required": ["sentence", "question", "options", "correct_answer", "explanation"]
                }
        }`
)

// UserAIConfig holds per-user AI configuration
type UserAIConfig struct {
        Provider string
        Model    string
        APIKey   string
        Username string // For logging purposes
}

// AIServiceInterface defines the interface for AI-powered question generation
type AIServiceInterface interface {
        GenerateQuestion(ctx context.Context, userConfig *UserAIConfig, req *models.AIQuestionGenRequest) (*models.Question, error)
        GenerateQuestions(ctx context.Context, userConfig *UserAIConfig, req *models.AIQuestionGenRequest) ([]*models.Question, error)
        GenerateQuestionsStream(ctx context.Context, userConfig *UserAIConfig, req *models.AIQuestionGenRequest, progress chan&lt;- *models.Question, variety *VarietyElements) error
        GenerateChatResponse(ctx context.Context, userConfig *UserAIConfig, req *models.AIChatRequest) (string, error)
        GenerateChatResponseStream(ctx context.Context, userConfig *UserAIConfig, req *models.AIChatRequest, chunks chan&lt;- string) error
        TestConnection(ctx context.Context, provider, model, apiKey string) error
        GetConcurrencyStats() ConcurrencyStats
        GetQuestionBatchSize(provider string) int
        VarietyService() *VarietyService
        Shutdown(ctx context.Context) error
}

// ConcurrencyStats provides metrics about AI request concurrency
type ConcurrencyStats struct {
        ActiveRequests  int            `json:"active_requests"`
        MaxConcurrent   int            `json:"max_concurrent"`
        QueuedRequests  int            `json:"queued_requests"`
        TotalRequests   int64          `json:"total_requests"`
        UserActiveCount map[string]int `json:"user_active_count"`
        MaxPerUser      int            `json:"max_per_user"`
}

// AIService provides AI-powered question generation using OpenAI-compatible APIs
type AIService struct {
        httpClient *http.Client
        debug      bool
        cfg        *config.Config

        // Template management
        templateManager *AITemplateManager

        // Variety service for question diversity
        varietyService *VarietyService

        // Concurrency control
        globalSemaphore chan struct{} // Limits total concurrent requests
        maxConcurrent   int           // Maximum concurrent requests globally
        maxPerUser      int           // Maximum concurrent requests per user

        // Per-user concurrency tracking
        userRequestCount map[string]int // Username -&gt; active request count
        concurrencyMu    sync.RWMutex   // Protects user maps

        // Metrics
        totalRequests  int64        // Total requests processed
        activeRequests int          // Current active requests
        statsMu        sync.RWMutex // Protects stats

        // Observability
        logger *observability.Logger

        // Shutdown control
        shutdownCtx context.Context
        shutdownMu  sync.RWMutex
}

// Schema validation counters
var (
        SchemaValidationFailures       = make(map[models.QuestionType]int)
        SchemaValidationFailureDetails = make(map[models.QuestionType][]string) // NEW: error details
        SchemaValidationMu             sync.Mutex
)

// extractItemsSchema extracts the items schema from a batch schema
func extractItemsSchema(batchSchema string) (result0 string, err error) <span class="cov8" title="2021">{
        var schemaMap map[string]interface{}
        if err = json.Unmarshal([]byte(batchSchema), &amp;schemaMap); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        // For batch schemas, extract the items schema
        <span class="cov8" title="2021">if items, ok := schemaMap["items"]; ok </span><span class="cov8" title="2021">{
                var itemsBytes []byte
                itemsBytes, err = json.Marshal(items)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov8" title="2021">return string(itemsBytes), nil</span>
        }
        <span class="cov0" title="0">return "", contextutils.ErrorWithContextf("no items found in batch schema")</span>
}

// ValidateQuestionSchema validates a question against the appropriate schema
func (s *AIService) ValidateQuestionSchema(ctx context.Context, qType models.QuestionType, question interface{}) (result0 bool, err error) <span class="cov8" title="2013">{
        _, span := observability.TraceAIFunction(ctx, "validate_question_schema",
                observability.AttributeQuestionType(qType),
        )
        defer func() </span><span class="cov8" title="2013">{
                if err != nil </span><span class="cov0" title="0">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov8" title="2013">span.End()</span>
        }()

        // Validate input parameters
        <span class="cov8" title="2013">if question == nil </span><span class="cov0" title="0">{
                span.SetAttributes(attribute.String("validation.result", "nil_question"))
                return false, contextutils.ErrorWithContextf("question cannot be nil")
        }</span>

        <span class="cov8" title="2013">var schema string
        switch qType </span>{
        case models.Vocabulary:<span class="cov8" title="2011">
                schema = BatchVocabularyQuestionSchema</span>
        case models.ReadingComprehension:<span class="cov1" title="1">
                schema = BatchReadingComprehensionSchema</span>
        case models.FillInBlank, models.QuestionAnswer:<span class="cov0" title="0">
                schema = BatchQuestionsSchema</span>
        default:<span class="cov0" title="0">
                span.SetAttributes(attribute.String("validation.result", "unknown_type"))
                return false, contextutils.ErrorWithContextf("unknown question type: %v", qType)</span>
        }

        // Extract the items schema for validation
        <span class="cov8" title="2013">itemSchema, err := extractItemsSchema(schema)
        if err != nil </span><span class="cov0" title="0">{
                span.SetAttributes(attribute.String("validation.result", "schema_extract_error"), attribute.String("validation.error", err.Error()))
                return false, contextutils.WrapErrorf(err, "failed to extract schema for question type %v", qType)
        }</span>

        // Marshal the question to JSON
        // If question is a *models.Question, validate only Content
        <span class="cov8" title="2013">toValidate := question
        if q, ok := question.(*models.Question); ok </span><span class="cov8" title="2013">{
                if q == nil </span><span class="cov0" title="0">{
                        span.SetAttributes(attribute.String("validation.result", "nil_question_model"))
                        return false, contextutils.ErrorWithContextf("question model is nil")
                }</span>
                <span class="cov8" title="2013">toValidate = q.Content</span>
        }

        <span class="cov8" title="2013">questionBytes, err := json.Marshal(toValidate)
        if err != nil </span><span class="cov0" title="0">{
                span.SetAttributes(attribute.String("validation.result", "marshal_error"), attribute.String("validation.error", err.Error()))
                return false, contextutils.WrapErrorf(err, "failed to marshal question for validation")
        }</span>

        // Validate
        <span class="cov8" title="2013">result, err := gojsonschema.Validate(
                gojsonschema.NewStringLoader(itemSchema),
                gojsonschema.NewBytesLoader(questionBytes),
        )
        if err != nil </span><span class="cov0" title="0">{
                span.SetAttributes(attribute.String("validation.result", "validate_error"), attribute.String("validation.error", err.Error()))
                return false, contextutils.WrapErrorf(err, "schema validation failed for question type %v", qType)
        }</span>

        <span class="cov8" title="2013">if !result.Valid() </span><span class="cov0" title="0">{
                errs := result.Errors()
                var errorMessages []string
                for _, e := range errs </span><span class="cov0" title="0">{
                        errorMessages = append(errorMessages, e.String())
                }</span>
                <span class="cov0" title="0">span.SetAttributes(attribute.String("validation.result", "invalid"))
                return false, contextutils.ErrorWithContextf("question failed schema validation: %s", strings.Join(errorMessages, "; "))</span>
        }

        <span class="cov8" title="2013">span.SetAttributes(attribute.String("validation.result", "valid"))
        return true, nil</span>
}

// NewAIService creates a new AI service instance
func NewAIService(cfg *config.Config, logger *observability.Logger) *AIService <span class="cov4" title="48">{
        // Create template manager
        templateManager, err := NewAITemplateManager()
        if err != nil </span><span class="cov0" title="0">{
                logger.Error(context.Background(), "Failed to create template manager", err, map[string]interface{}{})
                panic(err)</span> // Use panic for fatal errors in initialization
        }

        // Create variety service
        <span class="cov4" title="48">varietyService := NewVarietyServiceWithLogger(cfg, logger)

        // Create instrumented HTTP client with reasonable timeouts and explicit span options
        httpClient := &amp;http.Client{
                Timeout: config.AIRequestTimeout,
                Transport: otelhttp.NewTransport(http.DefaultTransport,
                        otelhttp.WithSpanOptions(trace.WithSpanKind(trace.SpanKindClient)),
                ),
        }

        // Get concurrency limits from config
        maxConcurrent := cfg.MaxAIConcurrent
        maxPerUser := cfg.MaxAIPerUser

        // Create global semaphore for limiting concurrent requests
        globalSemaphore := make(chan struct{}, maxConcurrent)

        service := &amp;AIService{
                httpClient:       httpClient,
                debug:            cfg.Debug,
                cfg:              cfg,
                templateManager:  templateManager,
                varietyService:   varietyService,
                globalSemaphore:  globalSemaphore,
                maxConcurrent:    maxConcurrent,
                maxPerUser:       maxPerUser,
                userRequestCount: make(map[string]int),
                shutdownCtx:      context.Background(),
                logger:           logger,
        }

        return service</span>
}

// Shutdown gracefully shuts down the AI service and cleans up resources
func (s *AIService) Shutdown(ctx context.Context) error <span class="cov2" title="6">{
        s.shutdownMu.Lock()
        defer s.shutdownMu.Unlock()

        // Create a new shutdown context
        shutdownCtx, cancel := context.WithCancel(ctx)
        s.shutdownCtx = shutdownCtx
        defer cancel()

        // Wait for all active requests to complete with timeout
        timeout := config.AIShutdownTimeout
        if deadline, ok := ctx.Deadline(); ok </span><span class="cov1" title="1">{
                timeout = time.Until(deadline)
        }</span>

        // Wait for active requests to complete
        <span class="cov2" title="6">ticker := time.NewTicker(config.AIShutdownPollInterval)
        defer ticker.Stop()

        for i := 0; i &lt; int(timeout/config.AIShutdownPollInterval); i++ </span><span class="cov2" title="6">{
                s.statsMu.RLock()
                active := s.activeRequests
                s.statsMu.RUnlock()

                if active == 0 </span><span class="cov2" title="6">{
                        break</span>
                }

                <span class="cov0" title="0">select </span>{
                case &lt;-ticker.C:<span class="cov0" title="0">
                        continue</span>
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return ctx.Err()</span>
                }
        }

        // Close the HTTP client
        <span class="cov2" title="6">if s.httpClient != nil </span><span class="cov2" title="6">{
                s.httpClient.CloseIdleConnections()
        }</span>

        // Clean up user request counts
        <span class="cov2" title="6">s.concurrencyMu.Lock()
        s.userRequestCount = make(map[string]int)
        s.concurrencyMu.Unlock()

        s.logger.Info(ctx, "AI Service shutdown completed")
        return nil</span>
}

// isShutdown checks if the service is shutting down
func (s *AIService) isShutdown() bool <span class="cov3" title="15">{
        s.shutdownMu.RLock()
        defer s.shutdownMu.RUnlock()
        select </span>{
        case &lt;-s.shutdownCtx.Done():<span class="cov2" title="3">
                return true</span>
        default:<span class="cov3" title="9">
                return false</span>
        }
}

// OpenAIRequest represents a request to the OpenAI-compatible API
type OpenAIRequest struct {
        Model       string    `json:"model"`
        Messages    []Message `json:"messages"`
        Temperature float64   `json:"temperature"`
        MaxTokens   int       `json:"max_tokens"`
        Grammar     string    `json:"grammar,omitempty"`
        Stream      bool      `json:"stream,omitempty"`
}

// Message represents a chat message in the API request
type Message struct {
        Role    string `json:"role"`
        Content string `json:"content"`
}

// OpenAIResponse represents a response from the OpenAI-compatible API
type OpenAIResponse struct {
        Choices []Choice  `json:"choices"`
        Error   *APIError `json:"error,omitempty"`
}

// Choice represents a choice in the API response
type Choice struct {
        Message Message `json:"message"`
}

// APIError represents an error response from the API
type APIError struct {
        Message string `json:"message"`
        Type    string `json:"type"`
}

// OpenAIStreamResponse represents a streaming response chunk from the OpenAI-compatible API
type OpenAIStreamResponse struct {
        Choices []StreamChoice `json:"choices"`
        Error   *APIError      `json:"error,omitempty"`
}

// StreamChoice represents a choice in the streaming API response
type StreamChoice struct {
        Delta        StreamDelta `json:"delta"`
        FinishReason *string     `json:"finish_reason"`
}

// StreamDelta represents the delta content in a streaming response
type StreamDelta struct {
        Content string `json:"content"`
}

// getGrammarSchema returns the appropriate JSON schema for the given question type
func getGrammarSchema(questionType models.QuestionType) string <span class="cov4" title="30">{
        // Always return the batch schema for each type
        switch questionType </span>{
        case models.ReadingComprehension:<span class="cov2" title="3">
                return BatchReadingComprehensionSchema</span>
        case models.Vocabulary:<span class="cov4" title="21">
                return BatchVocabularyQuestionSchema</span>
        case models.FillInBlank:<span class="cov2" title="3">
                return BatchQuestionsSchema</span>
        case models.QuestionAnswer:<span class="cov2" title="3">
                return BatchQuestionsSchema</span>
        }
        // Fallback for unknown types
        <span class="cov0" title="0">return BatchQuestionsSchema</span>
}

// addJSONStructureGuidance appends JSON structure requirements to prompts for providers that don't support grammar
func (s *AIService) addJSONStructureGuidance(prompt string, questionType models.QuestionType) string <span class="cov2" title="6">{
        // Get the schema for this question type
        schema := getGrammarSchema(questionType)

        data := AITemplateData{
                SchemaForPrompt: schema,
        }

        guidance, err := s.templateManager.RenderTemplate(JSONStructureGuidanceTemplate, data)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error(context.Background(), "Failed to render JSON structure guidance template", err, map[string]interface{}{})
                panic(err)</span>
        }

        <span class="cov2" title="6">return prompt + guidance</span>
}

// GenerateQuestion generates a single question using AI
func (s *AIService) GenerateQuestion(ctx context.Context, userConfig *UserAIConfig, req *models.AIQuestionGenRequest) (result0 *models.Question, err error) <span class="cov2" title="3">{
        ctx, span := observability.TraceAIFunction(ctx, "generate_question",
                attribute.String("user.username", userConfig.Username),
                attribute.String("ai.provider", userConfig.Provider),
                attribute.String("ai.model", userConfig.Model),
                observability.AttributeQuestionType(string(req.QuestionType)),
        )
        defer func() </span><span class="cov2" title="3">{
                if err != nil </span><span class="cov2" title="3">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov2" title="3">span.End()</span>
        }()
        // Check if the provider supports grammar field
        <span class="cov2" title="3">supportsGrammar := s.supportsGrammarField(userConfig.Provider)

        var prompt string
        var grammar string

        if supportsGrammar </span><span class="cov2" title="3">{
                // Use batch prompt with count=1 for single question
                prompt = s.buildBatchQuestionPrompt(ctx, req, nil)
                grammar = getGrammarSchema(req.QuestionType)
        }</span> else<span class="cov0" title="0"> {
                // Use batch prompt with JSON structure guidance embedded
                prompt = s.buildBatchQuestionPromptWithJSONStructure(ctx, req, nil)
                grammar = "" // No grammar field for providers that don't support it
        }</span>

        <span class="cov2" title="3">response, err := s.callOpenAI(ctx, userConfig, prompt, grammar)
        if err != nil </span><span class="cov2" title="3">{
                return nil, err
        }</span>

        <span class="cov0" title="0">question, err := s.parseQuestionResponse(ctx, response, req.Language, req.Level, req.QuestionType, userConfig.Provider)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return question, nil</span>
}

// GenerateQuestions generates multiple questions in a single batch request
func (s *AIService) GenerateQuestions(ctx context.Context, userConfig *UserAIConfig, req *models.AIQuestionGenRequest) (result0 []*models.Question, err error) <span class="cov1" title="1">{
        ctx, span := observability.TraceAIFunction(ctx, "generate_questions",
                attribute.String("user.username", userConfig.Username),
                attribute.String("ai.provider", userConfig.Provider),
                attribute.String("ai.model", userConfig.Model),
                observability.AttributeQuestionType(string(req.QuestionType)),
                observability.AttributeLimit(req.Count),
        )
        defer func() </span><span class="cov1" title="1">{
                if err != nil </span><span class="cov1" title="1">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov1" title="1">span.End()</span>
        }()
        // Check if the provider supports grammar field
        <span class="cov1" title="1">supportsGrammar := s.supportsGrammarField(userConfig.Provider)

        var prompt string
        var grammar string

        if supportsGrammar </span><span class="cov1" title="1">{
                // Use regular prompt with grammar field
                prompt = s.buildBatchQuestionPrompt(ctx, req, nil)
                grammar = getGrammarSchema(req.QuestionType)
        }</span> else<span class="cov0" title="0"> {
                // Use prompt with JSON structure guidance embedded
                prompt = s.buildBatchQuestionPromptWithJSONStructure(ctx, req, nil)
                grammar = "" // No grammar field for providers that don't support it
        }</span>

        <span class="cov1" title="1">response, err := s.callOpenAI(ctx, userConfig, prompt, grammar)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov0" title="0">questions, err := s.parseQuestionsResponse(ctx, response, req.Language, req.Level, req.QuestionType, userConfig.Provider)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return questions, nil</span>
}

// GenerateQuestionsStream generates questions and streams them via a channel, using the provided variety elements
func (s *AIService) GenerateQuestionsStream(ctx context.Context, userConfig *UserAIConfig, req *models.AIQuestionGenRequest, progress chan&lt;- *models.Question, variety *VarietyElements) (err error) <span class="cov1" title="2">{
        ctx, span := observability.TraceAIFunction(ctx, "generate_questions_stream",
                attribute.String("user.username", userConfig.Username),
                attribute.String("ai.provider", userConfig.Provider),
                attribute.String("ai.model", userConfig.Model),
                observability.AttributeQuestionType(string(req.QuestionType)),
                observability.AttributeLimit(req.Count),
        )
        defer func() </span><span class="cov1" title="2">{
                if err != nil </span><span class="cov1" title="2">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov1" title="2">span.End()</span>
        }()
        <span class="cov1" title="2">defer close(progress)

        return s.withConcurrencyControl(ctx, userConfig.Username, func() error </span><span class="cov1" title="2">{
                // Get the batch size for this provider
                batchSize := s.getQuestionBatchSize(userConfig.Provider)
                // Use batch generation for multiple questions
                return s.generateQuestionsInBatchesWithVariety(ctx, userConfig, req, progress, batchSize, variety)
        }</span>)
}

// generateQuestionsInBatchesWithVariety generates questions in batches for efficiency, using the provided variety elements
func (s *AIService) generateQuestionsInBatchesWithVariety(ctx context.Context, userConfig *UserAIConfig, req *models.AIQuestionGenRequest, progress chan&lt;- *models.Question, batchSize int, variety *VarietyElements) (err error) <span class="cov1" title="2">{
        ctx, span := observability.TraceAIFunction(ctx, "generate_questions_in_batches_with_variety",
                attribute.String("ai.provider", userConfig.Provider),
                attribute.String("ai.model", userConfig.Model),
                observability.AttributeQuestionType(req.QuestionType),
                observability.AttributeLanguage(req.Language),
                observability.AttributeLevel(req.Level),
                attribute.Int("batch_size", batchSize),
                attribute.Int("total_count", req.Count),
                attribute.Bool("variety.enabled", variety != nil),
        )
        defer func() </span><span class="cov1" title="2">{
                if err != nil </span><span class="cov1" title="2">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov1" title="2">span.End()</span>
        }()
        // Local copy of history to be updated as we generate questions
        <span class="cov1" title="2">localHistory := make([]string, len(req.RecentQuestionHistory))
        copy(localHistory, req.RecentQuestionHistory)

        remaining := req.Count
        generated := 0

        for remaining &gt; 0 </span><span class="cov1" title="2">{
                // Check for context cancellation
                select </span>{
                case &lt;-ctx.Done():<span class="cov1" title="1">
                        return ctx.Err()</span>
                default:<span class="cov1" title="1"></span>
                }

                // Calculate how many questions to generate in this batch
                <span class="cov1" title="1">currentBatchSize := min(remaining, batchSize)

                // Create a batch request
                batchReq := &amp;models.AIQuestionGenRequest{
                        Language:              req.Language,
                        Level:                 req.Level,
                        QuestionType:          req.QuestionType,
                        Count:                 currentBatchSize,
                        RecentQuestionHistory: localHistory,
                }

                // Generate questions in batch using the provided variety elements
                questions, err := s.generateQuestionsWithVariety(ctx, userConfig, batchReq, variety)
                if err != nil </span><span class="cov1" title="1">{
                        return contextutils.WrapErrorf(err, "failed to generate batch of %d questions", currentBatchSize)
                }</span>

                // Stream the generated questions
                <span class="cov0" title="0">for _, question := range questions </span><span class="cov0" title="0">{
                        // Add generated question content to history for next iterations
                        if qContent, ok := question.Content["question"]; ok </span><span class="cov0" title="0">{
                                if qStr, ok := qContent.(string); ok </span><span class="cov0" title="0">{
                                        localHistory = append(localHistory, qStr)
                                }</span>
                        }

                        <span class="cov0" title="0">progress &lt;- question
                        generated++</span>
                }

                <span class="cov0" title="0">remaining -= len(questions)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// generateQuestionsWithVariety generates a batch of questions using the provided variety elements
func (s *AIService) generateQuestionsWithVariety(ctx context.Context, userConfig *UserAIConfig, req *models.AIQuestionGenRequest, variety *VarietyElements) (result0 []*models.Question, err error) <span class="cov1" title="1">{
        ctx, span := observability.TraceAIFunction(ctx, "generate_questions_with_variety",
                attribute.String("ai.provider", userConfig.Provider),
                attribute.String("ai.model", userConfig.Model),
                observability.AttributeQuestionType(req.QuestionType),
                observability.AttributeLanguage(req.Language),
                observability.AttributeLevel(req.Level),
                attribute.Int("count", req.Count),
                attribute.Bool("variety.enabled", variety != nil),
        )
        defer func() </span><span class="cov1" title="1">{
                if err != nil </span><span class="cov1" title="1">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov1" title="1">span.End()</span>
        }()
        // Check if the provider supports grammar field
        <span class="cov1" title="1">supportsGrammar := s.supportsGrammarField(userConfig.Provider)

        var prompt string
        var grammar string

        if supportsGrammar </span><span class="cov1" title="1">{
                prompt = s.buildBatchQuestionPrompt(ctx, req, variety)
                grammar = getGrammarSchema(req.QuestionType)
        }</span> else<span class="cov0" title="0"> {
                prompt = s.buildBatchQuestionPromptWithJSONStructure(ctx, req, variety)
                grammar = ""
        }</span>

        <span class="cov1" title="1">response, err := s.callOpenAI(ctx, userConfig, prompt, grammar)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov0" title="0">questions, err := s.parseQuestionsResponse(ctx, response, req.Language, req.Level, req.QuestionType, userConfig.Provider)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return questions, nil</span>
}

// GenerateChatResponse generates a chat response using AI
func (s *AIService) GenerateChatResponse(ctx context.Context, userConfig *UserAIConfig, req *models.AIChatRequest) (result0 string, err error) <span class="cov1" title="1">{
        ctx, span := observability.TraceAIFunction(ctx, "generate_chat_response",
                attribute.String("user.username", userConfig.Username),
                attribute.String("ai.provider", userConfig.Provider),
                attribute.String("ai.model", userConfig.Model),
        )
        defer func() </span><span class="cov1" title="1">{
                if err != nil </span><span class="cov1" title="1">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov1" title="1">span.End()</span>
        }()
        <span class="cov1" title="1">var result string
        var resultErr error

        err = s.withConcurrencyControl(ctx, userConfig.Username, func() error </span><span class="cov1" title="1">{
                prompt := s.buildChatPrompt(req)
                // No grammar constraint for open-ended chat
                result, resultErr = s.callOpenAI(ctx, userConfig, prompt, "")
                return resultErr
        }</span>)
        <span class="cov1" title="1">if err != nil </span><span class="cov1" title="1">{
                return "", err
        }</span>
        <span class="cov0" title="0">return result, resultErr</span>
}

// GenerateChatResponseStream generates a streaming chat response using AI
func (s *AIService) GenerateChatResponseStream(ctx context.Context, userConfig *UserAIConfig, req *models.AIChatRequest, chunks chan&lt;- string) (err error) <span class="cov1" title="2">{
        ctx, span := observability.TraceAIFunction(ctx, "generate_chat_response_stream",
                attribute.String("user.username", userConfig.Username),
                attribute.String("ai.provider", userConfig.Provider),
                attribute.String("ai.model", userConfig.Model),
        )
        defer func() </span><span class="cov1" title="2">{
                if err != nil </span><span class="cov1" title="2">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov1" title="2">span.End()</span>
        }()
        // Don't close the channel here - let the caller handle it to avoid race conditions

        <span class="cov1" title="2">return s.withConcurrencyControl(ctx, userConfig.Username, func() error </span><span class="cov1" title="1">{
                prompt := s.buildChatPrompt(req)
                // No grammar constraint for open-ended chat
                return s.callOpenAIStream(ctx, userConfig, prompt, "", chunks)
        }</span>)
}

// TestConnection tests the connection to the AI service
func (s *AIService) TestConnection(ctx context.Context, provider, model, apiKey string) (err error) <span class="cov2" title="3">{
        _, span := observability.TraceAIFunction(ctx, "test_connection",
                attribute.String("ai.provider", provider),
                attribute.String("ai.model", model),
        )
        defer func() </span><span class="cov2" title="3">{
                if err != nil </span><span class="cov2" title="3">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov2" title="3">span.End()</span>
        }()

        // Validate input parameters
        <span class="cov2" title="3">if provider == "" </span><span class="cov0" title="0">{
                span.SetAttributes(attribute.String("test.result", "empty_provider"))
                return contextutils.WrapError(contextutils.ErrAIConfigInvalid, "provider is required for testing connection")
        }</span>

        <span class="cov2" title="3">if model == "" </span><span class="cov0" title="0">{
                span.SetAttributes(attribute.String("test.result", "empty_model"))
                return contextutils.WrapError(contextutils.ErrAIConfigInvalid, "model is required for testing connection")
        }</span>

        <span class="cov2" title="3">s.logger.Debug(ctx, "TestConnection called", map[string]interface{}{
                "provider": provider,
                "model":    model,
                "apiKey":   contextutils.MaskAPIKey(apiKey),
        })

        // Require API key for all providers that are not Ollama
        if provider != "ollama" &amp;&amp; apiKey == "" </span><span class="cov1" title="1">{
                span.SetAttributes(attribute.String("test.result", "missing_api_key"), attribute.String("provider", provider))
                return contextutils.WrapErrorf(contextutils.ErrAIConfigInvalid, "API key is required for testing connection with provider '%s'", provider)
        }</span>

        // Create a simple test configuration
        <span class="cov1" title="2">userConfig := &amp;UserAIConfig{
                Provider: provider,
                Model:    model,
                APIKey:   apiKey,
                Username: "test-user",
        }

        s.logger.Debug(ctx, "Created userConfig", map[string]interface{}{
                "provider": userConfig.Provider,
                "model":    userConfig.Model,
        })

        // Create a simple test request
        testPrompt := "Respond with exactly the word 'SUCCESS' and nothing else."

        // Create a timeout context for the test
        testCtx, cancel := context.WithTimeout(ctx, config.AIRequestTimeout)
        defer cancel()

        // Test the actual AI service call
        response, err := s.callOpenAI(testCtx, userConfig, testPrompt, "")
        if err != nil </span><span class="cov1" title="2">{
                span.SetAttributes(attribute.String("test.result", "call_failed"), attribute.String("error", err.Error()))
                return contextutils.WrapErrorf(err, "connection test failed for provider '%s' with model '%s'", provider, model)
        }</span>

        // Check if we got a reasonable response
        <span class="cov0" title="0">if response == "" </span><span class="cov0" title="0">{
                span.SetAttributes(attribute.String("test.result", "empty_response"))
                return contextutils.WrapError(contextutils.ErrAIResponseInvalid, "connection test failed: received empty response from AI service")
        }</span>

        // Validate that the response contains something meaningful
        <span class="cov0" title="0">if len(response) &lt; 3 </span><span class="cov0" title="0">{
                span.SetAttributes(attribute.String("test.result", "response_too_short"), attribute.Int("response_length", len(response)))
                return contextutils.WrapErrorf(contextutils.ErrAIResponseInvalid, "connection test failed: response too short (%d characters)", len(response))
        }</span>

        // The response should contain something meaningful
        <span class="cov0" title="0">s.logger.Info(ctx, "TestConnection successful", map[string]interface{}{
                "provider":        provider,
                "response_length": len(response),
        })
        span.SetAttributes(attribute.String("test.result", "success"), attribute.Int("response_length", len(response)))
        return nil</span>
}

// buildBatchQuestionPromptWithJSONStructure now takes variety elements
func (s *AIService) buildBatchQuestionPromptWithJSONStructure(ctx context.Context, req *models.AIQuestionGenRequest, variety *VarietyElements) string <span class="cov1" title="2">{
        prompt := s.buildBatchQuestionPrompt(ctx, req, variety)
        return s.addJSONStructureGuidance(prompt, req.QuestionType)
}</span>

// buildBatchQuestionPrompt now takes variety elements
func (s *AIService) buildBatchQuestionPrompt(ctx context.Context, req *models.AIQuestionGenRequest, variety *VarietyElements) string <span class="cov3" title="11">{
        _, span := observability.TraceAIFunction(ctx, "build_batch_question_prompt",
                observability.AttributeQuestionType(req.QuestionType),
                observability.AttributeLanguage(req.Language),
                observability.AttributeLevel(req.Level),
                attribute.Int("count", req.Count),
                attribute.Bool("variety.enabled", variety != nil),
        )
        defer span.End()
        tmplData := AITemplateData{
                SchemaForPrompt:       getGrammarSchema(req.QuestionType),
                Language:              req.Language,
                Level:                 req.Level,
                QuestionType:          string(req.QuestionType),
                Count:                 req.Count,
                RecentQuestionHistory: req.RecentQuestionHistory,
        }
        if variety != nil </span><span class="cov2" title="4">{
                tmplData.TopicCategory = variety.TopicCategory
                tmplData.GrammarFocus = variety.GrammarFocus
                tmplData.VocabularyDomain = variety.VocabularyDomain
                tmplData.Scenario = variety.Scenario
                tmplData.StyleModifier = variety.StyleModifier
                tmplData.DifficultyModifier = variety.DifficultyModifier
                tmplData.TimeContext = variety.TimeContext
        }</span>

        // Priority data is handled by the worker, not passed to AI service

        // Load example for this question type
        <span class="cov3" title="11">if exampleContent, err := s.templateManager.LoadExample(string(req.QuestionType)); err == nil </span><span class="cov3" title="11">{
                tmplData.ExampleContent = exampleContent
        }</span>

        <span class="cov3" title="11">prompt, err := s.templateManager.RenderTemplate(BatchQuestionPromptTemplate, tmplData)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error(ctx, "Failed to render batch question prompt template", err, map[string]interface{}{})
                panic(err)</span> // Use panic for fatal errors in template rendering
        }

        <span class="cov3" title="11">return prompt</span>
}

func (s *AIService) buildChatPrompt(req *models.AIChatRequest) string <span class="cov2" title="3">{
        // Convert conversation history to template format
        var conversationHistory []ChatMessage
        for _, msg := range req.ConversationHistory </span><span class="cov0" title="0">{
                conversationHistory = append(conversationHistory, ChatMessage{
                        Role:    string(msg.Role),
                        Content: msg.Content,
                })
        }</span>

        <span class="cov2" title="3">data := AITemplateData{
                Language:            req.Language,
                Level:               req.Level,
                Passage:             req.Passage,
                Question:            req.Question,
                Options:             req.Options,
                IsCorrect:           req.IsCorrect,
                ConversationHistory: conversationHistory,
                UserMessage:         req.UserMessage,
        }

        prompt, err := s.templateManager.RenderTemplate(ChatPromptTemplate, data)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error(context.Background(), "Failed to render chat prompt template", err, map[string]interface{}{})
                panic(err)</span> // Use panic for fatal errors in template rendering
        }

        <span class="cov2" title="3">return prompt</span>
}

// getMaxTokensForModel looks up the max_tokens for a specific provider and model
func (s *AIService) getMaxTokensForModel(provider, model string) int <span class="cov3" title="9">{
        // Look up the model in the provider configuration
        if s.cfg.AppConfig != nil </span><span class="cov3" title="9">{
                for _, providerConfig := range s.cfg.AppConfig.Providers </span><span class="cov3" title="10">{
                        if providerConfig.Code == provider </span><span class="cov2" title="5">{
                                for _, modelConfig := range providerConfig.Models </span><span class="cov0" title="0">{
                                        if modelConfig.Code == model </span><span class="cov0" title="0">{
                                                if modelConfig.MaxTokens &gt; 0 </span><span class="cov0" title="0">{
                                                        return modelConfig.MaxTokens
                                                }</span>
                                                <span class="cov0" title="0">break</span>
                                        }
                                }
                                <span class="cov2" title="5">break</span>
                        }
                }
        }

        // Default fallback
        <span class="cov3" title="9">return 4000</span>
}

// callOpenAI makes a request to the OpenAI-compatible API
func (s *AIService) callOpenAI(ctx context.Context, userConfig *UserAIConfig, prompt, grammar string) (result0 string, err error) <span class="cov3" title="8">{
        if userConfig == nil </span><span class="cov0" title="0">{
                return "", contextutils.WrapError(contextutils.ErrAIConfigInvalid, "userConfig is required")
        }</span>
        <span class="cov3" title="8">_, span := observability.TraceAIFunction(ctx, "call_openai",
                attribute.String("ai.provider", userConfig.Provider),
                attribute.String("ai.model", userConfig.Model),
                attribute.String("ai.username", userConfig.Username),
                attribute.Int("prompt.length", len(prompt)),
                attribute.Bool("grammar.enabled", grammar != ""),
        )
        defer func() </span><span class="cov3" title="8">{
                if err != nil </span><span class="cov3" title="8">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov3" title="8">span.End()</span>
        }()

        // Validate input parameters
        <span class="cov3" title="8">if userConfig.Provider == "" </span><span class="cov0" title="0">{
                span.SetAttributes(attribute.String("call.result", "empty_provider"))
                return "", contextutils.WrapError(contextutils.ErrAIConfigInvalid, "provider is required")
        }</span>

        <span class="cov3" title="8">if userConfig.Model == "" </span><span class="cov0" title="0">{
                span.SetAttributes(attribute.String("call.result", "empty_model"))
                return "", contextutils.WrapError(contextutils.ErrAIConfigInvalid, "model is required")
        }</span>

        <span class="cov3" title="8">if prompt == "" </span><span class="cov0" title="0">{
                span.SetAttributes(attribute.String("call.result", "empty_prompt"))
                return "", contextutils.WrapError(contextutils.ErrAIConfigInvalid, "prompt cannot be empty")
        }</span>

        <span class="cov3" title="8">apiURL := ""
        model := userConfig.Model
        apiKey := userConfig.APIKey

        // Look up the default URL from provider config
        if s.cfg.AppConfig != nil </span><span class="cov3" title="8">{
                for _, providerConfig := range s.cfg.AppConfig.Providers </span><span class="cov3" title="8">{
                        if providerConfig.Code == userConfig.Provider &amp;&amp; providerConfig.URL != "" </span><span class="cov2" title="4">{
                                apiURL = providerConfig.URL
                                break</span>
                        }
                }
        }

        <span class="cov3" title="8">if apiURL == "" </span><span class="cov2" title="4">{
                span.SetAttributes(attribute.String("call.result", "no_url_configured"), attribute.String("provider", userConfig.Provider))
                return "", contextutils.WrapErrorf(contextutils.ErrAIConfigInvalid, "no base URL configured for provider '%s'", userConfig.Provider)
        }</span>

        <span class="cov2" title="4">userPrefix := ""
        if userConfig.Username != "" </span><span class="cov0" title="0">{
                userPrefix = fmt.Sprintf("[user=%s] ", userConfig.Username)
        }</span>

        <span class="cov2" title="4">s.logger.Debug(ctx, "Starting AI request", map[string]interface{}{
                "user_prefix": userPrefix,
                "url":         apiURL + "/chat/completions",
                "model":       model,
                "provider":    userConfig.Provider,
        })

        // Create messages with just the user prompt - grammar field will enforce JSON structure
        messages := []Message{{Role: "user", Content: prompt}}

        // Check if the provider supports grammar field
        supportsGrammar := s.supportsGrammarField(userConfig.Provider)

        reqBody := OpenAIRequest{
                Model:       model,
                Messages:    messages,
                Temperature: 0.7,
                MaxTokens:   s.getMaxTokensForModel(userConfig.Provider, userConfig.Model),
        }

        // Only include grammar field if the provider supports it
        if supportsGrammar &amp;&amp; grammar != "" </span><span class="cov2" title="4">{
                reqBody.Grammar = grammar
        }</span>

        <span class="cov2" title="4">jsonData, err := json.Marshal(reqBody)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error(ctx, "Failed to marshal AI request", err, map[string]interface{}{
                        "user_prefix": userPrefix,
                })
                span.SetAttributes(attribute.String("call.result", "marshal_failed"), attribute.String("error", err.Error()))
                return "", contextutils.WrapErrorf(err, "failed to marshal request body")
        }</span>

        <span class="cov2" title="4">s.logger.Debug(ctx, "Making AI HTTP request", map[string]interface{}{
                "user_prefix": userPrefix,
                "url":         apiURL + "/chat/completions",
        })
        req, err := http.NewRequestWithContext(ctx, "POST", apiURL+"/chat/completions", bytes.NewBuffer(jsonData))
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error(ctx, "Failed to create AI HTTP request", err, map[string]interface{}{
                        "user_prefix": userPrefix,
                })
                span.SetAttributes(attribute.String("call.result", "request_creation_failed"), attribute.String("error", err.Error()))
                return "", contextutils.WrapErrorf(err, "failed to create HTTP request")
        }</span>

        <span class="cov2" title="4">req.Header.Set("Content-Type", "application/json")
        if apiKey != "" </span><span class="cov0" title="0">{
                req.Header.Set("Authorization", "Bearer "+apiKey)
                s.logger.Debug(ctx, "Using API key authentication", map[string]interface{}{
                        "user_prefix": userPrefix,
                })
        }</span> else<span class="cov2" title="4"> {
                s.logger.Debug(ctx, "No API key provided, using anonymous access", map[string]interface{}{
                        "user_prefix": userPrefix,
                })
        }</span>

        <span class="cov2" title="4">startTime := time.Now()
        resp, err := s.httpClient.Do(req.WithContext(ctx))
        duration := time.Since(startTime)

        if err != nil </span><span class="cov1" title="1">{
                s.logger.Error(ctx, "AI HTTP request failed", err, map[string]interface{}{
                        "user_prefix": userPrefix,
                        "duration":    duration.String(),
                })
                span.SetAttributes(attribute.String("call.result", "http_request_failed"), attribute.String("error", err.Error()), attribute.String("duration", duration.String()))
                return "", contextutils.WrapErrorf(err, "HTTP request failed after %v", duration)
        }</span>
        <span class="cov2" title="3">defer func() </span><span class="cov2" title="3">{
                if err := resp.Body.Close(); err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn(ctx, "Failed to close response body", map[string]interface{}{
                                "error": err.Error(),
                        })
                }</span>
        }()

        <span class="cov2" title="3">s.logger.Info(ctx, "AI Service HTTP request completed", map[string]interface{}{
                "user_prefix": userPrefix,
                "duration":    duration.String(),
                "status_code": resp.StatusCode,
        })

        body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                span.SetAttributes(attribute.String("call.result", "body_read_failed"), attribute.String("error", err.Error()))
                return "", contextutils.WrapErrorf(err, "failed to read response body")
        }</span>

        <span class="cov2" title="3">if resp.StatusCode != http.StatusOK </span><span class="cov1" title="1">{
                span.SetAttributes(attribute.String("call.result", "http_error"), attribute.Int("status_code", resp.StatusCode), attribute.String("body", string(body)))
                return "", contextutils.WrapErrorf(contextutils.ErrAIRequestFailed, "API request failed with status %d to %s: %s", resp.StatusCode, apiURL+"/chat/completions", string(body))
        }</span>

        <span class="cov1" title="2">var openAIResp OpenAIResponse
        if err := json.Unmarshal(body, &amp;openAIResp); err != nil </span><span class="cov1" title="1">{
                span.SetAttributes(attribute.String("call.result", "json_unmarshal_failed"), attribute.String("error", err.Error()), attribute.String("body", string(body)))
                return "", contextutils.WrapErrorf(contextutils.ErrAIResponseInvalid, "failed to parse AI response as JSON: %w. Raw Response: %s", err, string(body))
        }</span>

        <span class="cov1" title="1">if openAIResp.Error != nil </span><span class="cov0" title="0">{
                span.SetAttributes(attribute.String("call.result", "api_error"), attribute.String("error_message", openAIResp.Error.Message), attribute.String("error_type", openAIResp.Error.Type))
                return "", contextutils.WrapErrorf(contextutils.ErrAIRequestFailed, "OpenAI API error: %s", openAIResp.Error.Message)
        }</span>

        <span class="cov1" title="1">if len(openAIResp.Choices) == 0 </span><span class="cov1" title="1">{
                span.SetAttributes(attribute.String("call.result", "no_choices"))
                return "", contextutils.WrapError(contextutils.ErrAIResponseInvalid, "no response from OpenAI")
        }</span>

        <span class="cov0" title="0">content := openAIResp.Choices[0].Message.Content
        if content == "" </span><span class="cov0" title="0">{
                span.SetAttributes(attribute.String("call.result", "empty_content"))
                return "", contextutils.WrapError(contextutils.ErrAIResponseInvalid, "OpenAI returned empty content")
        }</span>

        <span class="cov0" title="0">span.SetAttributes(attribute.String("call.result", "success"), attribute.Int("content_length", len(content)), attribute.String("duration", duration.String()))
        return content, nil</span>
}

// callOpenAIStream makes a streaming request to the OpenAI-compatible API
func (s *AIService) callOpenAIStream(ctx context.Context, userConfig *UserAIConfig, prompt, grammar string, chunks chan&lt;- string) error <span class="cov1" title="1">{
        if userConfig == nil </span><span class="cov0" title="0">{
                return contextutils.WrapError(contextutils.ErrAIConfigInvalid, "userConfig is required")
        }</span>
        <span class="cov1" title="1">_, span := observability.TraceAIFunction(ctx, "call_openai_stream",
                attribute.String("ai.provider", userConfig.Provider),
                attribute.String("ai.model", userConfig.Model),
                attribute.String("ai.username", userConfig.Username),
                attribute.Int("prompt.length", len(prompt)),
                attribute.Bool("grammar.enabled", grammar != ""),
        )
        defer span.End()

        // Validate input parameters
        if userConfig.Provider == "" </span><span class="cov0" title="0">{
                span.SetAttributes(attribute.String("stream.result", "empty_provider"))
                return contextutils.WrapError(contextutils.ErrAIConfigInvalid, "provider is required")
        }</span>

        <span class="cov1" title="1">if userConfig.Model == "" </span><span class="cov0" title="0">{
                span.SetAttributes(attribute.String("stream.result", "empty_model"))
                return contextutils.WrapError(contextutils.ErrAIConfigInvalid, "model is required")
        }</span>

        <span class="cov1" title="1">if prompt == "" </span><span class="cov0" title="0">{
                span.SetAttributes(attribute.String("stream.result", "empty_prompt"))
                return contextutils.WrapError(contextutils.ErrAIConfigInvalid, "prompt cannot be empty")
        }</span>

        <span class="cov1" title="1">if chunks == nil </span><span class="cov0" title="0">{
                span.SetAttributes(attribute.String("stream.result", "nil_chunks_channel"))
                return contextutils.WrapError(contextutils.ErrAIConfigInvalid, "chunks channel is required")
        }</span>

        <span class="cov1" title="1">apiURL := ""
        model := userConfig.Model
        apiKey := userConfig.APIKey

        // Look up the default URL from provider config
        if s.cfg.AppConfig != nil </span><span class="cov1" title="1">{
                for _, providerConfig := range s.cfg.AppConfig.Providers </span><span class="cov1" title="2">{
                        if providerConfig.Code == userConfig.Provider &amp;&amp; providerConfig.URL != "" </span><span class="cov1" title="1">{
                                apiURL = providerConfig.URL
                                break</span>
                        }
                }
        }

        <span class="cov1" title="1">if apiURL == "" </span><span class="cov0" title="0">{
                span.SetAttributes(attribute.String("stream.result", "no_url_configured"), attribute.String("provider", userConfig.Provider))
                return contextutils.WrapErrorf(contextutils.ErrAIConfigInvalid, "no base URL configured for provider '%s'", userConfig.Provider)
        }</span>

        <span class="cov1" title="1">userPrefix := ""
        if userConfig.Username != "" </span><span class="cov1" title="1">{
                userPrefix = fmt.Sprintf("[user=%s] ", userConfig.Username)
        }</span>

        <span class="cov1" title="1">s.logger.Info(ctx, "AI Service Starting streaming request", map[string]interface{}{
                "user_prefix": userPrefix,
                "api_url":     apiURL + "/chat/completions",
                "model":       model,
                "provider":    userConfig.Provider,
        })

        // Create messages with just the user prompt - grammar field will enforce JSON structure
        messages := []Message{{Role: "user", Content: prompt}}

        // Check if the provider supports grammar field
        supportsGrammar := s.supportsGrammarField(userConfig.Provider)

        reqBody := OpenAIRequest{
                Model:       model,
                Messages:    messages,
                Temperature: 0.7,
                MaxTokens:   s.getMaxTokensForModel(userConfig.Provider, userConfig.Model),
                Stream:      true, // Enable streaming
        }

        // Only include grammar field if the provider supports it
        if supportsGrammar &amp;&amp; grammar != "" </span><span class="cov0" title="0">{
                reqBody.Grammar = grammar
        }</span>

        <span class="cov1" title="1">jsonData, err := json.Marshal(reqBody)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error(ctx, "Failed to marshal request", err, map[string]interface{}{
                        "user_prefix": userPrefix,
                })
                span.SetAttributes(attribute.String("stream.result", "marshal_failed"), attribute.String("error", err.Error()))
                return contextutils.WrapErrorf(err, "failed to marshal streaming request body")
        }</span>

        <span class="cov1" title="1">s.logger.Info(ctx, "AI Service Making streaming HTTP request", map[string]interface{}{
                "user_prefix": userPrefix,
                "api_url":     apiURL + "/chat/completions",
        })
        req, err := http.NewRequestWithContext(ctx, "POST", apiURL+"/chat/completions", bytes.NewBuffer(jsonData))
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error(ctx, "Failed to create HTTP request", err, map[string]interface{}{
                        "user_prefix": userPrefix,
                })
                span.SetAttributes(attribute.String("stream.result", "request_creation_failed"), attribute.String("error", err.Error()))
                return contextutils.WrapErrorf(err, "failed to create streaming HTTP request")
        }</span>

        <span class="cov1" title="1">req.Header.Set("Content-Type", "application/json")
        req.Header.Set("Accept", "text/event-stream")
        req.Header.Set("Cache-Control", "no-cache")
        if apiKey != "" </span><span class="cov1" title="1">{
                req.Header.Set("Authorization", "Bearer "+apiKey)
                s.logger.Info(ctx, "AI Service Using API key authentication", map[string]interface{}{
                        "user_prefix": userPrefix,
                })
        }</span> else<span class="cov0" title="0"> {
                s.logger.Info(ctx, "AI Service No API key provided, using anonymous access", map[string]interface{}{
                        "user_prefix": userPrefix,
                })
        }</span>

        <span class="cov1" title="1">startTime := time.Now()
        resp, err := s.httpClient.Do(req.WithContext(ctx))
        if err != nil </span><span class="cov1" title="1">{
                s.logger.Error(ctx, "HTTP request failed", err, map[string]interface{}{
                        "user_prefix": userPrefix,
                })
                span.SetAttributes(attribute.String("stream.result", "http_request_failed"), attribute.String("error", err.Error()))
                return contextutils.WrapErrorf(contextutils.ErrAIRequestFailed, "http client error: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := resp.Body.Close(); err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn(ctx, "Failed to close response body", map[string]interface{}{
                                "error": err.Error(),
                        })
                }</span>
        }()

        <span class="cov0" title="0">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                span.SetAttributes(attribute.String("stream.result", "http_error"), attribute.Int("status_code", resp.StatusCode), attribute.String("body", string(body)))
                return contextutils.WrapErrorf(contextutils.ErrAIRequestFailed, "API request failed with status %d to %s: %s", resp.StatusCode, apiURL+"/chat/completions", string(body))
        }</span>

        <span class="cov0" title="0">s.logger.Info(ctx, "AI Service Streaming response started", map[string]interface{}{
                "user_prefix": userPrefix,
                "duration":    time.Since(startTime).String(),
        })

        // Read the streaming response
        scanner := bufio.NewScanner(resp.Body)
        var chunkCount int
        var totalContentLength int

        for scanner.Scan() </span><span class="cov0" title="0">{
                line := scanner.Text()

                // Skip empty lines and comments
                if line == "" || strings.HasPrefix(line, ":") </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Parse Server-Sent Events format
                <span class="cov0" title="0">if strings.HasPrefix(line, "data: ") </span><span class="cov0" title="0">{
                        data := strings.TrimPrefix(line, "data: ")

                        // Check for end of stream
                        if data == "[DONE]" </span><span class="cov0" title="0">{
                                break</span>
                        }

                        // Parse the JSON chunk
                        <span class="cov0" title="0">var streamResp OpenAIStreamResponse
                        if err := json.Unmarshal([]byte(data), &amp;streamResp); err != nil </span><span class="cov0" title="0">{
                                s.logger.Warn(ctx, "AI Service WARNING: Failed to parse streaming chunk", map[string]interface{}{
                                        "error": err.Error(),
                                        "data":  data,
                                })
                                span.SetAttributes(attribute.String("stream.result", "chunk_parse_failed"), attribute.String("error", err.Error()), attribute.String("data", data))
                                continue</span>
                        }

                        <span class="cov0" title="0">if streamResp.Error != nil </span><span class="cov0" title="0">{
                                span.SetAttributes(attribute.String("stream.result", "api_streaming_error"), attribute.String("error_message", streamResp.Error.Message), attribute.String("error_type", streamResp.Error.Type))
                                return contextutils.WrapErrorf(contextutils.ErrAIRequestFailed, "OpenAI API streaming error: %s", streamResp.Error.Message)
                        }</span>

                        // Extract content from the chunk
                        <span class="cov0" title="0">if len(streamResp.Choices) &gt; 0 &amp;&amp; streamResp.Choices[0].Delta.Content != "" </span><span class="cov0" title="0">{
                                content := streamResp.Choices[0].Delta.Content
                                totalContentLength += len(content)

                                // Filter out thinking content for thinking models
                                filteredContent := s.filterThinkingContent(content, model)

                                if filteredContent != "" </span><span class="cov0" title="0">{
                                        select </span>{
                                        case chunks &lt;- filteredContent:<span class="cov0" title="0">
                                                chunkCount++</span>
                                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                                span.SetAttributes(attribute.String("stream.result", "context_cancelled"))
                                                return ctx.Err()</span>
                                        }
                                }
                        }

                        // Check if streaming is finished
                        <span class="cov0" title="0">if len(streamResp.Choices) &gt; 0 &amp;&amp; streamResp.Choices[0].FinishReason != nil </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
        }

        <span class="cov0" title="0">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                span.SetAttributes(attribute.String("stream.result", "scanner_error"), attribute.String("error", err.Error()))
                return contextutils.WrapErrorf(contextutils.ErrAIRequestFailed, "error reading streaming response: %w", err)
        }</span>

        <span class="cov0" title="0">s.logger.Info(ctx, "AI Service Streaming response completed", map[string]interface{}{
                "user_prefix":          userPrefix,
                "duration":             time.Since(startTime).String(),
                "chunk_count":          chunkCount,
                "total_content_length": totalContentLength,
        })
        span.SetAttributes(attribute.String("stream.result", "success"), attribute.Int("chunk_count", chunkCount), attribute.Int("total_content_length", totalContentLength), attribute.String("duration", time.Since(startTime).String()))
        return nil</span>
}

// filterThinkingContent filters out thinking sections for reasoning models
func (s *AIService) filterThinkingContent(content, model string) string <span class="cov2" title="3">{
        // Check if this is a thinking/reasoning model
        if !s.isThinkingModel(model) </span><span class="cov1" title="1">{
                return content
        }</span>

        // For thinking models, filter out content between &lt;thinking&gt; tags
        <span class="cov1" title="2">if strings.Contains(content, "&lt;thinking&gt;") || strings.Contains(content, "&lt;/thinking&gt;") </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov1" title="2">if idx := strings.Index(content, "The answer is:"); idx != -1 </span><span class="cov1" title="1">{
                answer := content[idx+len("The answer is:"):]
                lines := strings.Split(answer, "\n")
                for _, line := range lines </span><span class="cov1" title="1">{
                        trimmed := strings.TrimSpace(line)
                        if trimmed != "" </span><span class="cov1" title="1">{
                                return trimmed
                        }</span>
                }
                <span class="cov0" title="0">return ""</span>
        }

        <span class="cov1" title="1">trimmed := strings.TrimSpace(content)
        if strings.HasPrefix(trimmed, "I need to") ||
                strings.HasPrefix(trimmed, "Let me think") ||
                strings.HasPrefix(trimmed, "First, I'll") </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov1" title="1">return content</span>
}

// isThinkingModel checks if the model is a reasoning/thinking model
func (s *AIService) isThinkingModel(model string) bool <span class="cov3" title="9">{
        thinkingModels := []string{
                "o1-preview",
                "o1-mini",
                "o1",
                "qwen2.5-coder:32b",
                "deepseek-r1",
                "marco-o1",
                "gpt-4",
                "gpt-4-turbo",
                "claude-3",
        }

        modelLower := strings.ToLower(model)
        for _, thinkingModel := range thinkingModels </span><span class="cov5" title="73">{
                if strings.Contains(modelLower, strings.ToLower(thinkingModel)) </span><span class="cov2" title="5">{
                        return true
                }</span>
        }

        <span class="cov2" title="4">return false</span>
}

// cleanJSONResponse extracts JSON from markdown code blocks or returns the original response
func (s *AIService) cleanJSONResponse(ctx context.Context, response, provider string) string <span class="cov4" title="43">{
        _, span := observability.TraceAIFunction(ctx, "clean_json_response",
                attribute.String("ai.provider", provider),
                attribute.Int("response.length", len(response)),
        )
        defer span.End()
        // If the provider supports grammar field, we expect clean JSON
        if s.supportsGrammarField(provider) </span><span class="cov4" title="35">{
                return response
        }</span>

        // For providers that don't support grammar field, clean up markdown code blocks
        <span class="cov2" title="4">response = strings.TrimSpace(response)

        // Remove markdown code block markers
        if strings.HasPrefix(response, "```json") </span><span class="cov1" title="2">{
                response = strings.TrimPrefix(response, "```json")
                response = strings.TrimSuffix(response, "```")
        }</span> else<span class="cov1" title="2"> if strings.HasPrefix(response, "```") </span><span class="cov1" title="1">{
                response = strings.TrimPrefix(response, "```")
                response = strings.TrimSuffix(response, "```")
        }</span>

        <span class="cov2" title="4">return strings.TrimSpace(response)</span>
}

func (s *AIService) parseQuestionsResponse(ctx context.Context, response, language, level string, qType models.QuestionType, provider string) (result0 []*models.Question, err error) <span class="cov3" title="17">{
        if s == nil </span><span class="cov1" title="1">{
                return nil, contextutils.WrapError(contextutils.ErrInternalError, "AIService instance is nil")
        }</span>
        <span class="cov3" title="16">_, span := observability.TraceAIFunction(ctx, "parse_questions_response",
                observability.AttributeQuestionType(qType),
                observability.AttributeLanguage(language),
                observability.AttributeLevel(level),
                attribute.String("ai.provider", provider),
                attribute.Int("response.length", len(response)),
        )
        defer func() </span><span class="cov3" title="16">{
                if err != nil </span><span class="cov3" title="10">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov3" title="16">span.End()</span>
        }()
        <span class="cov3" title="16">defer func() </span><span class="cov3" title="16">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        s.logger.Error(ctx, "PANIC in parseQuestionsResponse", nil, map[string]interface{}{
                                "panic":    fmt.Sprintf("%v", r),
                                "response": response,
                                "stack":    string(debug.Stack()),
                        })
                        span.SetAttributes(attribute.String("parse.result", "panic"), attribute.String("panic", fmt.Sprintf("%v", r)))
                }</span>
        }()

        // Validate input parameters
        <span class="cov3" title="16">if response == "" </span><span class="cov1" title="1">{
                span.SetAttributes(attribute.String("parse.result", "empty_response"))
                return nil, contextutils.WrapError(contextutils.ErrAIResponseInvalid, "AI provider returned empty response")
        }</span>
        <span class="cov3" title="15">if language == "" </span><span class="cov0" title="0">{
                span.SetAttributes(attribute.String("parse.result", "empty_language"))
                return nil, contextutils.WrapError(contextutils.ErrAIResponseInvalid, "language cannot be empty")
        }</span>
        <span class="cov3" title="15">if level == "" </span><span class="cov0" title="0">{
                span.SetAttributes(attribute.String("parse.result", "empty_level"))
                return nil, contextutils.WrapError(contextutils.ErrAIResponseInvalid, "level cannot be empty")
        }</span>

        // Clean the response to handle markdown code blocks for providers without grammar support
        <span class="cov3" title="15">cleanedResponse := s.cleanJSONResponse(ctx, response, provider)

        if cleanedResponse == "" </span><span class="cov0" title="0">{
                span.SetAttributes(attribute.String("parse.result", "empty_cleaned_response"))
                return nil, contextutils.WrapError(contextutils.ErrAIResponseInvalid, "AI provider returned empty response after cleaning")
        }</span>

        // With grammar field enforcement, we should get clean JSON directly
        // No need for complex extraction - just parse the response directly
        <span class="cov3" title="15">var questions []map[string]interface{}
        if err := json.Unmarshal([]byte(cleanedResponse), &amp;questions); err != nil </span><span class="cov1" title="1">{
                span.SetAttributes(attribute.String("parse.result", "json_unmarshal_failed"), attribute.String("error", err.Error()))
                return nil, contextutils.WrapErrorf(contextutils.ErrAIResponseInvalid, "failed to parse AI response as JSON: %w", err)
        }</span>

        <span class="cov3" title="14">if len(questions) == 0 </span><span class="cov1" title="1">{
                span.SetAttributes(attribute.String("parse.result", "no_questions_in_response"))
                return nil, contextutils.WrapError(contextutils.ErrAIResponseInvalid, "AI provider returned no questions in response")
        }</span>

        <span class="cov3" title="13">var result []*models.Question
        var validationErrors []string
        var skippedCount int

        for i, qData := range questions </span><span class="cov7" title="1018">{
                if qData == nil </span><span class="cov2" title="3">{
                        skippedCount++
                        span.SetAttributes(attribute.String("parse.result", "nil_question_data"), attribute.Int("question_index", i))
                        continue</span>
                }

                <span class="cov7" title="1015">question, err := s.createQuestionFromData(ctx, qData, language, level, qType)
                if err != nil </span><span class="cov3" title="9">{
                        // Try to extract more info about the failure
                        var failedField, failedValue string
                        for k, v := range qData </span><span class="cov4" title="53">{
                                if v == nil || v == "" </span><span class="cov1" title="2">{
                                        failedField = k
                                        failedValue = fmt.Sprintf("%v", v)
                                        break</span>
                                }
                        }
                        <span class="cov3" title="9">validationErrors = append(validationErrors, fmt.Sprintf("question %d: %v (field: %s, value: %s)", i+1, err, failedField, failedValue))
                        span.SetAttributes(attribute.String("parse.result", "question_creation_failed"), attribute.Int("question_index", i), attribute.String("error", err.Error()))
                        continue</span>
                }

                <span class="cov7" title="1006">if question == nil </span><span class="cov0" title="0">{
                        skippedCount++
                        span.SetAttributes(attribute.String("parse.result", "nil_question_after_creation"), attribute.Int("question_index", i))
                        continue</span>
                }

                // Coerce correct_answer to int if it's a float64 (for schema validation)
                <span class="cov7" title="1006">if m := question.Content; m != nil </span><span class="cov7" title="1006">{
                        if v, ok := m["correct_answer"]; ok </span><span class="cov7" title="1006">{
                                switch val := v.(type) </span>{
                                case float64:<span class="cov0" title="0">
                                        m["correct_answer"] = int(val)</span>
                                }
                        }
                }

                <span class="cov7" title="1006">valid, err := s.ValidateQuestionSchema(ctx, qType, question)
                if err != nil </span><span class="cov0" title="0">{
                        validationErrors = append(validationErrors, fmt.Sprintf("question %d schema validation error: %v", i+1, err))
                        span.SetAttributes(attribute.String("parse.result", "schema_validation_error"), attribute.Int("question_index", i), attribute.String("error", err.Error()))
                }</span>

                <span class="cov7" title="1006">if !valid </span><span class="cov0" title="0">{
                        SchemaValidationMu.Lock()
                        SchemaValidationFailures[qType]++
                        if err != nil </span><span class="cov0" title="0">{
                                SchemaValidationFailureDetails[qType] = append(SchemaValidationFailureDetails[qType], err.Error())
                        }</span> else<span class="cov0" title="0"> {
                                SchemaValidationFailureDetails[qType] = append(SchemaValidationFailureDetails[qType], "validation failed")
                        }</span>
                        <span class="cov0" title="0">if len(SchemaValidationFailureDetails[qType]) &gt; 10 </span><span class="cov0" title="0">{
                                SchemaValidationFailureDetails[qType] = SchemaValidationFailureDetails[qType][len(SchemaValidationFailureDetails[qType])-10:]
                        }</span>
                        <span class="cov0" title="0">SchemaValidationMu.Unlock()
                        skippedCount++
                        span.SetAttributes(attribute.String("parse.result", "schema_validation_failed"), attribute.Int("question_index", i))
                        continue</span> // skip invalid question
                }

                <span class="cov7" title="1006">result = append(result, question)</span>
        }

        // Log validation summary
        <span class="cov3" title="13">if len(validationErrors) &gt; 0 </span><span class="cov3" title="8">{
                s.logger.Warn(ctx, "AI Service WARNING: validation errors in response", map[string]interface{}{
                        "validation_errors_count": len(validationErrors),
                        "validation_errors":       strings.Join(validationErrors, "; "),
                })
                span.SetAttributes(attribute.String("parse.result", "validation_errors"), attribute.String("errors", strings.Join(validationErrors, "; ")))
        }</span>

        <span class="cov3" title="13">if len(result) == 0 </span><span class="cov2" title="7">{
                span.SetAttributes(attribute.String("parse.result", "no_valid_questions"), attribute.Int("total_questions", len(questions)), attribute.Int("skipped_count", skippedCount))
                return nil, contextutils.WrapErrorf(contextutils.ErrAIResponseInvalid, "AI provider returned only invalid or empty questions (total: %d, skipped: %d)", len(questions), skippedCount)
        }</span>

        <span class="cov2" title="6">span.SetAttributes(attribute.String("parse.result", "success"), attribute.Int("valid_questions", len(result)), attribute.Int("total_questions", len(questions)), attribute.Int("skipped_count", skippedCount))
        return result, nil</span>
}

// createQuestionFromData creates a Question from parsed JSON data
func (s *AIService) createQuestionFromData(ctx context.Context, data map[string]interface{}, language, level string, qType models.QuestionType) (result0 *models.Question, err error) <span class="cov8" title="2035">{
        if s == nil </span><span class="cov1" title="1">{
                return nil, contextutils.WrapError(contextutils.ErrInternalError, "AIService instance is nil")
        }</span>
        <span class="cov8" title="2033">_, span := observability.TraceAIFunction(ctx, "create_question_from_data",
                observability.AttributeQuestionType(qType),
                observability.AttributeLanguage(language),
                observability.AttributeLevel(level),
                attribute.Int("data.fields", len(data)),
        )
        defer func() </span><span class="cov8" title="2033">{
                if err != nil </span><span class="cov3" title="10">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov8" title="2033">span.End()</span>
        }()

        <span class="cov8" title="2033">if data == nil </span><span class="cov1" title="1">{
                span.SetAttributes(attribute.String("creation.result", "nil_data"))
                return nil, contextutils.WrapError(contextutils.ErrAIResponseInvalid, "question data is nil")
        }</span>

        // Validate required parameters
        <span class="cov8" title="2031">if language == "" </span><span class="cov0" title="0">{
                span.SetAttributes(attribute.String("creation.result", "empty_language"))
                return nil, contextutils.WrapError(contextutils.ErrAIResponseInvalid, "language cannot be empty")
        }</span>
        <span class="cov8" title="2031">if level == "" </span><span class="cov0" title="0">{
                span.SetAttributes(attribute.String("creation.result", "empty_level"))
                return nil, contextutils.WrapError(contextutils.ErrAIResponseInvalid, "level cannot be empty")
        }</span>

        <span class="cov8" title="2031">if ok, errMsg := s.validateQuestionContent(ctx, qType, data); !ok </span><span class="cov3" title="9">{
                missingFields := []string{}
                for k, v := range data </span><span class="cov4" title="30">{
                        if v == nil || v == "" </span><span class="cov1" title="2">{
                                missingFields = append(missingFields, k)
                        }</span>
                }
                <span class="cov3" title="9">if len(missingFields) &gt; 0 </span><span class="cov1" title="2">{
                        span.SetAttributes(attribute.String("creation.result", "validation_failed_with_missing_fields"), attribute.String("missing_fields", strings.Join(missingFields, ",")))
                        return nil, contextutils.WrapErrorf(contextutils.ErrAIResponseInvalid, "invalid question content structure: %s. Missing or empty fields: %v", errMsg, missingFields)
                }</span>
                <span class="cov2" title="7">span.SetAttributes(attribute.String("creation.result", "validation_failed"), attribute.String("error", errMsg))
                return nil, contextutils.WrapErrorf(contextutils.ErrAIResponseInvalid, "invalid question content structure: %s", errMsg)</span>
        }

        // Defensive: For reading comprehension, check passage, question, options, correct_answer
        <span class="cov8" title="2013">if qType == models.ReadingComprehension </span><span class="cov1" title="1">{
                if _, ok := data["passage"].(string); !ok </span><span class="cov0" title="0">{
                        span.SetAttributes(attribute.String("creation.result", "reading_missing_passage"))
                        return nil, contextutils.WrapError(contextutils.ErrAIResponseInvalid, "reading comprehension question missing or invalid 'passage' field")
                }</span>
                <span class="cov1" title="1">if _, ok := data["question"].(string); !ok </span><span class="cov0" title="0">{
                        span.SetAttributes(attribute.String("creation.result", "reading_missing_question"))
                        return nil, contextutils.WrapError(contextutils.ErrAIResponseInvalid, "reading comprehension question missing or invalid 'question' field")
                }</span>
                <span class="cov1" title="1">options, ok := data["options"].([]interface{})
                if !ok || len(options) != 4 </span><span class="cov0" title="0">{
                        span.SetAttributes(attribute.String("creation.result", "reading_invalid_options"))
                        return nil, contextutils.WrapError(contextutils.ErrAIResponseInvalid, "reading comprehension question missing or invalid 'options' field (must be array of 4 strings)")
                }</span>
                <span class="cov1" title="1">for i, opt := range options </span><span class="cov2" title="4">{
                        if _, ok := opt.(string); !ok </span><span class="cov0" title="0">{
                                span.SetAttributes(attribute.String("creation.result", "reading_invalid_option_type"), attribute.Int("option_index", i))
                                return nil, contextutils.WrapErrorf(contextutils.ErrAIResponseInvalid, "reading comprehension question 'options' must be array of strings, found invalid type at index %d", i)
                        }</span>
                }
                <span class="cov1" title="1">if _, ok := data["correct_answer"]; !ok </span><span class="cov0" title="0">{
                        span.SetAttributes(attribute.String("creation.result", "reading_missing_correct_answer"))
                        return nil, contextutils.WrapError(contextutils.ErrAIResponseInvalid, "reading comprehension question missing 'correct_answer' field")
                }</span>
        }

        // Parse correct_answer as index (integer)
        <span class="cov8" title="2013">var correctAnswerIndex int
        if correctAnswerRaw, exists := data["correct_answer"]; exists </span><span class="cov8" title="2013">{
                switch v := correctAnswerRaw.(type) </span>{
                case int:<span class="cov0" title="0">
                        correctAnswerIndex = v</span>
                case float64:<span class="cov8" title="2013">
                        correctAnswerIndex = int(v)</span>
                case string:<span class="cov0" title="0">
                        // Handle string indices like "0", "1", "2", "3"
                        if idx, err := strconv.Atoi(v); err == nil </span><span class="cov0" title="0">{
                                correctAnswerIndex = idx
                        }</span> else<span class="cov0" title="0"> {
                                // Handle answer text - find index in options
                                if options, ok := data["options"].([]interface{}); ok </span><span class="cov0" title="0">{
                                        found := false
                                        for i, opt := range options </span><span class="cov0" title="0">{
                                                if optStr, ok := opt.(string); ok &amp;&amp; optStr == v </span><span class="cov0" title="0">{
                                                        correctAnswerIndex = i
                                                        found = true
                                                        break</span>
                                                }
                                        }
                                        <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                                                span.SetAttributes(attribute.String("creation.result", "correct_answer_not_found_in_options"))
                                                return nil, contextutils.WrapErrorf(contextutils.ErrAIResponseInvalid, "correct_answer '%s' not found in options", v)
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        span.SetAttributes(attribute.String("creation.result", "no_options_for_text_answer"))
                                        return nil, contextutils.WrapErrorf(contextutils.ErrAIResponseInvalid, "correct_answer is text '%s' but no options available to match against", v)
                                }</span>
                        }
                default:<span class="cov0" title="0">
                        span.SetAttributes(attribute.String("creation.result", "invalid_correct_answer_type"), attribute.String("type", fmt.Sprintf("%T", v)))
                        return nil, contextutils.WrapErrorf(contextutils.ErrAIResponseInvalid, "invalid correct_answer type: %T", v)</span>
                }
        } else<span class="cov0" title="0"> {
                span.SetAttributes(attribute.String("creation.result", "missing_correct_answer"))
                return nil, contextutils.WrapError(contextutils.ErrAIResponseInvalid, "missing correct_answer field")
        }</span>

        // Validate correct answer index
        <span class="cov8" title="2013">if options, ok := data["options"].([]interface{}); ok </span><span class="cov8" title="2013">{
                if correctAnswerIndex &lt; 0 || correctAnswerIndex &gt;= len(options) </span><span class="cov0" title="0">{
                        span.SetAttributes(attribute.String("creation.result", "invalid_correct_answer_index"), attribute.Int("index", correctAnswerIndex), attribute.Int("options_count", len(options)))
                        return nil, contextutils.WrapErrorf(contextutils.ErrAIResponseInvalid, "correct_answer index %d is out of range (0-%d)", correctAnswerIndex, len(options)-1)
                }</span>
        }

        // --- Post-processing: shuffle options and update correct answer index ---
        // Only for multiple choice types
        <span class="cov8" title="2013">if optionsRaw, ok := data["options"]; ok </span><span class="cov8" title="2013">{
                if options, ok := optionsRaw.([]interface{}); ok &amp;&amp; len(options) == 4 </span><span class="cov8" title="2013">{
                        // Find the correct answer value before shuffling
                        var correctValue string
                        if correctAnswerIndex &gt;= 0 &amp;&amp; correctAnswerIndex &lt; len(options) </span><span class="cov8" title="2013">{
                                if v, ok := options[correctAnswerIndex].(string); ok </span><span class="cov8" title="2013">{
                                        correctValue = v
                                }</span> else<span class="cov0" title="0"> {
                                        span.SetAttributes(attribute.String("creation.result", "correct_answer_not_string"))
                                        return nil, contextutils.WrapErrorf(contextutils.ErrAIResponseInvalid, "correct answer at index %d is not a string", correctAnswerIndex)
                                }</span>
                        }
                        // Shuffle options
                        <span class="cov8" title="2013">rand.Shuffle(len(options), func(i, j int) </span><span class="cov9" title="6039">{
                                options[i], options[j] = options[j], options[i]
                        }</span>)
                        // Find new index of correct answer
                        <span class="cov8" title="2013">found := false
                        for i, opt := range options </span><span class="cov9" title="4912">{
                                if optStr, ok := opt.(string); ok &amp;&amp; optStr == correctValue </span><span class="cov8" title="2013">{
                                        correctAnswerIndex = i
                                        found = true
                                        break</span>
                                }
                        }
                        <span class="cov8" title="2013">if !found </span><span class="cov0" title="0">{
                                span.SetAttributes(attribute.String("creation.result", "correct_answer_lost_after_shuffle"))
                                return nil, contextutils.WrapErrorf(contextutils.ErrAIResponseInvalid, "correct answer '%s' not found after shuffling options", correctValue)
                        }</span>
                        // Update options and correct_answer in data
                        <span class="cov8" title="2013">data["options"] = options
                        data["correct_answer"] = correctAnswerIndex</span>
                }
        }

        // Get explanation or provide default
        <span class="cov8" title="2013">explanation, _ := data["explanation"].(string)
        if explanation == "" </span><span class="cov7" title="1005">{
                // Provide a default explanation based on question type
                switch qType </span>{
                case models.Vocabulary:<span class="cov7" title="1005">
                        explanation = "This vocabulary question tests your knowledge of words in context."</span>
                case models.ReadingComprehension:<span class="cov0" title="0">
                        explanation = "This reading comprehension question tests your understanding of the passage."</span>
                case models.FillInBlank:<span class="cov0" title="0">
                        explanation = "This fill-in-the-blank question tests your grammar and vocabulary knowledge."</span>
                case models.QuestionAnswer:<span class="cov0" title="0">
                        explanation = "This question tests your conversational and practical language skills."</span>
                default:<span class="cov0" title="0">
                        explanation = "This question tests your language skills."</span>
                }
                // Add the explanation to the data for schema validation
                <span class="cov7" title="1005">data["explanation"] = explanation</span>
        }

        <span class="cov8" title="2013">question := &amp;models.Question{
                Type:            qType,
                Language:        language,
                Level:           level,
                DifficultyScore: s.getDifficultyScore(level),
                Content:         data,
                CorrectAnswer:   correctAnswerIndex,
                Explanation:     explanation,
                CreatedAt:       time.Now(),
        }

        span.SetAttributes(attribute.String("creation.result", "success"))
        return question, nil</span>
}

func (s *AIService) parseQuestionResponse(ctx context.Context, response, language, level string, qType models.QuestionType, provider string) (result0 *models.Question, err error) <span class="cov2" title="3">{
        _, span := observability.TraceAIFunction(ctx, "parse_question_response",
                observability.AttributeQuestionType(qType),
                observability.AttributeLanguage(language),
                observability.AttributeLevel(level),
                attribute.String("ai.provider", provider),
                attribute.Int("response.length", len(response)),
        )
        defer func() </span><span class="cov2" title="3">{
                if err != nil </span><span class="cov1" title="2">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov2" title="3">span.End()</span>
        }()
        // Clean the response to handle markdown code blocks for providers without grammar support
        <span class="cov2" title="3">cleanedResponse := s.cleanJSONResponse(ctx, response, provider)

        // With grammar field enforcement, we should get clean JSON directly
        // No need for complex extraction - just parse the response directly
        var data map[string]interface{}
        if err := json.Unmarshal([]byte(cleanedResponse), &amp;data); err != nil </span><span class="cov1" title="2">{
                s.logger.Error(ctx, "Failed to parse JSON response", err, map[string]interface{}{
                        "raw_response": response,
                })
                return nil, contextutils.WrapErrorf(contextutils.ErrAIResponseInvalid, "failed to parse AI response as JSON: %w", err)
        }</span>

        <span class="cov1" title="1">question, err := s.createQuestionFromData(ctx, data, language, level, qType)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error(ctx, "Failed to create question from data", err, map[string]interface{}{
                        "raw_question_data":   data,
                        "full_model_response": response,
                })
                return nil, contextutils.WrapErrorf(contextutils.ErrAIResponseInvalid, "failed to create question: %w", err)
        }</span>
        <span class="cov1" title="1">valid, err := s.ValidateQuestionSchema(ctx, qType, question)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error(ctx, "Schema validation error for question", err, nil)
        }</span>
        <span class="cov1" title="1">if !valid </span><span class="cov0" title="0">{
                SchemaValidationMu.Lock()
                SchemaValidationFailures[qType]++
                if err != nil </span><span class="cov0" title="0">{
                        SchemaValidationFailureDetails[qType] = append(SchemaValidationFailureDetails[qType], err.Error())
                }</span> else<span class="cov0" title="0"> {
                        SchemaValidationFailureDetails[qType] = append(SchemaValidationFailureDetails[qType], "validation failed")
                }</span>
                <span class="cov0" title="0">if len(SchemaValidationFailureDetails[qType]) &gt; 10 </span><span class="cov0" title="0">{
                        SchemaValidationFailureDetails[qType] = SchemaValidationFailureDetails[qType][len(SchemaValidationFailureDetails[qType])-10:]
                }</span>
                <span class="cov0" title="0">SchemaValidationMu.Unlock()</span>
        }
        <span class="cov1" title="1">return question, nil</span>
}

func (s *AIService) getDifficultyScore(level string) float64 <span class="cov8" title="2061">{
        // Use language-specific level mapping from configuration
        if s.cfg != nil &amp;&amp; s.cfg.AppConfig != nil </span><span class="cov4" title="49">{
                // Try to find the level in any language's level configuration
                for _, langConfig := range s.cfg.AppConfig.LanguageLevels </span><span class="cov5" title="96">{
                        for i, langLevel := range langConfig.Levels </span><span class="cov7" title="430">{
                                if langLevel == level </span><span class="cov4" title="21">{
                                        // Return difficulty score based on position in the level list
                                        // Higher index = higher difficulty
                                        return float64(i + 1)
                                }</span>
                        }
                }
        }

        // Default score if level not found or no configuration available
        <span class="cov8" title="2019">return 3.0</span>
}

func (s *AIService) validateQuestionContent(ctx context.Context, qType models.QuestionType, content map[string]interface{}) (bool, string) <span class="cov8" title="2031">{
        _, span := observability.TraceAIFunction(ctx, "validate_question_content",
                observability.AttributeQuestionType(qType),
                attribute.Int("content.fields", len(content)),
        )
        defer span.End()

        // Validate input parameters
        if content == nil </span><span class="cov0" title="0">{
                span.SetAttributes(attribute.String("validation.result", "nil_content"))
                return false, "question content cannot be nil"
        }</span>

        <span class="cov8" title="2031">requiredFields := make(map[string]func(interface{}) bool)
        isString := func(v interface{}) bool </span><span class="cov9" title="4056">{
                if v == nil </span><span class="cov1" title="1">{
                        return false
                }</span>
                <span class="cov9" title="4054">_, ok := v.(string)
                return ok &amp;&amp; v.(string) != ""</span>
        }
        <span class="cov8" title="2031">isStringSlice := func(v interface{}) bool </span><span class="cov7" title="1014">{
                if v == nil </span><span class="cov1" title="2">{
                        return false
                }</span>
                <span class="cov7" title="1012">if slice, ok := v.([]interface{}); ok </span><span class="cov7" title="1012">{
                        if len(slice) &lt; 4 </span><span class="cov2" title="3">{
                                return false
                        }</span>
                        <span class="cov8" title="2021">for _, item := range slice </span><span class="cov10" title="8084">{
                                if item == nil </span><span class="cov0" title="0">{
                                        return false
                                }</span>
                                <span class="cov10" title="8084">if _, ok := item.(string); !ok </span><span class="cov0" title="0">{
                                        return false
                                }</span>
                                <span class="cov10" title="8084">if item.(string) == "" </span><span class="cov0" title="0">{
                                        return false
                                }</span>
                        }
                        <span class="cov8" title="2021">return true</span>
                }
                <span class="cov0" title="0">return false</span>
        }
        <span class="cov8" title="2031">isCorrectAnswer := func(v interface{}) bool </span><span class="cov1" title="1">{
                if v == nil </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov1" title="1">switch val := v.(type) </span>{
                case int:<span class="cov0" title="0">
                        return val &gt;= 0</span>
                case float64:<span class="cov1" title="1">
                        return val &gt;= 0 &amp;&amp; val == float64(int(val))</span> // Must be whole number
                case string:<span class="cov0" title="0">
                        // Accept string indices like "0", "1", "2", "3" or answer text
                        if _, err := strconv.Atoi(val); err == nil </span><span class="cov0" title="0">{
                                return true
                        }</span>
                        // Or accept answer text that matches one of the options
                        <span class="cov0" title="0">if options, ok := content["options"].([]interface{}); ok </span><span class="cov0" title="0">{
                                for _, opt := range options </span><span class="cov0" title="0">{
                                        if optStr, ok := opt.(string); ok &amp;&amp; optStr == val </span><span class="cov0" title="0">{
                                                return true
                                        }</span>
                                }
                        }
                        <span class="cov0" title="0">return false</span>
                default:<span class="cov0" title="0">
                        return false</span>
                }
        }

        <span class="cov8" title="2031">switch qType </span>{
        case models.Vocabulary:<span class="cov8" title="2029">
                requiredFields["sentence"] = isString
                requiredFields["question"] = isString
                requiredFields["options"] = isStringSlice
                for field, validator := range requiredFields </span><span class="cov9" title="6078">{
                        if !validator(content[field]) </span><span class="cov2" title="5">{
                                span.SetAttributes(attribute.String("validation.result", "field_validation_failed"), attribute.String("field", field))
                                return false, fmt.Sprintf("[Vocabulary] Validation failed for field '%s': %v", field, content[field])
                        }</span>
                }
                <span class="cov8" title="2019">sentence, _ := content["sentence"].(string)
                targetWord, _ := content["question"].(string)
                options, _ := content["options"].([]interface{})
                if sentence == "" || targetWord == "" || len(options) != 4 </span><span class="cov0" title="0">{
                        span.SetAttributes(attribute.String("validation.result", "vocabulary_structure_failed"))
                        return false, "[Vocabulary] Validation failed: missing or invalid sentence/question/options"
                }</span>
                <span class="cov8" title="2019">if !strings.Contains(sentence, targetWord) </span><span class="cov2" title="4">{
                        span.SetAttributes(attribute.String("validation.result", "vocabulary_word_not_found"))
                        return false, fmt.Sprintf("[Vocabulary] Validation failed: question '%s' not found in sentence '%s'", targetWord, sentence)
                }</span>
                <span class="cov8" title="2011">span.SetAttributes(attribute.String("validation.result", "valid"))
                return true, ""</span>

        case models.ReadingComprehension:<span class="cov1" title="1">
                requiredFields["passage"] = isString
                requiredFields["question"] = isString
                requiredFields["options"] = isStringSlice
                requiredFields["correct_answer"] = isCorrectAnswer
                for field, validator := range requiredFields </span><span class="cov2" title="4">{
                        if !validator(content[field]) </span><span class="cov0" title="0">{
                                span.SetAttributes(attribute.String("validation.result", "field_validation_failed"), attribute.String("field", field))
                                return false, fmt.Sprintf("[ReadingComprehension] Validation failed for field '%s': %v", field, content[field])
                        }</span>
                }
                <span class="cov1" title="1">passage, _ := content["passage"].(string)
                if passage == "" </span><span class="cov0" title="0">{
                        span.SetAttributes(attribute.String("validation.result", "reading_passage_empty"))
                        return false, "[ReadingComprehension] Validation failed: passage cannot be empty"
                }</span>
                <span class="cov1" title="1">span.SetAttributes(attribute.String("validation.result", "valid"))
                return true, ""</span>

        case models.FillInBlank:<span class="cov0" title="0">
                // Fill-in-blank questions now use multiple choice format like all other types
                requiredFields["question"] = isString
                requiredFields["options"] = isStringSlice
                requiredFields["correct_answer"] = isCorrectAnswer
                for field, validator := range requiredFields </span><span class="cov0" title="0">{
                        if !validator(content[field]) </span><span class="cov0" title="0">{
                                span.SetAttributes(attribute.String("validation.result", "field_validation_failed"), attribute.String("field", field))
                                return false, fmt.Sprintf("[FillInBlank] Validation failed for field '%s': %v", field, content[field])
                        }</span>
                }
                <span class="cov0" title="0">span.SetAttributes(attribute.String("validation.result", "valid"))
                return true, ""</span>

        case models.QuestionAnswer:<span class="cov0" title="0">
                // Question-answer questions now use multiple choice format like all other types
                requiredFields["question"] = isString
                requiredFields["options"] = isStringSlice
                requiredFields["correct_answer"] = isCorrectAnswer
                for field, validator := range requiredFields </span><span class="cov0" title="0">{
                        if !validator(content[field]) </span><span class="cov0" title="0">{
                                span.SetAttributes(attribute.String("validation.result", "field_validation_failed"), attribute.String("field", field))
                                return false, fmt.Sprintf("[QuestionAnswer] Validation failed for field '%s': %v", field, content[field])
                        }</span>
                }
                <span class="cov0" title="0">span.SetAttributes(attribute.String("validation.result", "valid"))
                return true, ""</span>
        }

        // If we reach here, it's an unknown question type
        <span class="cov0" title="0">span.SetAttributes(attribute.String("validation.result", "unknown_type"))
        return false, fmt.Sprintf("unknown question type: %v", qType)</span>
}

// GetConcurrencyStats returns current concurrency metrics
func (s *AIService) GetConcurrencyStats() ConcurrencyStats <span class="cov3" title="9">{
        s.statsMu.RLock()
        s.concurrencyMu.RLock()
        defer s.statsMu.RUnlock()
        defer s.concurrencyMu.RUnlock()

        // Count active requests globally and per user
        queuedRequests := 0 // Currently we don't queue, we fail fast

        userActiveCount := make(map[string]int)
        for username, count := range s.userRequestCount </span><span class="cov3" title="11">{
                if count &gt; 0 </span><span class="cov1" title="1">{
                        userActiveCount[username] = count
                }</span>
        }

        <span class="cov3" title="9">return ConcurrencyStats{
                ActiveRequests:  s.activeRequests,
                MaxConcurrent:   s.maxConcurrent,
                QueuedRequests:  queuedRequests,
                TotalRequests:   s.totalRequests,
                UserActiveCount: userActiveCount,
                MaxPerUser:      s.maxPerUser,
        }</span>
}

// acquireGlobalSlot attempts to acquire a global concurrency slot
func (s *AIService) acquireGlobalSlot(ctx context.Context) error <span class="cov3" title="15">{
        select </span>{
        case s.globalSemaphore &lt;- struct{}{}:<span class="cov3" title="12">
                return nil</span>
        case &lt;-ctx.Done():<span class="cov1" title="1">
                return contextutils.WrapErrorf(contextutils.ErrTimeout, "request cancelled while waiting for global AI slot: %w", ctx.Err())</span>
        default:<span class="cov1" title="1">
                return contextutils.WrapErrorf(contextutils.ErrServiceUnavailable, "AI service at capacity (%d concurrent requests), please try again", s.maxConcurrent)</span>
        }
}

// releaseGlobalSlot releases a global concurrency slot
func (s *AIService) releaseGlobalSlot(ctx context.Context) <span class="cov3" title="12">{
        s.concurrencyMu.Lock()
        defer s.concurrencyMu.Unlock()

        select </span>{
        case &lt;-s.globalSemaphore:<span class="cov3" title="12">
                // Successfully released a slot
                s.statsMu.Lock()
                if s.activeRequests &gt; 0 </span><span class="cov2" title="6">{
                        s.activeRequests--
                }</span>
                <span class="cov3" title="12">s.statsMu.Unlock()</span>
        default:<span class="cov0" title="0">
                // No slot was acquired
                s.logger.Warn(ctx, "WARNING: Attempted to release global AI slot but none were acquired", nil)</span>
        }
}

// acquireUserSlot acquires a user-specific concurrency slot
func (s *AIService) acquireUserSlot(_ context.Context, username string) error <span class="cov3" title="16">{
        s.concurrencyMu.Lock()
        defer s.concurrencyMu.Unlock()

        currentCount := s.userRequestCount[username]
        if currentCount &gt;= s.maxPerUser </span><span class="cov1" title="1">{
                return contextutils.WrapErrorf(contextutils.ErrServiceUnavailable, "user concurrency limit exceeded for %s: %d/%d", username, currentCount, s.maxPerUser)
        }</span>

        <span class="cov3" title="14">s.userRequestCount[username] = currentCount + 1
        return nil</span>
}

// releaseUserSlot releases a user-specific concurrency slot
func (s *AIService) releaseUserSlot(ctx context.Context, username string) <span class="cov3" title="14">{
        s.concurrencyMu.Lock()
        defer s.concurrencyMu.Unlock()

        currentCount := s.userRequestCount[username]
        if currentCount &gt; 0 </span><span class="cov3" title="14">{
                s.userRequestCount[username] = currentCount - 1
        }</span> else<span class="cov0" title="0"> {
                s.logger.Warn(ctx, "WARNING: Attempted to release user AI slot but none were acquired", map[string]interface{}{
                        "username": username,
                })
        }</span>
}

// incrementTotalRequests increments the total request counter
func (s *AIService) incrementTotalRequests() <span class="cov2" title="7">{
        s.statsMu.Lock()
        defer s.statsMu.Unlock()
        s.totalRequests++
}</span>

// withConcurrencyControl wraps an AI operation with concurrency limits
func (s *AIService) withConcurrencyControl(ctx context.Context, username string, operation func() error) error <span class="cov3" title="9">{
        // Check if service is shutting down
        if s.isShutdown() </span><span class="cov1" title="1">{
                return contextutils.WrapError(contextutils.ErrServiceUnavailable, "AI service is shutting down")
        }</span>

        // Increment total request counter
        <span class="cov2" title="7">s.incrementTotalRequests()

        // Acquire global slot
        if err := s.acquireGlobalSlot(ctx); err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        // Track active request
        <span class="cov2" title="6">s.statsMu.Lock()
        s.activeRequests++
        s.statsMu.Unlock()

        defer func() </span><span class="cov2" title="6">{
                s.releaseGlobalSlot(ctx)
        }</span>()

        // Acquire per-user slot
        <span class="cov2" title="6">if err := s.acquireUserSlot(ctx, username); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov2" title="6">defer s.releaseUserSlot(ctx, username)

        // Execute the actual operation
        return operation()</span>
}

// supportsGrammarField checks if the provider supports the grammar field
func (s *AIService) supportsGrammarField(provider string) bool <span class="cov5" title="77">{
        // If no provider configs are loaded, default to true for backward compatibility
        if s.cfg.AppConfig == nil </span><span class="cov3" title="19">{
                return true
        }</span>

        // Look up the provider in the configuration
        <span class="cov4" title="39">for _, providerConfig := range s.cfg.AppConfig.Providers </span><span class="cov5" title="81">{
                if providerConfig.Code == provider </span><span class="cov4" title="32">{
                        return providerConfig.SupportsGrammar
                }</span>
        }

        // Default to true for unknown providers (backward compatibility)
        <span class="cov2" title="7">return true</span>
}

// getQuestionBatchSize returns the maximum number of questions that can be generated in a single request for the given provider
func (s *AIService) getQuestionBatchSize(provider string) int <span class="cov2" title="6">{
        if s.cfg.AppConfig == nil </span><span class="cov0" title="0">{
                return 1 // Default to 1 if no config available
        }</span>

        <span class="cov2" title="6">for _, p := range s.cfg.AppConfig.Providers </span><span class="cov3" title="11">{
                if p.Code == provider </span><span class="cov2" title="3">{
                        if p.QuestionBatchSize &gt; 0 </span><span class="cov2" title="3">{
                                return p.QuestionBatchSize
                        }</span>
                        <span class="cov0" title="0">return 1</span> // Default to 1 if not specified
                }
        }

        <span class="cov2" title="3">return 1</span> // Default to 1 if provider not found
}

// GetQuestionBatchSize returns the maximum number of questions that can be generated in a single request for the given provider
func (s *AIService) GetQuestionBatchSize(provider string) int <span class="cov0" title="0">{
        return s.getQuestionBatchSize(provider)
}</span>

// VarietyService returns the variety service used by the AI service
func (s *AIService) VarietyService() *VarietyService <span class="cov1" title="1">{
        return s.varietyService
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">// Package services provides embedded templates for AI service prompts
package services

import (
        "embed"
        "fmt"
        "strings"
        "text/template"

        contextutils "quizapp/internal/utils"
)

//go:embed templates/*.tmpl
var aiTemplatesFS embed.FS

//go:embed templates/examples/*.json
var exampleFilesFS embed.FS

// Template names as constants
const (
        BatchQuestionPromptTemplate   = "batch_question_prompt.tmpl"
        ChatPromptTemplate            = "chat_prompt.tmpl"
        JSONStructureGuidanceTemplate = "json_structure_guidance.tmpl"
)

// AITemplateData holds data for rendering AI prompt templates
type AITemplateData struct {
        // Common fields
        Language              string
        Level                 string
        QuestionType          string
        Topic                 string
        RecentQuestionHistory []string
        Count                 int // For batch generation

        // Variety fields for question generation
        TopicCategory      string
        GrammarFocus       string
        VocabularyDomain   string
        Scenario           string
        StyleModifier      string
        DifficultyModifier string
        TimeContext        string

        // Schema and formatting
        SchemaForPrompt string // for direct inclusion in prompt for non-grammar providers
        ExampleContent  string // for including example in prompt

        // Explanation specific
        Question      string
        UserAnswer    string
        CorrectAnswer string // The text of the correct answer for explanations

        // Chat specific
        Passage             string
        Options             []string
        IsCorrect           *bool
        ConversationHistory []ChatMessage
        UserMessage         string

        // Priority-aware generation fields (NEW)
        UserWeakAreas        []string
        HighPriorityTopics   []string
        GapAnalysis          map[string]int
        FocusOnWeakAreas     bool
        FreshQuestionRatio   float64
        PriorityDistribution map[string]int
}

// ChatMessage represents a chat message for templates
type ChatMessage struct {
        Role    string
        Content string
}

// AITemplateManager manages AI prompt templates
type AITemplateManager struct {
        templates *template.Template
}

// NewAITemplateManager creates a new template manager
func NewAITemplateManager() (result0 *AITemplateManager, err error) <span class="cov10" title="52">{
        templates, err := template.New("").ParseFS(aiTemplatesFS, "templates/*.tmpl")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov10" title="52">return &amp;AITemplateManager{
                templates: templates,
        }, nil</span>
}

// RenderTemplate renders a template with the given data
func (tm *AITemplateManager) RenderTemplate(templateName string, data AITemplateData) (result0 string, err error) <span class="cov7" title="20">{
        var buf strings.Builder
        err = tm.templates.ExecuteTemplate(&amp;buf, templateName, data)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov7" title="20">return buf.String(), nil</span>
}

// LoadExample loads the example JSON for a specific question type
func (tm *AITemplateManager) LoadExample(questionType string) (result0 string, err error) <span class="cov7" title="19">{
        examplePath := fmt.Sprintf("templates/examples/%s_example.json", questionType)
        content, err := exampleFilesFS.ReadFile(examplePath)
        if err != nil </span><span class="cov0" title="0">{
                return "", contextutils.WrapErrorf(contextutils.ErrInternalError, "failed to load example for %s: %w", questionType, err)
        }</span>
        <span class="cov7" title="19">return string(content), nil</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package services

import (
        "context"
        "database/sql"
        "errors"
        "time"

        "go.opentelemetry.io/otel/attribute"
        "go.opentelemetry.io/otel/codes"
        "go.opentelemetry.io/otel/trace"

        "quizapp/internal/observability"
)

// CleanupService handles database maintenance and cleanup tasks
type CleanupService struct {
        db     *sql.DB
        logger *observability.Logger
}

// NewCleanupServiceWithLogger creates a new cleanup service with logger
func NewCleanupServiceWithLogger(db *sql.DB, logger *observability.Logger) *CleanupService <span class="cov10" title="13">{
        return &amp;CleanupService{
                db:     db,
                logger: logger,
        }
}</span>

// CleanupLegacyQuestionTypes removes questions with unsupported question types
func (c *CleanupService) CleanupLegacyQuestionTypes(ctx context.Context) (err error) <span class="cov8" title="8">{
        ctx, span := observability.TraceCleanupFunction(ctx, "cleanup_legacy_question_types")
        defer func() </span><span class="cov8" title="8">{
                if err != nil </span><span class="cov3" title="2">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov8" title="8">span.End()</span>
        }()

        // Check if database is available
        <span class="cov8" title="8">if c.db == nil </span><span class="cov1" title="1">{
                return errors.New("database connection not available")
        }</span>

        // Get count of legacy questions first
        <span class="cov7" title="7">var count int
        err = c.db.QueryRowContext(ctx, `
                SELECT COUNT(*)
                FROM questions
                WHERE type NOT IN ('vocabulary', 'fill_blank', 'qa', 'reading_comprehension')
        `).Scan(&amp;count)
        if err != nil </span><span class="cov1" title="1">{
                span.SetAttributes(attribute.String("error", err.Error()))
                return err
        }</span>

        <span class="cov7" title="6">span.SetAttributes(attribute.Int("cleanup.legacy_questions_count", count))

        if count == 0 </span><span class="cov4" title="3">{
                c.logger.Info(ctx, "No legacy question types found to cleanup", map[string]interface{}{})
                span.SetAttributes(attribute.String("cleanup.result", "no_legacy_questions"))
                return nil
        }</span>

        <span class="cov4" title="3">c.logger.Info(ctx, "Found questions with legacy types to cleanup", map[string]interface{}{"count": count})

        // Delete questions with unsupported types
        result, err := c.db.ExecContext(ctx, `
                DELETE FROM questions
                WHERE type NOT IN ('vocabulary', 'fill_blank', 'qa', 'reading_comprehension')
        `)
        if err != nil </span><span class="cov0" title="0">{
                span.SetAttributes(attribute.String("error", err.Error()))
                return err
        }</span>

        <span class="cov4" title="3">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                span.SetAttributes(attribute.String("error", err.Error()))
                return err
        }</span>

        <span class="cov4" title="3">span.SetAttributes(
                attribute.Int64("cleanup.rows_affected", rowsAffected),
                attribute.String("cleanup.result", "success"),
        )

        c.logger.Info(ctx, "Successfully cleaned up questions with legacy types", map[string]interface{}{"rows_affected": rowsAffected})
        return nil</span>
}

// CleanupOrphanedResponses removes user responses for questions that no longer exist
func (c *CleanupService) CleanupOrphanedResponses(ctx context.Context) (err error) <span class="cov0" title="0">{
        ctx, span := observability.TraceCleanupFunction(ctx, "cleanup_orphaned_responses")
        defer func() </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov0" title="0">span.End()</span>
        }()

        // Check if database is available
        <span class="cov0" title="0">if c.db == nil </span><span class="cov0" title="0">{
                return errors.New("database connection not available")
        }</span>

        <span class="cov0" title="0">var count int
        err = c.db.QueryRowContext(ctx, `
                SELECT COUNT(*)
                FROM user_responses ur
                LEFT JOIN questions q ON ur.question_id = q.id
                WHERE q.id IS NULL
        `).Scan(&amp;count)
        if err != nil </span><span class="cov0" title="0">{
                span.SetAttributes(attribute.String("error", err.Error()))
                return err
        }</span>

        <span class="cov0" title="0">span.SetAttributes(attribute.Int("cleanup.orphaned_responses_count", count))

        if count == 0 </span><span class="cov0" title="0">{
                c.logger.Info(ctx, "No orphaned responses found to cleanup", map[string]interface{}{})
                span.SetAttributes(attribute.String("cleanup.result", "no_orphaned_responses"))
                return nil
        }</span>

        <span class="cov0" title="0">c.logger.Info(ctx, "Found orphaned responses to cleanup", map[string]interface{}{"count": count})

        result, err := c.db.ExecContext(ctx, `
                DELETE FROM user_responses
                WHERE question_id NOT IN (SELECT id FROM questions)
        `)
        if err != nil </span><span class="cov0" title="0">{
                span.SetAttributes(attribute.String("error", err.Error()))
                return err
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                span.SetAttributes(attribute.String("error", err.Error()))
                return err
        }</span>

        <span class="cov0" title="0">span.SetAttributes(
                attribute.Int64("cleanup.rows_affected", rowsAffected),
                attribute.String("cleanup.result", "success"),
        )

        c.logger.Info(ctx, "Successfully cleaned up orphaned responses", map[string]interface{}{"rows_affected": rowsAffected})
        return nil</span>
}

// RunFullCleanup performs all cleanup operations
func (c *CleanupService) RunFullCleanup(ctx context.Context) (err error) <span class="cov0" title="0">{
        ctx, span := observability.TraceCleanupFunction(ctx, "run_full_cleanup")
        defer func() </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov0" title="0">span.End()</span>
        }()

        <span class="cov0" title="0">span.SetAttributes(attribute.String("cleanup.start_time", time.Now().Format(time.RFC3339)))

        c.logger.Info(ctx, "Starting database cleanup", map[string]interface{}{"start_time": time.Now().Format(time.RFC3339)})

        if err = c.CleanupLegacyQuestionTypes(ctx); err != nil </span><span class="cov0" title="0">{
                c.logger.Error(ctx, "Failed to cleanup legacy question types", err, map[string]interface{}{})
                span.SetAttributes(attribute.String("error", err.Error()))
                return err
        }</span>

        <span class="cov0" title="0">if err := c.CleanupOrphanedResponses(ctx); err != nil </span><span class="cov0" title="0">{
                c.logger.Error(ctx, "Failed to cleanup orphaned responses", err, map[string]interface{}{})
                span.SetAttributes(attribute.String("error", err.Error()))
                return err
        }</span>

        <span class="cov0" title="0">span.SetAttributes(
                attribute.String("cleanup.end_time", time.Now().Format(time.RFC3339)),
                attribute.String("cleanup.result", "success"),
        )

        c.logger.Info(ctx, "Database cleanup completed successfully", map[string]interface{}{"end_time": time.Now().Format(time.RFC3339)})
        return nil</span>
}

// GetCleanupStats returns statistics about cleanup operations
func (c *CleanupService) GetCleanupStats(ctx context.Context) (result0 map[string]int, err error) <span class="cov0" title="0">{
        ctx, span := observability.TraceCleanupFunction(ctx, "get_cleanup_stats")
        defer func() </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov0" title="0">span.End()</span>
        }()

        // Check if database is available
        <span class="cov0" title="0">if c.db == nil </span><span class="cov0" title="0">{
                return nil, errors.New("database connection not available")
        }</span>

        <span class="cov0" title="0">stats := make(map[string]int)

        // Count legacy question types
        var legacyCount int
        err = c.db.QueryRowContext(ctx, `
                SELECT COUNT(*)
                FROM questions
                WHERE type NOT IN ('vocabulary', 'fill_blank', 'qa', 'reading_comprehension')
        `).Scan(&amp;legacyCount)
        if err != nil </span><span class="cov0" title="0">{
                span.SetAttributes(attribute.String("error", err.Error()))
                return nil, err
        }</span>
        <span class="cov0" title="0">stats["legacy_questions"] = legacyCount

        // Count orphaned responses
        var orphanedCount int
        err = c.db.QueryRowContext(ctx, `
                SELECT COUNT(*)
                FROM user_responses ur
                LEFT JOIN questions q ON ur.question_id = q.id
                WHERE q.id IS NULL
        `).Scan(&amp;orphanedCount)
        if err != nil </span><span class="cov0" title="0">{
                span.SetAttributes(attribute.String("error", err.Error()))
                return nil, err
        }</span>
        <span class="cov0" title="0">stats["orphaned_responses"] = orphanedCount

        span.SetAttributes(
                attribute.Int("cleanup.stats.legacy_questions", legacyCount),
                attribute.Int("cleanup.stats.orphaned_responses", orphanedCount),
        )

        return stats, nil</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package services

import (
        "context"
        "database/sql"
        "errors"
        "fmt"
        "math"
        "strings"
        "time"

        "quizapp/internal/config"
        "quizapp/internal/models"
        "quizapp/internal/observability"
        contextutils "quizapp/internal/utils"

        "github.com/lib/pq"
        "go.opentelemetry.io/otel/attribute"
        "go.opentelemetry.io/otel/codes"
        "go.opentelemetry.io/otel/trace"
)

// LearningServiceInterface defines the interface for the learning service
type LearningServiceInterface interface {
        RecordUserResponse(ctx context.Context, response *models.UserResponse) error
        GetUserProgress(ctx context.Context, userID int) (*models.UserProgress, error)
        GetWeakestTopics(ctx context.Context, userID, limit int) ([]*models.PerformanceMetrics, error)
        ShouldAvoidQuestion(ctx context.Context, userID, questionID int) (bool, error)
        GetUserQuestionStats(ctx context.Context, userID int) (*UserQuestionStats, error)
        // Priority system methods
        RecordAnswerWithPriority(ctx context.Context, userID, questionID int, answer string, isCorrect bool, responseTime int) error
        MarkQuestionAsKnown(ctx context.Context, userID, questionID int) error
        GetUserLearningPreferences(ctx context.Context, userID int) (*models.UserLearningPreferences, error)
        CalculatePriorityScore(ctx context.Context, userID, questionID int) (float64, error)
        UpdateUserLearningPreferences(ctx context.Context, userID int, prefs *models.UserLearningPreferences) (*models.UserLearningPreferences, error)
        // Analytics methods
        GetPriorityScoreDistribution(ctx context.Context) (map[string]interface{}, error)
        GetHighPriorityQuestions(ctx context.Context, limit int) ([]map[string]interface{}, error)
        GetWeakAreasByTopic(ctx context.Context, limit int) ([]map[string]interface{}, error)
        GetLearningPreferencesUsage(ctx context.Context) (map[string]interface{}, error)
        GetQuestionTypeGaps(ctx context.Context) ([]map[string]interface{}, error)
        GetGenerationSuggestions(ctx context.Context) ([]map[string]interface{}, error)
        GetPrioritySystemPerformance(ctx context.Context) (map[string]interface{}, error)
        GetBackgroundJobsStatus(ctx context.Context) (map[string]interface{}, error)
        // User-specific analytics methods
        GetUserPriorityScoreDistribution(ctx context.Context, userID int) (map[string]interface{}, error)
        GetUserHighPriorityQuestions(ctx context.Context, userID, limit int) ([]map[string]interface{}, error)
        GetUserWeakAreas(ctx context.Context, userID, limit int) ([]map[string]interface{}, error)
}

// UserQuestionStats represents per-user question statistics
type UserQuestionStats struct {
        UserID           int                `json:"user_id"`
        TotalAnswered    int                `json:"total_answered"`
        CorrectAnswers   int                `json:"correct_answers"`
        IncorrectAnswers int                `json:"incorrect_answers"`
        AccuracyRate     float64            `json:"accuracy_rate"`
        AnsweredByType   map[string]int     `json:"answered_by_type"`
        AnsweredByLevel  map[string]int     `json:"answered_by_level"`
        AccuracyByType   map[string]float64 `json:"accuracy_by_type"`
        AccuracyByLevel  map[string]float64 `json:"accuracy_by_level"`
        AvailableByType  map[string]int     `json:"available_by_type"`
        AvailableByLevel map[string]int     `json:"available_by_level"`
        RecentlyAnswered int                `json:"recently_answered"` // Within last hour
}

// ErrQuestionNotFound is returned when a question does not exist in the database
var ErrQuestionNotFound = errors.New("question not found")

// LearningService provides methods for managing user learning progress
type LearningService struct {
        db     *sql.DB
        cfg    *config.Config
        logger *observability.Logger
}

// NewLearningServiceWithLogger creates a new LearningService with a logger
func NewLearningServiceWithLogger(db *sql.DB, cfg *config.Config, logger *observability.Logger) *LearningService <span class="cov7" title="63">{
        return &amp;LearningService{
                db:     db,
                cfg:    cfg,
                logger: logger,
        }
}</span>

// RecordUserResponse records a user's response to a question and updates metrics
func (s *LearningService) RecordUserResponse(ctx context.Context, response *models.UserResponse) (err error) <span class="cov6" title="33">{
        ctx, span := observability.TraceLearningFunction(ctx, "record_user_response",
                observability.AttributeUserID(response.UserID),
                observability.AttributeQuestionID(response.QuestionID),
                attribute.Bool("response.is_correct", response.IsCorrect),
                attribute.Int("response.time_ms", response.ResponseTimeMs),
        )
        defer func() </span><span class="cov6" title="33">{
                if err != nil </span><span class="cov1" title="1">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov6" title="33">span.End()</span>
        }()

        <span class="cov6" title="33">query := `
                INSERT INTO user_responses (user_id, question_id, user_answer, is_correct, response_time_ms)
                VALUES ($1, $2, $3, $4, $5) RETURNING id
        `

        var id int
        err = s.db.QueryRowContext(ctx, query,
                response.UserID,
                response.QuestionID,
                response.UserAnswer,
                response.IsCorrect,
                response.ResponseTimeMs,
        ).Scan(&amp;id)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov6" title="32">response.ID = id

        // Update performance metrics
        return s.updatePerformanceMetrics(ctx, response)</span>
}

func (s *LearningService) updatePerformanceMetrics(ctx context.Context, response *models.UserResponse) (err error) <span class="cov6" title="32">{
        ctx, span := observability.TraceLearningFunction(ctx, "update_performance_metrics",
                observability.AttributeUserID(response.UserID),
                observability.AttributeQuestionID(response.QuestionID),
                attribute.Bool("response.is_correct", response.IsCorrect),
        )
        defer func() </span><span class="cov6" title="32">{
                if err != nil </span><span class="cov0" title="0">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov6" title="32">span.End()</span>
        }()

        // Get question details
        <span class="cov6" title="32">var question *models.Question
        question, err = s.getQuestionDetails(ctx, response.QuestionID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Update or create performance metrics
        <span class="cov6" title="32">query := `
                INSERT INTO performance_metrics (
                        user_id, topic, language, level, total_attempts, correct_attempts,
                        average_response_time_ms, difficulty_adjustment, last_updated
                )
                VALUES ($1, $2, $3, $4, 1, $5, $6, 0.0, CURRENT_TIMESTAMP)
                ON CONFLICT(user_id, topic, language, level) DO UPDATE SET
                        total_attempts = performance_metrics.total_attempts + 1,
                        correct_attempts = performance_metrics.correct_attempts + $7,
                        average_response_time_ms = (performance_metrics.average_response_time_ms * (performance_metrics.total_attempts - 1) + $8) / performance_metrics.total_attempts,
                        last_updated = CURRENT_TIMESTAMP
        `

        correctIncrement := 0
        if response.IsCorrect </span><span class="cov5" title="18">{
                correctIncrement = 1
        }</span>

        <span class="cov6" title="32">_, err = s.db.ExecContext(ctx, query,
                response.UserID,
                question.TopicCategory,
                question.Language,
                question.Level,
                correctIncrement,                 // For initial correct_attempts in VALUES
                float64(response.ResponseTimeMs), // For initial average_response_time_ms in VALUES
                correctIncrement,                 // For correct_attempts increment in UPDATE
                response.ResponseTimeMs,          // For average_response_time_ms calculation in UPDATE
        )

        return err</span>
}

func (s *LearningService) getQuestionDetails(ctx context.Context, questionID int) (result0 *models.Question, err error) <span class="cov6" title="32">{
        ctx, span := observability.TraceLearningFunction(ctx, "get_question_details",
                observability.AttributeQuestionID(questionID),
        )
        defer func() </span><span class="cov6" title="32">{
                if err != nil </span><span class="cov0" title="0">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov6" title="32">span.End()</span>
        }()

        <span class="cov6" title="32">query := `SELECT type, language, level, topic_category FROM questions WHERE id = $1`

        question := &amp;models.Question{}
        var topicCategory sql.NullString
        err = s.db.QueryRowContext(ctx, query, questionID).Scan(
                &amp;question.Type,
                &amp;question.Language,
                &amp;question.Level,
                &amp;topicCategory,
        )

        if topicCategory.Valid </span><span class="cov6" title="28">{
                question.TopicCategory = topicCategory.String
        }</span>

        <span class="cov6" title="32">return question, err</span>
}

// GetUserProgress retrieves comprehensive learning progress for a user
func (s *LearningService) GetUserProgress(ctx context.Context, userID int) (result0 *models.UserProgress, err error) <span class="cov1" title="1">{
        ctx, span := observability.TraceLearningFunction(ctx, "get_user_progress", observability.AttributeUserID(userID))
        defer func() </span><span class="cov1" title="1">{
                if err != nil </span><span class="cov0" title="0">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov1" title="1">span.End()</span>
        }()

        <span class="cov1" title="1">progress := &amp;models.UserProgress{
                PerformanceByTopic: make(map[string]*models.PerformanceMetrics),
        }

        // Get overall stats
        overallQuery := `
                SELECT
                        COUNT(*) as total,
                        COALESCE(SUM(CASE WHEN is_correct THEN 1 ELSE 0 END), 0) as correct
                FROM user_responses
                WHERE user_id = $1
        `

        err = s.db.QueryRowContext(ctx, overallQuery, userID).Scan(
                &amp;progress.TotalQuestions,
                &amp;progress.CorrectAnswers,
        )

        if err != nil &amp;&amp; err != sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if progress.TotalQuestions &gt; 0 </span><span class="cov1" title="1">{
                progress.AccuracyRate = float64(progress.CorrectAnswers) / float64(progress.TotalQuestions) * 100
        }</span>

        // Get performance by topic
        <span class="cov1" title="1">metricsQuery := `
                SELECT id, topic, language, level, total_attempts, correct_attempts,
                           average_response_time_ms, difficulty_adjustment, last_updated
                FROM performance_metrics
                WHERE user_id = $1
        `

        rows, err := s.db.QueryContext(ctx, metricsQuery, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">defer func() </span><span class="cov1" title="1">{
                if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn(ctx, "Failed to close rows", map[string]interface{}{"error": err.Error()})
                }</span>
        }()

        <span class="cov1" title="1">for rows.Next() </span><span class="cov1" title="1">{
                metric := &amp;models.PerformanceMetrics{UserID: userID}
                err = rows.Scan(
                        &amp;metric.ID,
                        &amp;metric.Topic,
                        &amp;metric.Language,
                        &amp;metric.Level,
                        &amp;metric.TotalAttempts,
                        &amp;metric.CorrectAttempts,
                        &amp;metric.AverageResponseTimeMs,
                        &amp;metric.DifficultyAdjustment,
                        &amp;metric.LastUpdated,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov1" title="1">key := metric.Topic + "_" + metric.Language + "_" + metric.Level
                progress.PerformanceByTopic[key] = metric</span>
        }

        // Identify weak areas (accuracy &lt; 60%)
        <span class="cov1" title="1">progress.WeakAreas = s.identifyWeakAreas(progress.PerformanceByTopic)

        // Get recent activity
        progress.RecentActivity, err = s.getRecentActivity(ctx, userID, 10)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Get current level from user
        <span class="cov1" title="1">currentLevel, err := s.getCurrentUserLevel(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">progress.CurrentLevel = currentLevel

        // Suggest level adjustment if needed
        progress.SuggestedLevel = s.suggestLevelAdjustment(progress)

        return progress, nil</span>
}

func (s *LearningService) identifyWeakAreas(metrics map[string]*models.PerformanceMetrics) []string <span class="cov1" title="1">{
        // Note: This is a pure function that doesn't need tracing since it doesn't make external calls
        // But we could add tracing if we want to track the analysis performance
        var weakAreas []string

        for key, metric := range metrics </span><span class="cov1" title="1">{
                if metric.TotalAttempts &gt; 0 &amp;&amp; metric.AccuracyRate() &lt; 60.0 &amp;&amp; metric.TotalAttempts &gt;= 3 </span><span class="cov0" title="0">{
                        weakAreas = append(weakAreas, key)
                }</span>
        }

        <span class="cov1" title="1">return weakAreas</span>
}

func (s *LearningService) getRecentActivity(ctx context.Context, userID, limit int) (result0 []models.UserResponse, err error) <span class="cov1" title="1">{
        ctx, span := observability.TraceLearningFunction(ctx, "get_recent_activity",
                observability.AttributeUserID(userID),
                attribute.Int("limit", limit),
        )
        defer func() </span><span class="cov1" title="1">{
                if err != nil </span><span class="cov0" title="0">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov1" title="1">span.End()</span>
        }()

        <span class="cov1" title="1">query := `
                SELECT id, user_id, question_id, user_answer, is_correct, response_time_ms, created_at
                FROM user_responses
                WHERE user_id = $1
                ORDER BY created_at DESC
                LIMIT $2
        `

        rows, err := s.db.QueryContext(ctx, query, userID, limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">defer func() </span><span class="cov1" title="1">{
                if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn(ctx, "Failed to close rows", map[string]interface{}{"error": err.Error()})
                }</span>
        }()

        <span class="cov1" title="1">var responses []models.UserResponse
        for rows.Next() </span><span class="cov2" title="3">{
                var response models.UserResponse
                err = rows.Scan(
                        &amp;response.ID,
                        &amp;response.UserID,
                        &amp;response.QuestionID,
                        &amp;response.UserAnswer,
                        &amp;response.IsCorrect,
                        &amp;response.ResponseTimeMs,
                        &amp;response.CreatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov2" title="3">responses = append(responses, response)</span>
        }

        <span class="cov1" title="1">return responses, nil</span>
}

func (s *LearningService) getCurrentUserLevel(ctx context.Context, userID int) (result0 string, err error) <span class="cov1" title="1">{
        ctx, span := observability.TraceLearningFunction(ctx, "get_current_user_level",
                observability.AttributeUserID(userID),
        )
        defer func() </span><span class="cov1" title="1">{
                if err != nil </span><span class="cov0" title="0">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov1" title="1">span.End()</span>
        }()

        <span class="cov1" title="1">query := `SELECT current_level FROM users WHERE id = $1`

        var level sql.NullString
        err = s.db.QueryRowContext(ctx, query, userID).Scan(&amp;level)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Return default level if NULL
        <span class="cov1" title="1">if !level.Valid || level.String == "" </span><span class="cov0" title="0">{
                return "A1", nil // Default level
        }</span>

        <span class="cov1" title="1">return level.String, nil</span>
}

func (s *LearningService) suggestLevelAdjustment(progress *models.UserProgress) string <span class="cov5" title="13">{
        // Note: This is a pure function that doesn't need tracing since it doesn't make external calls
        // But we could add tracing if we want to track the analysis performance
        if progress.TotalQuestions &lt; 20 </span><span class="cov2" title="3">{
                return "" // Not enough data
        }</span>

        // If accuracy is consistently high (&gt;85%), suggest level up
        <span class="cov3" title="5">if progress.AccuracyRate &gt; 85.0 </span><span class="cov2" title="2">{
                return s.getNextLevel(progress.CurrentLevel)
        }</span>

        // If accuracy is consistently low (&lt;50%), suggest level down
        <span class="cov2" title="3">if progress.AccuracyRate &lt; 50.0 </span><span class="cov2" title="2">{
                return s.getPreviousLevel(progress.CurrentLevel)
        }</span>

        <span class="cov1" title="1">return ""</span>
}

func (s *LearningService) getNextLevel(currentLevel string) string <span class="cov4" title="10">{
        // Note: This is a pure function that doesn't need tracing since it doesn't make external calls
        levels := s.cfg.AppConfig.GetAllLevels()

        for i, level := range levels </span><span class="cov7" title="45">{
                if level == currentLevel &amp;&amp; i &lt; len(levels)-1 </span><span class="cov4" title="8">{
                        return levels[i+1]
                }</span>
        }

        <span class="cov2" title="2">return currentLevel</span>
}

func (s *LearningService) getPreviousLevel(currentLevel string) string <span class="cov4" title="10">{
        // Note: This is a pure function that doesn't need tracing since it doesn't make external calls
        levels := s.cfg.AppConfig.GetAllLevels()

        for i, level := range levels </span><span class="cov7" title="54">{
                if level == currentLevel &amp;&amp; i &gt; 0 </span><span class="cov4" title="8">{
                        return levels[i-1]
                }</span>
        }

        <span class="cov2" title="2">return currentLevel</span>
}

// GetWeakestTopics returns the topics where the user performs poorest
func (s *LearningService) GetWeakestTopics(ctx context.Context, userID, limit int) (result0 []*models.PerformanceMetrics, err error) <span class="cov1" title="1">{
        ctx, span := observability.TraceLearningFunction(ctx, "get_weakest_topics",
                observability.AttributeUserID(userID),
                attribute.Int("limit", limit),
        )
        defer func() </span><span class="cov1" title="1">{
                if err != nil </span><span class="cov0" title="0">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov1" title="1">span.End()</span>
        }()

        <span class="cov1" title="1">query := `
                SELECT id, topic, language, level, total_attempts, correct_attempts, average_response_time_ms, difficulty_adjustment, last_updated
                FROM performance_metrics
                WHERE user_id = $1 AND total_attempts &gt;= 3
                ORDER BY (correct_attempts * 1.0 / total_attempts) ASC, last_updated ASC
                LIMIT $2
        `

        rows, err := s.db.QueryContext(ctx, query, userID, limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">defer func() </span><span class="cov1" title="1">{
                if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn(ctx, "Failed to close rows", map[string]interface{}{"error": err.Error()})
                }</span>
        }()

        <span class="cov1" title="1">var topics []*models.PerformanceMetrics
        for rows.Next() </span><span class="cov2" title="3">{
                metric := &amp;models.PerformanceMetrics{UserID: userID}
                err = rows.Scan(
                        &amp;metric.ID,
                        &amp;metric.Topic,
                        &amp;metric.Language,
                        &amp;metric.Level,
                        &amp;metric.TotalAttempts,
                        &amp;metric.CorrectAttempts,
                        &amp;metric.AverageResponseTimeMs,
                        &amp;metric.DifficultyAdjustment,
                        &amp;metric.LastUpdated,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov2" title="3">topics = append(topics, metric)</span>
        }

        <span class="cov1" title="1">return topics, nil</span>
}

// ShouldAvoidQuestion determines if a question should be avoided for a user
func (s *LearningService) ShouldAvoidQuestion(ctx context.Context, userID, questionID int) (result0 bool, err error) <span class="cov2" title="2">{
        ctx, span := observability.TraceLearningFunction(ctx, "should_avoid_question",
                observability.AttributeUserID(userID),
                observability.AttributeQuestionID(questionID),
        )
        defer func() </span><span class="cov2" title="2">{
                if err != nil </span><span class="cov0" title="0">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov2" title="2">span.End()</span>
        }()

        // Avoid questions answered correctly in the last 24 hours
        <span class="cov2" title="2">query := `
                SELECT COUNT(*)
                FROM user_responses
                WHERE user_id = $1 AND question_id = $2 AND is_correct = true
                AND created_at &gt; CURRENT_TIMESTAMP - INTERVAL '24 hours'
        `

        var count int
        err = s.db.QueryRowContext(ctx, query, userID, questionID).Scan(&amp;count)

        span.SetAttributes(attribute.Bool("should_avoid", count &gt; 0))
        return count &gt; 0, err</span>
}

// GetUserQuestionStats returns comprehensive per-user question statistics
func (s *LearningService) GetUserQuestionStats(ctx context.Context, userID int) (result0 *UserQuestionStats, err error) <span class="cov1" title="1">{
        ctx, span := observability.TraceLearningFunction(ctx, "get_user_question_stats",
                observability.AttributeUserID(userID),
        )
        defer func() </span><span class="cov1" title="1">{
                if err != nil </span><span class="cov0" title="0">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov1" title="1">span.End()</span>
        }()

        <span class="cov1" title="1">stats := &amp;UserQuestionStats{
                UserID:           userID,
                AnsweredByType:   make(map[string]int),
                AnsweredByLevel:  make(map[string]int),
                AccuracyByType:   make(map[string]float64),
                AccuracyByLevel:  make(map[string]float64),
                AvailableByType:  make(map[string]int),
                AvailableByLevel: make(map[string]int),
        }

        // Get user's language and level preferences
        var userLanguage, userLevel string
        userQuery := `SELECT COALESCE(preferred_language, 'italian'), COALESCE(current_level, 'B1') FROM users WHERE id = $1`
        err = s.db.QueryRowContext(ctx, userQuery, userID).Scan(&amp;userLanguage, &amp;userLevel)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">span.SetAttributes(
                attribute.String("user.language", userLanguage),
                attribute.String("user.level", userLevel),
        )

        // Get questions answered by user with stats
        answeredQuery := `
                SELECT
                        q.type,
                        q.level,
                        COUNT(*) as total,
                        SUM(CASE WHEN ur.is_correct THEN 1 ELSE 0 END) as correct
                FROM user_responses ur
                JOIN questions q ON ur.question_id = q.id
                WHERE ur.user_id = $1
                GROUP BY q.type, q.level
        `

        rows, err := s.db.QueryContext(ctx, answeredQuery, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">defer func() </span><span class="cov1" title="1">{
                if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn(ctx, "Failed to close rows", map[string]interface{}{"error": err.Error()})
                }</span>
        }()

        <span class="cov1" title="1">for rows.Next() </span><span class="cov1" title="1">{
                var qType, level string
                var total, correct int

                if err := rows.Scan(&amp;qType, &amp;level, &amp;total, &amp;correct); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov1" title="1">stats.AnsweredByType[qType] += total
                stats.AnsweredByLevel[level] += total
                stats.TotalAnswered += total

                // Calculate accuracy rates
                accuracy := float64(correct) / float64(total) * 100

                // For type accuracy, we need to aggregate across levels
                if _, exists := stats.AnsweredByType[qType]; exists </span><span class="cov1" title="1">{
                        // Recalculate accuracy for this type
                        typeQuery := `
                                SELECT
                                        COUNT(*) as total,
                                        SUM(CASE WHEN ur.is_correct THEN 1 ELSE 0 END) as correct
                                FROM user_responses ur
                                JOIN questions q ON ur.question_id = q.id
                                WHERE ur.user_id = $1 AND q.type = $2
                        `
                        var typeTotal, typeCorrect int
                        if err := s.db.QueryRowContext(ctx, typeQuery, userID, qType).Scan(&amp;typeTotal, &amp;typeCorrect); err != nil </span><span class="cov0" title="0">{
                                s.logger.Warn(ctx, "Failed to scan type query result", map[string]interface{}{"error": err.Error()})
                        }</span>
                        <span class="cov1" title="1">if typeTotal &gt; 0 </span><span class="cov1" title="1">{
                                stats.AccuracyByType[qType] = float64(typeCorrect) / float64(typeTotal) * 100
                        }</span>
                } else<span class="cov0" title="0"> {
                        stats.AccuracyByType[qType] = accuracy
                }</span>

                // For level accuracy
                <span class="cov1" title="1">if _, exists := stats.AnsweredByLevel[level]; exists </span><span class="cov1" title="1">{
                        // Recalculate accuracy for this level
                        levelQuery := `
                                SELECT
                                        COUNT(*) as total,
                                        SUM(CASE WHEN ur.is_correct THEN 1 ELSE 0 END) as correct
                                FROM user_responses ur
                                JOIN questions q ON ur.question_id = q.id
                                WHERE ur.user_id = $1 AND q.level = $2
                        `
                        var levelTotal, levelCorrect int
                        if err := s.db.QueryRowContext(ctx, levelQuery, userID, level).Scan(&amp;levelTotal, &amp;levelCorrect); err != nil </span><span class="cov0" title="0">{
                                s.logger.Warn(ctx, "Failed to scan level query result", map[string]interface{}{"error": err.Error()})
                        }</span>
                        <span class="cov1" title="1">if levelTotal &gt; 0 </span><span class="cov1" title="1">{
                                stats.AccuracyByLevel[level] = float64(levelCorrect) / float64(levelTotal) * 100
                        }</span>
                } else<span class="cov0" title="0"> {
                        stats.AccuracyByLevel[level] = accuracy
                }</span>
        }

        // Get available questions (not answered by user) that belong to this user
        <span class="cov1" title="1">availableQuery := `
                SELECT
                        q.type,
                        q.level,
                        COUNT(*) as available
                FROM questions q
                JOIN user_questions uq ON uq.question_id = q.id
                WHERE uq.user_id = $1
                AND q.language = $2
                AND q.status = 'active'
                AND q.id NOT IN (
                        SELECT DISTINCT question_id
                        FROM user_responses
                        WHERE user_id = $3
                )
                GROUP BY q.type, q.level
        `

        rows, err = s.db.QueryContext(ctx, availableQuery, userID, userLanguage, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">defer func() </span><span class="cov1" title="1">{
                if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn(ctx, "Failed to close rows", map[string]interface{}{"error": err.Error()})
                }</span>
        }()

        <span class="cov1" title="1">for rows.Next() </span><span class="cov0" title="0">{
                var qType, level string
                var available int

                if err := rows.Scan(&amp;qType, &amp;level, &amp;available); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">stats.AvailableByType[qType] += available
                stats.AvailableByLevel[level] += available</span>
        }

        // Get recently answered questions (within last hour)
        <span class="cov1" title="1">recentQuery := `
                SELECT COUNT(*)
                FROM user_responses ur
                WHERE ur.user_id = $1
                AND ur.created_at &gt; NOW() - INTERVAL '1 hour'
        `

        err = s.db.QueryRowContext(ctx, recentQuery, userID).Scan(&amp;stats.RecentlyAnswered)
        if err != nil </span><span class="cov0" title="0">{
                stats.RecentlyAnswered = 0 // Default to 0 if query fails
        }</span>

        // Calculate overall correct/incorrect answers and accuracy rate
        <span class="cov1" title="1">overallQuery := `
                SELECT
                        COUNT(*) as total,
                        SUM(CASE WHEN is_correct THEN 1 ELSE 0 END) as correct
                FROM user_responses
                WHERE user_id = $1
        `

        var total, correct int
        err = s.db.QueryRowContext(ctx, overallQuery, userID).Scan(&amp;total, &amp;correct)
        if err != nil </span><span class="cov0" title="0">{
                // Default values if query fails
                stats.CorrectAnswers = 0
                stats.IncorrectAnswers = 0
                stats.AccuracyRate = 0.0
        }</span> else<span class="cov1" title="1"> {
                stats.CorrectAnswers = correct
                stats.IncorrectAnswers = total - correct
                if total &gt; 0 </span><span class="cov1" title="1">{
                        stats.AccuracyRate = float64(correct) / float64(total) * 100
                }</span> else<span class="cov0" title="0"> {
                        stats.AccuracyRate = 0.0
                }</span>
        }

        <span class="cov1" title="1">return stats, nil</span>
}

// PRIORITY SYSTEM METHODS

// RecordAnswerWithPriority records a user's response and updates priority scores
func (s *LearningService) RecordAnswerWithPriority(ctx context.Context, userID, questionID int, answer string, isCorrect bool, responseTime int) error <span class="cov1" title="1">{
        // Create user response object
        response := &amp;models.UserResponse{
                UserID:         userID,
                QuestionID:     questionID,
                UserAnswer:     answer,
                IsCorrect:      isCorrect,
                ResponseTimeMs: responseTime,
                CreatedAt:      time.Now(),
        }

        // Use existing RecordUserResponse method
        err := s.RecordUserResponse(ctx, response)
        if err != nil </span><span class="cov0" title="0">{
                return contextutils.WrapError(err, "failed to record user response")
        }</span>

        // Update priority score in background
        <span class="cov1" title="1">go s.updatePriorityScoreAsync(ctx, userID, questionID)

        return nil</span>
}

// MarkQuestionAsKnown marks a question as known for a user
func (s *LearningService) MarkQuestionAsKnown(ctx context.Context, userID, questionID int) (err error) <span class="cov3" title="4">{
        ctx, span := observability.TraceLearningFunction(ctx, "mark_question_as_known",
                observability.AttributeUserID(userID),
                observability.AttributeQuestionID(questionID),
        )
        defer func() </span><span class="cov3" title="4">{
                if err != nil </span><span class="cov0" title="0">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov3" title="4">span.End()</span>
        }()

        // DEBUG: Log the attempt
        <span class="cov3" title="4">s.logger.Debug(ctx, "MarkQuestionAsKnown called", map[string]interface{}{
                "user_id":     userID,
                "question_id": questionID,
        })

        // Update user_question_metadata table
        _, err = s.db.ExecContext(ctx, `
                INSERT INTO user_question_metadata (user_id, question_id, marked_as_known, marked_as_known_at, created_at, updated_at)
                VALUES ($1, $2, TRUE, NOW(), NOW(), NOW())
                ON CONFLICT (user_id, question_id) DO UPDATE
                SET marked_as_known = TRUE, marked_as_known_at = NOW(), updated_at = NOW()
        `, userID, questionID)
        if err != nil </span><span class="cov0" title="0">{
                // DEBUG: Log the actual error
                s.logger.Debug(ctx, "MarkQuestionAsKnown error", map[string]interface{}{
                        "user_id":     userID,
                        "question_id": questionID,
                        "error":       err.Error(),
                        "error_type":  fmt.Sprintf("%T", err),
                })

                if isForeignKeyConstraintViolation(err) </span><span class="cov0" title="0">{
                        s.logger.Debug(ctx, "Foreign key constraint violation detected", map[string]interface{}{
                                "user_id":     userID,
                                "question_id": questionID,
                        })
                        return ErrQuestionNotFound
                }</span>
                <span class="cov0" title="0">s.logger.Debug(ctx, "Not a foreign key constraint violation, returning original error", map[string]interface{}{
                        "user_id":     userID,
                        "question_id": questionID,
                })
                return err</span>
        }

        <span class="cov3" title="4">s.logger.Debug(ctx, "MarkQuestionAsKnown succeeded", map[string]interface{}{
                "user_id":     userID,
                "question_id": questionID,
        })
        return nil</span>
}

// GetUserLearningPreferences retrieves user learning preferences
func (s *LearningService) GetUserLearningPreferences(ctx context.Context, userID int) (result0 *models.UserLearningPreferences, err error) <span class="cov10" title="212">{
        ctx, span := observability.TraceLearningFunction(ctx, "get_user_learning_preferences",
                observability.AttributeUserID(userID),
        )
        defer func() </span><span class="cov10" title="212">{
                if err != nil </span><span class="cov1" title="1">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov10" title="212">span.End()</span>
        }()

        <span class="cov10" title="212">var prefs models.UserLearningPreferences
        err = s.db.QueryRowContext(ctx, `
                SELECT id, user_id, focus_on_weak_areas, include_review_questions, fresh_question_ratio,
                       known_question_penalty, review_interval_days, weak_area_boost, created_at, updated_at
                FROM user_learning_preferences
                WHERE user_id = $1
        `, userID).Scan(
                &amp;prefs.ID, &amp;prefs.UserID, &amp;prefs.FocusOnWeakAreas, &amp;prefs.IncludeReviewQuestions,
                &amp;prefs.FreshQuestionRatio, &amp;prefs.KnownQuestionPenalty, &amp;prefs.ReviewIntervalDays,
                &amp;prefs.WeakAreaBoost, &amp;prefs.CreatedAt, &amp;prefs.UpdatedAt,
        )

        if err == sql.ErrNoRows </span><span class="cov4" title="8">{
                // Check if user exists before creating default preferences
                var userExists bool
                err = s.db.QueryRowContext(ctx, "SELECT EXISTS(SELECT 1 FROM users WHERE id = $1)", userID).Scan(&amp;userExists)
                if err != nil </span><span class="cov1" title="1">{
                        return nil, contextutils.WrapError(err, "failed to check if user exists")
                }</span>
                <span class="cov4" title="7">if !userExists </span><span class="cov0" title="0">{
                        return nil, contextutils.WrapErrorf(contextutils.ErrRecordNotFound, "user %d not found", userID)
                }</span>
                // Create default preferences if none exist
                <span class="cov4" title="7">return s.createDefaultPreferences(ctx, userID)</span>
        }

        <span class="cov9" title="204">if err != nil </span><span class="cov0" title="0">{
                return nil, contextutils.WrapError(err, "failed to get user preferences")
        }</span>

        <span class="cov9" title="204">return &amp;prefs, nil</span>
}

// UpdateUserLearningPreferences updates user learning preferences
func (s *LearningService) UpdateUserLearningPreferences(ctx context.Context, userID int, prefs *models.UserLearningPreferences) (result0 *models.UserLearningPreferences, err error) <span class="cov2" title="2">{
        ctx, span := observability.TraceLearningFunction(ctx, "update_user_learning_preferences",
                observability.AttributeUserID(userID),
                attribute.Bool("prefs.focus_on_weak_areas", prefs.FocusOnWeakAreas),
                attribute.Bool("prefs.include_review_questions", prefs.IncludeReviewQuestions),
                attribute.Float64("prefs.fresh_question_ratio", prefs.FreshQuestionRatio),
                attribute.Float64("prefs.known_question_penalty", prefs.KnownQuestionPenalty),
                attribute.Int("prefs.review_interval_days", prefs.ReviewIntervalDays),
                attribute.Float64("prefs.weak_area_boost", prefs.WeakAreaBoost),
        )
        defer func() </span><span class="cov2" title="2">{
                if err != nil </span><span class="cov0" title="0">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov2" title="2">span.End()</span>
        }()

        <span class="cov2" title="2">var updatedPrefs models.UserLearningPreferences
        err = s.db.QueryRowContext(ctx, `
                UPDATE user_learning_preferences
                SET focus_on_weak_areas = $2, include_review_questions = $3, fresh_question_ratio = $4,
                        known_question_penalty = $5, review_interval_days = $6, weak_area_boost = $7, updated_at = NOW()
                WHERE user_id = $1
                RETURNING id, user_id, focus_on_weak_areas, include_review_questions, fresh_question_ratio,
                          known_question_penalty, review_interval_days, weak_area_boost, created_at, updated_at
        `, userID, prefs.FocusOnWeakAreas, prefs.IncludeReviewQuestions, prefs.FreshQuestionRatio,
                prefs.KnownQuestionPenalty, prefs.ReviewIntervalDays, prefs.WeakAreaBoost).Scan(
                &amp;updatedPrefs.ID, &amp;updatedPrefs.UserID, &amp;updatedPrefs.FocusOnWeakAreas, &amp;updatedPrefs.IncludeReviewQuestions,
                &amp;updatedPrefs.FreshQuestionRatio, &amp;updatedPrefs.KnownQuestionPenalty, &amp;updatedPrefs.ReviewIntervalDays,
                &amp;updatedPrefs.WeakAreaBoost, &amp;updatedPrefs.CreatedAt, &amp;updatedPrefs.UpdatedAt,
        )

        if err == sql.ErrNoRows </span><span class="cov2" title="2">{
                // If no preferences exist, create them
                return s.createDefaultPreferences(ctx, userID)
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, contextutils.WrapError(err, "failed to update user preferences")
        }</span>

        <span class="cov0" title="0">return &amp;updatedPrefs, nil</span>
}

// createDefaultPreferences creates default learning preferences for a user
func (s *LearningService) createDefaultPreferences(ctx context.Context, userID int) (result0 *models.UserLearningPreferences, err error) <span class="cov4" title="9">{
        ctx, span := observability.TraceLearningFunction(ctx, "create_default_preferences",
                observability.AttributeUserID(userID),
        )
        defer func() </span><span class="cov4" title="9">{
                if err != nil </span><span class="cov0" title="0">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov4" title="9">span.End()</span>
        }()

        <span class="cov4" title="9">defaultPrefs := s.GetDefaultLearningPreferences()
        defaultPrefs.UserID = userID

        err = s.db.QueryRowContext(ctx, `
                INSERT INTO user_learning_preferences (user_id, focus_on_weak_areas, include_review_questions,
                                                       fresh_question_ratio, known_question_penalty,
                                                       review_interval_days, weak_area_boost, created_at, updated_at)
                VALUES ($1, $2, $3, $4, $5, $6, $7, NOW(), NOW())
                RETURNING id, created_at, updated_at
        `, userID, defaultPrefs.FocusOnWeakAreas, defaultPrefs.IncludeReviewQuestions,
                defaultPrefs.FreshQuestionRatio, defaultPrefs.KnownQuestionPenalty,
                defaultPrefs.ReviewIntervalDays, defaultPrefs.WeakAreaBoost).Scan(
                &amp;defaultPrefs.ID, &amp;defaultPrefs.CreatedAt, &amp;defaultPrefs.UpdatedAt,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, contextutils.WrapError(err, "failed to create default preferences")
        }</span>

        <span class="cov4" title="9">return defaultPrefs, nil</span>
}

// GetDefaultLearningPreferences returns default learning preferences
func (s *LearningService) GetDefaultLearningPreferences() *models.UserLearningPreferences <span class="cov4" title="9">{
        return &amp;models.UserLearningPreferences{
                FocusOnWeakAreas:       true,
                IncludeReviewQuestions: true,
                FreshQuestionRatio:     0.3,
                KnownQuestionPenalty:   0.1,
                ReviewIntervalDays:     7,
                WeakAreaBoost:          2.0,
        }
}</span>

// CalculatePriorityScore calculates priority score for a specific question for a user
func (s *LearningService) CalculatePriorityScore(ctx context.Context, userID, questionID int) (result0 float64, err error) <span class="cov4" title="6">{
        ctx, span := observability.TraceLearningFunction(ctx, "calculate_priority_score",
                observability.AttributeUserID(userID),
                observability.AttributeQuestionID(questionID),
        )
        defer func() </span><span class="cov4" title="6">{
                if err != nil </span><span class="cov1" title="1">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov4" title="6">span.End()</span>
        }()

        // Get user preferences
        <span class="cov4" title="6">prefs, err := s.GetUserLearningPreferences(ctx, userID)
        if err != nil </span><span class="cov1" title="1">{
                return 0, contextutils.WrapErrorf(contextutils.ErrDatabaseQuery, "failed to get user preferences: %w", err)
        }</span>

        // Get user's performance history for this question
        <span class="cov3" title="5">performance, err := s.getQuestionPerformance(ctx, userID, questionID)
        if err != nil </span><span class="cov0" title="0">{
                return 0, contextutils.WrapErrorf(contextutils.ErrDatabaseQuery, "failed to get question performance: %w", err)
        }</span>

        // Calculate components
        <span class="cov3" title="5">baseScore := 100.0
        performanceMultiplier := s.calculatePerformanceMultiplier(performance, prefs.WeakAreaBoost)
        spacedRepetitionBoost := s.calculateSpacedRepetitionBoost(performance.LastSeenAt)
        userPreferenceMultiplier := s.calculateUserPreferenceMultiplier(performance, prefs)
        freshnessBoost := s.calculateFreshnessBoost(performance.TimesAnswered)

        // Final score with bounds checking
        finalScore := baseScore * performanceMultiplier * spacedRepetitionBoost * userPreferenceMultiplier * freshnessBoost

        // Apply bounds to prevent extreme values
        if finalScore &lt; 1.0 </span><span class="cov0" title="0">{
                finalScore = 1.0
        }</span> else<span class="cov3" title="5"> if finalScore &gt; 1000.0 </span><span class="cov0" title="0">{
                finalScore = 1000.0
        }</span>

        <span class="cov3" title="5">return finalScore, nil</span>
}

// updatePriorityScoreAsync updates priority score for a question asynchronously
func (s *LearningService) updatePriorityScoreAsync(ctx context.Context, userID, questionID int) <span class="cov2" title="2">{
        ctx, span := observability.TraceLearningFunction(ctx, "update_priority_score_async",
                observability.AttributeUserID(userID),
                observability.AttributeQuestionID(questionID),
        )
        defer span.End()

        score, err := s.CalculatePriorityScore(ctx, userID, questionID)
        if err != nil </span><span class="cov1" title="1">{
                s.logger.Error(ctx, "Failed to calculate priority score", err, map[string]interface{}{
                        "user_id":     userID,
                        "question_id": questionID,
                })
                return
        }</span>

        // Update or insert priority score
        <span class="cov1" title="1">_, err = s.db.ExecContext(ctx, `
                INSERT INTO question_priority_scores (user_id, question_id, priority_score, last_calculated_at, created_at, updated_at)
                VALUES ($1, $2, $3, NOW(), NOW(), NOW())
                ON CONFLICT (user_id, question_id) DO UPDATE
                SET priority_score = $3, last_calculated_at = NOW(), updated_at = NOW()
        `, userID, questionID, score)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error(ctx, "Failed to update priority score", err, map[string]interface{}{
                        "user_id":     userID,
                        "question_id": questionID,
                        "score":       score,
                })
        }</span>
}

// QuestionPerformance represents performance data for a specific question
type QuestionPerformance struct {
        TimesAnswered   int
        CorrectAnswers  int
        LastSeenAt      *time.Time
        MarkedAsKnown   bool
        MarkedAsKnownAt *time.Time
}

// getQuestionPerformance retrieves performance data for a specific question
func (s *LearningService) getQuestionPerformance(ctx context.Context, userID, questionID int) (result0 *QuestionPerformance, err error) <span class="cov3" title="5">{
        ctx, span := observability.TraceLearningFunction(ctx, "get_question_performance",
                observability.AttributeUserID(userID),
                observability.AttributeQuestionID(questionID),
        )
        defer func() </span><span class="cov3" title="5">{
                if err != nil </span><span class="cov0" title="0">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov3" title="5">span.End()</span>
        }()

        <span class="cov3" title="5">performance := &amp;QuestionPerformance{}

        // Get response statistics
        err = s.db.QueryRowContext(ctx, `
                SELECT
                        COUNT(*) as times_answered,
                        COALESCE(SUM(CASE WHEN is_correct THEN 1 ELSE 0 END), 0) as correct_answers,
                        MAX(created_at) as last_seen_at
                FROM user_responses
                WHERE user_id = $1 AND question_id = $2
        `, userID, questionID).Scan(
                &amp;performance.TimesAnswered,
                &amp;performance.CorrectAnswers,
                &amp;performance.LastSeenAt,
        )

        if err != nil &amp;&amp; err != sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, contextutils.WrapErrorf(contextutils.ErrDatabaseQuery, "failed to get response statistics: %w", err)
        }</span>

        // Get metadata
        <span class="cov3" title="5">var markedAsKnownAt sql.NullTime
        err = s.db.QueryRowContext(ctx, `
                SELECT marked_as_known, marked_as_known_at
                FROM user_question_metadata
                WHERE user_id = $1 AND question_id = $2
        `, userID, questionID).Scan(&amp;performance.MarkedAsKnown, &amp;markedAsKnownAt)

        if err != nil &amp;&amp; err != sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, contextutils.WrapErrorf(contextutils.ErrDatabaseQuery, "failed to get question metadata: %w", err)
        }</span>

        <span class="cov3" title="5">if markedAsKnownAt.Valid </span><span class="cov1" title="1">{
                performance.MarkedAsKnownAt = &amp;markedAsKnownAt.Time
        }</span>

        <span class="cov3" title="5">return performance, nil</span>
}

// calculatePerformanceMultiplier calculates the performance-based multiplier
func (s *LearningService) calculatePerformanceMultiplier(performance *QuestionPerformance, weakAreaBoost float64) float64 <span class="cov3" title="5">{
        // Note: This is a pure function that doesn't need tracing since it doesn't make external calls
        if performance.TimesAnswered == 0 </span><span class="cov2" title="2">{
                return 1.0 // Neutral for new questions
        }</span>

        <span class="cov2" title="3">errorRate := float64(performance.TimesAnswered-performance.CorrectAnswers) / float64(performance.TimesAnswered)
        successRate := float64(performance.CorrectAnswers) / float64(performance.TimesAnswered)

        // Apply weak area boost for questions with high error rates
        multiplier := 1.0 + (errorRate * weakAreaBoost) - (successRate * 0.5)

        // Apply bounds to prevent extreme values
        if multiplier &lt; 0.1 </span><span class="cov0" title="0">{
                multiplier = 0.1
        }</span> else<span class="cov2" title="3"> if multiplier &gt; 10.0 </span><span class="cov0" title="0">{
                multiplier = 10.0
        }</span>

        <span class="cov2" title="3">return multiplier</span>
}

// calculateSpacedRepetitionBoost calculates the spaced repetition boost
func (s *LearningService) calculateSpacedRepetitionBoost(lastSeenAt *time.Time) float64 <span class="cov3" title="5">{
        // Note: This is a pure function that doesn't need tracing since it doesn't make external calls
        if lastSeenAt == nil </span><span class="cov2" title="2">{
                return 1.0 // No boost for never-seen questions
        }</span>

        <span class="cov2" title="3">daysSinceLastSeen := time.Since(*lastSeenAt).Hours() / 24.0
        boost := 1.0 + (daysSinceLastSeen * 0.1)

        // Cap the boost at 5.0x multiplier
        return math.Min(boost, 5.0)</span>
}

// calculateUserPreferenceMultiplier calculates the user preference multiplier
func (s *LearningService) calculateUserPreferenceMultiplier(performance *QuestionPerformance, prefs *models.UserLearningPreferences) float64 <span class="cov3" title="5">{
        // Note: This is a pure function that doesn't need tracing since it doesn't make external calls
        if performance.MarkedAsKnown </span><span class="cov1" title="1">{
                return prefs.KnownQuestionPenalty
        }</span>
        <span class="cov3" title="4">return 1.0</span>
}

// calculateFreshnessBoost calculates the freshness boost for new questions
func (s *LearningService) calculateFreshnessBoost(timesAnswered int) float64 <span class="cov3" title="5">{
        // Note: This is a pure function that doesn't need tracing since it doesn't make external calls
        if timesAnswered == 0 </span><span class="cov2" title="2">{
                return 1.5 // Boost for fresh questions
        }</span>
        <span class="cov2" title="3">return 1.0</span>
}

// isForeignKeyConstraintViolation checks if the error is a foreign key constraint violation
func isForeignKeyConstraintViolation(err error) bool <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check for PostgreSQL foreign key constraint violation error code
        <span class="cov0" title="0">if pqErr, ok := err.(*pq.Error); ok </span><span class="cov0" title="0">{
                // PostgreSQL error code 23503 is for foreign key constraint violations
                if pqErr.Code == "23503" </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        // Also check for the error message pattern as a fallback
        <span class="cov0" title="0">errorStr := err.Error()
        return strings.Contains(errorStr, "violates foreign key constraint")</span>
}

// Analytics Methods

// GetPriorityScoreDistribution returns the distribution of priority scores
func (s *LearningService) GetPriorityScoreDistribution(ctx context.Context) (result0 map[string]interface{}, err error) <span class="cov1" title="1">{
        ctx, span := observability.TraceLearningFunction(ctx, "get_priority_score_distribution")
        defer func() </span><span class="cov1" title="1">{
                if err != nil </span><span class="cov0" title="0">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov1" title="1">span.End()</span>
        }()

        <span class="cov1" title="1">query := `
                SELECT
                        COUNT(CASE WHEN qps.priority_score &gt; 200 THEN 1 END) as high,
                        COUNT(CASE WHEN qps.priority_score BETWEEN 100 AND 200 THEN 1 END) as medium,
                        COUNT(CASE WHEN qps.priority_score &lt; 100 THEN 1 END) as low,
                        AVG(qps.priority_score) as average
                FROM question_priority_scores qps
                JOIN questions q ON qps.question_id = q.id
                WHERE qps.priority_score &gt; 0
        `

        var high, medium, low int
        var average sql.NullFloat64

        err = s.db.QueryRowContext(ctx, query).Scan(&amp;high, &amp;medium, &amp;low, &amp;average)
        if err != nil </span><span class="cov0" title="0">{
                return nil, contextutils.WrapErrorf(contextutils.ErrDatabaseQuery, "failed to get priority score distribution: %w", err)
        }</span>

        <span class="cov1" title="1">result := map[string]interface{}{
                "high":    high,
                "medium":  medium,
                "low":     low,
                "average": 0.0,
        }

        if average.Valid </span><span class="cov1" title="1">{
                result["average"] = average.Float64
        }</span>

        <span class="cov1" title="1">span.SetAttributes(
                attribute.Int("high_count", high),
                attribute.Int("medium_count", medium),
                attribute.Int("low_count", low),
                attribute.Float64("average_score", result["average"].(float64)),
        )

        return result, nil</span>
}

// GetHighPriorityQuestions returns the highest priority questions
func (s *LearningService) GetHighPriorityQuestions(ctx context.Context, limit int) (result0 []map[string]interface{}, err error) <span class="cov1" title="1">{
        ctx, span := observability.TraceLearningFunction(ctx, "get_high_priority_questions",
                attribute.Int("limit", limit),
        )
        defer func() </span><span class="cov1" title="1">{
                if err != nil </span><span class="cov0" title="0">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov1" title="1">span.End()</span>
        }()

        <span class="cov1" title="1">query := `
                SELECT
                        q.type as question_type,
                        q.level,
                        q.topic_category as topic,
                        qps.priority_score
                FROM question_priority_scores qps
                JOIN questions q ON qps.question_id = q.id
                WHERE qps.priority_score &gt; 200
                ORDER BY qps.priority_score DESC
                LIMIT $1
        `

        rows, err := s.db.QueryContext(ctx, query, limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, contextutils.WrapErrorf(contextutils.ErrDatabaseQuery, "failed to get high priority questions: %w", err)
        }</span>
        <span class="cov1" title="1">defer func() </span><span class="cov1" title="1">{
                if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn(ctx, "Failed to close rows", map[string]interface{}{"error": err.Error()})
                }</span>
        }()

        <span class="cov1" title="1">var questions []map[string]interface{}
        for rows.Next() </span><span class="cov2" title="3">{
                var questionType, level, topic sql.NullString
                var priorityScore float64

                err = rows.Scan(&amp;questionType, &amp;level, &amp;topic, &amp;priorityScore)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov2" title="3">question := map[string]interface{}{
                        "question_type":  questionType.String,
                        "level":          level.String,
                        "topic":          topic.String,
                        "priority_score": priorityScore,
                }
                questions = append(questions, question)</span>
        }

        <span class="cov1" title="1">span.SetAttributes(attribute.Int("questions_count", len(questions)))
        return questions, nil</span>
}

// GetWeakAreasByTopic returns weak areas by topic
func (s *LearningService) GetWeakAreasByTopic(ctx context.Context, limit int) (result0 []map[string]interface{}, err error) <span class="cov1" title="1">{
        ctx, span := observability.TraceLearningFunction(ctx, "get_weak_areas_by_topic",
                attribute.Int("limit", limit),
        )
        defer func() </span><span class="cov1" title="1">{
                if err != nil </span><span class="cov0" title="0">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov1" title="1">span.End()</span>
        }()

        <span class="cov1" title="1">query := `
                SELECT
                        topic,
                        SUM(total_attempts) as total_attempts,
                        SUM(correct_attempts) as correct_attempts
                FROM performance_metrics
                WHERE total_attempts &gt; 0
                GROUP BY topic
                ORDER BY (SUM(correct_attempts)::float / SUM(total_attempts)) ASC
                LIMIT $1
        `

        rows, err := s.db.QueryContext(ctx, query, limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, contextutils.WrapErrorf(contextutils.ErrDatabaseQuery, "failed to get weak areas: %w", err)
        }</span>
        <span class="cov1" title="1">defer func() </span><span class="cov1" title="1">{
                if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn(ctx, "Failed to close rows", map[string]interface{}{"error": err.Error()})
                }</span>
        }()

        <span class="cov1" title="1">var weakAreas []map[string]interface{}
        for rows.Next() </span><span class="cov1" title="1">{
                var topic sql.NullString
                var totalAttempts, correctAttempts int

                err = rows.Scan(&amp;topic, &amp;totalAttempts, &amp;correctAttempts)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov1" title="1">area := map[string]interface{}{
                        "topic":            topic.String,
                        "total_attempts":   totalAttempts,
                        "correct_attempts": correctAttempts,
                }
                weakAreas = append(weakAreas, area)</span>
        }

        <span class="cov1" title="1">span.SetAttributes(attribute.Int("weak_areas_count", len(weakAreas)))
        return weakAreas, nil</span>
}

// GetLearningPreferencesUsage returns learning preferences usage statistics
func (s *LearningService) GetLearningPreferencesUsage(ctx context.Context) (result0 map[string]interface{}, err error) <span class="cov1" title="1">{
        ctx, span := observability.TraceLearningFunction(ctx, "get_learning_preferences_usage")
        defer func() </span><span class="cov1" title="1">{
                if err != nil </span><span class="cov0" title="0">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov1" title="1">span.End()</span>
        }()

        <span class="cov1" title="1">query := `
                SELECT
                        COUNT(*) as total_users,
                        AVG(focus_on_weak_areas::int) as avg_focus_on_weak_areas,
                        AVG(fresh_question_ratio) as avg_fresh_question_ratio,
                        AVG(weak_area_boost) as avg_weak_area_boost,
                        AVG(known_question_penalty) as avg_known_question_penalty
                FROM user_learning_preferences
        `

        var totalUsers int
        var avgFocusOnWeakAreas, avgFreshQuestionRatio, avgWeakAreaBoost, avgKnownQuestionPenalty sql.NullFloat64

        err = s.db.QueryRowContext(ctx, query).Scan(
                &amp;totalUsers,
                &amp;avgFocusOnWeakAreas,
                &amp;avgFreshQuestionRatio,
                &amp;avgWeakAreaBoost,
                &amp;avgKnownQuestionPenalty,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, contextutils.WrapErrorf(contextutils.ErrDatabaseQuery, "failed to get learning preferences usage: %w", err)
        }</span>

        <span class="cov1" title="1">result := map[string]interface{}{
                "total_users":          0,
                "focusOnWeakAreas":     false,
                "freshQuestionRatio":   0.3,
                "weakAreaBoost":        2.0,
                "knownQuestionPenalty": 0.1,
        }

        if totalUsers &gt; 0 </span><span class="cov1" title="1">{
                result["total_users"] = totalUsers
                if avgFocusOnWeakAreas.Valid </span><span class="cov1" title="1">{
                        result["focusOnWeakAreas"] = avgFocusOnWeakAreas.Float64 &gt; 0.5
                }</span>
                <span class="cov1" title="1">if avgFreshQuestionRatio.Valid </span><span class="cov1" title="1">{
                        result["freshQuestionRatio"] = avgFreshQuestionRatio.Float64
                }</span>
                <span class="cov1" title="1">if avgWeakAreaBoost.Valid </span><span class="cov1" title="1">{
                        result["weakAreaBoost"] = avgWeakAreaBoost.Float64
                }</span>
                <span class="cov1" title="1">if avgKnownQuestionPenalty.Valid </span><span class="cov1" title="1">{
                        result["knownQuestionPenalty"] = avgKnownQuestionPenalty.Float64
                }</span>
        }

        <span class="cov1" title="1">span.SetAttributes(
                attribute.Int("total_users", result["total_users"].(int)),
                attribute.Bool("focus_on_weak_areas", result["focusOnWeakAreas"].(bool)),
                attribute.Float64("fresh_question_ratio", result["freshQuestionRatio"].(float64)),
                attribute.Float64("weak_area_boost", result["weakAreaBoost"].(float64)),
                attribute.Float64("known_question_penalty", result["knownQuestionPenalty"].(float64)),
        )

        return result, nil</span>
}

// GetQuestionTypeGaps returns gaps in question types
func (s *LearningService) GetQuestionTypeGaps(ctx context.Context) (result0 []map[string]interface{}, err error) <span class="cov1" title="1">{
        ctx, span := observability.TraceLearningFunction(ctx, "get_question_type_gaps")
        defer func() </span><span class="cov1" title="1">{
                if err != nil </span><span class="cov0" title="0">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov1" title="1">span.End()</span>
        }()

        <span class="cov1" title="1">query := `
                SELECT
                        q.type as question_type,
                        q.level,
                        COUNT(q.id) as available,
                        COUNT(qps.question_id) as with_priority_scores
                FROM questions q
                LEFT JOIN question_priority_scores qps ON q.id = qps.question_id
                GROUP BY q.type, q.level
                HAVING COUNT(qps.question_id) &lt; COUNT(q.id) * 0.8
                ORDER BY (COUNT(qps.question_id)::float / COUNT(q.id)) ASC
        `

        rows, err := s.db.QueryContext(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                span.SetAttributes(attribute.String("error.type", "database_query_failed"), attribute.String("error", err.Error()))
                return nil, contextutils.WrapErrorf(contextutils.ErrDatabaseQuery, "failed to get question type gaps: %w", err)
        }</span>
        <span class="cov1" title="1">defer func() </span><span class="cov1" title="1">{
                if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn(ctx, "Failed to close rows in GetQuestionTypeGaps", map[string]interface{}{"error": err.Error()})
                }</span>
        }()

        <span class="cov1" title="1">var gaps []map[string]interface{}
        var scanErrors int

        for rows.Next() </span><span class="cov2" title="3">{
                var questionType, level sql.NullString
                var available, withPriorityScores int

                err = rows.Scan(&amp;questionType, &amp;level, &amp;available, &amp;withPriorityScores)
                if err != nil </span><span class="cov0" title="0">{
                        scanErrors++
                        span.SetAttributes(attribute.String("error.type", "row_scan_failed"), attribute.String("error", err.Error()))
                        continue</span>
                }

                <span class="cov2" title="3">gap := map[string]interface{}{
                        "question_type": questionType.String,
                        "level":         level.String,
                        "available":     available,
                        "demand":        available - withPriorityScores,
                }
                gaps = append(gaps, gap)</span>
        }

        <span class="cov1" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                span.SetAttributes(attribute.String("error.type", "rows_iteration_failed"), attribute.String("error", err.Error()))
                return nil, contextutils.WrapErrorf(contextutils.ErrDatabaseQuery, "error during rows iteration: %w", err)
        }</span>

        <span class="cov1" title="1">span.SetAttributes(
                attribute.Int("gaps_count", len(gaps)),
                attribute.Int("scan_errors", scanErrors),
        )
        return gaps, nil</span>
}

// GetGenerationSuggestions returns suggestions for question generation
func (s *LearningService) GetGenerationSuggestions(ctx context.Context) (result0 []map[string]interface{}, err error) <span class="cov1" title="1">{
        ctx, span := observability.TraceLearningFunction(ctx, "get_generation_suggestions")
        defer func() </span><span class="cov1" title="1">{
                if err != nil </span><span class="cov0" title="0">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov1" title="1">span.End()</span>
        }()

        <span class="cov1" title="1">query := `
                SELECT
                        q.type as question_type,
                        q.level,
                        q.language,
                        COUNT(q.id) as available,
                        COUNT(CASE WHEN qps.priority_score &gt; 100 THEN 1 END) as high_priority,
                        AVG(qps.priority_score) as avg_priority
                FROM questions q
                LEFT JOIN question_priority_scores qps ON q.id = qps.question_id
                GROUP BY q.type, q.level, q.language
                HAVING COUNT(q.id) &lt; 50 OR COUNT(CASE WHEN qps.priority_score &gt; 100 THEN 1 END) &lt; 10
                ORDER BY COUNT(q.id) ASC, AVG(qps.priority_score) DESC
        `

        rows, err := s.db.QueryContext(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                span.SetAttributes(attribute.String("error.type", "database_query_failed"), attribute.String("error", err.Error()))
                return nil, contextutils.WrapErrorf(contextutils.ErrDatabaseQuery, "failed to get generation suggestions: %w", err)
        }</span>
        <span class="cov1" title="1">defer func() </span><span class="cov1" title="1">{
                if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn(ctx, "Failed to close rows in GetGenerationSuggestions", map[string]interface{}{"error": err.Error()})
                }</span>
        }()

        <span class="cov1" title="1">var suggestions []map[string]interface{}
        var scanErrors int

        for rows.Next() </span><span class="cov1" title="1">{
                var questionType, level, language sql.NullString
                var available, highPriority int
                var avgPriority sql.NullFloat64

                err = rows.Scan(&amp;questionType, &amp;level, &amp;language, &amp;available, &amp;highPriority, &amp;avgPriority)
                if err != nil </span><span class="cov0" title="0">{
                        scanErrors++
                        span.SetAttributes(attribute.String("error.type", "row_scan_failed"), attribute.String("error", err.Error()))
                        continue</span>
                }

                <span class="cov1" title="1">suggestion := map[string]interface{}{
                        "question_type":  questionType.String,
                        "level":          level.String,
                        "language":       language.String,
                        "available":      available,
                        "high_priority":  highPriority,
                        "avg_priority":   0.0,
                        "priority_score": 0.0,
                }

                if avgPriority.Valid </span><span class="cov0" title="0">{
                        suggestion["avg_priority"] = avgPriority.Float64
                        suggestion["priority_score"] = avgPriority.Float64
                }</span>

                <span class="cov1" title="1">suggestions = append(suggestions, suggestion)</span>
        }

        <span class="cov1" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                span.SetAttributes(attribute.String("error.type", "rows_iteration_failed"), attribute.String("error", err.Error()))
                return nil, contextutils.WrapErrorf(contextutils.ErrDatabaseQuery, "error during rows iteration: %w", err)
        }</span>

        <span class="cov1" title="1">span.SetAttributes(
                attribute.Int("suggestions_count", len(suggestions)),
                attribute.Int("scan_errors", scanErrors),
        )
        return suggestions, nil</span>
}

// GetPrioritySystemPerformance returns performance metrics for the priority system
func (s *LearningService) GetPrioritySystemPerformance(ctx context.Context) (result0 map[string]interface{}, err error) <span class="cov1" title="1">{
        ctx, span := observability.TraceLearningFunction(ctx, "get_priority_system_performance")
        defer func() </span><span class="cov1" title="1">{
                if err != nil </span><span class="cov0" title="0">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov1" title="1">span.End()</span>
        }()

        // This is a simplified implementation - in a real system, this would track actual performance metrics
        <span class="cov1" title="1">query := `
                SELECT
                        COUNT(*) as total_calculations,
                        AVG(priority_score) as avg_score,
                        MAX(last_calculated_at) as last_calculation
                FROM question_priority_scores
                WHERE last_calculated_at &gt; NOW() - INTERVAL '1 hour'
        `

        var totalCalculations int
        var avgScore sql.NullFloat64
        var lastCalculation sql.NullTime

        err = s.db.QueryRowContext(ctx, query).Scan(&amp;totalCalculations, &amp;avgScore, &amp;lastCalculation)
        if err != nil </span><span class="cov0" title="0">{
                return nil, contextutils.WrapErrorf(contextutils.ErrDatabaseQuery, "failed to get priority system performance: %w", err)
        }</span>

        <span class="cov1" title="1">result := map[string]interface{}{
                "calculationsPerSecond": float64(totalCalculations) / 3600.0, // Per hour converted to per second
                "avgCalculationTime":    0.0,                                 // Would need to track actual calculation times
                "avgQueryTime":          0.0,                                 // Would need to track actual query times
                "memoryUsage":           0.0,                                 // Would need to track actual memory usage
                "avgScore":              0.0,                                 // Default value
        }

        if avgScore.Valid </span><span class="cov0" title="0">{
                result["avgScore"] = avgScore.Float64
        }</span>

        <span class="cov1" title="1">if lastCalculation.Valid </span><span class="cov0" title="0">{
                result["lastCalculation"] = lastCalculation.Time.Format(time.RFC3339)
        }</span>

        <span class="cov1" title="1">span.SetAttributes(
                attribute.Float64("calculations_per_second", result["calculationsPerSecond"].(float64)),
                attribute.Float64("avg_score", result["avgScore"].(float64)),
                attribute.Int("total_calculations", totalCalculations),
        )

        return result, nil</span>
}

// GetBackgroundJobsStatus returns the status of background jobs
func (s *LearningService) GetBackgroundJobsStatus(ctx context.Context) (result0 map[string]interface{}, err error) <span class="cov1" title="1">{
        ctx, span := observability.TraceLearningFunction(ctx, "get_background_jobs_status")
        defer func() </span><span class="cov1" title="1">{
                if err != nil </span><span class="cov0" title="0">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov1" title="1">span.End()</span>
        }()

        // This is a simplified implementation - in a real system, this would track actual background job status
        <span class="cov1" title="1">query := `
                SELECT
                        COUNT(*) as total_updates,
                        MAX(updated_at) as last_update
                FROM question_priority_scores
                WHERE updated_at &gt; NOW() - INTERVAL '1 minute'
        `

        var totalUpdates int
        var lastUpdate sql.NullTime

        err = s.db.QueryRowContext(ctx, query).Scan(&amp;totalUpdates, &amp;lastUpdate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, contextutils.WrapError(err, "failed to get background jobs status")
        }</span>

        <span class="cov1" title="1">result := map[string]interface{}{
                "priorityUpdates": totalUpdates,
                "lastUpdate":      "N/A",
                "queueSize":       0, // Would need to track actual queue size
                "status":          "healthy",
        }

        if lastUpdate.Valid </span><span class="cov0" title="0">{
                result["lastUpdate"] = lastUpdate.Time.Format(time.RFC3339)
        }</span>

        <span class="cov1" title="1">if totalUpdates == 0 </span><span class="cov1" title="1">{
                result["status"] = "idle"
        }</span>

        <span class="cov1" title="1">span.SetAttributes(
                attribute.Int("priority_updates", totalUpdates),
                attribute.String("status", result["status"].(string)),
                attribute.Int("queue_size", result["queueSize"].(int)),
        )

        return result, nil</span>
}

// GetUserPriorityScoreDistribution returns priority score distribution for a specific user
func (s *LearningService) GetUserPriorityScoreDistribution(ctx context.Context, userID int) (result0 map[string]interface{}, err error) <span class="cov2" title="3">{
        ctx, span := observability.TraceLearningFunction(ctx, "get_user_priority_score_distribution",
                observability.AttributeUserID(userID),
        )
        defer func() </span><span class="cov2" title="3">{
                if err != nil </span><span class="cov0" title="0">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov2" title="3">span.End()</span>
        }()

        <span class="cov2" title="3">query := `
                SELECT
                        COUNT(CASE WHEN priority_score &gt; 200 THEN 1 END) as high,
                        COUNT(CASE WHEN priority_score BETWEEN 100 AND 200 THEN 1 END) as medium,
                        COUNT(CASE WHEN priority_score &lt; 100 THEN 1 END) as low,
                        AVG(priority_score) as average
                FROM question_priority_scores
                WHERE user_id = $1 AND priority_score &gt; 0
        `

        var high, medium, low int
        var average sql.NullFloat64

        err = s.db.QueryRowContext(ctx, query, userID).Scan(&amp;high, &amp;medium, &amp;low, &amp;average)
        if err != nil </span><span class="cov0" title="0">{
                return nil, contextutils.WrapError(err, "failed to get user priority score distribution")
        }</span>

        <span class="cov2" title="3">result := map[string]interface{}{
                "high":    high,
                "medium":  medium,
                "low":     low,
                "average": 0.0,
        }

        if average.Valid </span><span class="cov2" title="2">{
                result["average"] = average.Float64
        }</span>

        <span class="cov2" title="3">span.SetAttributes(
                attribute.Int("high_count", high),
                attribute.Int("medium_count", medium),
                attribute.Int("low_count", low),
                attribute.Float64("average_score", result["average"].(float64)),
        )

        return result, nil</span>
}

// GetUserHighPriorityQuestions returns the highest priority questions for a specific user
func (s *LearningService) GetUserHighPriorityQuestions(ctx context.Context, userID, limit int) (result0 []map[string]interface{}, err error) <span class="cov3" title="5">{
        ctx, span := observability.TraceLearningFunction(ctx, "get_user_high_priority_questions",
                observability.AttributeUserID(userID),
                attribute.Int("limit", limit),
        )
        defer func() </span><span class="cov3" title="5">{
                if err != nil </span><span class="cov0" title="0">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov3" title="5">span.End()</span>
        }()

        <span class="cov3" title="5">query := `
                SELECT
                        q.type as question_type,
                        q.level,
                        q.topic_category as topic,
                        qps.priority_score
                FROM question_priority_scores qps
                JOIN questions q ON qps.question_id = q.id
                WHERE qps.user_id = $1 AND qps.priority_score &gt; 200
                ORDER BY qps.priority_score DESC
                LIMIT $2
        `

        rows, err := s.db.QueryContext(ctx, query, userID, limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, contextutils.WrapError(err, "failed to get user high priority questions")
        }</span>
        <span class="cov3" title="5">defer func() </span><span class="cov3" title="5">{
                if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn(ctx, "Failed to close rows", map[string]interface{}{"error": err.Error()})
                }</span>
        }()

        <span class="cov3" title="5">var questions []map[string]interface{}
        for rows.Next() </span><span class="cov4" title="9">{
                var questionType, level, topic sql.NullString
                var priorityScore float64

                err = rows.Scan(&amp;questionType, &amp;level, &amp;topic, &amp;priorityScore)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov4" title="9">question := map[string]interface{}{
                        "question_type":  questionType.String,
                        "level":          level.String,
                        "topic":          topic.String,
                        "priority_score": priorityScore,
                }
                questions = append(questions, question)</span>
        }

        <span class="cov3" title="5">span.SetAttributes(attribute.Int("questions_count", len(questions)))
        return questions, nil</span>
}

// GetUserWeakAreas returns weak areas for a specific user
func (s *LearningService) GetUserWeakAreas(ctx context.Context, userID, limit int) (result0 []map[string]interface{}, err error) <span class="cov4" title="7">{
        ctx, span := observability.TraceLearningFunction(ctx, "get_user_weak_areas",
                observability.AttributeUserID(userID),
                attribute.Int("limit", limit),
        )
        defer func() </span><span class="cov4" title="7">{
                if err != nil </span><span class="cov1" title="1">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov4" title="7">span.End()</span>
        }()

        <span class="cov4" title="7">query := `
                SELECT
                        topic,
                        total_attempts,
                        correct_attempts
                FROM performance_metrics
                WHERE user_id = $1 AND total_attempts &gt; 0
                ORDER BY (correct_attempts::float / total_attempts) ASC
                LIMIT $2
        `

        rows, err := s.db.QueryContext(ctx, query, userID, limit)
        if err != nil </span><span class="cov1" title="1">{
                return nil, contextutils.WrapError(err, "failed to get user weak areas")
        }</span>
        <span class="cov4" title="6">defer func() </span><span class="cov4" title="6">{
                if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn(ctx, "Failed to close rows", map[string]interface{}{"error": err.Error()})
                }</span>
        }()

        <span class="cov4" title="6">var weakAreas []map[string]interface{}
        for rows.Next() </span><span class="cov4" title="8">{
                var topic sql.NullString
                var totalAttempts, correctAttempts int

                err = rows.Scan(&amp;topic, &amp;totalAttempts, &amp;correctAttempts)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov4" title="8">area := map[string]interface{}{
                        "topic":            topic.String,
                        "total_attempts":   totalAttempts,
                        "correct_attempts": correctAttempts,
                }
                weakAreas = append(weakAreas, area)</span>
        }

        <span class="cov4" title="6">span.SetAttributes(attribute.Int("weak_areas_count", len(weakAreas)))
        return weakAreas, nil</span>
}

// Priority generation methods moved to worker
</pre>
		
		<pre class="file" id="file30" style="display: none">package services

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "net/http"
        "net/url"
        "strings"

        "go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp"
        "go.opentelemetry.io/otel/attribute"
        "go.opentelemetry.io/otel/codes"
        "go.opentelemetry.io/otel/trace"

        "quizapp/internal/config"
        "quizapp/internal/models"
        "quizapp/internal/observability"
        contextutils "quizapp/internal/utils"
)

// ErrSignupsDisabled is returned when user registration is disabled by config
var ErrSignupsDisabled = errors.New("user registration is currently disabled")

// OAuth sentinel errors
var (
        ErrOAuthCodeAlreadyUsed  = errors.New("authorization code has already been used")
        ErrOAuthClientConfig     = errors.New("OAuth client configuration error")
        ErrOAuthInvalidRequest   = errors.New("invalid OAuth request")
        ErrOAuthUnauthorized     = errors.New("OAuth client is not authorized")
        ErrOAuthUnsupportedGrant = errors.New("unsupported OAuth grant type")
)

// OAuthService handles OAuth authentication flows
type OAuthService struct {
        config           *config.Config
        TokenEndpoint    string // for testing/mocking
        UserInfoEndpoint string // for testing/mocking
        logger           *observability.Logger
}

// NewOAuthServiceWithLogger creates a new OAuth service with logger
func NewOAuthServiceWithLogger(cfg *config.Config, logger *observability.Logger) *OAuthService <span class="cov10" title="7">{
        return &amp;OAuthService{
                config:           cfg,
                TokenEndpoint:    "https://oauth2.googleapis.com/token",
                UserInfoEndpoint: "https://www.googleapis.com/oauth2/v2/userinfo",
                logger:           logger,
        }
}</span>

// GoogleUserInfo represents the user information returned by Google OAuth
type GoogleUserInfo struct {
        ID            string `json:"id"`
        Email         string `json:"email"`
        Name          string `json:"name"`
        GivenName     string `json:"given_name"`
        FamilyName    string `json:"family_name"`
        Picture       string `json:"picture"`
        VerifiedEmail bool   `json:"verified_email"`
}

// GoogleTokenResponse represents the token response from Google OAuth
type GoogleTokenResponse struct {
        AccessToken  string `json:"access_token"`
        TokenType    string `json:"token_type"`
        ExpiresIn    int    `json:"expires_in"`
        RefreshToken string `json:"refresh_token,omitempty"`
        IDToken      string `json:"id_token,omitempty"`
}

// GetGoogleAuthURL generates the Google OAuth authorization URL
func (s *OAuthService) GetGoogleAuthURL(ctx context.Context, state string) string <span class="cov1" title="1">{
        _, span := observability.TraceOAuthFunction(ctx, "get_google_auth_url",
                attribute.String("oauth.state", state),
                attribute.String("oauth.client_id", s.config.GoogleOAuthClientID),
                attribute.String("oauth.redirect_url", s.config.GoogleOAuthRedirectURL),
        )
        defer span.End()

        // Debug logging
        if s.config.GoogleOAuthClientID == "" </span><span class="cov0" title="0">{
                fmt.Printf("WARNING: GoogleOAuthClientID is not set. Please set GOOGLE_OAUTH_CLIENT_ID environment variable.\n")
        }</span>
        <span class="cov1" title="1">if s.config.GoogleOAuthRedirectURL == "" </span><span class="cov0" title="0">{
                fmt.Printf("WARNING: GoogleOAuthRedirectURL is not set. Please set GOOGLE_OAUTH_REDIRECT_URL environment variable.\n")
        }</span>

        <span class="cov1" title="1">params := url.Values{}
        params.Set("client_id", s.config.GoogleOAuthClientID)
        params.Set("redirect_uri", s.config.GoogleOAuthRedirectURL)
        params.Set("response_type", "code")
        params.Set("scope", "openid email profile")
        params.Set("state", state)
        params.Set("access_type", "offline")
        params.Set("prompt", "consent")

        return fmt.Sprintf("https://accounts.google.com/o/oauth2/v2/auth?%s", params.Encode())</span>
}

// ExchangeCodeForToken exchanges the authorization code for an access token
func (s *OAuthService) ExchangeCodeForToken(ctx context.Context, code string) (result0 *GoogleTokenResponse, err error) <span class="cov4" title="2">{
        ctx, span := observability.TraceOAuthFunction(ctx, "exchange_code_for_token",
                attribute.String("oauth.code", code),
                attribute.String("oauth.token_endpoint", s.TokenEndpoint),
        )
        defer func() </span><span class="cov4" title="2">{
                if err != nil </span><span class="cov0" title="0">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov4" title="2">span.End()</span>
        }()

        <span class="cov4" title="2">data := url.Values{}
        data.Set("client_id", s.config.GoogleOAuthClientID)
        data.Set("client_secret", s.config.GoogleOAuthClientSecret)
        data.Set("code", code)
        data.Set("grant_type", "authorization_code")
        data.Set("redirect_uri", s.config.GoogleOAuthRedirectURL)

        tokenURL := s.TokenEndpoint
        if tokenURL == "" </span><span class="cov0" title="0">{
                tokenURL = "https://oauth2.googleapis.com/token"
        }</span>

        <span class="cov4" title="2">req, err := http.NewRequest("POST", tokenURL, strings.NewReader(data.Encode()))
        if err != nil </span><span class="cov0" title="0">{
                span.SetAttributes(attribute.String("error", err.Error()))
                return nil, contextutils.WrapError(err, "failed to create token request")
        }</span>

        <span class="cov4" title="2">req.Header.Set("Content-Type", "application/x-www-form-urlencoded")

        // Use instrumented HTTP client for automatic tracing with explicit span options
        client := &amp;http.Client{
                Timeout: config.OAuthHTTPTimeout,
                Transport: otelhttp.NewTransport(http.DefaultTransport,
                        otelhttp.WithSpanOptions(trace.WithSpanKind(trace.SpanKindClient)),
                ),
        }
        resp, err := client.Do(req.WithContext(ctx))
        if err != nil </span><span class="cov0" title="0">{
                span.SetAttributes(attribute.String("error", err.Error()))
                return nil, contextutils.WrapError(err, "failed to exchange code for token")
        }</span>
        <span class="cov4" title="2">defer func() </span><span class="cov4" title="2">{
                err = resp.Body.Close()
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn(ctx, "Failed to close response body", map[string]interface{}{"error": err.Error()})
                }</span>
        }()

        <span class="cov4" title="2">span.SetAttributes(attribute.Int("http.status_code", resp.StatusCode))

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)

                // Try to parse the error response for better error messages
                var errorResp struct {
                        Error            string `json:"error"`
                        ErrorDescription string `json:"error_description"`
                }

                if json.Unmarshal(body, &amp;errorResp) == nil </span><span class="cov0" title="0">{
                        span.SetAttributes(
                                attribute.String("oauth.error", errorResp.Error),
                                attribute.String("oauth.error_description", errorResp.ErrorDescription),
                        )
                        switch errorResp.Error </span>{
                        case "invalid_grant":<span class="cov0" title="0">
                                return nil, contextutils.WrapErrorf(ErrOAuthCodeAlreadyUsed, "please try signing in again")</span>
                        case "invalid_client":<span class="cov0" title="0">
                                return nil, contextutils.WrapError(ErrOAuthClientConfig, "")</span>
                        case "invalid_request":<span class="cov0" title="0">
                                return nil, contextutils.WrapError(ErrOAuthInvalidRequest, "")</span>
                        case "unauthorized_client":<span class="cov0" title="0">
                                return nil, contextutils.WrapError(ErrOAuthUnauthorized, "")</span>
                        case "unsupported_grant_type":<span class="cov0" title="0">
                                return nil, contextutils.WrapError(ErrOAuthUnsupportedGrant, "")</span>
                        default:<span class="cov0" title="0">
                                return nil, contextutils.WrapErrorf(contextutils.ErrOAuthProviderError, "OAuth error: %s - %s", errorResp.Error, errorResp.ErrorDescription)</span>
                        }
                }

                <span class="cov0" title="0">return nil, contextutils.WrapErrorf(contextutils.ErrOAuthProviderError, "token exchange failed with status %d: %s", resp.StatusCode, string(body))</span>
        }

        <span class="cov4" title="2">var tokenResp GoogleTokenResponse
        if err := json.NewDecoder(resp.Body).Decode(&amp;tokenResp); err != nil </span><span class="cov0" title="0">{
                span.SetAttributes(attribute.String("error", err.Error()))
                return nil, contextutils.WrapError(err, "failed to decode token response")
        }</span>

        <span class="cov4" title="2">span.SetAttributes(
                attribute.String("oauth.token_type", tokenResp.TokenType),
                attribute.Int("oauth.expires_in", tokenResp.ExpiresIn),
        )

        return &amp;tokenResp, nil</span>
}

// GetGoogleUserInfo retrieves user information from Google using the access token
func (s *OAuthService) GetGoogleUserInfo(ctx context.Context, accessToken string) (result0 *GoogleUserInfo, err error) <span class="cov4" title="2">{
        ctx, span := observability.TraceOAuthFunction(ctx, "get_google_user_info",
                attribute.String("oauth.userinfo_endpoint", s.UserInfoEndpoint),
        )
        defer func() </span><span class="cov4" title="2">{
                if err != nil </span><span class="cov0" title="0">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov4" title="2">span.End()</span>
        }()

        <span class="cov4" title="2">userinfoURL := s.UserInfoEndpoint
        if userinfoURL == "" </span><span class="cov0" title="0">{
                userinfoURL = "https://www.googleapis.com/oauth2/v2/userinfo"
        }</span>

        <span class="cov4" title="2">req, err := http.NewRequest("GET", userinfoURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                span.SetAttributes(attribute.String("error", err.Error()))
                return nil, contextutils.WrapError(err, "failed to create userinfo request")
        }</span>

        <span class="cov4" title="2">req.Header.Set("Authorization", "Bearer "+accessToken)

        // Use instrumented HTTP client for automatic tracing with explicit span options
        client := &amp;http.Client{
                Timeout: config.OAuthHTTPTimeout,
                Transport: otelhttp.NewTransport(http.DefaultTransport,
                        otelhttp.WithSpanOptions(trace.WithSpanKind(trace.SpanKindClient)),
                ),
        }
        resp, err := client.Do(req.WithContext(ctx))
        if err != nil </span><span class="cov0" title="0">{
                span.SetAttributes(attribute.String("error", err.Error()))
                return nil, contextutils.WrapError(err, "failed to get user info")
        }</span>
        <span class="cov4" title="2">defer func() </span><span class="cov4" title="2">{
                err = resp.Body.Close()
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn(ctx, "Failed to close response body", map[string]interface{}{"error": err.Error()})
                }</span>
        }()

        <span class="cov4" title="2">span.SetAttributes(attribute.Int("http.status_code", resp.StatusCode))

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                span.SetAttributes(attribute.String("error", fmt.Sprintf("userinfo request failed with status %d: %s", resp.StatusCode, string(body))))
                return nil, contextutils.WrapErrorf(contextutils.ErrOAuthProviderError, "userinfo request failed with status %d: %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov4" title="2">var userInfo GoogleUserInfo
        if err := json.NewDecoder(resp.Body).Decode(&amp;userInfo); err != nil </span><span class="cov0" title="0">{
                span.SetAttributes(attribute.String("error", err.Error()))
                return nil, contextutils.WrapError(err, "failed to decode user info")
        }</span>

        <span class="cov4" title="2">span.SetAttributes(
                attribute.String("user.email", userInfo.Email),
                attribute.String("user.id", userInfo.ID),
                attribute.Bool("user.verified_email", userInfo.VerifiedEmail),
        )

        return &amp;userInfo, nil</span>
}

// AuthenticateGoogleUser handles the complete Google OAuth flow
func (s *OAuthService) AuthenticateGoogleUser(ctx context.Context, code string, userService UserServiceInterface) (result0 *models.User, err error) <span class="cov4" title="2">{
        ctx, span := observability.TraceOAuthFunction(ctx, "authenticate_google_user",
                attribute.String("oauth.code", code),
        )
        defer func() </span><span class="cov4" title="2">{
                if err != nil </span><span class="cov0" title="0">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov4" title="2">span.End()</span>
        }()

        // Exchange code for token
        <span class="cov4" title="2">tokenResp, err := s.ExchangeCodeForToken(ctx, code)
        if err != nil </span><span class="cov0" title="0">{
                span.SetAttributes(attribute.String("error", err.Error()))
                return nil, contextutils.WrapError(err, "failed to exchange code for token")
        }</span>

        // Get user info from Google
        <span class="cov4" title="2">userInfo, err := s.GetGoogleUserInfo(ctx, tokenResp.AccessToken)
        if err != nil </span><span class="cov0" title="0">{
                span.SetAttributes(attribute.String("error", err.Error()))
                return nil, contextutils.WrapError(err, "failed to get user info")
        }</span>

        <span class="cov4" title="2">span.SetAttributes(
                attribute.String("user.email", userInfo.Email),
                attribute.String("user.id", userInfo.ID),
        )

        // Check if user exists by email
        existingUser, err := userService.GetUserByEmail(ctx, userInfo.Email)
        if err != nil </span><span class="cov0" title="0">{
                span.SetAttributes(attribute.String("error", err.Error()))
                return nil, contextutils.WrapError(err, "failed to check existing user")
        }</span>

        <span class="cov4" title="2">if existingUser != nil </span><span class="cov1" title="1">{
                // User exists, return the user
                span.SetAttributes(
                        attribute.Int("user.id", existingUser.ID),
                        attribute.String("auth.result", "existing_user"),
                )
                return existingUser, nil
        }</span>

        // Check if signups are disabled before creating new user
        <span class="cov1" title="1">if s.config != nil &amp;&amp; s.config.IsSignupDisabled() </span><span class="cov0" title="0">{
                span.SetAttributes(attribute.String("auth.result", "signups_disabled"))
                return nil, ErrSignupsDisabled
        }</span>

        // User doesn't exist, create new user
        // Use email as username (we'll handle conflicts)
        <span class="cov1" title="1">username := userInfo.Email
        email := userInfo.Email

        // Check if username already exists, if so, append a number
        counter := 1
        for </span><span class="cov1" title="1">{
                existingUser, err := userService.GetUserByUsername(ctx, username)
                if err != nil </span><span class="cov0" title="0">{
                        span.SetAttributes(attribute.String("error", err.Error()))
                        return nil, contextutils.WrapError(err, "failed to check username availability")
                }</span>
                <span class="cov1" title="1">if existingUser == nil </span><span class="cov1" title="1">{
                        break</span>
                }
                <span class="cov0" title="0">username = fmt.Sprintf("%s_%d", userInfo.Email, counter)
                counter++</span>
        }

        <span class="cov1" title="1">span.SetAttributes(
                attribute.String("user.username", username),
                attribute.String("user.email", email),
                attribute.String("auth.result", "new_user"),
        )

        // Create user with default settings
        user, err := userService.CreateUserWithEmailAndTimezone(ctx, username, email, "UTC", "italian", "beginner")
        if err != nil </span><span class="cov0" title="0">{
                span.SetAttributes(attribute.String("error", err.Error()))
                return nil, contextutils.WrapError(err, "failed to create user")
        }</span>

        <span class="cov1" title="1">span.SetAttributes(attribute.Int("user.id", user.ID))

        return user, nil</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package services

import (
        "context"
        "database/sql"
        "encoding/json"
        "errors"
        "fmt"
        "math/rand"
        "strings"

        "quizapp/internal/models"
        "quizapp/internal/observability"
        contextutils "quizapp/internal/utils"

        "go.opentelemetry.io/otel/codes"
        "go.opentelemetry.io/otel/trace"
)

// QuestionServiceInterface defines the interface for question-related operations.
// This allows for easier mocking in tests.
type QuestionServiceInterface interface {
        SaveQuestion(ctx context.Context, question *models.Question) error
        AssignQuestionToUser(ctx context.Context, questionID, userID int) error
        GetQuestionByID(ctx context.Context, id int) (*models.Question, error)
        GetQuestionWithStats(ctx context.Context, id int) (*QuestionWithStats, error)
        GetQuestionsByFilter(ctx context.Context, userID int, language, level string, questionType models.QuestionType, limit int) ([]models.Question, error)
        GetNextQuestion(ctx context.Context, userID int, language, level string, qType models.QuestionType) (*QuestionWithStats, error)
        ReportQuestion(ctx context.Context, questionID int) error
        GetQuestionStats(ctx context.Context) (map[string]interface{}, error)
        GetDetailedQuestionStats(ctx context.Context) (map[string]interface{}, error)
        GetRecentQuestionContentsForUser(ctx context.Context, userID, limit int) ([]string, error)
        GetReportedQuestions(ctx context.Context) ([]*ReportedQuestionWithUser, error)
        MarkQuestionAsFixed(ctx context.Context, questionID int) error
        UpdateQuestion(ctx context.Context, questionID int, content map[string]interface{}, correctAnswerIndex int, explanation string) error
        DeleteQuestion(ctx context.Context, questionID int) error
        GetUserQuestions(ctx context.Context, userID, limit int) ([]*models.Question, error)
        GetUserQuestionsWithStats(ctx context.Context, userID, limit int) ([]*QuestionWithStats, error)
        GetQuestionsPaginated(ctx context.Context, userID, page, pageSize int, search, typeFilter, statusFilter string) ([]*QuestionWithStats, int, error)
        GetUserQuestionCount(ctx context.Context, userID int) (int, error)
        GetUserResponseCount(ctx context.Context, userID int) (int, error)
        GetRandomGlobalQuestionForUser(ctx context.Context, userID int, language, level string, qType models.QuestionType) (*QuestionWithStats, error)
        DB() *sql.DB
}

// QuestionService provides methods for question management.
type QuestionService struct {
        db              *sql.DB
        learningService *LearningService
        logger          *observability.Logger
}

// Shared query constants to eliminate duplication
const (
        // questionSelectFields contains all question fields for SELECT queries
        questionSelectFields = `id, type, language, level, difficulty_score, content, correct_answer, explanation, created_at, status, topic_category, grammar_focus, vocabulary_domain, scenario, style_modifier, difficulty_modifier, time_context`
)

// scanQuestionFromRow scans a database row into a models.Question struct
func (s *QuestionService) scanQuestionFromRow(row *sql.Row) (result0 *models.Question, err error) <span class="cov4" title="13">{
        question := &amp;models.Question{}
        var contentJSON string

        err = row.Scan(
                &amp;question.ID,
                &amp;question.Type,
                &amp;question.Language,
                &amp;question.Level,
                &amp;question.DifficultyScore,
                &amp;contentJSON,
                &amp;question.CorrectAnswer,
                &amp;question.Explanation,
                &amp;question.CreatedAt,
                &amp;question.Status,
                &amp;question.TopicCategory,
                &amp;question.GrammarFocus,
                &amp;question.VocabularyDomain,
                &amp;question.Scenario,
                &amp;question.StyleModifier,
                &amp;question.DifficultyModifier,
                &amp;question.TimeContext,
        )
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov3" title="12">if err := json.Unmarshal([]byte(contentJSON), &amp;question.Content); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov3" title="12">return question, nil</span>
}

// scanQuestionFromRows scans a database rows into a models.Question struct
func (s *QuestionService) scanQuestionFromRows(rows *sql.Rows) (result0 *models.Question, err error) <span class="cov4" title="13">{
        question := &amp;models.Question{}
        var contentJSON string

        err = rows.Scan(
                &amp;question.ID,
                &amp;question.Type,
                &amp;question.Language,
                &amp;question.Level,
                &amp;question.DifficultyScore,
                &amp;contentJSON,
                &amp;question.CorrectAnswer,
                &amp;question.Explanation,
                &amp;question.CreatedAt,
                &amp;question.Status,
                &amp;question.TopicCategory,
                &amp;question.GrammarFocus,
                &amp;question.VocabularyDomain,
                &amp;question.Scenario,
                &amp;question.StyleModifier,
                &amp;question.DifficultyModifier,
                &amp;question.TimeContext,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov4" title="13">if err := json.Unmarshal([]byte(contentJSON), &amp;question.Content); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov4" title="13">return question, nil</span>
}

// scanQuestionBasicFromRows scans a database rows into a models.Question struct (basic fields only)
func (s *QuestionService) scanQuestionBasicFromRows(rows *sql.Rows) (result0 *models.Question, err error) <span class="cov3" title="6">{
        question := &amp;models.Question{}
        var contentJSON string

        err = rows.Scan(
                &amp;question.ID,
                &amp;question.Type,
                &amp;question.Language,
                &amp;question.Level,
                &amp;question.DifficultyScore,
                &amp;contentJSON,
                &amp;question.CorrectAnswer,
                &amp;question.Explanation,
                &amp;question.CreatedAt,
                &amp;question.Status,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov3" title="6">if err := json.Unmarshal([]byte(contentJSON), &amp;question.Content); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov3" title="6">return question, nil</span>
}

// scanQuestionWithStatsFromRows scans a database rows into a QuestionWithStats struct
func (s *QuestionService) scanQuestionWithStatsFromRows(rows *sql.Rows) (result0 *QuestionWithStats, err error) <span class="cov5" title="66">{
        questionWithStats := &amp;QuestionWithStats{
                Question: &amp;models.Question{},
        }
        var contentJSON string

        err = rows.Scan(
                &amp;questionWithStats.ID,
                &amp;questionWithStats.Type,
                &amp;questionWithStats.Language,
                &amp;questionWithStats.Level,
                &amp;questionWithStats.DifficultyScore,
                &amp;contentJSON,
                &amp;questionWithStats.CorrectAnswer,
                &amp;questionWithStats.Explanation,
                &amp;questionWithStats.CreatedAt,
                &amp;questionWithStats.Status,
                &amp;questionWithStats.CorrectCount,
                &amp;questionWithStats.IncorrectCount,
                &amp;questionWithStats.TotalResponses,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov5" title="66">if err := json.Unmarshal([]byte(contentJSON), &amp;questionWithStats.Content); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov5" title="66">return questionWithStats, nil</span>
}

// scanQuestionWithStatsAndAllFieldsFromRows scans a database rows into a QuestionWithStats struct (with all fields)
func (s *QuestionService) scanQuestionWithStatsAndAllFieldsFromRows(rows *sql.Rows) (result0 *QuestionWithStats, err error) <span class="cov5" title="67">{
        questionWithStats := &amp;QuestionWithStats{
                Question: &amp;models.Question{},
        }
        var contentJSON string

        err = rows.Scan(
                &amp;questionWithStats.ID,
                &amp;questionWithStats.Type,
                &amp;questionWithStats.Language,
                &amp;questionWithStats.Level,
                &amp;questionWithStats.DifficultyScore,
                &amp;contentJSON,
                &amp;questionWithStats.CorrectAnswer,
                &amp;questionWithStats.Explanation,
                &amp;questionWithStats.CreatedAt,
                &amp;questionWithStats.Status,
                &amp;questionWithStats.TopicCategory,
                &amp;questionWithStats.GrammarFocus,
                &amp;questionWithStats.VocabularyDomain,
                &amp;questionWithStats.Scenario,
                &amp;questionWithStats.StyleModifier,
                &amp;questionWithStats.DifficultyModifier,
                &amp;questionWithStats.TimeContext,
                &amp;questionWithStats.CorrectCount,
                &amp;questionWithStats.IncorrectCount,
                &amp;questionWithStats.TotalResponses,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov5" title="67">if err := json.Unmarshal([]byte(contentJSON), &amp;questionWithStats.Content); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov5" title="67">return questionWithStats, nil</span>
}

// scanQuestionWithPriorityAndStatsFromRows scans a database rows into a QuestionWithStats struct (with priority and stats)
func (s *QuestionService) scanQuestionWithPriorityAndStatsFromRows(rows *sql.Rows) (result0 *QuestionWithStats, err error) <span class="cov10" title="2011">{
        questionWithStats := &amp;QuestionWithStats{
                Question: &amp;models.Question{},
        }
        var contentJSON string
        var priorityScore float64
        var timesAnswered int
        var lastAnsweredAt sql.NullTime

        err = rows.Scan(
                &amp;questionWithStats.ID,
                &amp;questionWithStats.Type,
                &amp;questionWithStats.Language,
                &amp;questionWithStats.Level,
                &amp;questionWithStats.DifficultyScore,
                &amp;contentJSON,
                &amp;questionWithStats.CorrectAnswer,
                &amp;questionWithStats.Explanation,
                &amp;questionWithStats.CreatedAt,
                &amp;questionWithStats.Status,
                &amp;questionWithStats.TopicCategory,
                &amp;questionWithStats.GrammarFocus,
                &amp;questionWithStats.VocabularyDomain,
                &amp;questionWithStats.Scenario,
                &amp;questionWithStats.StyleModifier,
                &amp;questionWithStats.DifficultyModifier,
                &amp;questionWithStats.TimeContext,
                &amp;priorityScore,
                &amp;timesAnswered,
                &amp;lastAnsweredAt,
                &amp;questionWithStats.CorrectCount,
                &amp;questionWithStats.IncorrectCount,
                &amp;questionWithStats.TotalResponses,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov10" title="2011">if err := json.Unmarshal([]byte(contentJSON), &amp;questionWithStats.Content); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov10" title="2011">return questionWithStats, nil</span>
}

// getQuestionByQuery is a shared method for getting a question by any query
func (s *QuestionService) getQuestionByQuery(ctx context.Context, query string, args ...interface{}) (result0 *models.Question, err error) <span class="cov4" title="13">{
        row := s.db.QueryRowContext(ctx, query, args...)
        var question *models.Question
        question, err = s.scanQuestionFromRow(row)
        if err != nil </span><span class="cov1" title="1">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov1" title="1">{
                        return nil, sql.ErrNoRows // Propagate sql.ErrNoRows for not found
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov3" title="12">return question, nil</span>
}

// NewQuestionServiceWithLogger creates a new QuestionService instance with logger
func NewQuestionServiceWithLogger(db *sql.DB, learningService *LearningService, logger *observability.Logger) *QuestionService <span class="cov5" title="42">{
        return &amp;QuestionService{
                db:              db,
                learningService: learningService,
                logger:          logger,
        }
}</span>

// SaveQuestion saves a question to the database
func (s *QuestionService) SaveQuestion(ctx context.Context, question *models.Question) (err error) <span class="cov7" title="161">{
        ctx, span := observability.TraceQuestionFunction(ctx, "save_question", observability.AttributeQuestion(question))
        defer func() </span><span class="cov7" title="161">{
                if err != nil </span><span class="cov0" title="0">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov7" title="161">span.End()</span>
        }()
        <span class="cov7" title="161">var contentJSON []byte
        contentJSON, err = json.Marshal(question.Content)
        if err != nil </span><span class="cov0" title="0">{
                return contextutils.WrapError(err, "failed to marshal question content")
        }</span>

        <span class="cov7" title="161">if question.Status == "" </span><span class="cov3" title="7">{
                question.Status = models.QuestionStatusActive
        }</span>

        <span class="cov7" title="161">query := `
                INSERT INTO questions (type, language, level, difficulty_score, content, correct_answer, explanation, status, topic_category, grammar_focus, vocabulary_domain, scenario, style_modifier, difficulty_modifier, time_context)
                VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15) RETURNING id
        `

        var id int
        err = s.db.QueryRowContext(ctx, query,
                question.Type,
                question.Language,
                question.Level,
                question.DifficultyScore,
                string(contentJSON),
                question.CorrectAnswer,
                question.Explanation,
                question.Status,
                question.TopicCategory,
                question.GrammarFocus,
                question.VocabularyDomain,
                question.Scenario,
                question.StyleModifier,
                question.DifficultyModifier,
                question.TimeContext,
        ).Scan(&amp;id)
        if err != nil </span><span class="cov0" title="0">{
                return contextutils.WrapError(err, "failed to save question to database")
        }</span>

        <span class="cov7" title="161">question.ID = id
        return nil</span>
}

// AssignQuestionToUser assigns a question to a user
func (s *QuestionService) AssignQuestionToUser(ctx context.Context, questionID, userID int) (err error) <span class="cov7" title="167">{
        ctx, span := observability.TraceQuestionFunction(ctx, "assign_question_to_user", observability.AttributeQuestionID(questionID), observability.AttributeUserID(userID))
        defer func() </span><span class="cov7" title="167">{
                if err != nil </span><span class="cov0" title="0">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov7" title="167">span.End()</span>
        }()
        <span class="cov7" title="167">query := `
                INSERT INTO user_questions (user_id, question_id)
                VALUES ($1, $2)
                ON CONFLICT (user_id, question_id) DO NOTHING
        `
        _, err = s.db.ExecContext(ctx, query, userID, questionID)
        return contextutils.WrapError(err, "failed to assign question to user")</span>
}

// GetQuestionByID retrieves a question by its ID
func (s *QuestionService) GetQuestionByID(ctx context.Context, id int) (result0 *models.Question, err error) <span class="cov4" title="13">{
        ctx, span := observability.TraceQuestionFunction(ctx, "get_question_by_id", observability.AttributeQuestionID(id))
        defer func() </span><span class="cov4" title="13">{
                if err != nil </span><span class="cov1" title="1">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov4" title="13">span.End()</span>
        }()
        <span class="cov4" title="13">query := fmt.Sprintf("SELECT %s FROM questions WHERE id = $1", questionSelectFields)
        return s.getQuestionByQuery(ctx, query, id)</span>
}

// GetQuestionWithStats retrieves a question by its ID with response statistics
func (s *QuestionService) GetQuestionWithStats(ctx context.Context, id int) (result0 *QuestionWithStats, err error) <span class="cov1" title="2">{
        ctx, span := observability.TraceQuestionFunction(ctx, "get_question_with_stats", observability.AttributeQuestionID(id))
        defer func() </span><span class="cov1" title="2">{
                if err != nil </span><span class="cov0" title="0">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov1" title="2">span.End()</span>
        }()
        <span class="cov1" title="2">query := `
                SELECT
                        q.id, q.type, q.language, q.level, q.difficulty_score,
                        q.content, q.correct_answer, q.explanation, q.created_at, q.status,
                        q.topic_category, q.grammar_focus, q.vocabulary_domain, q.scenario, q.style_modifier, q.difficulty_modifier, q.time_context,
                        COALESCE(SUM(CASE WHEN ur.is_correct = true THEN 1 ELSE 0 END), 0) as correct_count,
                        COALESCE(SUM(CASE WHEN ur.is_correct = false THEN 1 ELSE 0 END), 0) as incorrect_count,
                        COALESCE(COUNT(ur.id), 0) as total_responses
                FROM questions q
                LEFT JOIN user_responses ur ON q.id = ur.question_id
                WHERE q.id = $1
                GROUP BY q.id, q.type, q.language, q.level, q.difficulty_score,
                                 q.content, q.correct_answer, q.explanation, q.created_at, q.status,
                                 q.topic_category, q.grammar_focus, q.vocabulary_domain, q.scenario, q.style_modifier, q.difficulty_modifier, q.time_context
        `

        q := &amp;models.Question{}
        stats := &amp;QuestionWithStats{Question: q}

        var contentJSON string
        err = s.db.QueryRowContext(ctx, query, id).Scan(
                &amp;q.ID, &amp;q.Type, &amp;q.Language, &amp;q.Level, &amp;q.DifficultyScore,
                &amp;contentJSON, &amp;q.CorrectAnswer, &amp;q.Explanation, &amp;q.CreatedAt, &amp;q.Status,
                &amp;q.TopicCategory, &amp;q.GrammarFocus, &amp;q.VocabularyDomain, &amp;q.Scenario, &amp;q.StyleModifier, &amp;q.DifficultyModifier, &amp;q.TimeContext,
                &amp;stats.CorrectCount, &amp;stats.IncorrectCount, &amp;stats.TotalResponses,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, contextutils.WrapError(err, "failed to get question with stats")
        }</span>

        // Parse JSON content
        <span class="cov1" title="2">if err := json.Unmarshal([]byte(contentJSON), &amp;q.Content); err != nil </span><span class="cov0" title="0">{
                return nil, contextutils.WrapError(err, "failed to unmarshal question content")
        }</span>

        <span class="cov1" title="2">return stats, nil</span>
}

// GetQuestionsByFilter retrieves questions matching the specified criteria
func (s *QuestionService) GetQuestionsByFilter(ctx context.Context, userID int, language, level string, questionType models.QuestionType, limit int) (result0 []models.Question, err error) <span class="cov3" title="8">{
        ctx, span := observability.TraceQuestionFunction(ctx, "get_questions_by_filter", observability.AttributeUserID(userID), observability.AttributeLanguage(language), observability.AttributeLevel(level), observability.AttributeQuestionType(questionType))
        defer func() </span><span class="cov3" title="8">{
                if err != nil </span><span class="cov0" title="0">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov3" title="8">span.End()</span>
        }()
        <span class="cov3" title="8">var query string
        var args []interface{}

        if questionType == "" </span><span class="cov2" title="3">{
                // Don't filter by type if questionType is empty
                query = `
                        SELECT q.id, q.type, q.language, q.level, q.difficulty_score, q.content, q.correct_answer, q.explanation, q.created_at, q.status
                        FROM questions q
                        JOIN user_questions uq ON q.id = uq.question_id
                        WHERE uq.user_id = $1 AND q.language = $2 AND q.level = $3 AND q.status = $4
                        ORDER BY RANDOM()
                        LIMIT $5
                `
                args = []interface{}{userID, language, level, models.QuestionStatusActive, limit}
        }</span> else<span class="cov2" title="5"> {
                // Filter by specific type
                query = `
                        SELECT q.id, q.type, q.language, q.level, q.difficulty_score, q.content, q.correct_answer, q.explanation, q.created_at, q.status
                        FROM questions q
                        JOIN user_questions uq ON q.id = uq.question_id
                        WHERE uq.user_id = $1 AND q.language = $2 AND q.level = $3 AND q.type = $4 AND q.status = $5
                        ORDER BY RANDOM()
                        LIMIT $6
                `
                args = []interface{}{userID, language, level, questionType, models.QuestionStatusActive, limit}
        }</span>

        <span class="cov3" title="8">rows, err := s.db.QueryContext(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, contextutils.WrapError(err, "failed to query questions by filter")
        }</span>
        <span class="cov3" title="8">defer func() </span><span class="cov3" title="8">{
                if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn(ctx, "Failed to close rows", map[string]interface{}{"error": err.Error()})
                }</span>
        }()

        <span class="cov3" title="8">var questions []models.Question
        for rows.Next() </span><span class="cov3" title="6">{
                question, err := s.scanQuestionBasicFromRows(rows)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, contextutils.WrapError(err, "failed to scan question from rows")
                }</span>
                <span class="cov3" title="6">questions = append(questions, *question)</span>
        }

        <span class="cov3" title="8">return questions, nil</span>
}

// ReportedQuestionWithUser represents a reported question with user information
type ReportedQuestionWithUser struct {
        *models.Question
        ReportedByUsername string `json:"reported_by_username"`
}

// GetReportedQuestions retrieves all questions that have been reported as problematic
func (s *QuestionService) GetReportedQuestions(ctx context.Context) (result0 []*ReportedQuestionWithUser, err error) <span class="cov1" title="1">{
        ctx, span := observability.TraceQuestionFunction(ctx, "get_reported_questions")
        defer func() </span><span class="cov1" title="1">{
                if err != nil </span><span class="cov0" title="0">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov1" title="1">span.End()</span>
        }()
        <span class="cov1" title="1">query := `
                SELECT q.id, q.type, q.language, q.level, q.difficulty_score, q.content, q.correct_answer, q.explanation, q.created_at, q.status, u.username
                FROM questions q
                LEFT JOIN user_questions uq ON q.id = uq.question_id
                LEFT JOIN users u ON uq.user_id = u.id
                WHERE q.status = $1
                ORDER BY q.created_at DESC
        `

        var rows *sql.Rows
        rows, err = s.db.QueryContext(ctx, query, models.QuestionStatusReported)
        if err != nil </span><span class="cov0" title="0">{
                return nil, contextutils.WrapError(err, "failed to query reported questions")
        }</span>
        <span class="cov1" title="1">defer func() </span><span class="cov1" title="1">{
                if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn(ctx, "Failed to close rows", map[string]interface{}{"error": err.Error()})
                }</span>
        }()

        <span class="cov1" title="1">var questions []*ReportedQuestionWithUser
        for rows.Next() </span><span class="cov1" title="2">{
                var question models.Question
                var reportedByUsername sql.NullString
                var contentJSON string

                err = rows.Scan(
                        &amp;question.ID,
                        &amp;question.Type,
                        &amp;question.Language,
                        &amp;question.Level,
                        &amp;question.DifficultyScore,
                        &amp;contentJSON,
                        &amp;question.CorrectAnswer,
                        &amp;question.Explanation,
                        &amp;question.CreatedAt,
                        &amp;question.Status,
                        &amp;reportedByUsername,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov1" title="2">if err := json.Unmarshal([]byte(contentJSON), &amp;question.Content); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov1" title="2">username := ""
                if reportedByUsername.Valid </span><span class="cov1" title="2">{
                        username = reportedByUsername.String
                }</span>

                <span class="cov1" title="2">reportedQuestion := &amp;ReportedQuestionWithUser{
                        Question:           &amp;question,
                        ReportedByUsername: username,
                }

                questions = append(questions, reportedQuestion)</span>
        }

        <span class="cov1" title="1">return questions, nil</span>
}

// MarkQuestionAsFixed marks a reported question as fixed and puts it back in rotation
func (s *QuestionService) MarkQuestionAsFixed(ctx context.Context, questionID int) (err error) <span class="cov1" title="1">{
        ctx, span := observability.TraceQuestionFunction(ctx, "mark_question_as_fixed", observability.AttributeQuestionID(questionID))
        defer func() </span><span class="cov1" title="1">{
                if err != nil </span><span class="cov0" title="0">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov1" title="1">span.End()</span>
        }()
        <span class="cov1" title="1">query := `UPDATE questions SET status = $1 WHERE id = $2`
        _, err = s.db.ExecContext(ctx, query, models.QuestionStatusActive, questionID)
        return contextutils.WrapError(err, "failed to mark question as fixed")</span>
}

// UpdateQuestion updates a question's content, correct answer, and explanation
func (s *QuestionService) UpdateQuestion(ctx context.Context, questionID int, content map[string]interface{}, correctAnswerIndex int, explanation string) (err error) <span class="cov1" title="1">{
        ctx, span := observability.TraceQuestionFunction(ctx, "update_question", observability.AttributeQuestionID(questionID))
        defer func() </span><span class="cov1" title="1">{
                if err != nil </span><span class="cov0" title="0">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov1" title="1">span.End()</span>
        }()
        <span class="cov1" title="1">var contentJSON []byte
        contentJSON, err = json.Marshal(content)
        if err != nil </span><span class="cov0" title="0">{
                return contextutils.WrapError(err, "failed to marshal content JSON")
        }</span>

        <span class="cov1" title="1">query := `UPDATE questions SET content = $1, correct_answer = $2, explanation = $3 WHERE id = $4`
        _, err = s.db.ExecContext(ctx, query, string(contentJSON), correctAnswerIndex, explanation, questionID)
        return contextutils.WrapError(err, "failed to update question")</span>
}

// DeleteQuestion permanently deletes a question from the database
func (s *QuestionService) DeleteQuestion(ctx context.Context, questionID int) (err error) <span class="cov1" title="1">{
        ctx, span := observability.TraceQuestionFunction(ctx, "delete_question", observability.AttributeQuestionID(questionID))
        defer func() </span><span class="cov1" title="1">{
                if err != nil </span><span class="cov0" title="0">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov1" title="1">span.End()</span>
        }()
        // First, delete associated user responses
        <span class="cov1" title="1">deleteResponsesQuery := `DELETE FROM user_responses WHERE question_id = $1`
        _, err = s.db.ExecContext(ctx, deleteResponsesQuery, questionID)
        if err != nil </span><span class="cov0" title="0">{
                return contextutils.WrapError(err, "failed to delete associated user responses")
        }</span>

        // Then delete the question itself
        <span class="cov1" title="1">deleteQuestionQuery := `DELETE FROM questions WHERE id = $1`
        var result sql.Result
        result, err = s.db.ExecContext(ctx, deleteQuestionQuery, questionID)
        if err != nil </span><span class="cov0" title="0">{
                return contextutils.WrapError(err, "failed to delete question")
        }</span>

        // Check if the question was actually deleted
        <span class="cov1" title="1">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return contextutils.WrapError(err, "failed to get rows affected")
        }</span>

        <span class="cov1" title="1">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return contextutils.WrapErrorf(contextutils.ErrRecordNotFound, "question with ID %d not found", questionID)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// ReportQuestion marks a question as reported/problematic
func (s *QuestionService) ReportQuestion(ctx context.Context, questionID int) (err error) <span class="cov2" title="4">{
        ctx, span := observability.TraceQuestionFunction(ctx, "report_question", observability.AttributeQuestionID(questionID))
        defer func() </span><span class="cov2" title="4">{
                if err != nil </span><span class="cov0" title="0">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov2" title="4">span.End()</span>
        }()
        <span class="cov2" title="4">query := `UPDATE questions SET status = $1 WHERE id = $2`
        _, err = s.db.ExecContext(ctx, query, models.QuestionStatusReported, questionID)
        return contextutils.WrapError(err, "failed to report question")</span>
}

// GetNextQuestion gets the next question for a user based on usage count and availability
func (s *QuestionService) GetNextQuestion(ctx context.Context, userID int, language, level string, qType models.QuestionType) (result0 *QuestionWithStats, err error) <span class="cov7" title="206">{
        ctx, span := observability.TraceQuestionFunction(ctx, "get_next_question", observability.AttributeUserID(userID), observability.AttributeLanguage(language), observability.AttributeLevel(level), observability.AttributeQuestionType(qType))
        defer func() </span><span class="cov7" title="206">{
                if err != nil </span><span class="cov0" title="0">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov7" title="206">span.End()</span>
        }()
        // Use priority-based selection with stats included
        <span class="cov7" title="206">return s.getNextQuestionWithPriority(ctx, userID, language, level, qType)</span>
}

// getNextQuestionWithPriority implements priority-based question selection with stats
func (s *QuestionService) getNextQuestionWithPriority(ctx context.Context, userID int, language, level string, qType models.QuestionType) (result0 *QuestionWithStats, err error) <span class="cov7" title="206">{
        ctx, span := observability.TraceQuestionFunction(ctx, "get_next_question_with_priority", observability.AttributeUserID(userID), observability.AttributeLanguage(language), observability.AttributeLevel(level), observability.AttributeQuestionType(qType))
        defer func() </span><span class="cov7" title="206">{
                if err != nil </span><span class="cov0" title="0">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov7" title="206">span.End()</span>
        }()
        // Get user preferences
        <span class="cov7" title="206">var prefs *models.UserLearningPreferences
        prefs, err = s.learningService.GetUserLearningPreferences(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Warn(ctx, "Failed to get user preferences", map[string]interface{}{"user_id": userID, "error": err.Error()})
                // Fall back to default preferences
                prefs = s.learningService.GetDefaultLearningPreferences()
        }</span>

        // Get available questions with priority scores and stats
        <span class="cov7" title="206">var questions []*QuestionWithStats
        questions, err = s.getAvailableQuestionsWithPriority(ctx, userID, language, level, qType, prefs)
        if err != nil </span><span class="cov0" title="0">{
                return nil, contextutils.WrapError(err, "failed to get available questions")
        }</span>

        <span class="cov7" title="206">if len(questions) == 0 </span><span class="cov2" title="3">{
                // Fallback: try to get a random global question and assign it to the user
                globalQ, err := s.GetRandomGlobalQuestionForUser(ctx, userID, language, level, qType)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, contextutils.WrapError(err, "no personalized questions, and failed to get global fallback question")
                }</span>
                <span class="cov2" title="3">if globalQ != nil </span><span class="cov1" title="2">{
                        return globalQ, nil
                }</span>
                <span class="cov1" title="1">return nil, nil</span> // No questions available at all
        }

        // Apply FreshQuestionRatio logic (NEW)
        <span class="cov7" title="203">selectedQuestion, err := s.selectQuestionWithFreshnessRatio(questions, prefs.FreshQuestionRatio)
        if err != nil </span><span class="cov0" title="0">{
                return nil, contextutils.WrapError(err, "failed to select question with freshness ratio")
        }</span>

        // Return the selected question with stats (already included)
        <span class="cov7" title="203">return selectedQuestion, nil</span>
}

// GetQuestionStats returns basic statistics about questions in the system
func (s *QuestionService) GetQuestionStats(ctx context.Context) (result0 map[string]interface{}, err error) <span class="cov1" title="1">{
        ctx, span := observability.TraceQuestionFunction(ctx, "get_question_stats")
        defer func() </span><span class="cov1" title="1">{
                if err != nil </span><span class="cov0" title="0">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov1" title="1">span.End()</span>
        }()
        <span class="cov1" title="1">stats := make(map[string]interface{})

        // Total questions
        var totalQuestions int
        err = s.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM questions").Scan(&amp;totalQuestions)
        if err != nil </span><span class="cov0" title="0">{
                return nil, contextutils.WrapError(err, "failed to get total questions count")
        }</span>
        <span class="cov1" title="1">stats["total_questions"] = totalQuestions

        // Questions by type
        typeQuery := `
                SELECT type, COUNT(*) as count
                FROM questions
                GROUP BY type
        `
        rows, err := s.db.QueryContext(ctx, typeQuery)
        if err != nil </span><span class="cov0" title="0">{
                return nil, contextutils.WrapError(err, "failed to query questions by type")
        }</span>
        <span class="cov1" title="1">defer func() </span><span class="cov1" title="1">{
                if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn(ctx, "Failed to close rows", map[string]interface{}{"error": err.Error()})
                }</span>
        }()

        <span class="cov1" title="1">questionsByType := make(map[string]int)
        for rows.Next() </span><span class="cov1" title="2">{
                var qType string
                var count int
                if err := rows.Scan(&amp;qType, &amp;count); err != nil </span><span class="cov0" title="0">{
                        return nil, contextutils.WrapError(err, "failed to scan question type count")
                }</span>
                <span class="cov1" title="2">questionsByType[qType] = count</span>
        }
        <span class="cov1" title="1">stats["questions_by_type"] = questionsByType

        // Questions by level
        levelQuery := `
                SELECT level, COUNT(*) as count
                FROM questions
                GROUP BY level
        `
        rows, err = s.db.QueryContext(ctx, levelQuery)
        if err != nil </span><span class="cov0" title="0">{
                return nil, contextutils.WrapError(err, "failed to query questions by level")
        }</span>
        <span class="cov1" title="1">defer func() </span><span class="cov1" title="1">{
                if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn(ctx, "Failed to close rows", map[string]interface{}{"error": err.Error()})
                }</span>
        }()

        <span class="cov1" title="1">questionsByLevel := make(map[string]int)
        for rows.Next() </span><span class="cov1" title="1">{
                var level string
                var count int
                if err := rows.Scan(&amp;level, &amp;count); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov1" title="1">questionsByLevel[level] = count</span>
        }
        <span class="cov1" title="1">stats["questions_by_level"] = questionsByLevel

        return stats, nil</span>
}

// GetDetailedQuestionStats returns detailed statistics about questions
func (s *QuestionService) GetDetailedQuestionStats(ctx context.Context) (result0 map[string]interface{}, err error) <span class="cov1" title="1">{
        ctx, span := observability.TraceQuestionFunction(ctx, "get_detailed_question_stats")
        defer func() </span><span class="cov1" title="1">{
                if err != nil </span><span class="cov0" title="0">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov1" title="1">span.End()</span>
        }()
        <span class="cov1" title="1">stats := make(map[string]interface{})

        // Total questions
        var totalQuestions int
        err = s.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM questions").Scan(&amp;totalQuestions)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">stats["total_questions"] = totalQuestions

        // Questions by language, level, and type combination
        detailQuery := `
                SELECT language, level, type, COUNT(*) as count
                FROM questions
                GROUP BY language, level, type
                ORDER BY language, level, type
        `
        rows, err := s.db.QueryContext(ctx, detailQuery)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">defer func() </span><span class="cov1" title="1">{
                if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn(ctx, "Failed to close rows", map[string]interface{}{"error": err.Error()})
                }</span>
        }()

        // Create nested structure: language -&gt; level -&gt; type -&gt; count
        <span class="cov1" title="1">questionsByDetail := make(map[string]map[string]map[string]int)
        for rows.Next() </span><span class="cov1" title="1">{
                var language, level, qType string
                var count int
                if err := rows.Scan(&amp;language, &amp;level, &amp;qType, &amp;count); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov1" title="1">if questionsByDetail[language] == nil </span><span class="cov1" title="1">{
                        questionsByDetail[language] = make(map[string]map[string]int)
                }</span>
                <span class="cov1" title="1">if questionsByDetail[language][level] == nil </span><span class="cov1" title="1">{
                        questionsByDetail[language][level] = make(map[string]int)
                }</span>
                <span class="cov1" title="1">questionsByDetail[language][level][qType] = count</span>
        }
        <span class="cov1" title="1">stats["questions_by_detail"] = questionsByDetail

        // Questions by language
        languageQuery := `
                SELECT language, COUNT(*) as count
                FROM questions
                GROUP BY language
        `
        rows, err = s.db.QueryContext(ctx, languageQuery)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">defer func() </span><span class="cov1" title="1">{
                if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn(ctx, "Failed to close rows", map[string]interface{}{"error": err.Error()})
                }</span>
        }()

        <span class="cov1" title="1">questionsByLanguage := make(map[string]int)
        for rows.Next() </span><span class="cov1" title="1">{
                var language string
                var count int
                if err := rows.Scan(&amp;language, &amp;count); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov1" title="1">questionsByLanguage[language] = count</span>
        }
        <span class="cov1" title="1">stats["questions_by_language"] = questionsByLanguage

        // Questions by type
        typeQuery := `
                SELECT type, COUNT(*) as count
                FROM questions
                GROUP BY type
        `
        rows, err = s.db.QueryContext(ctx, typeQuery)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">defer func() </span><span class="cov1" title="1">{
                if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn(ctx, "Failed to close rows", map[string]interface{}{"error": err.Error()})
                }</span>
        }()

        <span class="cov1" title="1">questionsByType := make(map[string]int)
        for rows.Next() </span><span class="cov1" title="1">{
                var qType string
                var count int
                if err := rows.Scan(&amp;qType, &amp;count); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov1" title="1">questionsByType[qType] = count</span>
        }
        <span class="cov1" title="1">stats["questions_by_type"] = questionsByType

        // Questions by level
        levelQuery := `
                SELECT level, COUNT(*) as count
                FROM questions
                GROUP BY level
        `
        rows, err = s.db.QueryContext(ctx, levelQuery)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">defer func() </span><span class="cov1" title="1">{
                if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn(ctx, "Failed to close rows", map[string]interface{}{"error": err.Error()})
                }</span>
        }()

        <span class="cov1" title="1">questionsByLevel := make(map[string]int)
        for rows.Next() </span><span class="cov1" title="1">{
                var level string
                var count int
                if err := rows.Scan(&amp;level, &amp;count); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov1" title="1">questionsByLevel[level] = count</span>
        }
        <span class="cov1" title="1">stats["questions_by_level"] = questionsByLevel

        return stats, nil</span>
}

// GetRecentQuestionContentsForUser retrieves recent question contents for a user
func (s *QuestionService) GetRecentQuestionContentsForUser(ctx context.Context, userID, limit int) (result0 []string, err error) <span class="cov1" title="1">{
        ctx, span := observability.TraceQuestionFunction(ctx, "get_recent_question_contents_for_user", observability.AttributeUserID(userID), observability.AttributeLimit(limit))
        defer func() </span><span class="cov1" title="1">{
                if err != nil </span><span class="cov0" title="0">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov1" title="1">span.End()</span>
        }()
        <span class="cov1" title="1">query := `
                SELECT DISTINCT q.content
                FROM user_responses ur
                JOIN questions q ON ur.question_id = q.id
                JOIN user_questions uq ON q.id = uq.question_id
                WHERE ur.user_id = $1 AND uq.user_id = $2
                ORDER BY q.content DESC
                LIMIT $3
        `

        var rows *sql.Rows
        rows, err = s.db.QueryContext(ctx, query, userID, userID, limit)
        if err != nil </span><span class="cov0" title="0">{
                return []string{}, err
        }</span>
        <span class="cov1" title="1">defer func() </span><span class="cov1" title="1">{
                if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn(ctx, "Failed to close rows", map[string]interface{}{"error": err.Error()})
                }</span>
        }()

        <span class="cov1" title="1">var contents []string
        for rows.Next() </span><span class="cov1" title="1">{
                var content string
                if err := rows.Scan(&amp;content); err != nil </span><span class="cov0" title="0">{
                        return []string{}, err
                }</span>
                <span class="cov1" title="1">contents = append(contents, content)</span>
        }

        // Ensure we always return an empty slice instead of nil
        <span class="cov1" title="1">if contents == nil </span><span class="cov0" title="0">{
                contents = []string{}
        }</span>

        <span class="cov1" title="1">return contents, nil</span>
}

// GetUserQuestions retrieves actual questions for a user (not just content)
func (s *QuestionService) GetUserQuestions(ctx context.Context, userID, limit int) (result0 []*models.Question, err error) <span class="cov3" title="6">{
        ctx, span := observability.TraceQuestionFunction(ctx, "get_user_questions", observability.AttributeUserID(userID), observability.AttributeLimit(limit))
        defer func() </span><span class="cov3" title="6">{
                if err != nil </span><span class="cov0" title="0">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov3" title="6">span.End()</span>
        }()
        <span class="cov3" title="6">query := `
                SELECT q.id, q.type, q.language, q.level, q.difficulty_score, q.content, q.correct_answer, q.explanation, q.created_at, q.status, q.topic_category, q.grammar_focus, q.vocabulary_domain, q.scenario, q.style_modifier, q.difficulty_modifier, q.time_context
                FROM questions q
                JOIN user_questions uq ON q.id = uq.question_id
                WHERE uq.user_id = $1
                ORDER BY q.created_at DESC
                LIMIT $2
        `

        var rows *sql.Rows
        rows, err = s.db.QueryContext(ctx, query, userID, limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov3" title="6">defer func() </span><span class="cov3" title="6">{
                if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn(ctx, "Failed to close rows", map[string]interface{}{"error": err.Error()})
                }</span>
        }()

        <span class="cov3" title="6">var questions []*models.Question
        for rows.Next() </span><span class="cov4" title="13">{
                question, err := s.scanQuestionFromRows(rows)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov4" title="13">questions = append(questions, question)</span>
        }

        <span class="cov3" title="6">return questions, nil</span>
}

// GetUserQuestionsWithStats retrieves questions for a user with response statistics
func (s *QuestionService) GetUserQuestionsWithStats(ctx context.Context, userID, limit int) (result0 []*QuestionWithStats, err error) <span class="cov2" title="4">{
        ctx, span := observability.TraceQuestionFunction(ctx, "get_user_questions_with_stats", observability.AttributeUserID(userID), observability.AttributeLimit(limit))
        defer func() </span><span class="cov2" title="4">{
                if err != nil </span><span class="cov0" title="0">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov2" title="4">span.End()</span>
        }()
        <span class="cov2" title="4">query := `
                SELECT
                        q.id, q.type, q.language, q.level, q.difficulty_score,
                        q.content, q.correct_answer, q.explanation, q.created_at, q.status,
                        COALESCE(SUM(CASE WHEN ur.is_correct = true THEN 1 ELSE 0 END), 0) as correct_count,
                        COALESCE(SUM(CASE WHEN ur.is_correct = false THEN 1 ELSE 0 END), 0) as incorrect_count,
                        COALESCE(COUNT(ur.id), 0) as total_responses
                FROM questions q
                JOIN user_questions uq ON q.id = uq.question_id
                LEFT JOIN user_responses ur ON q.id = ur.question_id
                WHERE uq.user_id = $1
                GROUP BY q.id, q.type, q.language, q.level, q.difficulty_score,
                        q.content, q.correct_answer, q.explanation, q.created_at, q.status
                ORDER BY q.created_at DESC
                LIMIT $2
        `

        rows, err := s.db.QueryContext(ctx, query, userID, limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov2" title="4">defer func() </span><span class="cov2" title="4">{
                if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn(ctx, "Failed to close rows", map[string]interface{}{"error": err.Error()})
                }</span>
        }()

        <span class="cov2" title="4">var questions []*QuestionWithStats
        for rows.Next() </span><span class="cov5" title="66">{
                questionWithStats, err := s.scanQuestionWithStatsFromRows(rows)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov5" title="66">questions = append(questions, questionWithStats)</span>
        }

        <span class="cov2" title="4">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov2" title="4">return questions, nil</span>
}

// QuestionWithStats represents a question with response statistics
type QuestionWithStats struct {
        *models.Question
        CorrectCount   int `json:"correct_count"`
        IncorrectCount int `json:"incorrect_count"`
        TotalResponses int `json:"total_responses"`
}

// GetQuestionsPaginated retrieves questions with pagination and response statistics
func (s *QuestionService) GetQuestionsPaginated(ctx context.Context, userID, page, pageSize int, search, typeFilter, statusFilter string) (result0 []*QuestionWithStats, result1 int, err error) <span class="cov3" title="7">{
        ctx, span := observability.TraceQuestionFunction(ctx, "get_questions_paginated", observability.AttributeUserID(userID), observability.AttributePage(page), observability.AttributePageSize(pageSize), observability.AttributeSearch(search), observability.AttributeTypeFilter(typeFilter), observability.AttributeStatusFilter(statusFilter))
        defer func() </span><span class="cov3" title="7">{
                if err != nil </span><span class="cov0" title="0">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov3" title="7">span.End()</span>
        }()

        // Build WHERE clause with filters using parameterized queries
        <span class="cov3" title="7">whereConditions := []string{"uq.user_id = $1"}
        args := []interface{}{userID}
        argCount := 1

        // Add search filter
        if search != "" </span><span class="cov1" title="1">{
                argCount++
                whereConditions = append(whereConditions, fmt.Sprintf("(q.content::text ILIKE $%d OR q.explanation ILIKE $%d)", argCount, argCount))
                args = append(args, "%"+search+"%")
        }</span>

        // Add type filter
        <span class="cov3" title="7">if typeFilter != "" </span><span class="cov1" title="1">{
                argCount++
                whereConditions = append(whereConditions, fmt.Sprintf("q.type = $%d", argCount))
                args = append(args, typeFilter)
        }</span>

        // Add status filter
        <span class="cov3" title="7">if statusFilter != "" </span><span class="cov1" title="1">{
                argCount++
                whereConditions = append(whereConditions, fmt.Sprintf("q.status = $%d", argCount))
                args = append(args, statusFilter)
        }</span>

        // Join all conditions
        <span class="cov3" title="7">whereClause := "WHERE " + strings.Join(whereConditions, " AND ")

        // First get the total count with filters
        countQuery := fmt.Sprintf("SELECT COUNT(*) FROM questions q JOIN user_questions uq ON q.id = uq.question_id %s", whereClause)
        var totalCount int
        err = s.db.QueryRowContext(ctx, countQuery, args...).Scan(&amp;totalCount)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        // Calculate offset
        <span class="cov3" title="7">offset := (page - 1) * pageSize

        // Build main query with pagination
        query := fmt.Sprintf(`
                SELECT
                        q.id, q.type, q.language, q.level, q.difficulty_score,
                        q.content, q.correct_answer, q.explanation, q.created_at, q.status,
                        q.topic_category, q.grammar_focus, q.vocabulary_domain, q.scenario, q.style_modifier, q.difficulty_modifier, q.time_context,
                        COALESCE(SUM(CASE WHEN ur.is_correct = true THEN 1 ELSE 0 END), 0) as correct_count,
                        COALESCE(SUM(CASE WHEN ur.is_correct = false THEN 1 ELSE 0 END), 0) as incorrect_count,
                        COALESCE(COUNT(ur.id), 0) as total_responses
                FROM questions q
                JOIN user_questions uq ON q.id = uq.question_id
                LEFT JOIN user_responses ur ON q.id = ur.question_id
                %s
                GROUP BY q.id, q.type, q.language, q.level, q.difficulty_score,
                        q.content, q.correct_answer, q.explanation, q.created_at, q.status,
                        q.topic_category, q.grammar_focus, q.vocabulary_domain, q.scenario, q.style_modifier, q.difficulty_modifier, q.time_context
                ORDER BY q.id DESC
                LIMIT $%d OFFSET $%d
        `, whereClause, argCount+1, argCount+2)

        // Add pagination parameters
        args = append(args, pageSize, offset)

        rows, err := s.db.QueryContext(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>
        <span class="cov3" title="7">defer func() </span><span class="cov3" title="7">{
                if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn(ctx, "Failed to close rows", map[string]interface{}{"error": err.Error()})
                }</span>
        }()

        <span class="cov3" title="7">var questions []*QuestionWithStats
        for rows.Next() </span><span class="cov5" title="67">{
                questionWithStats, err := s.scanQuestionWithStatsAndAllFieldsFromRows(rows)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, 0, err
                }</span>
                <span class="cov5" title="67">questions = append(questions, questionWithStats)</span>
        }

        <span class="cov3" title="7">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov3" title="7">return questions, totalCount, nil</span>
}

// PRIORITY-BASED QUESTION SELECTION METHODS

// getAvailableQuestionsWithPriority retrieves available questions with priority scores and stats
func (s *QuestionService) getAvailableQuestionsWithPriority(ctx context.Context, userID int, language, level string, qType models.QuestionType, _ *models.UserLearningPreferences) (result0 []*QuestionWithStats, err error) <span class="cov7" title="206">{
        ctx, span := observability.TraceQuestionFunction(ctx, "get_available_questions_with_priority", observability.AttributeUserID(userID), observability.AttributeLanguage(language), observability.AttributeLevel(level), observability.AttributeQuestionType(qType))
        defer func() </span><span class="cov7" title="206">{
                if err != nil </span><span class="cov0" title="0">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov7" title="206">span.End()</span>
        }()
        // Build SQL query with priority scoring and stats
        <span class="cov7" title="206">query := `
                SELECT q.id, q.type, q.language, q.level, q.difficulty_score, q.content, q.correct_answer, q.explanation, q.created_at, q.status,
                       q.topic_category, q.grammar_focus, q.vocabulary_domain, q.scenario, q.style_modifier, q.difficulty_modifier, q.time_context,
                       COALESCE(qps.priority_score, 100.0) as priority_score,
                       COALESCE(uq_stats.times_answered, 0) as times_answered,
                       uq_stats.last_answered_at,
                       COALESCE(stats.correct_count, 0) as correct_count,
                       COALESCE(stats.incorrect_count, 0) as incorrect_count,
                       COALESCE(stats.total_responses, 0) as total_responses
                FROM questions q
                JOIN user_questions uq ON q.id = uq.question_id
                LEFT JOIN question_priority_scores qps ON q.id = qps.question_id AND qps.user_id = $1
                LEFT JOIN (
                        SELECT question_id,
                               COUNT(*) as times_answered,
                               MAX(created_at) as last_answered_at
                        FROM user_responses
                        WHERE user_id = $1
                        GROUP BY question_id
                ) uq_stats ON q.id = uq_stats.question_id
                LEFT JOIN (
                        SELECT
                                question_id,
                                COUNT(CASE WHEN is_correct = true THEN 1 END) as correct_count,
                                COUNT(CASE WHEN is_correct = false THEN 1 END) as incorrect_count,
                                COUNT(*) as total_responses
                        FROM user_responses
                        GROUP BY question_id
                ) stats ON q.id = stats.question_id
                WHERE uq.user_id = $1
                AND q.language = $2
                AND q.level = $3
                AND q.type = $4
                AND q.status = 'active'
                AND q.id NOT IN (
                        SELECT ur.question_id
                        FROM user_responses ur
                        WHERE ur.user_id = $1
                        AND ur.created_at &gt; NOW() - INTERVAL '1 hour'
                )
                ORDER BY priority_score DESC, RANDOM()
                LIMIT 50
        `

        rows, err := s.db.QueryContext(ctx, query, userID, language, level, qType)
        if err != nil </span><span class="cov0" title="0">{
                return nil, contextutils.WrapErrorf(contextutils.ErrDatabaseQuery, "failed to query questions: %w", err)
        }</span>
        <span class="cov7" title="206">defer func() </span><span class="cov7" title="206">{
                if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn(ctx, "Failed to close rows", map[string]interface{}{"error": err.Error()})
                }</span>
        }()

        <span class="cov7" title="206">var questions []*QuestionWithStats
        for rows.Next() </span><span class="cov10" title="2011">{
                questionWithStats, err := s.scanQuestionWithPriorityAndStatsFromRows(rows)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Error(ctx, "Error scanning question", err, map[string]interface{}{})
                        continue</span> // Skip malformed rows
                }
                <span class="cov10" title="2011">questions = append(questions, questionWithStats)</span>
        }

        <span class="cov7" title="206">return questions, nil</span>
}

// selectQuestionWithWeightedRandomness selects a question using weighted random selection
func (s *QuestionService) selectQuestionWithWeightedRandomness(questions []*QuestionWithStats) (result0 *QuestionWithStats, err error) <span class="cov7" title="203">{
        if len(questions) == 0 </span><span class="cov0" title="0">{
                return nil, contextutils.WrapError(contextutils.ErrRecordNotFound, "no questions available")
        }</span>

        // Use weighted random selection based on usage count (lower = higher priority)
        <span class="cov7" title="203">totalWeight := 0.0
        for _, q := range questions </span><span class="cov9" title="1011">{
                // Lower usage count = higher weight
                weight := 1.0 / (float64(q.TotalResponses) + 1.0)
                totalWeight += weight
        }</span>

        <span class="cov7" title="203">if totalWeight == 0 </span><span class="cov0" title="0">{
                return nil, contextutils.WrapError(contextutils.ErrValidationFailed, "all questions have zero weight")
        }</span>

        <span class="cov7" title="203">target := rand.Float64() * totalWeight
        currentWeight := 0.0

        for _, q := range questions </span><span class="cov8" title="617">{
                weight := 1.0 / (float64(q.TotalResponses) + 1.0)
                currentWeight += weight
                if currentWeight &gt;= target </span><span class="cov7" title="203">{
                        return q, nil
                }</span>
        }

        <span class="cov0" title="0">return nil, contextutils.WrapError(contextutils.ErrInternalError, "failed to select question with weighted randomness")</span>
}

// selectQuestionWithFreshnessRatio selects a question based on freshness ratio
func (s *QuestionService) selectQuestionWithFreshnessRatio(questions []*QuestionWithStats, freshnessRatio float64) (result0 *QuestionWithStats, err error) <span class="cov7" title="203">{
        if len(questions) == 0 </span><span class="cov0" title="0">{
                return nil, contextutils.WrapError(contextutils.ErrRecordNotFound, "no questions available")
        }</span>

        // Separate fresh and review questions based on total responses
        <span class="cov7" title="203">var freshQuestions []*QuestionWithStats
        var reviewQuestions []*QuestionWithStats

        for _, q := range questions </span><span class="cov10" title="2011">{
                if q.TotalResponses == 0 </span><span class="cov8" title="411">{
                        freshQuestions = append(freshQuestions, q)
                }</span> else<span class="cov9" title="1600"> {
                        reviewQuestions = append(reviewQuestions, q)
                }</span>
        }

        // Decide whether to serve a fresh or review question based on ratio
        <span class="cov7" title="203">shouldServeFresh := rand.Float64() &lt; freshnessRatio

        var selectedQuestions []*QuestionWithStats
        if shouldServeFresh &amp;&amp; len(freshQuestions) &gt; 0 </span><span class="cov6" title="100">{
                selectedQuestions = freshQuestions
        }</span> else<span class="cov6" title="103"> if len(reviewQuestions) &gt; 0 </span><span class="cov6" title="100">{
                selectedQuestions = reviewQuestions
        }</span> else<span class="cov2" title="3"> if len(freshQuestions) &gt; 0 </span><span class="cov2" title="3">{
                // Fallback to fresh if no review questions available
                selectedQuestions = freshQuestions
        }</span> else<span class="cov0" title="0"> {
                // Fallback to all questions if no separation possible
                selectedQuestions = questions
        }</span>

        <span class="cov7" title="203">if len(selectedQuestions) == 0 </span><span class="cov0" title="0">{
                return nil, contextutils.WrapError(contextutils.ErrRecordNotFound, "no questions available after freshness filtering")
        }</span>

        // Use weighted random selection within the chosen category
        <span class="cov7" title="203">return s.selectQuestionWithWeightedRandomness(selectedQuestions)</span>
}

// GetUserQuestionCount returns the total number of questions available for a user
func (s *QuestionService) GetUserQuestionCount(ctx context.Context, userID int) (result0 int, err error) <span class="cov2" title="3">{
        ctx, span := observability.TraceQuestionFunction(ctx, "get_user_question_count", observability.AttributeUserID(userID))
        defer func() </span><span class="cov2" title="3">{
                if err != nil </span><span class="cov0" title="0">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov2" title="3">span.End()</span>
        }()
        <span class="cov2" title="3">query := `
                SELECT COUNT(DISTINCT q.id)
                FROM questions q
                JOIN user_questions uq ON q.id = uq.question_id
                WHERE uq.user_id = $1 AND q.status = 'active'
        `

        var count int
        err = s.db.QueryRowContext(ctx, query, userID).Scan(&amp;count)
        if err != nil </span><span class="cov0" title="0">{
                return 0, contextutils.WrapErrorf(contextutils.ErrDatabaseQuery, "failed to get user question count: %w", err)
        }</span>
        <span class="cov2" title="3">return count, nil</span>
}

// GetUserResponseCount returns the total number of responses for a user
func (s *QuestionService) GetUserResponseCount(ctx context.Context, userID int) (result0 int, err error) <span class="cov2" title="3">{
        ctx, span := observability.TraceQuestionFunction(ctx, "get_user_response_count", observability.AttributeUserID(userID))
        defer func() </span><span class="cov2" title="3">{
                if err != nil </span><span class="cov0" title="0">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov2" title="3">span.End()</span>
        }()
        <span class="cov2" title="3">query := `SELECT COUNT(*) FROM user_responses WHERE user_id = $1`

        var count int
        err = s.db.QueryRowContext(ctx, query, userID).Scan(&amp;count)
        if err != nil </span><span class="cov0" title="0">{
                return 0, contextutils.WrapErrorf(contextutils.ErrDatabaseQuery, "failed to get user response count: %w", err)
        }</span>
        <span class="cov2" title="3">return count, nil</span>
}

// Helper: scan a *sql.Row into a QuestionWithStats (for single-row queries)
func (s *QuestionService) scanQuestionWithPriorityAndStatsFromRow(row *sql.Row) (result0 *QuestionWithStats, err error) <span class="cov4" title="13">{
        questionWithStats := &amp;QuestionWithStats{
                Question: &amp;models.Question{},
        }
        var contentJSON string
        var priorityScore float64
        var timesAnswered int
        var lastAnsweredAt sql.NullTime

        err = row.Scan(
                &amp;questionWithStats.ID,
                &amp;questionWithStats.Type,
                &amp;questionWithStats.Language,
                &amp;questionWithStats.Level,
                &amp;questionWithStats.DifficultyScore,
                &amp;contentJSON,
                &amp;questionWithStats.CorrectAnswer,
                &amp;questionWithStats.Explanation,
                &amp;questionWithStats.CreatedAt,
                &amp;questionWithStats.Status,
                &amp;questionWithStats.TopicCategory,
                &amp;questionWithStats.GrammarFocus,
                &amp;questionWithStats.VocabularyDomain,
                &amp;questionWithStats.Scenario,
                &amp;questionWithStats.StyleModifier,
                &amp;questionWithStats.DifficultyModifier,
                &amp;questionWithStats.TimeContext,
                &amp;priorityScore,
                &amp;timesAnswered,
                &amp;lastAnsweredAt,
                &amp;questionWithStats.CorrectCount,
                &amp;questionWithStats.IncorrectCount,
                &amp;questionWithStats.TotalResponses,
        )
        if err != nil </span><span class="cov3" title="6">{
                return nil, err
        }</span>

        <span class="cov3" title="7">if err := json.Unmarshal([]byte(contentJSON), &amp;questionWithStats.Content); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov3" title="7">return questionWithStats, nil</span>
}

// GetRandomGlobalQuestionForUser finds a random question from the global pool for the given language, level, and type that is not already assigned to the user, assigns it, and returns it.
func (s *QuestionService) GetRandomGlobalQuestionForUser(ctx context.Context, userID int, language, level string, qType models.QuestionType) (result0 *QuestionWithStats, err error) <span class="cov4" title="13">{
        ctx, span := observability.TraceQuestionFunction(ctx, "get_random_global_question_for_user", observability.AttributeUserID(userID), observability.AttributeLanguage(language), observability.AttributeLevel(level), observability.AttributeQuestionType(qType))
        defer func() </span><span class="cov4" title="13">{
                if err != nil </span><span class="cov0" title="0">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov4" title="13">span.End()</span>
        }()

        <span class="cov4" title="13">query := `
                SELECT q.id, q.type, q.language, q.level, q.difficulty_score, q.content, q.correct_answer, q.explanation, q.created_at, q.status,
                       q.topic_category, q.grammar_focus, q.vocabulary_domain, q.scenario, q.style_modifier, q.difficulty_modifier, q.time_context,
                       100.0 as priority_score, 0 as times_answered, NULL as last_answered_at, 0 as correct_count, 0 as incorrect_count, 0 as total_responses
                FROM questions q
                WHERE q.language = $1
                  AND q.level = $2
                  AND q.type = $3
                  AND q.status = 'active'
                  AND q.id NOT IN (
                    SELECT uq.question_id
                    FROM user_questions uq
                    WHERE uq.user_id = $4
                  )
                ORDER BY RANDOM()
                LIMIT 1
        `

        row := s.db.QueryRowContext(ctx, query, language, level, qType, userID)
        questionWithStats, err := s.scanQuestionWithPriorityAndStatsFromRow(row)
        if err != nil </span><span class="cov3" title="6">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov3" title="6">{
                        return nil, nil // No global questions available
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        // Assign the question to the user
        <span class="cov3" title="7">err = s.AssignQuestionToUser(ctx, questionWithStats.ID, userID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Warn(ctx, "Failed to assign global question to user", map[string]interface{}{"question_id": questionWithStats.ID, "user_id": userID, "error": err.Error()})
                // Still return the question, but log the error
        }</span>

        <span class="cov3" title="7">return questionWithStats, nil</span>
}

// DB returns the underlying *sql.DB instance
func (s *QuestionService) DB() *sql.DB <span class="cov0" title="0">{
        return s.db
}</span>
</pre>
		
		<pre class="file" id="file32" style="display: none">//go:build integration
// +build integration

package services

import (
        "context"
        "database/sql"
        "fmt"
        "os"
        "testing"

        "quizapp/internal/config"
        "quizapp/internal/database"
        "quizapp/internal/observability"

        "github.com/stretchr/testify/require"
)

// SharedTestDBSetup provides a clean, isolated database for each integration test
func SharedTestDBSetup(t *testing.T) *sql.DB <span class="cov7" title="114">{
        observabilityLogger := observability.NewLogger(&amp;config.OpenTelemetryConfig{EnableLogging: false})
        dbManager := database.NewManager(observabilityLogger)

        // Use environment variable for test database URL, fallback to default
        databaseURL := os.Getenv("TEST_DATABASE_URL")
        if databaseURL == "" </span><span class="cov0" title="0">{
                databaseURL = "postgres://quiz_user:quiz_password@localhost:5433/quiz_test_db?sslmode=disable"
        }</span>

        <span class="cov7" title="114">db, err := dbManager.InitDB(databaseURL)
        require.NoError(t, err)

        // Whitelist of valid table names to prevent SQL injection
        validTables := map[string]bool{
                "user_responses":            true,
                "performance_metrics":       true,
                "user_question_metadata":    true,
                "question_priority_scores":  true,
                "user_learning_preferences": true,
                "user_questions":            true,
                "questions":                 true,
                "worker_status":             true,
                "worker_settings":           true,
                "users":                     true,
        }

        // Whitelist of valid sequence names to prevent SQL injection
        validSequences := map[string]bool{
                "users_id_seq":               true,
                "questions_id_seq":           true,
                "user_responses_id_seq":      true,
                "performance_metrics_id_seq": true,
        }

        // Clean up any existing data using TRUNCATE CASCADE for proper isolation
        // Order matters: child tables first, then parent tables
        tables := []string{
                "user_responses",
                "performance_metrics",
                "user_question_metadata",
                "question_priority_scores",
                "user_learning_preferences",
                "user_questions",
                "questions",
                "worker_status",
                "worker_settings",
                "users",
        }

        ctx := context.Background()
        for _, table := range tables </span><span class="cov10" title="1140">{
                // Validate table name against whitelist
                if !validTables[table] </span><span class="cov0" title="0">{
                        t.Logf("Warning: Invalid table name %s, skipping", table)
                        continue</span>
                }

                <span class="cov10" title="1140">query := fmt.Sprintf("TRUNCATE TABLE %s CASCADE", table)
                _, err := db.ExecContext(ctx, query)
                if err != nil </span><span class="cov0" title="0">{
                        t.Logf("Warning: Could not truncate table %s: %v", table, err)
                }</span>
        }

        // Reset sequences to ensure consistent IDs starting from 1
        <span class="cov7" title="114">sequences := []string{"users_id_seq", "questions_id_seq", "user_responses_id_seq", "performance_metrics_id_seq"}
        for _, seq := range sequences </span><span class="cov8" title="456">{
                // Validate sequence name against whitelist
                if !validSequences[seq] </span><span class="cov0" title="0">{
                        t.Logf("Warning: Invalid sequence name %s, skipping", seq)
                        continue</span>
                }

                <span class="cov8" title="456">query := fmt.Sprintf("ALTER SEQUENCE %s RESTART WITH 1", seq)
                _, err := db.ExecContext(ctx, query)
                if err != nil </span><span class="cov0" title="0">{
                        // Log but don't fail if sequence doesn't exist
                        t.Logf("Note: Could not reset sequence %s: %v", seq, err)
                }</span>
        }

        // Insert default worker settings for consistent test state
        <span class="cov7" title="114">_, err = db.ExecContext(ctx, `
                INSERT INTO worker_settings (setting_key, setting_value, created_at, updated_at)
                VALUES ('global_pause', 'false', NOW(), NOW())
                ON CONFLICT (setting_key) DO NOTHING;
        `)
        require.NoError(t, err)

        return db</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package services

import (
        "context"
        "database/sql"
        "errors"
        "fmt"
        "strings"
        "time"

        "quizapp/internal/config"
        "quizapp/internal/models"
        "quizapp/internal/observability"
        contextutils "quizapp/internal/utils"

        "go.opentelemetry.io/otel/attribute"
        "go.opentelemetry.io/otel/codes"
        "go.opentelemetry.io/otel/trace"
        "golang.org/x/crypto/bcrypt"
)

// UserServiceInterface defines the interface for user-related operations.
// This allows for easier mocking in tests.
type UserServiceInterface interface {
        CreateUser(ctx context.Context, username, language, level string) (*models.User, error)
        CreateUserWithPassword(ctx context.Context, username, password, language, level string) (*models.User, error)
        CreateUserWithEmailAndTimezone(ctx context.Context, username, email, timezone, language, level string) (*models.User, error)
        GetUserByID(ctx context.Context, id int) (*models.User, error)
        GetUserByUsername(ctx context.Context, username string) (*models.User, error)
        GetUserByEmail(ctx context.Context, email string) (*models.User, error)
        AuthenticateUser(ctx context.Context, username, password string) (*models.User, error)
        UpdateUserSettings(ctx context.Context, userID int, settings *models.UserSettings) error
        UpdateUserProfile(ctx context.Context, userID int, username, email, timezone string) error
        UpdateUserPassword(ctx context.Context, userID int, newPassword string) error
        UpdateLastActive(ctx context.Context, userID int) error
        GetAllUsers(ctx context.Context) ([]models.User, error)
        DeleteUser(ctx context.Context, userID int) error
        DeleteAllUsers(ctx context.Context) error
        EnsureAdminUserExists(ctx context.Context, adminUsername, adminPassword string) error
        ResetDatabase(ctx context.Context) error
        ClearUserData(ctx context.Context) error
        ClearUserDataForUser(ctx context.Context, userID int) error
        GetUserAPIKey(ctx context.Context, userID int, provider string) (string, error)
        SetUserAPIKey(ctx context.Context, userID int, provider, apiKey string) error
        HasUserAPIKey(ctx context.Context, userID int, provider string) (bool, error)
}

// UserService provides methods for user management.
type UserService struct {
        db     *sql.DB
        cfg    *config.Config
        logger *observability.Logger
}

// Shared query constants to eliminate duplication
const (
        // userSelectFields contains all user fields for SELECT queries
        userSelectFields = `id, username, email, timezone, password_hash, last_active, preferred_language, current_level, ai_provider, ai_model, ai_enabled, ai_api_key, api_key, created_at, updated_at`

        // userSelectFieldsNoPassword contains user fields excluding password_hash for GetAllUsers
        userSelectFieldsNoPassword = `id, username, email, timezone, last_active, preferred_language, current_level, ai_provider, ai_model, ai_enabled, ai_api_key, created_at, updated_at`
)

// scanUserFromRow scans a database row into a models.User struct
func (s *UserService) scanUserFromRow(row *sql.Row) (result0 *models.User, err error) <span class="cov10" title="136">{
        user := &amp;models.User{}
        err = row.Scan(
                &amp;user.ID, &amp;user.Username, &amp;user.Email, &amp;user.Timezone, &amp;user.PasswordHash, &amp;user.LastActive,
                &amp;user.PreferredLanguage, &amp;user.CurrentLevel, &amp;user.AIProvider,
                &amp;user.AIModel, &amp;user.AIEnabled, &amp;user.AIAPIKey, &amp;user.APIKey, &amp;user.CreatedAt, &amp;user.UpdatedAt,
        )
        if err != nil </span><span class="cov5" title="11">{
                return nil, err
        }</span>
        <span class="cov9" title="125">return user, nil</span>
}

// scanUserFromRowsNoPassword scans a database rows into a models.User struct (without password_hash)
func (s *UserService) scanUserFromRowsNoPassword(rows *sql.Rows) (result0 *models.User, err error) <span class="cov6" title="16">{
        user := &amp;models.User{}
        err = rows.Scan(
                &amp;user.ID, &amp;user.Username, &amp;user.Email, &amp;user.Timezone, &amp;user.LastActive,
                &amp;user.PreferredLanguage, &amp;user.CurrentLevel, &amp;user.AIProvider,
                &amp;user.AIModel, &amp;user.AIEnabled, &amp;user.AIAPIKey, &amp;user.CreatedAt, &amp;user.UpdatedAt,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov6" title="16">return user, nil</span>
}

// getUserByQuery is a shared method for getting a user by any query
func (s *UserService) getUserByQuery(ctx context.Context, query string, args ...interface{}) (result0 *models.User, err error) <span class="cov10" title="136">{
        row := s.db.QueryRowContext(ctx, query, args...)
        var user *models.User
        user, err = s.scanUserFromRow(row)
        if err != nil </span><span class="cov5" title="11">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov5" title="11">{
                        return nil, nil // User not found is not an error here
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        // Try to apply default settings, but don't fail if there's an issue
        <span class="cov9" title="125">s.applyDefaultSettings(ctx, user)
        return user, nil</span>
}

// NewUserServiceWithLogger creates a new UserService instance with logger
func NewUserServiceWithLogger(db *sql.DB, cfg *config.Config, logger *observability.Logger) *UserService <span class="cov8" title="75">{
        return &amp;UserService{
                db:     db,
                cfg:    cfg,
                logger: logger,
        }
}</span>

// CreateUser creates a new user with the specified username, language, and level
func (s *UserService) CreateUser(ctx context.Context, username, language, level string) (result0 *models.User, err error) <span class="cov6" title="16">{
        ctx, span := observability.TraceUserFunction(ctx, "create_user", attribute.String("user.username", username))
        defer func() </span><span class="cov6" title="16">{
                if err != nil </span><span class="cov2" title="2">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov6" title="16">span.End()</span>
        }()

        // Validate username is not empty
        <span class="cov6" title="16">if username == "" || len(strings.TrimSpace(username)) == 0 </span><span class="cov1" title="1">{
                return nil, contextutils.WrapError(contextutils.ErrInvalidInput, "username cannot be empty")
        }</span>

        <span class="cov5" title="15">query := `INSERT INTO users (username, preferred_language, current_level, last_active, created_at, updated_at) VALUES ($1, $2, $3, $4, $5, $6) RETURNING id`
        now := time.Now()
        var id int
        err = s.db.QueryRowContext(ctx, query, username, language, level, now, now, now).Scan(&amp;id)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov5" title="14">var user *models.User
        user, err = s.GetUserByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov5" title="14">if user == nil </span><span class="cov0" title="0">{
                return nil, contextutils.WrapError(contextutils.ErrDatabaseQuery, "user was created but could not be retrieved from database")
        }</span>
        <span class="cov5" title="14">return user, nil</span>
}

// CreateUserWithEmailAndTimezone creates a new user with email and timezone
func (s *UserService) CreateUserWithEmailAndTimezone(ctx context.Context, username, email, timezone, language, level string) (result0 *models.User, err error) <span class="cov5" title="11">{
        ctx, span := observability.TraceUserFunction(ctx, "create_user_with_email", attribute.String("user.username", username))
        defer func() </span><span class="cov5" title="11">{
                if err != nil </span><span class="cov0" title="0">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov5" title="11">span.End()</span>
        }()

        // Validate username is not empty
        <span class="cov5" title="11">if username == "" || len(strings.TrimSpace(username)) == 0 </span><span class="cov0" title="0">{
                return nil, contextutils.WrapError(contextutils.ErrInvalidInput, "username cannot be empty")
        }</span>

        <span class="cov5" title="11">query := `INSERT INTO users (username, email, timezone, preferred_language, current_level, ai_enabled, last_active, created_at, updated_at) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9) RETURNING id`
        now := time.Now()
        var id int
        err = s.db.QueryRowContext(ctx, query, username, email, timezone, language, level, false, now, now, now).Scan(&amp;id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov5" title="11">var user *models.User
        user, err = s.GetUserByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov5" title="11">if user == nil </span><span class="cov0" title="0">{
                return nil, contextutils.WrapError(contextutils.ErrDatabaseQuery, "user was created but could not be retrieved from database")
        }</span>
        <span class="cov5" title="11">return user, nil</span>
}

// CreateUserWithPassword creates a new user with password authentication
func (s *UserService) CreateUserWithPassword(ctx context.Context, username, password, language, level string) (result0 *models.User, err error) <span class="cov8" title="64">{
        ctx, span := observability.TraceUserFunction(ctx, "create_user_with_password", attribute.String("user.username", username))
        defer func() </span><span class="cov8" title="64">{
                if err != nil </span><span class="cov0" title="0">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov8" title="64">span.End()</span>
        }()

        // Validate username is not empty
        <span class="cov8" title="64">if username == "" || len(strings.TrimSpace(username)) == 0 </span><span class="cov0" title="0">{
                return nil, contextutils.WrapError(contextutils.ErrInvalidInput, "username cannot be empty")
        }</span>

        // Hash the password using bcrypt
        <span class="cov8" title="64">var hashedPassword []byte
        hashedPassword, err = bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="64">query := `INSERT INTO users (username, password_hash, preferred_language, current_level, ai_enabled, last_active, created_at, updated_at) VALUES ($1, $2, $3, $4, $5, $6, $7, $8) RETURNING id`
        now := time.Now()
        var id int
        err = s.db.QueryRowContext(ctx, query, username, string(hashedPassword), language, level, false, now, now, now).Scan(&amp;id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="64">user, err := s.GetUserByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="64">if user == nil </span><span class="cov0" title="0">{
                return nil, contextutils.WrapError(contextutils.ErrDatabaseQuery, "user was created but could not be retrieved from database")
        }</span>
        <span class="cov8" title="64">return user, nil</span>
}

// AuthenticateUser verifies user credentials and returns the user if valid
func (s *UserService) AuthenticateUser(ctx context.Context, username, password string) (result0 *models.User, err error) <span class="cov5" title="9">{
        ctx, span := observability.TraceUserFunction(ctx, "authenticate_user", attribute.String("user.username", username))
        defer func() </span><span class="cov5" title="9">{
                if err != nil </span><span class="cov3" title="5">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov5" title="9">span.End()</span>
        }()
        // Get user by username
        <span class="cov5" title="9">var user *models.User
        user, err = s.GetUserByUsername(ctx, username)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov5" title="9">if user == nil </span><span class="cov1" title="1">{
                return nil, errors.New("user not found")
        }</span>

        // Check if password hash exists
        <span class="cov4" title="8">if !user.PasswordHash.Valid </span><span class="cov1" title="1">{
                return nil, errors.New("user has no password set")
        }</span>

        // Compare provided password with stored hash
        <span class="cov4" title="7">err = bcrypt.CompareHashAndPassword([]byte(user.PasswordHash.String), []byte(password))
        if err != nil </span><span class="cov3" title="3">{
                return nil, errors.New("invalid password")
        }</span>

        <span class="cov3" title="4">return user, nil</span>
}

// GetUserByID retrieves a user by their ID
func (s *UserService) GetUserByID(ctx context.Context, id int) (result0 *models.User, err error) <span class="cov9" title="119">{
        ctx, span := observability.TraceUserFunction(ctx, "get_user_by_id", attribute.Int("user.id", id))
        defer func() </span><span class="cov9" title="119">{
                if err != nil </span><span class="cov0" title="0">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov9" title="119">span.End()</span>
        }()
        <span class="cov9" title="119">query := fmt.Sprintf("SELECT %s FROM users WHERE id = $1", userSelectFields)
        var user *models.User
        user, err = s.getUserByQuery(ctx, query, id)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error(ctx, "Database error retrieving user", err, map[string]interface{}{"user_id": id})
                return nil, err
        }</span>
        <span class="cov9" title="119">if user == nil </span><span class="cov4" title="7">{
                s.logger.Debug(ctx, "User not found in database", map[string]interface{}{"user_id": id})
        }</span>
        <span class="cov9" title="119">return user, nil</span>
}

// GetUserByUsername retrieves a user by their username
func (s *UserService) GetUserByUsername(ctx context.Context, username string) (result0 *models.User, err error) <span class="cov5" title="13">{
        ctx, span := observability.TraceUserFunction(ctx, "get_user_by_username", attribute.String("user.username", username))
        defer func() </span><span class="cov5" title="13">{
                if err != nil </span><span class="cov0" title="0">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov5" title="13">span.End()</span>
        }()
        <span class="cov5" title="13">query := fmt.Sprintf("SELECT %s FROM users WHERE username = $1", userSelectFields)
        return s.getUserByQuery(ctx, query, username)</span>
}

// UpdateUserSettings updates user settings including AI configuration
func (s *UserService) UpdateUserSettings(ctx context.Context, userID int, settings *models.UserSettings) (err error) <span class="cov5" title="9">{
        ctx, span := observability.TraceUserFunction(ctx, "update_user_settings", attribute.Int("user.id", userID))
        defer func() </span><span class="cov5" title="9">{
                if err != nil </span><span class="cov1" title="1">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov5" title="9">span.End()</span>
        }()

        // Check if user exists before updating settings
        <span class="cov5" title="9">user, err := s.GetUserByID(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return contextutils.WrapError(err, "failed to check if user exists")
        }</span>
        <span class="cov5" title="9">if user == nil </span><span class="cov1" title="1">{
                return contextutils.WrapError(contextutils.ErrRecordNotFound, "user not found")
        }</span>

        // Start a transaction to update both user settings and API key
        <span class="cov4" title="8">var tx *sql.Tx
        tx, err = s.db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return contextutils.WrapError(err, "failed to begin transaction for user settings update")
        }</span>
        <span class="cov4" title="8">defer func() </span><span class="cov4" title="8">{
                if rollbackErr := tx.Rollback(); rollbackErr != nil &amp;&amp; rollbackErr != sql.ErrTxDone </span><span class="cov0" title="0">{
                        s.logger.Warn(ctx, "Warning: failed to rollback transaction", map[string]interface{}{"error": rollbackErr.Error()})
                }</span>
        }()

        // Handle AI enabled logic
        <span class="cov4" title="8">aiProvider := settings.AIProvider
        aiModel := settings.AIModel

        // If AI is disabled, clear the provider and model
        if !settings.AIEnabled </span><span class="cov2" title="2">{
                aiProvider = ""
                aiModel = ""
        }</span>

        // Update user settings (excluding API key which is now stored separately)
        <span class="cov4" title="8">query := `UPDATE users SET preferred_language = $1, current_level = $2, ai_provider = $3, ai_model = $4, ai_enabled = $5, updated_at = $6 WHERE id = $7`
        _, err = tx.ExecContext(ctx, query, settings.Language, settings.Level, aiProvider, aiModel, settings.AIEnabled, time.Now(), userID)
        if err != nil </span><span class="cov0" title="0">{
                return contextutils.WrapError(err, "failed to update user settings in transaction")
        }</span>

        // If an API key is provided and AI is enabled, save it for the specific provider
        <span class="cov4" title="8">if settings.AIAPIKey != "" &amp;&amp; settings.AIProvider != "" &amp;&amp; settings.AIEnabled </span><span class="cov1" title="1">{
                err = s.setUserAPIKeyTx(ctx, tx, userID, settings.AIProvider, settings.AIAPIKey)
                if err != nil </span><span class="cov0" title="0">{
                        return contextutils.WrapError(err, "failed to set user API key in transaction")
                }</span>
        }

        <span class="cov4" title="8">return tx.Commit()</span>
}

// GetUserAPIKey retrieves the API key for a specific provider for a user
func (s *UserService) GetUserAPIKey(ctx context.Context, userID int, provider string) (result0 string, err error) <span class="cov3" title="3">{
        ctx, span := observability.TraceUserFunction(ctx, "get_user_api_key", attribute.Int("user.id", userID), attribute.String("user.provider", provider))
        defer func() </span><span class="cov3" title="3">{
                if err != nil </span><span class="cov3" title="3">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov3" title="3">span.End()</span>
        }()

        // Check if user exists before getting API key
        <span class="cov3" title="3">user, err := s.GetUserByID(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return "", contextutils.WrapError(err, "failed to check if user exists")
        }</span>
        <span class="cov3" title="3">if user == nil </span><span class="cov2" title="2">{
                return "", contextutils.WrapError(contextutils.ErrRecordNotFound, "user not found")
        }</span>

        <span class="cov1" title="1">query := `SELECT api_key FROM user_api_keys WHERE user_id = $1 AND provider = $2`
        var apiKey string
        err = s.db.QueryRowContext(ctx, query, userID, provider).Scan(&amp;apiKey)
        if err != nil </span><span class="cov1" title="1">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov1" title="1">{
                        return "", contextutils.WrapError(contextutils.ErrRecordNotFound, "API key for provider not found")
                }</span>
                <span class="cov0" title="0">return "", contextutils.WrapError(err, "failed to get user API key")</span>
        }
        <span class="cov0" title="0">return apiKey, nil</span>
}

// SetUserAPIKey sets the API key for a specific provider for a user
func (s *UserService) SetUserAPIKey(ctx context.Context, userID int, provider, apiKey string) (err error) <span class="cov2" title="2">{
        ctx, span := observability.TraceUserFunction(ctx, "set_user_api_key", attribute.Int("user.id", userID), attribute.String("user.provider", provider))
        defer func() </span><span class="cov2" title="2">{
                if err != nil </span><span class="cov1" title="1">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov2" title="2">span.End()</span>
        }()

        // Check if user exists before setting API key
        <span class="cov2" title="2">user, err := s.GetUserByID(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return contextutils.WrapError(err, "failed to check if user exists")
        }</span>
        <span class="cov2" title="2">if user == nil </span><span class="cov1" title="1">{
                return contextutils.WrapError(contextutils.ErrRecordNotFound, "user not found")
        }</span>

        <span class="cov1" title="1">var tx *sql.Tx
        tx, err = s.db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return contextutils.WrapError(err, "failed to begin transaction for API key update")
        }</span>
        <span class="cov1" title="1">defer func() </span><span class="cov1" title="1">{
                if err != nil </span><span class="cov0" title="0">{
                        if rollbackErr := tx.Rollback(); rollbackErr != nil </span><span class="cov0" title="0">{
                                s.logger.Warn(ctx, "Warning: failed to rollback transaction", map[string]interface{}{"error": rollbackErr.Error()})
                        }</span>
                }
        }()

        <span class="cov1" title="1">err = s.setUserAPIKeyTx(ctx, tx, userID, provider, apiKey)
        if err != nil </span><span class="cov0" title="0">{
                return contextutils.WrapError(err, "failed to set user API key in transaction")
        }</span>

        <span class="cov1" title="1">commitErr := tx.Commit()
        if commitErr != nil </span><span class="cov0" title="0">{
                return contextutils.WrapError(commitErr, "failed to commit API key transaction")
        }</span>

        // Clear the error so defer doesn't try to rollback
        <span class="cov1" title="1">err = nil
        return nil</span>
}

// setUserAPIKeyTx sets the API key for a specific provider within a transaction
func (s *UserService) setUserAPIKeyTx(ctx context.Context, tx *sql.Tx, userID int, provider, apiKey string) error <span class="cov2" title="2">{
        query := `INSERT INTO user_api_keys (user_id, provider, api_key, updated_at)
                          VALUES ($1, $2, $3, $4)
                          ON CONFLICT (user_id, provider)
                          DO UPDATE SET api_key = $3, updated_at = $4`
        _, err := tx.ExecContext(ctx, query, userID, provider, apiKey, time.Now())
        return contextutils.WrapError(err, "failed to execute API key transaction")
}</span>

// HasUserAPIKey checks if a user has an API key for a specific provider
func (s *UserService) HasUserAPIKey(ctx context.Context, userID int, provider string) (result0 bool, err error) <span class="cov1" title="1">{
        ctx, span := observability.TraceUserFunction(ctx, "has_user_api_key", attribute.Int("user.id", userID), attribute.String("user.provider", provider))
        defer func() </span><span class="cov1" title="1">{
                if err != nil </span><span class="cov1" title="1">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov1" title="1">span.End()</span>
        }()
        <span class="cov1" title="1">var apiKey string
        apiKey, err = s.GetUserAPIKey(ctx, userID, provider)
        if err != nil </span><span class="cov1" title="1">{
                // If the error is "not found" and it's specifically about the API key not existing (not the user),
                // then it means no API key exists, which is not an error
                if errors.Is(err, contextutils.ErrRecordNotFound) </span><span class="cov1" title="1">{
                        // Check if the error message indicates it's about the API key, not the user
                        if strings.Contains(err.Error(), "API key for provider not found") </span><span class="cov0" title="0">{
                                return false, nil
                        }</span>
                        // If it's about the user not found, return the error
                        <span class="cov1" title="1">return false, err</span>
                }
                <span class="cov0" title="0">return false, contextutils.WrapError(err, "failed to check if user has API key")</span>
        }
        <span class="cov0" title="0">return apiKey != "", nil</span>
}

// UpdateLastActive updates the user's last activity timestamp
func (s *UserService) UpdateLastActive(ctx context.Context, userID int) (err error) <span class="cov1" title="1">{
        ctx, span := observability.TraceUserFunction(ctx, "update_last_active", attribute.Int("user.id", userID))
        defer func() </span><span class="cov1" title="1">{
                if err != nil </span><span class="cov0" title="0">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov1" title="1">span.End()</span>
        }()
        <span class="cov1" title="1">query := `UPDATE users SET last_active = $1 WHERE id = $2`
        _, err = s.db.ExecContext(ctx, query, time.Now(), userID)
        return contextutils.WrapError(err, "failed to update user last active timestamp")</span>
}

// GetAllUsers retrieves all users from the database
func (s *UserService) GetAllUsers(ctx context.Context) (result0 []models.User, err error) <span class="cov3" title="4">{
        ctx, span := observability.TraceUserFunction(ctx, "get_all_users")
        defer func() </span><span class="cov3" title="4">{
                if err != nil </span><span class="cov0" title="0">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov3" title="4">span.End()</span>
        }()
        <span class="cov3" title="4">query := fmt.Sprintf("SELECT %s FROM users", userSelectFieldsNoPassword)
        var rows *sql.Rows
        rows, err = s.db.QueryContext(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, contextutils.WrapError(err, "failed to query all users")
        }</span>
        <span class="cov3" title="4">defer func() </span><span class="cov3" title="4">{
                if err = rows.Close(); err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn(ctx, "Warning: failed to close rows", map[string]interface{}{"error": err.Error()})
                }</span>
        }()

        <span class="cov3" title="4">var users []models.User
        for rows.Next() </span><span class="cov6" title="16">{
                user, err := s.scanUserFromRowsNoPassword(rows)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, contextutils.WrapError(err, "failed to scan user from rows")
                }</span>
                <span class="cov6" title="16">users = append(users, *user)</span>
        }

        <span class="cov3" title="4">return users, nil</span>
}

// GetUserByEmail retrieves a user by their email address
func (s *UserService) GetUserByEmail(ctx context.Context, email string) (result0 *models.User, err error) <span class="cov3" title="4">{
        ctx, span := observability.TraceUserFunction(ctx, "get_user_by_email", attribute.String("user.email", email))
        defer func() </span><span class="cov3" title="4">{
                if err != nil </span><span class="cov0" title="0">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov3" title="4">span.End()</span>
        }()
        <span class="cov3" title="4">query := fmt.Sprintf("SELECT %s FROM users WHERE email = $1", userSelectFields)
        return s.getUserByQuery(ctx, query, email)</span>
}

// UpdateUserProfile updates user profile information (username, email, timezone)
func (s *UserService) UpdateUserProfile(ctx context.Context, userID int, username, email, timezone string) (err error) <span class="cov1" title="1">{
        ctx, span := observability.TraceUserFunction(ctx, "update_user_profile", attribute.Int("user.id", userID))
        defer func() </span><span class="cov1" title="1">{
                if err != nil </span><span class="cov0" title="0">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov1" title="1">span.End()</span>
        }()
        <span class="cov1" title="1">query := `UPDATE users SET username = $1, email = $2, timezone = $3, updated_at = $4 WHERE id = $5`
        _, err = s.db.ExecContext(ctx, query, username, email, timezone, time.Now(), userID)
        return contextutils.WrapError(err, "failed to update user profile")</span>
}

// UpdateUserPassword updates a user's password
func (s *UserService) UpdateUserPassword(ctx context.Context, userID int, newPassword string) (err error) <span class="cov3" title="4">{
        ctx, span := observability.TraceUserFunction(ctx, "update_user_password", attribute.Int("user.id", userID))
        defer func() </span><span class="cov3" title="4">{
                if err != nil </span><span class="cov1" title="1">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov3" title="4">span.End()</span>
        }()

        // Validate password is not empty
        <span class="cov3" title="4">if newPassword == "" </span><span class="cov1" title="1">{
                return contextutils.ErrorWithContextf("password cannot be empty")
        }</span>

        // Hash the new password using bcrypt
        <span class="cov3" title="3">var hashedPassword []byte
        hashedPassword, err = bcrypt.GenerateFromPassword([]byte(newPassword), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                return contextutils.WrapError(err, "failed to hash password")
        }</span>

        <span class="cov3" title="3">query := `UPDATE users SET password_hash = $1, updated_at = $2 WHERE id = $3`
        _, err = s.db.ExecContext(ctx, query, string(hashedPassword), time.Now(), userID)
        return contextutils.WrapError(err, "failed to update user password")</span>
}

// DeleteUser removes a user and their associated data
func (s *UserService) DeleteUser(ctx context.Context, userID int) (err error) <span class="cov1" title="1">{
        ctx, span := observability.TraceUserFunction(ctx, "delete_user", attribute.Int("user.id", userID))
        defer func() </span><span class="cov1" title="1">{
                if err != nil </span><span class="cov1" title="1">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov1" title="1">span.End()</span>
        }()

        // Check if user exists before deleting
        <span class="cov1" title="1">user, err := s.GetUserByID(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return contextutils.WrapError(err, "failed to check if user exists")
        }</span>
        <span class="cov1" title="1">if user == nil </span><span class="cov1" title="1">{
                return contextutils.WrapError(contextutils.ErrRecordNotFound, "user not found")
        }</span>

        <span class="cov0" title="0">query := `DELETE FROM users WHERE id = $1`
        _, err = s.db.ExecContext(ctx, query, userID)
        return contextutils.WrapError(err, "failed to delete user")</span>
}

// DeleteAllUsers removes all users from the database
func (s *UserService) DeleteAllUsers(ctx context.Context) (err error) <span class="cov2" title="2">{
        ctx, span := observability.TraceUserFunction(ctx, "delete_all_users")
        defer func() </span><span class="cov2" title="2">{
                if err != nil </span><span class="cov0" title="0">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov2" title="2">span.End()</span>
        }()
        <span class="cov2" title="2">var tx *sql.Tx
        tx, err = s.db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return contextutils.WrapError(err, "failed to begin transaction for delete all users")
        }</span>
        <span class="cov2" title="2">defer func() </span><span class="cov2" title="2">{
                if err != nil </span><span class="cov0" title="0">{
                        if rollbackErr := tx.Rollback(); rollbackErr != nil </span><span class="cov0" title="0">{
                                s.logger.Warn(ctx, "Warning: failed to rollback transaction", map[string]interface{}{"error": rollbackErr.Error()})
                        }</span>
                }
        }()

        // Whitelist of valid table names to prevent SQL injection
        <span class="cov2" title="2">validTables := map[string]bool{
                "user_responses":      true,
                "performance_metrics": true,
                "users":               true,
        }

        // Delete all data in the correct order (to respect foreign key constraints)
        tables := []string{
                "user_responses",
                "performance_metrics",
                "users",
        }

        for _, table := range tables </span><span class="cov4" title="6">{
                // Validate table name against whitelist
                if !validTables[table] </span><span class="cov0" title="0">{
                        return contextutils.ErrorWithContextf("invalid table name: %s", table)
                }</span>

                // Use parameterized query with validated table name
                <span class="cov4" title="6">query := fmt.Sprintf("DELETE FROM %s", table)
                if _, err := tx.ExecContext(ctx, query); err != nil </span><span class="cov0" title="0">{
                        return contextutils.WrapErrorf(err, "failed to delete from table %s", table)
                }</span>
                // Reset sequence for PostgreSQL
                <span class="cov4" title="6">sequenceQuery := fmt.Sprintf("ALTER SEQUENCE %s_id_seq RESTART WITH 1", table)
                if _, err := tx.ExecContext(ctx, sequenceQuery); err != nil </span><span class="cov0" title="0">{
                        // This might fail if the table doesn't have a sequence, so we log but don't fail
                        s.logger.Warn(ctx, "Note: Could not reset sequence for %s (this is normal for some tables)", map[string]interface{}{"table": table})
                }</span>
        }

        <span class="cov2" title="2">return contextutils.WrapError(tx.Commit(), "failed to commit delete all users transaction")</span>
}

// EnsureAdminUserExists creates the admin user if it doesn't exist
func (s *UserService) EnsureAdminUserExists(ctx context.Context, adminUsername, adminPassword string) (err error) <span class="cov3" title="4">{
        ctx, span := observability.TraceUserFunction(ctx, "ensure_admin_user_exists", attribute.String("admin.username", adminUsername))
        defer func() </span><span class="cov3" title="4">{
                if err != nil </span><span class="cov2" title="2">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov3" title="4">span.End()</span>
        }()

        // Validate input parameters
        <span class="cov3" title="4">if adminUsername == "" </span><span class="cov1" title="1">{
                return contextutils.ErrorWithContextf("admin username cannot be empty")
        }</span>

        <span class="cov3" title="3">if adminPassword == "" </span><span class="cov1" title="1">{
                return contextutils.ErrorWithContextf("admin password cannot be empty")
        }</span>
        // Check if admin user already exists
        <span class="cov2" title="2">var existingUser *models.User
        existingUser, err = s.GetUserByUsername(ctx, adminUsername)
        if err != nil </span><span class="cov0" title="0">{
                return contextutils.WrapError(err, "failed to check if admin user exists")
        }</span>

        <span class="cov2" title="2">if existingUser != nil </span><span class="cov1" title="1">{
                // User exists, check if password needs to be updated
                if existingUser.PasswordHash.Valid </span><span class="cov1" title="1">{
                        // User has a password, test if it matches current admin password
                        err = bcrypt.CompareHashAndPassword([]byte(existingUser.PasswordHash.String), []byte(adminPassword))
                        if err == nil </span><span class="cov0" title="0">{
                                // Password matches, ensure AI settings are configured
                                err = s.ensureAdminAISettings(ctx, existingUser.ID)
                                if err != nil </span><span class="cov0" title="0">{
                                        s.logger.Warn(ctx, "Warning: Failed to set AI settings for existing admin user", map[string]interface{}{"error": err.Error()})
                                }</span>

                                // Ensure admin user has email and timezone if not set
                                <span class="cov0" title="0">if !existingUser.Email.Valid || !existingUser.Timezone.Valid </span><span class="cov0" title="0">{
                                        err = s.ensureAdminProfile(ctx, existingUser.ID)
                                        if err != nil </span><span class="cov0" title="0">{
                                                s.logger.Warn(ctx, "Warning: Failed to update admin profile", map[string]interface{}{"error": err.Error()})
                                        }</span>
                                }

                                <span class="cov0" title="0">s.logger.Info(ctx, "Admin user already exists with correct password", map[string]interface{}{"username": adminUsername})
                                return nil</span>
                        }
                }

                // Update password
                <span class="cov1" title="1">hashedPassword, err := bcrypt.GenerateFromPassword([]byte(adminPassword), bcrypt.DefaultCost)
                if err != nil </span><span class="cov0" title="0">{
                        return contextutils.WrapError(err, "failed to hash admin password")
                }</span>

                <span class="cov1" title="1">query := `UPDATE users SET password_hash = $1, updated_at = $2 WHERE username = $3`
                _, err = s.db.ExecContext(ctx, query, string(hashedPassword), time.Now(), adminUsername)
                if err != nil </span><span class="cov0" title="0">{
                        return contextutils.WrapError(err, "failed to update admin user password")
                }</span>

                // Ensure AI settings are configured
                <span class="cov1" title="1">err = s.ensureAdminAISettings(ctx, existingUser.ID)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn(ctx, "Warning: Failed to set AI settings for existing admin user", map[string]interface{}{"error": err.Error()})
                }</span>

                // Ensure admin user has email and timezone if not set
                <span class="cov1" title="1">if !existingUser.Email.Valid || !existingUser.Timezone.Valid </span><span class="cov0" title="0">{
                        err = s.ensureAdminProfile(ctx, existingUser.ID)
                        if err != nil </span><span class="cov0" title="0">{
                                s.logger.Warn(ctx, "Warning: Failed to update admin profile", map[string]interface{}{"error": err.Error()})
                        }</span>
                }

                <span class="cov1" title="1">s.logger.Info(ctx, "Updated password for admin user", map[string]interface{}{"username": adminUsername})
                return nil</span>
        }

        // Create new admin user with email and timezone
        <span class="cov1" title="1">user, err := s.CreateUserWithEmailAndTimezone(ctx, adminUsername, "admin@example.com", "America/New_York", "italian", "A1")
        if err != nil </span><span class="cov0" title="0">{
                return contextutils.WrapError(err, "failed to create admin user")
        }</span>

        // Set password for the admin user
        <span class="cov1" title="1">hashedPassword, err := bcrypt.GenerateFromPassword([]byte(adminPassword), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                return contextutils.WrapError(err, "failed to hash new admin password")
        }</span>

        <span class="cov1" title="1">query := `UPDATE users SET password_hash = $1, updated_at = $2 WHERE id = $3`
        _, err = s.db.ExecContext(ctx, query, string(hashedPassword), time.Now(), user.ID)
        if err != nil </span><span class="cov0" title="0">{
                return contextutils.WrapError(err, "failed to set password for new admin user")
        }</span>

        // Set up AI settings for the admin user
        <span class="cov1" title="1">err = s.ensureAdminAISettings(ctx, user.ID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Warn(ctx, "Warning: Failed to set AI settings for new admin user", map[string]interface{}{"error": err.Error()})
        }</span>

        <span class="cov1" title="1">s.logger.Info(ctx, "Created admin user", map[string]interface{}{"username": adminUsername})
        return nil</span>
}

// ensureAdminAISettings ensures the admin user has AI settings configured
// Only sets default values if the user doesn't already have AI settings configured
func (s *UserService) ensureAdminAISettings(ctx context.Context, userID int) (err error) <span class="cov2" title="2">{
        ctx, span := observability.TraceUserFunction(ctx, "ensure_admin_ai_settings", attribute.Int("user.id", userID))
        defer func() </span><span class="cov2" title="2">{
                if err != nil </span><span class="cov0" title="0">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov2" title="2">span.End()</span>
        }()
        <span class="cov2" title="2">var user *models.User
        user, err = s.GetUserByID(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov2" title="2">if user == nil </span><span class="cov0" title="0">{
                return errors.New("admin user not found")
        }</span>

        // If user already has AI provider configured, don't override their settings
        <span class="cov2" title="2">if user.AIProvider.Valid &amp;&amp; user.AIProvider.String != "" </span><span class="cov1" title="1">{
                s.logger.Info(ctx, "User ID already has AI settings configured, preserving existing settings", map[string]interface{}{"user_id": userID, "provider": user.AIProvider.String})
                return nil
        }</span>

        // Set default AI settings with a default API key
        <span class="cov1" title="1">settings := &amp;models.UserSettings{
                AIProvider: "ollama",
                AIModel:    "llama4:latest",
                AIAPIKey:   "not_needed", // Default API key
        }

        // Only update AI settings, preserve other user settings
        query := `UPDATE users SET ai_provider = $1, ai_model = $2, ai_api_key = $3, updated_at = $4 WHERE id = $5`
        _, err = s.db.ExecContext(ctx, query, settings.AIProvider, settings.AIModel, settings.AIAPIKey, time.Now(), userID)
        if err != nil </span><span class="cov0" title="0">{
                return contextutils.WrapError(err, "failed to update user AI settings")
        }</span>

        // Save the API key to the user_api_keys table
        <span class="cov1" title="1">err = s.SetUserAPIKey(ctx, userID, settings.AIProvider, settings.AIAPIKey)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Warn(ctx, "Warning: Failed to save API key for user %d", map[string]interface{}{"user_id": userID, "error": err.Error()})
        }</span>

        <span class="cov1" title="1">s.logger.Info(ctx, "Set default AI settings for user", map[string]interface{}{"user_id": userID, "provider": settings.AIProvider, "model": settings.AIModel})
        return nil</span>
}

// ensureAdminProfile ensures the admin user has email and timezone set
func (s *UserService) ensureAdminProfile(ctx context.Context, userID int) (err error) <span class="cov0" title="0">{
        ctx, span := observability.TraceUserFunction(ctx, "ensure_admin_profile", attribute.Int("user.id", userID))
        defer func() </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov0" title="0">span.End()</span>
        }()
        <span class="cov0" title="0">query := `UPDATE users SET email = $1, timezone = $2, updated_at = $3 WHERE id = $4 AND (email IS NULL OR timezone IS NULL)`
        _, err = s.db.ExecContext(ctx, query, "admin@example.com", "America/New_York", time.Now(), userID)
        if err != nil </span><span class="cov0" title="0">{
                return contextutils.WrapError(err, "failed to update admin profile")
        }</span>

        <span class="cov0" title="0">s.logger.Info(ctx, "Updated admin user profile with default email and timezone", map[string]interface{}{"user_id": userID})
        return nil</span>
}

// ResetDatabase completely resets the database to an empty state
func (s *UserService) ResetDatabase(ctx context.Context) (err error) <span class="cov0" title="0">{
        ctx, span := observability.TraceUserFunction(ctx, "reset_database")
        defer func() </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov0" title="0">span.End()</span>
        }()
        <span class="cov0" title="0">var tx *sql.Tx
        tx, err = s.db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return contextutils.WrapError(err, "failed to begin transaction for database reset")
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if rollbackErr := tx.Rollback(); rollbackErr != nil &amp;&amp; rollbackErr != sql.ErrTxDone </span><span class="cov0" title="0">{
                        s.logger.Warn(ctx, "Warning: failed to rollback transaction", map[string]interface{}{"error": rollbackErr.Error()})
                }</span>
        }()

        // Whitelist of valid table names to prevent SQL injection
        <span class="cov0" title="0">validTables := map[string]bool{
                "user_responses":      true,
                "performance_metrics": true,
                "questions":           true,
                "users":               true,
        }

        // Delete all data in the correct order (to respect foreign key constraints)
        tables := []string{
                "user_responses",
                "performance_metrics",
                "questions",
                "users",
        }

        for _, table := range tables </span><span class="cov0" title="0">{
                // Validate table name against whitelist
                if !validTables[table] </span><span class="cov0" title="0">{
                        return contextutils.ErrorWithContextf("invalid table name: %s", table)
                }</span>

                // Use parameterized query with validated table name
                <span class="cov0" title="0">query := fmt.Sprintf("DELETE FROM %s", table)
                if _, err := tx.ExecContext(ctx, query); err != nil </span><span class="cov0" title="0">{
                        return contextutils.WrapErrorf(err, "failed to delete from table %s during reset", table)
                }</span>
                <span class="cov0" title="0">s.logger.Info(ctx, "Cleared table: %s", map[string]interface{}{"table": table})

                // Reset sequence for PostgreSQL
                sequenceQuery := fmt.Sprintf("ALTER SEQUENCE %s_id_seq RESTART WITH 1", table)
                if _, err := tx.ExecContext(ctx, sequenceQuery); err != nil </span><span class="cov0" title="0">{
                        // This might fail if the table doesn't have a sequence, so we log but don't fail
                        s.logger.Warn(ctx, "Note: Could not reset sequence for %s (this is normal for some tables)", map[string]interface{}{"table": table})
                }</span>
        }

        <span class="cov0" title="0">err = tx.Commit()
        if err != nil </span><span class="cov0" title="0">{
                return contextutils.WrapError(err, "failed to commit database reset transaction")
        }</span>

        <span class="cov0" title="0">s.logger.Info(ctx, "Database reset completed successfully")
        return nil</span>
}

// ClearUserData removes all user activity data but keeps the users themselves
func (s *UserService) ClearUserData(ctx context.Context) (err error) <span class="cov1" title="1">{
        ctx, span := observability.TraceUserFunction(ctx, "clear_user_data")
        defer func() </span><span class="cov1" title="1">{
                if err != nil </span><span class="cov0" title="0">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov1" title="1">span.End()</span>
        }()
        <span class="cov1" title="1">var tx *sql.Tx
        tx, err = s.db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return contextutils.WrapError(err, "failed to begin transaction for clear user data")
        }</span>
        <span class="cov1" title="1">defer func() </span><span class="cov1" title="1">{
                if rollbackErr := tx.Rollback(); rollbackErr != nil &amp;&amp; rollbackErr != sql.ErrTxDone </span><span class="cov0" title="0">{
                        s.logger.Warn(ctx, "Warning: failed to rollback transaction", map[string]interface{}{"error": rollbackErr.Error()})
                }</span>
        }()

        // Whitelist of valid table names to prevent SQL injection
        <span class="cov1" title="1">validTables := map[string]bool{
                "user_responses":      true,
                "performance_metrics": true,
                "questions":           true,
        }

        // Delete user data but keep users (order matters due to foreign key constraints)
        tables := []string{
                "user_responses",
                "performance_metrics",
                "questions",
        }

        for _, table := range tables </span><span class="cov3" title="3">{
                // Validate table name against whitelist
                if !validTables[table] </span><span class="cov0" title="0">{
                        return contextutils.ErrorWithContextf("invalid table name: %s", table)
                }</span>

                // Use parameterized query with validated table name
                <span class="cov3" title="3">query := fmt.Sprintf("DELETE FROM %s", table)
                if _, err := tx.ExecContext(ctx, query); err != nil </span><span class="cov0" title="0">{
                        return contextutils.WrapErrorf(err, "failed to delete from table %s during clear user data", table)
                }</span>
                <span class="cov3" title="3">s.logger.Info(ctx, "Cleared table: %s", map[string]interface{}{"table": table})

                // Reset sequence for PostgreSQL
                sequenceQuery := fmt.Sprintf("ALTER SEQUENCE %s_id_seq RESTART WITH 1", table)
                if _, err := tx.ExecContext(ctx, sequenceQuery); err != nil </span><span class="cov0" title="0">{
                        // This might fail if the table doesn't have a sequence, so we log but don't fail
                        s.logger.Warn(ctx, "Note: Could not reset sequence for %s (this is normal for some tables)", map[string]interface{}{"table": table})
                }</span>
        }

        <span class="cov1" title="1">err = tx.Commit()
        if err != nil </span><span class="cov0" title="0">{
                return contextutils.WrapError(err, "failed to commit clear user data transaction")
        }</span>

        <span class="cov1" title="1">s.logger.Info(ctx, "User data cleared successfully (users preserved)")
        return nil</span>
}

// ClearUserDataForUser removes all user activity data for a specific user but keeps the user record
func (s *UserService) ClearUserDataForUser(ctx context.Context, userID int) (err error) <span class="cov2" title="2">{
        ctx, span := observability.TraceUserFunction(ctx, "clear_user_data_for_user", attribute.Int("user.id", userID))
        defer func() </span><span class="cov2" title="2">{
                if err != nil </span><span class="cov0" title="0">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov2" title="2">span.End()</span>
        }()
        <span class="cov2" title="2">var tx *sql.Tx
        tx, err = s.db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Warn(ctx, "Failed to begin transaction", map[string]interface{}{"error": err.Error()})
                return contextutils.WrapError(err, "failed to begin transaction for clear user data for specific user")
        }</span>
        <span class="cov2" title="2">defer func() </span><span class="cov2" title="2">{
                if rollbackErr := tx.Rollback(); rollbackErr != nil &amp;&amp; rollbackErr != sql.ErrTxDone </span><span class="cov0" title="0">{
                        s.logger.Warn(ctx, "Warning: failed to rollback transaction", map[string]interface{}{"error": rollbackErr.Error()})
                }</span>
        }()

        // Delete user_responses for this user's questions (via user_questions)
        <span class="cov2" title="2">query := `DELETE FROM user_responses WHERE question_id IN (SELECT question_id FROM user_questions WHERE user_id = $1)`
        result, err := tx.ExecContext(ctx, query, userID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Warn(ctx, "Failed to delete user_responses", map[string]interface{}{"error": err.Error()})
                return contextutils.WrapError(err, "failed to delete user responses for specific user")
        }</span>
        <span class="cov2" title="2">rows, _ := result.RowsAffected()
        s.logger.Info(ctx, "Deleted %d user_responses for user %d", map[string]interface{}{"count": rows, "user_id": userID})

        // Delete performance_metrics for this user (performance_metrics has user_id, not question_id)
        query = `DELETE FROM performance_metrics WHERE user_id = $1`
        result, err = tx.ExecContext(ctx, query, userID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Warn(ctx, "Failed to delete performance_metrics", map[string]interface{}{"error": err.Error()})
                return contextutils.WrapError(err, "failed to delete performance metrics for specific user")
        }</span>
        <span class="cov2" title="2">rows, _ = result.RowsAffected()
        s.logger.Info(ctx, "Deleted %d performance_metrics for user %d", map[string]interface{}{"count": rows, "user_id": userID})

        // Delete user_questions for this user
        query = `DELETE FROM user_questions WHERE user_id = $1`
        result, err = tx.ExecContext(ctx, query, userID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Warn(ctx, "Failed to delete user_questions", map[string]interface{}{"error": err.Error()})
                return contextutils.WrapError(err, "failed to delete user questions for specific user")
        }</span>
        <span class="cov2" title="2">rows, _ = result.RowsAffected()
        s.logger.Info(ctx, "Deleted %d user_questions for user %d", map[string]interface{}{"count": rows, "user_id": userID})

        // Optionally, delete orphaned questions (not assigned to any user)
        query = `DELETE FROM questions WHERE id NOT IN (SELECT question_id FROM user_questions)`
        result, err = tx.ExecContext(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Warn(ctx, "Failed to delete orphaned questions", map[string]interface{}{"error": err.Error()})
                return contextutils.WrapError(err, "failed to delete orphaned questions")
        }</span>
        <span class="cov2" title="2">rows, _ = result.RowsAffected()
        s.logger.Info(ctx, "Deleted %d orphaned questions", map[string]interface{}{"count": rows})

        if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                s.logger.Warn(ctx, "Failed to commit transaction", map[string]interface{}{"error": err.Error()})
                return contextutils.WrapError(err, "failed to commit clear user data for specific user transaction")
        }</span>
        <span class="cov2" title="2">s.logger.Info(ctx, "User data cleared successfully for user %d (users preserved)", map[string]interface{}{"user_id": userID})
        return nil</span>
}

func (s *UserService) applyDefaultSettings(ctx context.Context, user *models.User) <span class="cov9" title="125">{
        if user == nil || s.cfg == nil || s.cfg.AppConfig == nil </span><span class="cov6" title="20">{
                return
        }</span>
        <span class="cov9" title="105">_, span := observability.TraceUserFunction(ctx, "apply_default_settings", attribute.Int("user.id", user.ID))
        defer span.End()
        if user.AIProvider.String == "" &amp;&amp; len(s.cfg.AppConfig.Providers) &gt; 0 </span><span class="cov9" title="97">{
                // Use the first available provider as default
                provider := s.cfg.AppConfig.Providers[0]
                user.AIProvider.String = provider.Code
                // Use first model in the list as default
                if len(provider.Models) &gt; 0 </span><span class="cov9" title="97">{
                        user.AIModel.String = provider.Models[0].Code
                }</span>
        }
        <span class="cov9" title="105">if user.CurrentLevel.String == "" </span><span class="cov1" title="1">{
                // Set default level based on user's preferred language, or use first available language
                language := user.PreferredLanguage.String
                if language == "" </span><span class="cov1" title="1">{
                        languages := s.cfg.AppConfig.GetLanguages()
                        if len(languages) &gt; 0 </span><span class="cov1" title="1">{
                                language = languages[0]
                        }</span>
                }
                <span class="cov1" title="1">if language != "" </span><span class="cov1" title="1">{
                        levels := s.cfg.AppConfig.GetLevelsForLanguage(language)
                        if len(levels) &gt; 0 </span><span class="cov1" title="1">{
                                user.CurrentLevel.String = levels[0]
                        }</span>
                }
        }
        <span class="cov9" title="105">if user.PreferredLanguage.String == "" </span><span class="cov1" title="1">{
                user.PreferredLanguage.String = "english"
        }</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package services

import (
        "context"
        "math/rand"

        "go.opentelemetry.io/otel/attribute"

        "quizapp/internal/config"
        "quizapp/internal/observability"
)

// VarietyService handles the selection of variety elements for question generation
type VarietyService struct {
        cfg    *config.Config
        logger *observability.Logger
}

// VarietyElements holds the randomly selected variety elements for a question generation request
type VarietyElements struct {
        TopicCategory      string
        GrammarFocus       string
        VocabularyDomain   string
        Scenario           string
        StyleModifier      string
        DifficultyModifier string
        TimeContext        string
}

// NewVarietyServiceWithLogger creates a new VarietyService with logger
func NewVarietyServiceWithLogger(cfg *config.Config, logger *observability.Logger) *VarietyService <span class="cov5" title="60">{
        return &amp;VarietyService{
                cfg:    cfg,
                logger: logger,
        }
}</span>

// SelectVarietyElements randomly selects variety elements for question generation
// If highPriorityTopics or userWeakAreas are provided, bias topic selection toward those topics first, then gapAnalysis.
func (vs *VarietyService) SelectVarietyElements(ctx context.Context, level string, highPriorityTopics, userWeakAreas []string, gapAnalysis map[string]int) *VarietyElements <span class="cov8" title="1277">{
        _, span := observability.TraceVarietyFunction(ctx, "select_variety_elements",
                attribute.String("variety.level", level),
                attribute.Int("variety.high_priority_topics_count", len(highPriorityTopics)),
                attribute.Int("variety.user_weak_areas_count", len(userWeakAreas)),
                attribute.Int("variety.gap_analysis_count", len(gapAnalysis)),
        )
        defer span.End()

        if vs.cfg.AppConfig == nil || vs.cfg.AppConfig.Variety == nil </span><span class="cov1" title="1">{
                span.SetAttributes(attribute.String("variety.result", "no_config"))
                return &amp;VarietyElements{} // Return empty if no variety config
        }</span>

        <span class="cov8" title="1276">variety := vs.cfg.AppConfig.Variety
        elements := &amp;VarietyElements{}

        // Helper function to get weighted selection from gap analysis
        getWeightedSelection := func(gapType string, availableOptions []string) string </span><span class="cov9" title="3385">{
                if len(gapAnalysis) == 0 || len(availableOptions) == 0 </span><span class="cov7" title="613">{
                        return ""
                }</span>

                <span class="cov8" title="2772">var weightedOptions []string
                for _, option := range availableOptions </span><span class="cov10" title="9015">{
                        gapKey := gapType + "_" + option
                        if count, ok := gapAnalysis[gapKey]; ok &amp;&amp; count &gt; 0 </span><span class="cov8" title="1520">{
                                // Add this option 'count' times to weight it by gap severity
                                for i := 0; i &lt; count; i++ </span><span class="cov8" title="3127">{
                                        weightedOptions = append(weightedOptions, option)
                                }</span>
                        }
                }

                <span class="cov8" title="2772">if len(weightedOptions) &gt; 0 </span><span class="cov7" title="1063">{
                        return weightedOptions[rand.Intn(len(weightedOptions))]
                }</span>
                <span class="cov8" title="1709">return ""</span>
        }

        // Define all possible variety elements with their selection functions
        <span class="cov8" title="1276">type varietySelector struct {
                name     string
                selector func() string
        }

        var selectors []varietySelector

        // Topic category selector (biased by userWeakAreas, highPriorityTopics, then gapAnalysis if provided)
        if len(variety.TopicCategories) &gt; 0 </span><span class="cov8" title="1276">{
                selectors = append(selectors, varietySelector{
                        name: "topic_category",
                        selector: func() string </span><span class="cov7" title="856">{
                                // 1. UserWeakAreas
                                if len(userWeakAreas) &gt; 0 </span><span class="cov0" title="0">{
                                        var matching []string
                                        for _, topic := range variety.TopicCategories </span><span class="cov0" title="0">{
                                                for _, weak := range userWeakAreas </span><span class="cov0" title="0">{
                                                        if topic == weak </span><span class="cov0" title="0">{
                                                                matching = append(matching, topic)
                                                        }</span>
                                                }
                                        }
                                        <span class="cov0" title="0">if len(matching) &gt; 0 </span><span class="cov0" title="0">{
                                                elements.TopicCategory = matching[rand.Intn(len(matching))]
                                                return elements.TopicCategory
                                        }</span>
                                }
                                // 2. HighPriorityTopics
                                <span class="cov7" title="856">if len(highPriorityTopics) &gt; 0 </span><span class="cov0" title="0">{
                                        var matching []string
                                        for _, topic := range variety.TopicCategories </span><span class="cov0" title="0">{
                                                for _, high := range highPriorityTopics </span><span class="cov0" title="0">{
                                                        if topic == high </span><span class="cov0" title="0">{
                                                                matching = append(matching, topic)
                                                        }</span>
                                                }
                                        }
                                        <span class="cov0" title="0">if len(matching) &gt; 0 </span><span class="cov0" title="0">{
                                                elements.TopicCategory = matching[rand.Intn(len(matching))]
                                                return elements.TopicCategory
                                        }</span>
                                }
                                // 3. GapAnalysis for topics
                                <span class="cov7" title="856">if selected := getWeightedSelection("topic_category", variety.TopicCategories); selected != "" </span><span class="cov6" title="394">{
                                        elements.TopicCategory = selected
                                        return elements.TopicCategory
                                }</span>
                                // Fallback to random
                                <span class="cov7" title="462">elements.TopicCategory = variety.TopicCategories[rand.Intn(len(variety.TopicCategories))]
                                return elements.TopicCategory</span>
                        },
                })
        }

        // Grammar focus selector (now with gap analysis support)
        <span class="cov8" title="1276">if grammarByLevel, exists := variety.GrammarFocusByLevel[level]; exists &amp;&amp; len(grammarByLevel) &gt; 0 </span><span class="cov8" title="1275">{
                selectors = append(selectors, varietySelector{
                        name: "grammar_focus",
                        selector: func() string </span><span class="cov7" title="846">{
                                // Check for grammar gaps first
                                if selected := getWeightedSelection("grammar_focus", grammarByLevel); selected != "" </span><span class="cov6" title="199">{
                                        elements.GrammarFocus = selected
                                        return elements.GrammarFocus
                                }</span>
                                // Fallback to random
                                <span class="cov7" title="647">elements.GrammarFocus = grammarByLevel[rand.Intn(len(grammarByLevel))]
                                return elements.GrammarFocus</span>
                        },
                })
        } else<span class="cov1" title="1"> if len(variety.GrammarFocus) &gt; 0 </span><span class="cov1" title="1">{
                selectors = append(selectors, varietySelector{
                        name: "grammar_focus",
                        selector: func() string </span><span class="cov0" title="0">{
                                // Check for grammar gaps first
                                if selected := getWeightedSelection("grammar_focus", variety.GrammarFocus); selected != "" </span><span class="cov0" title="0">{
                                        elements.GrammarFocus = selected
                                        return elements.GrammarFocus
                                }</span>
                                // Fallback to random
                                <span class="cov0" title="0">elements.GrammarFocus = variety.GrammarFocus[rand.Intn(len(variety.GrammarFocus))]
                                return elements.GrammarFocus</span>
                        },
                })
        }

        // Vocabulary domain selector (now with gap analysis support)
        <span class="cov8" title="1276">if len(variety.VocabularyDomains) &gt; 0 </span><span class="cov8" title="1273">{
                selectors = append(selectors, varietySelector{
                        name: "vocabulary_domain",
                        selector: func() string </span><span class="cov7" title="824">{
                                // Check for vocabulary gaps first
                                if selected := getWeightedSelection("vocabulary_domain", variety.VocabularyDomains); selected != "" </span><span class="cov5" title="97">{
                                        elements.VocabularyDomain = selected
                                        return elements.VocabularyDomain
                                }</span>
                                // Fallback to random
                                <span class="cov7" title="630">elements.VocabularyDomain = variety.VocabularyDomains[rand.Intn(len(variety.VocabularyDomains))]
                                return elements.VocabularyDomain</span>
                        },
                })
        }

        // Scenario selector (now with gap analysis support)
        <span class="cov8" title="1276">if len(variety.Scenarios) &gt; 0 </span><span class="cov8" title="1273">{
                selectors = append(selectors, varietySelector{
                        name: "scenario",
                        selector: func() string </span><span class="cov7" title="859">{
                                // Check for scenario gaps first
                                if selected := getWeightedSelection("scenario", variety.Scenarios); selected != "" </span><span class="cov5" title="138">{
                                        elements.Scenario = selected
                                        return elements.Scenario
                                }</span>
                                // Fallback to random
                                <span class="cov7" title="583">elements.Scenario = variety.Scenarios[rand.Intn(len(variety.Scenarios))]
                                return elements.Scenario</span>
                        },
                })
        }

        // Style modifier selector
        <span class="cov8" title="1276">if len(variety.StyleModifiers) &gt; 0 </span><span class="cov8" title="1273">{
                selectors = append(selectors, varietySelector{
                        name: "style_modifier",
                        selector: func() string </span><span class="cov7" title="829">{
                                elements.StyleModifier = variety.StyleModifiers[rand.Intn(len(variety.StyleModifiers))]
                                return elements.StyleModifier
                        }</span>,
                })
        }

        // Difficulty modifier selector
        <span class="cov8" title="1276">if len(variety.DifficultyModifiers) &gt; 0 </span><span class="cov8" title="1273">{
                selectors = append(selectors, varietySelector{
                        name: "difficulty_modifier",
                        selector: func() string </span><span class="cov7" title="798">{
                                elements.DifficultyModifier = variety.DifficultyModifiers[rand.Intn(len(variety.DifficultyModifiers))]
                                return elements.DifficultyModifier
                        }</span>,
                })
        }

        // Time context selector
        <span class="cov8" title="1276">if len(variety.TimeContexts) &gt; 0 </span><span class="cov8" title="1273">{
                selectors = append(selectors, varietySelector{
                        name: "time_context",
                        selector: func() string </span><span class="cov7" title="852">{
                                elements.TimeContext = variety.TimeContexts[rand.Intn(len(variety.TimeContexts))]
                                return elements.TimeContext
                        }</span>,
                })
        }

        // Randomly select 2-3 variety elements (instead of all 7)
        <span class="cov8" title="1276">numToSelect := 2
        if len(selectors) &gt; 2 </span><span class="cov8" title="1273">{
                // 70% chance of 2 elements, 30% chance of 3 elements
                if rand.Float64() &lt; 0.3 </span><span class="cov7" title="760">{
                        numToSelect = 3
                }</span>
        }

        // Shuffle and select the first numToSelect elements
        <span class="cov8" title="1276">rand.Shuffle(len(selectors), func(i, j int) </span><span class="cov9" title="7641">{
                selectors[i], selectors[j] = selectors[j], selectors[i]
        }</span>)

        // Apply the selected variety elements
        <span class="cov8" title="1276">for i := 0; i &lt; numToSelect &amp;&amp; i &lt; len(selectors); i++ </span><span class="cov9" title="5864">{
                selected := selectors[i].selector()
                span.SetAttributes(attribute.String("variety."+selectors[i].name, selected))
        }</span>

        <span class="cov8" title="1276">span.SetAttributes(
                attribute.String("variety.topic_category", elements.TopicCategory),
                attribute.String("variety.grammar_focus", elements.GrammarFocus),
                attribute.String("variety.vocabulary_domain", elements.VocabularyDomain),
                attribute.String("variety.scenario", elements.Scenario),
                attribute.String("variety.style_modifier", elements.StyleModifier),
                attribute.String("variety.difficulty_modifier", elements.DifficultyModifier),
                attribute.String("variety.time_context", elements.TimeContext),
                attribute.Int("variety.elements_selected", numToSelect),
        )

        span.SetAttributes(attribute.String("variety.result", "success"))
        return elements</span>
}

// SelectMultipleVarietyElements selects multiple sets of variety elements for batch generation
func (vs *VarietyService) SelectMultipleVarietyElements(ctx context.Context, level string, count int) []*VarietyElements <span class="cov1" title="1">{
        ctx, span := observability.TraceVarietyFunction(ctx, "select_multiple_variety_elements",
                attribute.String("variety.level", level),
                attribute.Int("variety.count", count),
        )
        defer span.End()

        elements := make([]*VarietyElements, count)
        for i := 0; i &lt; count; i++ </span><span class="cov2" title="3">{
                elements[i] = vs.SelectVarietyElements(ctx, level, nil, nil, nil)
        }</span>

        <span class="cov1" title="1">span.SetAttributes(attribute.String("variety.result", "success"), attribute.Int("variety.elements_count", len(elements)))
        return elements</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package services

import (
        "context"
        "database/sql"
        "errors"
        "fmt"
        "strings"
        "time"

        "quizapp/internal/models"
        "quizapp/internal/observability"
        contextutils "quizapp/internal/utils"

        "go.opentelemetry.io/otel/attribute"
        "go.opentelemetry.io/otel/codes"
        "go.opentelemetry.io/otel/trace"
)

// ErrSettingNotFound is returned when a setting is not found in the database
var ErrSettingNotFound = errors.New("setting not found")

// WorkerServiceInterface defines the interface for worker management operations
type WorkerServiceInterface interface {
        // Settings management
        GetSetting(ctx context.Context, key string) (string, error)
        SetSetting(ctx context.Context, key, value string) error
        IsGlobalPaused(ctx context.Context) (bool, error)
        SetGlobalPause(ctx context.Context, paused bool) error
        IsUserPaused(ctx context.Context, userID int) (bool, error)
        SetUserPause(ctx context.Context, userID int, paused bool) error

        // Status management
        UpdateWorkerStatus(ctx context.Context, instance string, status *models.WorkerStatus) error
        GetWorkerStatus(ctx context.Context, instance string) (*models.WorkerStatus, error)
        GetAllWorkerStatuses(ctx context.Context) ([]models.WorkerStatus, error)
        UpdateHeartbeat(ctx context.Context, instance string) error
        IsWorkerHealthy(ctx context.Context, instance string) (bool, error)

        // Control operations
        PauseWorker(ctx context.Context, instance string) error
        ResumeWorker(ctx context.Context, instance string) error
        GetWorkerHealth(ctx context.Context) (map[string]interface{}, error)
        GetHighPriorityTopics(ctx context.Context, userID int, language, level, questionType string) ([]string, error)
        GetGapAnalysis(ctx context.Context, userID int, language, level, questionType string) (map[string]int, error)
        GetPriorityDistribution(ctx context.Context, userID int, language, level, questionType string) (map[string]int, error)
}

// WorkerService implements worker management operations
type WorkerService struct {
        db     *sql.DB
        logger *observability.Logger
}

// NewWorkerServiceWithLogger creates a new WorkerService instance with logger
func NewWorkerServiceWithLogger(db *sql.DB, logger *observability.Logger) *WorkerService <span class="cov10" title="14">{
        return &amp;WorkerService{
                db:     db,
                logger: logger,
        }
}</span>

// GetSetting retrieves a setting value by key
func (s *WorkerService) GetSetting(ctx context.Context, key string) (result0 string, err error) <span class="cov8" title="10">{
        ctx, span := observability.TraceWorkerFunction(ctx, "get_setting", attribute.String("setting.key", key))
        defer func() </span><span class="cov8" title="10">{
                if err != nil </span><span class="cov5" title="4">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov8" title="10">span.End()</span>
        }()

        // Validate key
        <span class="cov8" title="10">if len(key) == 0 || len(strings.TrimSpace(key)) == 0 </span><span class="cov1" title="1">{
                return "", contextutils.WrapErrorf(errors.New("invalid setting key"), "setting key cannot be empty")
        }</span>

        <span class="cov8" title="9">var value string
        err = s.db.QueryRowContext(ctx, `
                SELECT setting_value FROM worker_settings WHERE setting_key = $1
        `, key).Scan(&amp;value)
        if err != nil </span><span class="cov4" title="3">{
                if err == sql.ErrNoRows </span><span class="cov3" title="2">{
                        s.logger.Debug(ctx, "Setting not found", map[string]interface{}{"setting_key": key})
                        return "", contextutils.WrapErrorf(ErrSettingNotFound, "%s", key)
                }</span>
                <span class="cov1" title="1">s.logger.Error(ctx, "Failed to get setting", err, map[string]interface{}{"setting_key": key})
                return "", contextutils.WrapErrorf(err, "failed to get setting %s", key)</span>
        }

        <span class="cov7" title="6">return value, nil</span>
}

// SetSetting updates or creates a setting
func (s *WorkerService) SetSetting(ctx context.Context, key, value string) (err error) <span class="cov8" title="10">{
        ctx, span := observability.TraceWorkerFunction(ctx, "set_setting", attribute.String("setting.key", key))
        defer func() </span><span class="cov8" title="10">{
                if err != nil </span><span class="cov4" title="3">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov8" title="10">span.End()</span>
        }()

        // Validate key
        <span class="cov8" title="10">if len(key) == 0 || len(strings.TrimSpace(key)) == 0 </span><span class="cov1" title="1">{
                return contextutils.WrapErrorf(errors.New("invalid setting key"), "setting key cannot be empty")
        }</span>

        <span class="cov8" title="9">_, err = s.db.ExecContext(ctx, `
                INSERT INTO worker_settings (setting_key, setting_value, updated_at)
                VALUES ($1, $2, NOW())
                ON CONFLICT (setting_key) DO UPDATE SET
                        setting_value = EXCLUDED.setting_value,
                        updated_at = EXCLUDED.updated_at
        `, key, value)
        if err != nil </span><span class="cov3" title="2">{
                s.logger.Error(ctx, "Failed to set setting", err, map[string]interface{}{"setting_key": key, "setting_value": value})
                return contextutils.WrapErrorf(err, "failed to set setting %s", key)
        }</span>

        <span class="cov7" title="7">s.logger.Debug(ctx, "Setting updated", map[string]interface{}{"setting_key": key, "setting_value": value})
        return nil</span>
}

// IsGlobalPaused checks if the worker is globally paused
func (s *WorkerService) IsGlobalPaused(ctx context.Context) (result0 bool, err error) <span class="cov5" title="4">{
        ctx, span := observability.TraceWorkerFunction(ctx, "is_global_paused")
        defer func() </span><span class="cov5" title="4">{
                if err != nil </span><span class="cov0" title="0">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov5" title="4">span.End()</span>
        }()

        <span class="cov5" title="4">var value string
        value, err = s.GetSetting(ctx, "global_pause")
        if err != nil </span><span class="cov0" title="0">{
                // If setting doesn't exist, default to false (not paused)
                if errors.Is(err, ErrSettingNotFound) </span><span class="cov0" title="0">{
                        // Initialize the setting with default value
                        if setErr := s.SetSetting(ctx, "global_pause", "false"); setErr != nil </span><span class="cov0" title="0">{
                                s.logger.Error(ctx, "Failed to initialize global_pause setting", setErr, map[string]interface{}{})
                                return false, contextutils.WrapError(setErr, "failed to initialize global_pause setting")
                        }</span>
                        <span class="cov0" title="0">return false, nil</span>
                }
                <span class="cov0" title="0">s.logger.Error(ctx, "Failed to check global pause status", err, map[string]interface{}{})
                return false, err</span>
        }

        <span class="cov5" title="4">paused := value == "true"
        s.logger.Debug(ctx, "Global pause status checked", map[string]interface{}{"global_paused": paused})
        return paused, nil</span>
}

// SetGlobalPause sets the global pause state
func (s *WorkerService) SetGlobalPause(ctx context.Context, paused bool) (err error) <span class="cov4" title="3">{
        ctx, span := observability.TraceWorkerFunction(ctx, "set_global_pause", attribute.Bool("paused", paused))
        defer func() </span><span class="cov4" title="3">{
                if err != nil </span><span class="cov1" title="1">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov4" title="3">span.End()</span>
        }()

        <span class="cov4" title="3">value := "false"
        if paused </span><span class="cov3" title="2">{
                value = "true"
        }</span>

        <span class="cov4" title="3">err = s.SetSetting(ctx, "global_pause", value)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov3" title="2">s.logger.Info(ctx, "Global pause state updated", map[string]interface{}{"global_paused": paused})
        return nil</span>
}

// IsUserPaused checks if a specific user is paused
func (s *WorkerService) IsUserPaused(ctx context.Context, userID int) (result0 bool, err error) <span class="cov6" title="5">{
        ctx, span := observability.TraceWorkerFunction(ctx, "is_user_paused", observability.AttributeUserID(userID))
        defer func() </span><span class="cov6" title="5">{
                if err != nil </span><span class="cov0" title="0">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov6" title="5">span.End()</span>
        }()

        <span class="cov6" title="5">key := fmt.Sprintf("user_pause_%d", userID)
        var value string
        err = s.db.QueryRowContext(ctx, `
                SELECT setting_value FROM worker_settings WHERE setting_key = $1
        `, key).Scan(&amp;value)
        if err != nil </span><span class="cov3" title="2">{
                if err == sql.ErrNoRows </span><span class="cov3" title="2">{
                        // If setting doesn't exist, user is not paused (this is the default state)
                        s.logger.Debug(ctx, "User pause setting not found, defaulting to not paused", map[string]interface{}{"user_id": userID})
                        return false, nil
                }</span>
                <span class="cov0" title="0">s.logger.Error(ctx, "Failed to check user pause status", err, map[string]interface{}{"user_id": userID})
                return false, contextutils.WrapErrorf(err, "failed to check user pause status for user %d", userID)</span>
        }

        <span class="cov4" title="3">paused := value == "true"
        s.logger.Debug(ctx, "User pause status checked", map[string]interface{}{"user_id": userID, "user_paused": paused})
        return paused, nil</span>
}

// SetUserPause sets the pause state for a specific user
func (s *WorkerService) SetUserPause(ctx context.Context, userID int, paused bool) (err error) <span class="cov4" title="3">{
        ctx, span := observability.TraceWorkerFunction(ctx, "set_user_pause", observability.AttributeUserID(userID), attribute.Bool("paused", paused))
        defer func() </span><span class="cov4" title="3">{
                if err != nil </span><span class="cov0" title="0">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov4" title="3">span.End()</span>
        }()

        <span class="cov4" title="3">key := fmt.Sprintf("user_pause_%d", userID)
        value := "false"
        if paused </span><span class="cov3" title="2">{
                value = "true"
        }</span>

        <span class="cov4" title="3">err = s.SetSetting(ctx, key, value)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov4" title="3">s.logger.Info(ctx, "User pause state updated", map[string]interface{}{"user_id": userID, "user_paused": paused})
        return nil</span>
}

// UpdateWorkerStatus updates the worker status in the database
func (s *WorkerService) UpdateWorkerStatus(ctx context.Context, instance string, status *models.WorkerStatus) (err error) <span class="cov8" title="10">{
        activity := ""
        if status.CurrentActivity.Valid </span><span class="cov3" title="2">{
                activity = status.CurrentActivity.String
        }</span>

        <span class="cov8" title="10">ctx, span := observability.TraceWorkerFunction(ctx, "update_worker_status",
                attribute.String("worker.instance", instance),
                attribute.Bool("worker.is_running", status.IsRunning),
                attribute.Bool("worker.is_paused", status.IsPaused),
                attribute.String("worker.activity", activity),
        )
        defer func() </span><span class="cov8" title="10">{
                if err != nil </span><span class="cov0" title="0">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov8" title="10">span.End()</span>
        }()

        <span class="cov8" title="10">_, err = s.db.ExecContext(ctx, `
                INSERT INTO worker_status (
                        worker_instance, is_running, is_paused, current_activity,
                        last_heartbeat, last_run_start, last_run_finish, last_run_error,
                        total_questions_generated, total_runs, updated_at
                ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, NOW())
                ON CONFLICT (worker_instance) DO UPDATE SET
                        is_running = EXCLUDED.is_running,
                        is_paused = EXCLUDED.is_paused,
                        current_activity = EXCLUDED.current_activity,
                        last_heartbeat = EXCLUDED.last_heartbeat,
                        last_run_start = EXCLUDED.last_run_start,
                        last_run_finish = EXCLUDED.last_run_finish,
                        last_run_error = EXCLUDED.last_run_error,
                        total_questions_generated = EXCLUDED.total_questions_generated,
                        total_runs = EXCLUDED.total_runs,
                        updated_at = EXCLUDED.updated_at
        `, instance, status.IsRunning, status.IsPaused, status.CurrentActivity,
                status.LastHeartbeat, status.LastRunStart, status.LastRunFinish,
                status.LastRunError, status.TotalQuestionsGenerated, status.TotalRuns)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error(ctx, "Failed to update worker status", err, map[string]interface{}{
                        "worker_instance": instance,
                        "is_running":      status.IsRunning,
                        "is_paused":       status.IsPaused,
                        "activity":        activity,
                })
                err = contextutils.WrapErrorf(err, "failed to update worker status for instance %s", instance)
                return
        }</span>

        <span class="cov8" title="10">s.logger.Debug(ctx, "Worker status updated", map[string]interface{}{
                "worker_instance": instance,
                "is_running":      status.IsRunning,
                "is_paused":       status.IsPaused,
                "activity":        activity,
        })
        return nil</span>
}

// GetWorkerStatus retrieves worker status by instance
func (s *WorkerService) GetWorkerStatus(ctx context.Context, instance string) (result0 *models.WorkerStatus, err error) <span class="cov7" title="6">{
        ctx, span := observability.TraceWorkerFunction(ctx, "get_worker_status", attribute.String("worker.instance", instance))
        defer func() </span><span class="cov7" title="6">{
                if err != nil </span><span class="cov1" title="1">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov7" title="6">span.End()</span>
        }()

        <span class="cov7" title="6">var status models.WorkerStatus
        err = s.db.QueryRowContext(ctx, `
                SELECT id, worker_instance, is_running, is_paused, current_activity,
                           last_heartbeat, last_run_start, last_run_finish, last_run_error,
                           total_questions_generated, total_runs, created_at, updated_at
                FROM worker_status WHERE worker_instance = $1
        `, instance).Scan(
                &amp;status.ID, &amp;status.WorkerInstance, &amp;status.IsRunning, &amp;status.IsPaused,
                &amp;status.CurrentActivity, &amp;status.LastHeartbeat, &amp;status.LastRunStart,
                &amp;status.LastRunFinish, &amp;status.LastRunError, &amp;status.TotalQuestionsGenerated,
                &amp;status.TotalRuns, &amp;status.CreatedAt, &amp;status.UpdatedAt,
        )
        if err != nil </span><span class="cov1" title="1">{
                if err == sql.ErrNoRows </span><span class="cov1" title="1">{
                        s.logger.Debug(ctx, "Worker status not found", map[string]interface{}{"worker_instance": instance})
                        return nil, contextutils.WrapErrorf(err, "worker status not found for instance %s", instance)
                }</span>
                <span class="cov0" title="0">s.logger.Error(ctx, "Failed to get worker status", err, map[string]interface{}{"worker_instance": instance})
                return nil, contextutils.WrapErrorf(err, "failed to get worker status for instance %s", instance)</span>
        }

        <span class="cov6" title="5">return &amp;status, nil</span>
}

// GetAllWorkerStatuses retrieves all worker statuses
func (s *WorkerService) GetAllWorkerStatuses(ctx context.Context) (result0 []models.WorkerStatus, err error) <span class="cov3" title="2">{
        ctx, span := observability.TraceWorkerFunction(ctx, "get_all_worker_statuses")
        defer func() </span><span class="cov3" title="2">{
                if err != nil </span><span class="cov0" title="0">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov3" title="2">span.End()</span>
        }()

        <span class="cov3" title="2">var rows *sql.Rows
        rows, err = s.db.QueryContext(ctx, `
                SELECT id, worker_instance, is_running, is_paused, current_activity,
                           last_heartbeat, last_run_start, last_run_finish, last_run_error,
                           total_questions_generated, total_runs, created_at, updated_at
                FROM worker_status ORDER BY worker_instance
        `)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error(ctx, "Failed to get all worker statuses", err, map[string]interface{}{})
                return nil, contextutils.WrapError(err, "failed to get all worker statuses")
        }</span>
        <span class="cov3" title="2">defer func() </span><span class="cov3" title="2">{
                if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                        s.logger.Error(ctx, "Failed to close rows", err, map[string]interface{}{})
                }</span>
        }()

        <span class="cov3" title="2">var statuses []models.WorkerStatus
        for rows.Next() </span><span class="cov6" title="5">{
                var status models.WorkerStatus
                err = rows.Scan(
                        &amp;status.ID, &amp;status.WorkerInstance, &amp;status.IsRunning, &amp;status.IsPaused,
                        &amp;status.CurrentActivity, &amp;status.LastHeartbeat, &amp;status.LastRunStart,
                        &amp;status.LastRunFinish, &amp;status.LastRunError, &amp;status.TotalQuestionsGenerated,
                        &amp;status.TotalRuns, &amp;status.CreatedAt, &amp;status.UpdatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Error(ctx, "Failed to scan worker status row", err, map[string]interface{}{})
                        return nil, contextutils.WrapError(err, "failed to scan worker status row")
                }</span>
                <span class="cov6" title="5">statuses = append(statuses, status)</span>
        }

        <span class="cov3" title="2">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                s.logger.Error(ctx, "Error iterating worker status rows", err, map[string]interface{}{})
                return nil, contextutils.WrapError(err, "error iterating worker status rows")
        }</span>

        <span class="cov3" title="2">s.logger.Debug(ctx, "Retrieved all worker statuses", map[string]interface{}{"count": len(statuses)})
        return statuses, nil</span>
}

// UpdateHeartbeat updates the heartbeat for a worker instance
func (s *WorkerService) UpdateHeartbeat(ctx context.Context, instance string) (err error) <span class="cov3" title="2">{
        ctx, span := observability.TraceWorkerFunction(ctx, "update_heartbeat", attribute.String("worker.instance", instance))
        defer func() </span><span class="cov3" title="2">{
                if err != nil </span><span class="cov0" title="0">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov3" title="2">span.End()</span>
        }()

        <span class="cov3" title="2">_, err = s.db.ExecContext(ctx, `
                INSERT INTO worker_status (worker_instance, last_heartbeat, updated_at)
                VALUES ($1, NOW(), NOW())
                ON CONFLICT (worker_instance) DO UPDATE SET
                        last_heartbeat = EXCLUDED.last_heartbeat,
                        updated_at = EXCLUDED.updated_at
        `, instance)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error(ctx, "Failed to update heartbeat", err, map[string]interface{}{"worker_instance": instance})
                return contextutils.WrapErrorf(err, "failed to update heartbeat for instance %s", instance)
        }</span>

        <span class="cov3" title="2">s.logger.Debug(ctx, "Heartbeat updated", map[string]interface{}{"worker_instance": instance})
        return nil</span>
}

// IsWorkerHealthy checks if a worker instance is healthy based on recent heartbeat
func (s *WorkerService) IsWorkerHealthy(ctx context.Context, instance string) (result0 bool, err error) <span class="cov7" title="6">{
        ctx, span := observability.TraceWorkerFunction(ctx, "is_worker_healthy", attribute.String("worker.instance", instance))
        defer func() </span><span class="cov7" title="6">{
                if err != nil </span><span class="cov0" title="0">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov7" title="6">span.End()</span>
        }()

        <span class="cov7" title="6">var lastHeartbeat sql.NullTime
        err = s.db.QueryRowContext(ctx, `
                SELECT last_heartbeat FROM worker_status WHERE worker_instance = $1
        `, instance).Scan(&amp;lastHeartbeat)
        if err != nil </span><span class="cov1" title="1">{
                if err == sql.ErrNoRows </span><span class="cov1" title="1">{
                        s.logger.Debug(ctx, "Worker not found, considered unhealthy", map[string]interface{}{"worker_instance": instance})
                        return false, nil
                }</span>
                <span class="cov0" title="0">s.logger.Error(ctx, "Failed to check worker health", err, map[string]interface{}{"worker_instance": instance})
                return false, contextutils.WrapErrorf(err, "failed to check worker health for instance %s", instance)</span>
        }

        <span class="cov6" title="5">if !lastHeartbeat.Valid </span><span class="cov0" title="0">{
                s.logger.Debug(ctx, "Worker has no heartbeat, considered unhealthy", map[string]interface{}{"worker_instance": instance})
                return false, nil
        }</span>

        // Consider worker healthy if heartbeat is within the last 5 minutes
        <span class="cov6" title="5">healthy := time.Since(lastHeartbeat.Time) &lt; 5*time.Minute
        s.logger.Debug(ctx, "Worker health checked", map[string]interface{}{
                "worker_instance": instance,
                "healthy":         healthy,
                "last_heartbeat":  lastHeartbeat.Time,
                "time_since":      time.Since(lastHeartbeat.Time).String(),
        })
        return healthy, nil</span>
}

// PauseWorker pauses a specific worker instance
func (s *WorkerService) PauseWorker(ctx context.Context, instance string) (err error) <span class="cov4" title="3">{
        ctx, span := observability.TraceWorkerFunction(ctx, "pause_worker", attribute.String("worker.instance", instance))
        defer func() </span><span class="cov4" title="3">{
                if err != nil </span><span class="cov0" title="0">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov4" title="3">span.End()</span>
        }()

        <span class="cov4" title="3">_, err = s.db.ExecContext(ctx, `
                UPDATE worker_status SET is_paused = true, updated_at = NOW()
                WHERE worker_instance = $1
        `, instance)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error(ctx, "Failed to pause worker", err, map[string]interface{}{"worker_instance": instance})
                return contextutils.WrapErrorf(err, "failed to pause worker instance %s", instance)
        }</span>

        <span class="cov4" title="3">s.logger.Info(ctx, "Worker paused", map[string]interface{}{"worker_instance": instance})
        return nil</span>
}

// ResumeWorker resumes a specific worker instance
func (s *WorkerService) ResumeWorker(ctx context.Context, instance string) (err error) <span class="cov4" title="3">{
        ctx, span := observability.TraceWorkerFunction(ctx, "resume_worker", attribute.String("worker.instance", instance))
        defer func() </span><span class="cov4" title="3">{
                if err != nil </span><span class="cov0" title="0">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov4" title="3">span.End()</span>
        }()

        <span class="cov4" title="3">_, err = s.db.ExecContext(ctx, `
                UPDATE worker_status SET is_paused = false, updated_at = NOW()
                WHERE worker_instance = $1
        `, instance)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error(ctx, "Failed to resume worker", err, map[string]interface{}{"worker_instance": instance})
                return contextutils.WrapErrorf(err, "failed to resume worker instance %s", instance)
        }</span>

        <span class="cov4" title="3">s.logger.Info(ctx, "Worker resumed", map[string]interface{}{"worker_instance": instance})
        return nil</span>
}

// GetWorkerHealth returns a map of worker health information
func (s *WorkerService) GetWorkerHealth(ctx context.Context) (result0 map[string]interface{}, err error) <span class="cov1" title="1">{
        ctx, span := observability.TraceWorkerFunction(ctx, "get_worker_health")
        defer func() </span><span class="cov1" title="1">{
                if err != nil </span><span class="cov0" title="0">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov1" title="1">span.End()</span>
        }()

        <span class="cov1" title="1">var statuses []models.WorkerStatus
        statuses, err = s.GetAllWorkerStatuses(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">var globalPaused bool
        globalPaused, err = s.IsGlobalPaused(ctx)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error(ctx, "Failed to get global pause state", err, map[string]interface{}{})
                globalPaused = false // Default to false if we can't get the state
        }</span>

        <span class="cov1" title="1">health := make(map[string]interface{})
        workerInstances := make([]map[string]interface{}, 0)
        healthyCount := 0
        totalCount := len(statuses)

        for _, status := range statuses </span><span class="cov4" title="3">{
                healthy, err := s.IsWorkerHealthy(ctx, status.WorkerInstance)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Error(ctx, "Failed to check health for worker", err, map[string]interface{}{"worker_instance": status.WorkerInstance})
                        continue</span>
                }

                <span class="cov4" title="3">if healthy </span><span class="cov4" title="3">{
                        healthyCount++
                }</span>

                <span class="cov4" title="3">workerInstance := map[string]interface{}{
                        "worker_instance":           status.WorkerInstance,
                        "healthy":                   healthy,
                        "is_running":                status.IsRunning,
                        "is_paused":                 status.IsPaused,
                        "last_heartbeat":            status.LastHeartbeat,
                        "total_questions_generated": status.TotalQuestionsGenerated,
                        "total_runs":                status.TotalRuns,
                }
                workerInstances = append(workerInstances, workerInstance)</span>
        }

        // Build comprehensive health summary
        <span class="cov1" title="1">health["global_paused"] = globalPaused
        health["worker_instances"] = workerInstances
        health["total_count"] = totalCount
        health["healthy_count"] = healthyCount

        s.logger.Debug(ctx, "Worker health retrieved", map[string]interface{}{"worker_count": len(health)})
        return health, nil</span>
}

// GetHighPriorityTopics returns topics with high average priority scores for a user
func (s *WorkerService) GetHighPriorityTopics(ctx context.Context, userID int, language, level, questionType string) (result0 []string, err error) <span class="cov1" title="1">{
        ctx, span := observability.TraceWorkerFunction(ctx, "get_high_priority_topics",
                observability.AttributeUserID(userID),
                observability.AttributeLanguage(language),
                observability.AttributeLevel(level),
                attribute.String("question.type", questionType),
        )
        defer func() </span><span class="cov1" title="1">{
                if err != nil </span><span class="cov0" title="0">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov1" title="1">span.End()</span>
        }()

        <span class="cov1" title="1">query := `
                SELECT q.topic_category, AVG(qps.priority_score) as avg_score
                FROM questions q
                JOIN user_questions uq ON q.id = uq.question_id
                JOIN question_priority_scores qps ON q.id = qps.question_id AND qps.user_id = $1
                WHERE uq.user_id = $1
                AND q.language = $2
                AND q.level = $3
                AND q.type = $4
                AND q.topic_category IS NOT NULL
                AND q.topic_category != ''
                GROUP BY q.topic_category
                HAVING AVG(qps.priority_score) &gt;= 7.0
                ORDER BY avg_score DESC
                LIMIT 5
        `
        rows, err := s.db.QueryContext(ctx, query, userID, language, level, questionType)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error(ctx, "Failed to get high priority topics", err, map[string]interface{}{
                        "user_id": userID, "language": language, "level": level, "question_type": questionType,
                })
                return nil, contextutils.WrapError(err, "failed to get high priority topics")
        }</span>
        <span class="cov1" title="1">defer func() </span><span class="cov1" title="1">{
                if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                        s.logger.Error(ctx, "Failed to close rows", err, map[string]interface{}{})
                }</span>
        }()
        <span class="cov1" title="1">var topics []string
        for rows.Next() </span><span class="cov0" title="0">{
                var topic string
                var avgScore float64
                if err := rows.Scan(&amp;topic, &amp;avgScore); err != nil </span><span class="cov0" title="0">{
                        s.logger.Error(ctx, "Failed to scan high priority topics row", err, map[string]interface{}{})
                        return nil, contextutils.WrapError(err, "failed to scan high priority topics row")
                }</span>
                <span class="cov0" title="0">topics = append(topics, topic)</span>
        }
        <span class="cov1" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                s.logger.Error(ctx, "Error iterating high priority topics rows", err, map[string]interface{}{})
                return nil, contextutils.WrapError(err, "error iterating high priority topics rows")
        }</span>
        <span class="cov1" title="1">s.logger.Debug(ctx, "Retrieved high priority topics", map[string]interface{}{"user_id": userID, "count": len(topics)})
        return topics, nil</span>
}

// GetGapAnalysis identifies areas with poor user performance (knowledge gaps)
func (s *WorkerService) GetGapAnalysis(ctx context.Context, userID int, language, level, questionType string) (result0 map[string]int, err error) <span class="cov1" title="1">{
        ctx, span := observability.TraceWorkerFunction(ctx, "get_gap_analysis",
                observability.AttributeUserID(userID),
                observability.AttributeLanguage(language),
                observability.AttributeLevel(level),
                attribute.String("question.type", questionType),
        )
        defer func() </span><span class="cov1" title="1">{
                if err != nil </span><span class="cov0" title="0">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov1" title="1">span.End()</span>
        }()

        // Query to find areas where user has poor performance (low accuracy)
        // This analyzes gaps in user's knowledge across topics and varieties
        <span class="cov1" title="1">query := `
                WITH user_performance AS (
                        SELECT
                                q.topic_category,
                                q.grammar_focus,
                                q.vocabulary_domain,
                                q.scenario,
                                COUNT(*) as total_questions,
                                COUNT(CASE WHEN ur.is_correct = true THEN 1 END) as correct_answers,
                                ROUND(
                                        COUNT(CASE WHEN ur.is_correct = true THEN 1 END)::decimal / COUNT(*)::decimal * 100, 2
                                ) as accuracy_percentage
                        FROM questions q
                        JOIN user_questions uq ON q.id = uq.question_id
                        LEFT JOIN user_responses ur ON q.id = ur.question_id AND ur.user_id = $1
                        WHERE uq.user_id = $1
                        AND q.language = $2
                        AND q.level = $3
                        AND q.type = $4
                        GROUP BY q.topic_category, q.grammar_focus, q.vocabulary_domain, q.scenario
                )
                SELECT
                        COALESCE(topic_category, 'unknown') as area,
                        'topic' as gap_type,
                        total_questions,
                        accuracy_percentage
                FROM user_performance
                WHERE accuracy_percentage &lt; 60 OR accuracy_percentage IS NULL
                UNION ALL
                SELECT
                        COALESCE(grammar_focus, 'unknown') as area,
                        'grammar' as gap_type,
                        total_questions,
                        accuracy_percentage
                FROM user_performance
                WHERE (accuracy_percentage &lt; 60 OR accuracy_percentage IS NULL) AND grammar_focus IS NOT NULL
                UNION ALL
                SELECT
                        COALESCE(vocabulary_domain, 'unknown') as area,
                        'vocabulary' as gap_type,
                        total_questions,
                        accuracy_percentage
                FROM user_performance
                WHERE (accuracy_percentage &lt; 60 OR accuracy_percentage IS NULL) AND vocabulary_domain IS NOT NULL
                UNION ALL
                SELECT
                        COALESCE(scenario, 'unknown') as area,
                        'scenario' as gap_type,
                        total_questions,
                        accuracy_percentage
                FROM user_performance
                WHERE (accuracy_percentage &lt; 60 OR accuracy_percentage IS NULL) AND scenario IS NOT NULL
                ORDER BY accuracy_percentage ASC, total_questions DESC
        `

        rows, err := s.db.QueryContext(ctx, query, userID, language, level, questionType)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error(ctx, "Failed to get gap analysis", err, map[string]interface{}{
                        "user_id": userID, "language": language, "level": level, "question_type": questionType,
                })
                return nil, contextutils.WrapError(err, "failed to get gap analysis")
        }</span>
        <span class="cov1" title="1">defer func() </span><span class="cov1" title="1">{
                if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                        s.logger.Error(ctx, "Failed to close rows", err, map[string]interface{}{})
                }</span>
        }()

        <span class="cov1" title="1">gaps := make(map[string]int)
        for rows.Next() </span><span class="cov1" title="1">{
                var area, gapType string
                var totalQuestions int
                var accuracyPercentage sql.NullFloat64

                if err := rows.Scan(&amp;area, &amp;gapType, &amp;totalQuestions, &amp;accuracyPercentage); err != nil </span><span class="cov0" title="0">{
                        s.logger.Error(ctx, "Failed to scan gap analysis row", err, map[string]interface{}{})
                        return nil, contextutils.WrapError(err, "failed to scan gap analysis row")
                }</span>

                // Create a key that includes the gap type for better identification
                <span class="cov1" title="1">key := fmt.Sprintf("%s_%s", gapType, area)

                // Use the number of questions as the gap severity indicator
                // Areas with more questions but poor performance are bigger gaps
                gaps[key] = totalQuestions</span>
        }

        <span class="cov1" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                s.logger.Error(ctx, "Error iterating gap analysis rows", err, map[string]interface{}{})
                return nil, contextutils.WrapError(err, "error iterating gap analysis rows")
        }</span>
        <span class="cov1" title="1">s.logger.Debug(ctx, "Retrieved gap analysis", map[string]interface{}{"user_id": userID, "count": len(gaps)})
        return gaps, nil</span>
}

// GetPriorityDistribution returns the distribution of priority scores by topic
func (s *WorkerService) GetPriorityDistribution(ctx context.Context, userID int, language, level, questionType string) (result0 map[string]int, err error) <span class="cov1" title="1">{
        ctx, span := observability.TraceWorkerFunction(ctx, "get_priority_distribution",
                observability.AttributeUserID(userID),
                observability.AttributeLanguage(language),
                observability.AttributeLevel(level),
                attribute.String("question.type", questionType),
        )
        defer func() </span><span class="cov1" title="1">{
                if err != nil </span><span class="cov0" title="0">{
                        span.RecordError(err, trace.WithStackTrace(true))
                        span.SetStatus(codes.Error, err.Error())
                }</span>
                <span class="cov1" title="1">span.End()</span>
        }()

        // Query to get priority score distribution by topic
        <span class="cov1" title="1">query := `
                SELECT q.topic_category, COUNT(*) as question_count
                FROM questions q
                JOIN user_questions uq ON q.id = uq.question_id
                JOIN question_priority_scores qps ON q.id = qps.question_id AND qps.user_id = $1
                WHERE uq.user_id = $1
                AND q.language = $2
                AND q.level = $3
                AND q.type = $4
                GROUP BY q.topic_category
        `

        rows, err := s.db.QueryContext(ctx, query, userID, language, level, questionType)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error(ctx, "Failed to get priority distribution", err, map[string]interface{}{
                        "user_id": userID, "language": language, "level": level, "question_type": questionType,
                })
                return nil, contextutils.WrapError(err, "failed to get priority distribution")
        }</span>
        <span class="cov1" title="1">defer func() </span><span class="cov1" title="1">{
                if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                        s.logger.Error(ctx, "Failed to close rows", err, map[string]interface{}{})
                }</span>
        }()

        <span class="cov1" title="1">distribution := make(map[string]int)
        for rows.Next() </span><span class="cov0" title="0">{
                var topic string
                var count int
                if err := rows.Scan(&amp;topic, &amp;count); err != nil </span><span class="cov0" title="0">{
                        s.logger.Error(ctx, "Failed to scan priority distribution row", err, map[string]interface{}{})
                        return nil, contextutils.WrapError(err, "failed to scan priority distribution row")
                }</span>
                <span class="cov0" title="0">distribution[topic] = count</span>
        }

        <span class="cov1" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                s.logger.Error(ctx, "Error iterating priority distribution rows", err, map[string]interface{}{})
                return nil, contextutils.WrapError(err, "error iterating priority distribution rows")
        }</span>
        <span class="cov1" title="1">s.logger.Debug(ctx, "Retrieved priority distribution", map[string]interface{}{"user_id": userID, "count": len(distribution)})
        return distribution, nil</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">// Package contextutils provides error handling utilities and standardized error types
// for consistent error management across the quiz application.
package contextutils

import (
        "errors"
        "fmt"
)

// Error types for consistent error handling
var (
        // Database errors
        ErrDatabaseConnection  = errors.New("database connection failed")
        ErrDatabaseQuery       = errors.New("database query failed")
        ErrDatabaseTransaction = errors.New("database transaction failed")
        ErrRecordNotFound      = errors.New("record not found")
        ErrRecordExists        = errors.New("record already exists")
        ErrForeignKeyViolation = errors.New("foreign key constraint violation")

        // Validation errors
        ErrInvalidInput     = errors.New("invalid input")
        ErrMissingRequired  = errors.New("missing required field")
        ErrInvalidFormat    = errors.New("invalid format")
        ErrValidationFailed = errors.New("validation failed")

        // Authentication errors
        ErrUnauthorized       = errors.New("unauthorized")
        ErrForbidden          = errors.New("forbidden")
        ErrInvalidCredentials = errors.New("invalid credentials")
        ErrSessionExpired     = errors.New("session expired")

        // Service errors
        ErrServiceUnavailable = errors.New("service unavailable")
        ErrTimeout            = errors.New("request timeout")
        ErrRateLimit          = errors.New("rate limit exceeded")
        ErrInternalError      = errors.New("internal server error")

        // AI Service errors
        ErrAIProviderUnavailable = errors.New("AI provider unavailable")
        ErrAIRequestFailed       = errors.New("AI request failed")
        ErrAIResponseInvalid     = errors.New("AI response invalid")
        ErrAIConfigInvalid       = errors.New("AI configuration invalid")

        // OAuth errors
        ErrOAuthCodeExpired   = errors.New("OAuth code expired")
        ErrOAuthStateMismatch = errors.New("OAuth state mismatch")
        ErrOAuthProviderError = errors.New("OAuth provider error")
)

// WrapError wraps an error with additional context using %w verb
func WrapError(err error, context string) error <span class="cov10" title="6">{
        if err == nil </span><span class="cov1" title="1">{
                return nil
        }</span>
        <span class="cov9" title="5">return fmt.Errorf("%s: %w", context, err)</span>
}

// WrapErrorf wraps an error with formatted context using %w verb
func WrapErrorf(err error, format string, args ...interface{}) error <span class="cov9" title="5">{
        if err == nil </span><span class="cov1" title="1">{
                return nil
        }</span>
        <span class="cov7" title="4">return fmt.Errorf(format+": %w", append(args, err)...)</span>
}

// ErrorWithContextf creates a new error with formatted context
func ErrorWithContextf(format string, args ...interface{}) error <span class="cov7" title="4">{
        return fmt.Errorf(format, args...)
}</span>
</pre>
		
		<pre class="file" id="file37" style="display: none">package contextutils

import (
        "strings"
)

// MaskAPIKey masks an API key for logging purposes to prevent exposure
// Returns a masked version that shows only first 4 and last 4 characters
func MaskAPIKey(apiKey string) string <span class="cov10" title="17">{
        if apiKey == "" </span><span class="cov1" title="1">{
                return "[EMPTY]"
        }</span>

        <span class="cov9" title="16">if len(apiKey) &lt;= 8 </span><span class="cov4" title="3">{
                return strings.Repeat("*", len(apiKey))
        }</span>

        <span class="cov9" title="13">return apiKey[:4] + strings.Repeat("*", len(apiKey)-8) + apiKey[len(apiKey)-4:]</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">// Package worker provides background job processing for question generation and management.
package worker

import (
        "context"
        "database/sql"
        "encoding/json"
        "fmt"
        "math"
        "os"
        "strconv"
        "strings"
        "sync"
        "time"

        "quizapp/internal/config"
        "quizapp/internal/models"
        "quizapp/internal/observability"
        "quizapp/internal/services"
        contextutils "quizapp/internal/utils"
)

const (
        checkInterval           = config.WorkerCheckInterval
        questionRefillThreshold = config.QuestionRefillThreshold // Refill when we have fewer than this many questions
        maxHistory              = config.MaxHistory
        maxActivityLogs         = config.MaxActivityLogs // Keep last 100 activity log entries
        // NoActionPrefix is used to identify when no action was taken during a worker run
        NoActionPrefix        = config.NoActionPrefix
        triggerThrottleWindow = config.WorkerTriggerThrottle // Prevent multiple triggers for same user within this window
)

// Status represents the current state of the worker
type Status struct {
        IsRunning       bool      `json:"is_running"`
        IsPaused        bool      `json:"is_paused"`
        CurrentActivity string    `json:"current_activity,omitempty"`
        LastRunStart    time.Time `json:"last_run_start"`
        LastRunFinish   time.Time `json:"last_run_finish"`
        LastRunError    string    `json:"last_run_error,omitempty"`
        NextRun         time.Time `json:"next_run"`
}

// RunRecord tracks individual worker runs
type RunRecord struct {
        StartTime time.Time     `json:"start_time"`
        EndTime   time.Time     `json:"end_time"`
        Duration  time.Duration `json:"duration"`
        Status    string        `json:"status"` // Success, Failure
        Details   string        `json:"details"`
}

// ActivityLog represents a single activity log entry
type ActivityLog struct {
        Timestamp time.Time `json:"timestamp"`
        Level     string    `json:"level"` // INFO, WARN, ERROR
        Message   string    `json:"message"`
        UserID    *int      `json:"user_id,omitempty"`
        Username  *string   `json:"username,omitempty"`
}

// UserFailureInfo tracks failure information for exponential backoff
type UserFailureInfo struct {
        ConsecutiveFailures int
        LastFailureTime     time.Time
        NextRetryTime       time.Time
}

// Config holds worker-specific configuration
type Config struct {
        StartWorkerPaused bool
}

// Worker manages AI question generation in the background
type Worker struct {
        userService     services.UserServiceInterface
        questionService services.QuestionServiceInterface
        aiService       services.AIServiceInterface
        learningService services.LearningServiceInterface
        workerService   services.WorkerServiceInterface
        instance        string
        status          Status
        history         []RunRecord
        activityLogs    []ActivityLog // Circular buffer for recent activity logs
        mu              sync.RWMutex
        manualTrigger   chan bool
        shutdownCtx     context.Context
        cfg             *config.Config
        workerCfg       Config
        logger          *observability.Logger

        // Track failures for exponential backoff
        userFailures map[int]*UserFailureInfo // userID -&gt; failure info
        failureMu    sync.RWMutex             // mutex for failure tracking
}

// NewWorker creates a new Worker instance
func NewWorker(
        userService services.UserServiceInterface,
        questionService services.QuestionServiceInterface,
        aiService services.AIServiceInterface,
        learningService services.LearningServiceInterface,
        workerService services.WorkerServiceInterface,
        instance string,
        cfg *config.Config,
        logger *observability.Logger,
) *Worker <span class="cov8" title="90">{
        if instance == "" </span><span class="cov1" title="1">{
                instance = "default"
        }</span>

        // Create worker-specific config
        <span class="cov8" title="90">workerCfg := Config{
                StartWorkerPaused: getEnvBool("START_WORKER_PAUSED", false),
        }

        return &amp;Worker{
                userService:     userService,
                questionService: questionService,
                aiService:       aiService,
                learningService: learningService,
                workerService:   workerService,
                instance:        instance,
                status:          Status{},
                history:         make([]RunRecord, 0),
                activityLogs:    make([]ActivityLog, 0),
                manualTrigger:   make(chan bool, 1), // Buffered to prevent blocking

                userFailures: make(map[int]*UserFailureInfo),
                cfg:          cfg,
                workerCfg:    workerCfg,
                logger:       logger,
        }</span>
}

// getEnvBool is a helper function to get boolean environment variables
func getEnvBool(key string, defaultValue bool) bool <span class="cov8" title="98">{
        valStr := os.Getenv(key)
        if valStr == "" </span><span class="cov8" title="92">{
                return defaultValue
        }</span>
        <span class="cov2" title="3">val, err := strconv.ParseBool(valStr)
        if err != nil </span><span class="cov1" title="1">{
                return defaultValue
        }</span>
        <span class="cov2" title="2">return val</span>
}

// Start begins the worker's background processing loop
func (w *Worker) Start(ctx context.Context) <span class="cov1" title="1">{
        w.shutdownCtx = ctx
        w.status.IsRunning = true
        w.updateDatabaseStatus(ctx)

        w.handleStartupPause(ctx)

        // Start heartbeat goroutine
        go w.heartbeatLoop(ctx)

        // Main worker loop
        ticker := time.NewTicker(config.WorkerHeartbeatInterval) // Check every 30 seconds
        defer ticker.Stop()

        initialStatus := w.getInitialWorkerStatus(ctx)

        w.logger.Info(ctx, "Worker started", map[string]interface{}{
                "instance": w.instance,
                "status":   initialStatus,
        })
        w.logActivity(ctx, "INFO", fmt.Sprintf("Worker %s started (%s)", w.instance, initialStatus), nil, nil)

        for </span><span class="cov1" title="1">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov1" title="1">
                        w.logger.Info(ctx, "Worker shutting down", map[string]interface{}{
                                "instance": w.instance,
                        })
                        w.logActivity(ctx, "INFO", fmt.Sprintf("Worker %s shutting down", w.instance), nil, nil)
                        w.status.IsRunning = false
                        w.updateDatabaseStatus(ctx)
                        return</span>

                case &lt;-ticker.C:<span class="cov0" title="0">
                        w.run()</span>

                case &lt;-w.manualTrigger:<span class="cov0" title="0">
                        w.logger.Info(ctx, "Worker triggered manually", map[string]interface{}{
                                "instance": w.instance,
                        })
                        w.logActivity(ctx, "INFO", fmt.Sprintf("Worker %s triggered manually", w.instance), nil, nil)
                        w.run()</span>
                }
        }
}

// handleStartupPause sets global pause if configured
func (w *Worker) handleStartupPause(ctx context.Context) <span class="cov2" title="3">{
        if w.workerCfg.StartWorkerPaused </span><span class="cov1" title="1">{
                w.logger.Info(ctx, "Worker configured to start paused - setting global pause", map[string]interface{}{
                        "instance": w.instance,
                })
                if err := w.workerService.SetGlobalPause(ctx, true); err != nil </span><span class="cov0" title="0">{
                        w.logger.Error(ctx, "Failed to set global pause on startup", err, map[string]interface{}{
                                "instance": w.instance,
                        })
                }</span> else<span class="cov1" title="1"> {
                        w.logger.Info(ctx, "Global pause set on startup as configured", map[string]interface{}{
                                "instance": w.instance,
                        })
                }</span>
        }
}

// getInitialWorkerStatus determines the initial status string
func (w *Worker) getInitialWorkerStatus(ctx context.Context) string <span class="cov2" title="3">{
        initialStatus := "running"
        globalPaused, err := w.workerService.IsGlobalPaused(ctx)
        if err != nil </span><span class="cov0" title="0">{
                w.logger.Error(ctx, "Failed to check global pause status on startup", err, map[string]interface{}{
                        "instance": w.instance,
                })
        }</span> else<span class="cov2" title="3"> if globalPaused </span><span class="cov0" title="0">{
                initialStatus = "paused (globally)"
        }</span> else<span class="cov2" title="3"> {
                status, err := w.workerService.GetWorkerStatus(ctx, w.instance)
                if err != nil </span><span class="cov0" title="0">{
                        w.logger.Error(ctx, "Failed to get worker status on startup", err, map[string]interface{}{
                                "instance": w.instance,
                        })
                }</span> else<span class="cov2" title="3"> if status != nil &amp;&amp; status.IsPaused </span><span class="cov1" title="1">{
                        initialStatus = "paused (instance)"
                }</span>
        }
        <span class="cov2" title="3">return initialStatus</span>
}

func (w *Worker) heartbeatLoop(ctx context.Context) <span class="cov2" title="2">{
        ticker := time.NewTicker(config.WorkerHeartbeatInterval) // Heartbeat every 30 seconds
        defer ticker.Stop()

        for </span><span class="cov2" title="2">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov2" title="2">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        w.updateHeartbeat(ctx)</span>
                }
        }
}

// updateHeartbeat updates the heartbeat in the database
func (w *Worker) updateHeartbeat(ctx context.Context) <span class="cov1" title="1">{
        if err := w.workerService.UpdateHeartbeat(ctx, w.instance); err != nil </span><span class="cov0" title="0">{
                w.logger.Error(ctx, "Failed to update heartbeat for worker", err, map[string]interface{}{
                        "instance": w.instance,
                })
        }</span>
}

// run executes a single worker cycle
func (w *Worker) run() <span class="cov3" title="4">{
        paused, reason := w.checkPauseStatus(w.shutdownCtx)
        if paused </span><span class="cov3" title="4">{
                w.updateActivity(reason)
                return
        }</span>

        <span class="cov0" title="0">w.status.LastRunStart = time.Now()
        w.updateDatabaseStatus(w.shutdownCtx)
        details, err := w.generateNeededQuestions(w.shutdownCtx)

        w.status.LastRunFinish = time.Now()
        if err != nil </span><span class="cov0" title="0">{
                w.status.LastRunError = err.Error()
                w.logger.Error(w.shutdownCtx, "Worker run failed", err, map[string]interface{}{
                        "instance": w.instance,
                })
        }</span> else<span class="cov0" title="0"> {
                w.status.LastRunError = ""
        }</span>

        <span class="cov0" title="0">w.recordRunHistory(details, err)
        w.updateDatabaseStatus(w.shutdownCtx)</span>
}

// checkPauseStatus checks global and instance pause
func (w *Worker) checkPauseStatus(ctx context.Context) (bool, string) <span class="cov3" title="6">{
        globalPaused, err := w.workerService.IsGlobalPaused(ctx)
        if err != nil </span><span class="cov0" title="0">{
                w.logger.Error(ctx, "Failed to check global pause status", err, map[string]interface{}{
                        "instance": w.instance,
                })
                return true, "Error checking global pause status"
        }</span>
        <span class="cov3" title="6">if globalPaused </span><span class="cov2" title="3">{
                return true, "Globally paused"
        }</span>
        <span class="cov2" title="3">status, err := w.workerService.GetWorkerStatus(ctx, w.instance)
        if err != nil </span><span class="cov2" title="3">{
                w.logger.Error(ctx, "Failed to get worker status", err, map[string]interface{}{
                        "instance": w.instance,
                })
                return true, "Error checking worker status"
        }</span> else<span class="cov0" title="0"> if status != nil &amp;&amp; status.IsPaused </span><span class="cov0" title="0">{
                return true, "Worker instance paused"
        }</span>
        <span class="cov0" title="0">return false, ""</span>
}

// recordRunHistory records the run in history and trims the slice
func (w *Worker) recordRunHistory(details string, err error) <span class="cov7" title="55">{
        record := RunRecord{
                StartTime: w.status.LastRunStart,
                EndTime:   w.status.LastRunFinish,
                Duration:  w.status.LastRunFinish.Sub(w.status.LastRunStart),
                Details:   details,
        }
        if err != nil </span><span class="cov0" title="0">{
                record.Status = "Failure"
        }</span> else<span class="cov7" title="55"> {
                record.Status = "Success"
        }</span>
        <span class="cov7" title="55">w.mu.Lock()
        w.history = append(w.history, record)
        if len(w.history) &gt; 50 </span><span class="cov3" title="5">{
                w.history = w.history[len(w.history)-50:]
        }</span>
        <span class="cov7" title="55">w.mu.Unlock()</span>
}

// GetStatus returns the current worker status
func (w *Worker) GetStatus() Status <span class="cov3" title="5">{
        w.mu.RLock()
        defer w.mu.RUnlock()
        return w.status
}</span>

// GetHistory returns the worker's run history
func (w *Worker) GetHistory() []RunRecord <span class="cov4" title="8">{
        w.mu.RLock()
        defer w.mu.RUnlock()
        // Return a copy to avoid race conditions
        history := make([]RunRecord, len(w.history))
        copy(history, w.history)
        return history
}</span>

// GetActivityLogs returns recent activity logs
func (w *Worker) GetActivityLogs() []ActivityLog <span class="cov4" title="7">{
        w.mu.RLock()
        defer w.mu.RUnlock()

        // Return a copy to avoid concurrent access issues
        logs := make([]ActivityLog, len(w.activityLogs))
        copy(logs, w.activityLogs)
        return logs
}</span>

// GetInstance returns the worker instance name
func (w *Worker) GetInstance() string <span class="cov1" title="1">{
        return w.instance
}</span>

// TriggerManualRun triggers a manual worker run
func (w *Worker) TriggerManualRun() <span class="cov3" title="5">{
        ctx := context.Background()
        select </span>{
        case w.manualTrigger &lt;- true:<span class="cov2" title="3">
                w.logger.Info(ctx, "Manual trigger sent to worker", map[string]interface{}{
                        "instance": w.instance,
                })</span>
        default:<span class="cov1" title="1">
                w.logger.Info(ctx, "Manual trigger already pending for worker", map[string]interface{}{
                        "instance": w.instance,
                })</span>
        }
}

// Pause pauses the worker
func (w *Worker) Pause(ctx context.Context) <span class="cov2" title="2">{
        if err := w.workerService.PauseWorker(ctx, w.instance); err != nil </span><span class="cov1" title="1">{
                w.logger.Warn(ctx, "Failed to pause worker in service", map[string]interface{}{
                        "instance": w.instance,
                        "error":    err.Error(),
                })
        }</span>
        <span class="cov2" title="2">w.logger.Info(ctx, "Worker paused", map[string]interface{}{
                "instance": w.instance,
        })
        w.logActivity(ctx, "INFO", fmt.Sprintf("Worker %s paused", w.instance), nil, nil)
        w.status.IsPaused = true
        w.updateDatabaseStatus(ctx)</span>
}

// Resume resumes the worker
func (w *Worker) Resume(ctx context.Context) <span class="cov2" title="2">{
        if err := w.workerService.ResumeWorker(ctx, w.instance); err != nil </span><span class="cov1" title="1">{
                w.logger.Warn(ctx, "Failed to resume worker in service", map[string]interface{}{
                        "instance": w.instance,
                        "error":    err.Error(),
                })
                // Do not unpause if resume failed
                w.updateDatabaseStatus(ctx)
                return
        }</span>
        <span class="cov1" title="1">w.logger.Info(ctx, "Worker resumed", map[string]interface{}{
                "instance": w.instance,
        })
        w.logActivity(ctx, "INFO", fmt.Sprintf("Worker %s resumed", w.instance), nil, nil)
        w.status.IsPaused = false
        w.updateDatabaseStatus(ctx)</span>
}

// Shutdown gracefully shuts down the worker and cleans up resources
func (w *Worker) Shutdown(ctx context.Context) error <span class="cov1" title="1">{
        w.mu.Lock()
        defer w.mu.Unlock()

        w.logger.Info(ctx, "Worker starting shutdown", map[string]interface{}{
                "instance": w.instance,
        })

        // Signal shutdown to any running operations
        if w.shutdownCtx != nil </span><span class="cov0" title="0">{
                // Create a new shutdown context if needed
                if w.shutdownCtx == context.Background() </span><span class="cov0" title="0">{
                        shutdownCtx, cancel := context.WithCancel(ctx)
                        w.shutdownCtx = shutdownCtx
                        defer cancel()
                }</span>
        }

        // Wait for any active operations to complete
        // This is a simple implementation - in a more complex system,
        // you might want to track active operations more precisely
        <span class="cov1" title="1">time.Sleep(config.WorkerSleepDuration)

        // Clean up user failures map
        w.failureMu.Lock()
        w.userFailures = make(map[int]*UserFailureInfo)
        w.failureMu.Unlock()

        // Clear activity logs
        w.activityLogs = make([]ActivityLog, 0)

        w.logger.Info(ctx, "Worker shutdown completed", map[string]interface{}{
                "instance": w.instance,
        })
        return nil</span>
}

// updateDatabaseStatus updates the worker status in the database
func (w *Worker) updateDatabaseStatus(ctx context.Context) <span class="cov4" title="10">{
        dbStatus := &amp;models.WorkerStatus{
                WorkerInstance:          w.instance,
                IsRunning:               w.status.IsRunning,
                IsPaused:                w.status.IsPaused,
                CurrentActivity:         sql.NullString{String: w.status.CurrentActivity, Valid: w.status.CurrentActivity != ""},
                LastHeartbeat:           sql.NullTime{Time: time.Now(), Valid: true},
                LastRunStart:            sql.NullTime{Time: w.status.LastRunStart, Valid: !w.status.LastRunStart.IsZero()},
                LastRunFinish:           sql.NullTime{Time: w.status.LastRunFinish, Valid: !w.status.LastRunFinish.IsZero()},
                LastRunError:            sql.NullString{String: w.status.LastRunError, Valid: w.status.LastRunError != ""},
                TotalQuestionsGenerated: w.getTotalQuestionsGenerated(),
                TotalRuns:               len(w.history),
        }

        if err := w.workerService.UpdateWorkerStatus(ctx, w.instance, dbStatus); err != nil </span><span class="cov1" title="1">{
                w.logger.Error(ctx, "Failed to update worker status in database", err, map[string]interface{}{
                        "instance": w.instance,
                })
        }</span>
}

// getTotalQuestionsGenerated calculates total questions generated from run history
func (w *Worker) getTotalQuestionsGenerated() int <span class="cov4" title="10">{
        total := 0
        for _, record := range w.history </span><span class="cov0" title="0">{
                if record.Status == "Success" </span><span class="cov0" title="0">{
                        // Parse details to count questions - simplified for now
                        total++ // This would need to be enhanced to parse actual count
                }</span>
        }
        <span class="cov4" title="10">return total</span>
}

func (w *Worker) generateNeededQuestions(ctx context.Context) (result0 string, err error) <span class="cov0" title="0">{ // Check if globally paused BEFORE any work or logging
        globalPaused, err := w.workerService.IsGlobalPaused(ctx)
        if err != nil </span><span class="cov0" title="0">{
                w.logger.Error(ctx, "Failed to check global pause status", err, map[string]interface{}{
                        "instance": w.instance,
                })
                return "Error checking global pause status", err
        }</span>
        <span class="cov0" title="0">if globalPaused </span><span class="cov0" title="0">{
                w.logger.Info(ctx, "Worker skipping question generation (globally paused)", map[string]interface{}{
                        "instance": w.instance,
                })
                return "Run paused globally", nil
        }</span>

        <span class="cov0" title="0">aiUsers, err := w.getEligibleAIUsers(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return "Error getting users", err
        }</span>
        <span class="cov0" title="0">if len(aiUsers) == 0 </span><span class="cov0" title="0">{
                w.logger.Info(ctx, "Worker: No active users with AI provider configuration found for question generation", map[string]interface{}{
                        "instance": w.instance,
                })
                return "No active users with AI provider configuration found", nil
        }</span>

        <span class="cov0" title="0">var actions []string
        var checkedUsers []string
        var actuallyProcessedUsers []string
        var hadAttemptedOperations bool
        var hadFailures bool

        for _, user := range aiUsers </span><span class="cov0" title="0">{
                checkedUsers = append(checkedUsers, user.Username)
                shouldProcess, skipReason := w.shouldProcessUser(ctx, &amp;user)
                if !shouldProcess </span><span class="cov0" title="0">{
                        if skipReason != "" </span><span class="cov0" title="0">{
                                w.logger.Info(ctx, "Worker user check", map[string]interface{}{
                                        "instance": w.instance,
                                        "username": user.Username,
                                        "reason":   skipReason,
                                })
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }
                <span class="cov0" title="0">actuallyProcessedUsers = append(actuallyProcessedUsers, user.Username)
                userActions, attempted, failed := w.processUserQuestionGeneration(ctx, &amp;user)
                if attempted </span><span class="cov0" title="0">{
                        hadAttemptedOperations = true
                }</span>
                <span class="cov0" title="0">if failed </span><span class="cov0" title="0">{
                        hadFailures = true
                }</span>
                <span class="cov0" title="0">if userActions != "" </span><span class="cov0" title="0">{
                        actions = append(actions, userActions)
                }</span>
                <span class="cov0" title="0">w.logger.Info(ctx, "Worker completed check for user", map[string]interface{}{
                        "instance": w.instance,
                        "username": user.Username,
                })</span>
        }

        <span class="cov0" title="0">w.updateActivity("")
        return w.summarizeRunActions(actions, checkedUsers, actuallyProcessedUsers, hadAttemptedOperations, hadFailures), nil</span>
}

// getEligibleAIUsers returns users eligible for AI question generation
func (w *Worker) getEligibleAIUsers(ctx context.Context) (result0 []models.User, err error) <span class="cov1" title="1">{
        users, err := w.userService.GetAllUsers(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">var aiUsers []models.User
        for _, user := range users </span><span class="cov2" title="3">{
                if !user.AIEnabled.Valid || !user.AIEnabled.Bool </span><span class="cov1" title="1">{
                        continue</span>
                }
                <span class="cov2" title="2">userPaused, err := w.workerService.IsUserPaused(ctx, user.ID)
                if err == nil &amp;&amp; userPaused </span><span class="cov1" title="1">{
                        continue</span>
                }
                <span class="cov1" title="1">hasAIProvider := user.AIProvider.Valid &amp;&amp; user.AIProvider.String != ""
                hasAPIKey := false
                if hasAIProvider </span><span class="cov1" title="1">{
                        savedKey, err := w.userService.GetUserAPIKey(ctx, user.ID, user.AIProvider.String)
                        if err == nil &amp;&amp; savedKey != "" </span><span class="cov1" title="1">{
                                hasAPIKey = true
                        }</span>
                }
                <span class="cov1" title="1">if hasAPIKey || hasAIProvider </span><span class="cov1" title="1">{
                        aiUsers = append(aiUsers, user)
                }</span>
        }
        <span class="cov1" title="1">return aiUsers, nil</span>
}

// shouldProcessUser encapsulates exponential backoff and pause checks
func (w *Worker) shouldProcessUser(ctx context.Context, user *models.User) (bool, string) <span class="cov3" title="4">{
        if !w.shouldRetryUser(user.ID) </span><span class="cov1" title="1">{
                w.failureMu.RLock()
                failure := w.userFailures[user.ID]
                nextRetry := time.Until(failure.NextRetryTime)
                w.failureMu.RUnlock()
                return false, fmt.Sprintf("Skipping due to exponential backoff (failure #%d, retry in %v)", failure.ConsecutiveFailures, nextRetry.Round(time.Second))
        }</span>
        <span class="cov2" title="3">globalPaused, err := w.workerService.IsGlobalPaused(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return false, "Error checking global pause status"
        }</span>
        <span class="cov2" title="3">if globalPaused </span><span class="cov1" title="1">{
                return false, "Run paused globally"
        }</span>
        <span class="cov2" title="2">status, err := w.workerService.GetWorkerStatus(ctx, w.instance)
        if err == nil &amp;&amp; status != nil &amp;&amp; status.IsPaused </span><span class="cov1" title="1">{
                return false, fmt.Sprintf("Worker instance %s paused", w.instance)
        }</span>
        <span class="cov1" title="1">if ctx.Err() != nil </span><span class="cov1" title="1">{
                return false, "Shutdown initiated"
        }</span>
        <span class="cov0" title="0">return true, ""</span>
}

// Helper: get the count of eligible questions for a user (not answered in the last hour)
func (w *Worker) getEligibleQuestionCount(ctx context.Context, userID int, language, level string, qType models.QuestionType) (result0 int, err error) <span class="cov3" title="5">{
        query := `
                SELECT COUNT(*)
                FROM questions q
                JOIN user_questions uq ON q.id = uq.question_id
                WHERE uq.user_id = $1
                  AND q.language = $2
                  AND q.level = $3
                  AND q.type = $4
                  AND q.status = 'active'
                  AND q.id NOT IN (
                    SELECT ur.question_id
                    FROM user_responses ur
                    WHERE ur.user_id = $1
                      AND ur.created_at &gt; NOW() - INTERVAL '1 hour'
                  )
        `

        // Try to get the database from the question service
        var db *sql.DB
        if qs, ok := w.questionService.(*services.QuestionService); ok </span><span class="cov0" title="0">{
                db = qs.DB()
        }</span> else<span class="cov3" title="5"> {
                // For mock services or other implementations, we can't get the DB directly
                // This is expected in unit tests
                return 0, contextutils.ErrorWithContextf("cannot get database from question service implementation")
        }</span>

        <span class="cov0" title="0">row := db.QueryRowContext(ctx, query, userID, language, level, qType)
        var count int
        if err := row.Scan(&amp;count); err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">return count, nil</span>
}

func (w *Worker) processUserQuestionGeneration(ctx context.Context, user *models.User) (string, bool, bool) <span class="cov1" title="1">{
        userLanguage := "italian"
        if user.PreferredLanguage.Valid &amp;&amp; user.PreferredLanguage.String != "" </span><span class="cov1" title="1">{
                userLanguage = user.PreferredLanguage.String
        }</span>
        <span class="cov1" title="1">userLevel := "A1"
        if user.CurrentLevel.Valid &amp;&amp; user.CurrentLevel.String != "" </span><span class="cov1" title="1">{
                userLevel = user.CurrentLevel.String
        }</span>
        <span class="cov1" title="1">languages := []string{userLanguage}
        levels := []string{userLevel}
        questionTypes := []models.QuestionType{
                models.Vocabulary,
                models.FillInBlank,
                models.QuestionAnswer,
                models.ReadingComprehension,
        }
        var actions []string
        var hadAttemptedOperations bool
        var hadFailures bool
        for _, language := range languages </span><span class="cov1" title="1">{
                for _, level := range levels </span><span class="cov1" title="1">{
                        for _, qType := range questionTypes </span><span class="cov3" title="4">{
                                activity := fmt.Sprintf("Checking questions for user %s: %s %s %s", user.Username, language, level, qType)
                                w.updateActivity(activity)
                                // Use eligible question count (not just total assigned)
                                eligibleCount, err := w.getEligibleQuestionCount(ctx, user.ID, language, level, qType)
                                if err != nil </span><span class="cov3" title="4">{
                                        hadFailures = true
                                        continue</span> // Continue to next question type
                                }
                                <span class="cov0" title="0">if eligibleCount &lt; questionRefillThreshold </span><span class="cov0" title="0">{
                                        provider := "default"
                                        if user.AIProvider.Valid &amp;&amp; user.AIProvider.String != "" </span><span class="cov0" title="0">{
                                                provider = user.AIProvider.String
                                        }</span>
                                        <span class="cov0" title="0">needed := w.aiService.GetQuestionBatchSize(provider)
                                        hadAttemptedOperations = true
                                        action, err := w.GenerateQuestionsForUser(ctx, user, language, level, qType, needed, "")
                                        if err != nil </span><span class="cov0" title="0">{
                                                hadFailures = true
                                                // Continue to next question type instead of breaking all loops
                                                continue</span>
                                        }
                                        <span class="cov0" title="0">if action != "" </span><span class="cov0" title="0">{
                                                actions = append(actions, action)
                                        }</span>
                                }
                        }
                }
        }
        <span class="cov1" title="1">return strings.Join(actions, "; "), hadAttemptedOperations, hadFailures</span>
}

// summarizeRunActions builds the summary string for actions taken
func (w *Worker) summarizeRunActions(actions, checkedUsers, actuallyProcessedUsers []string, hadAttemptedOperations, hadFailures bool) string <span class="cov3" title="4">{
        userList := "No users with AI configuration found"
        if len(checkedUsers) &gt; 0 </span><span class="cov3" title="4">{
                userList = fmt.Sprintf("Checked users: %s", strings.Join(checkedUsers, ", "))
        }</span>
        <span class="cov3" title="4">if len(actions) == 0 </span><span class="cov2" title="3">{
                if len(actuallyProcessedUsers) == 0 </span><span class="cov1" title="1">{
                        return fmt.Sprintf("No actions taken. All users in exponential backoff. %s", userList)
                }</span>
                <span class="cov2" title="2">if hadAttemptedOperations &amp;&amp; hadFailures &amp;&amp; len(actions) == 0 </span><span class="cov1" title="1">{
                        return fmt.Sprintf("No actions taken due to errors. %s", userList)
                }</span>
                <span class="cov1" title="1">return fmt.Sprintf("No actions taken. All question types have sufficient questions. %s", userList)</span>
        }
        <span class="cov1" title="1">userList = fmt.Sprintf("Processed users: %s", strings.Join(actuallyProcessedUsers, ", "))
        return fmt.Sprintf("%s. %s", strings.Join(actions, "; "), userList)</span>
}

// GenerateQuestionsForUser generates questions for a specific user with the given parameters
func (w *Worker) GenerateQuestionsForUser(ctx context.Context, user *models.User, language, level string, qType models.QuestionType, count int, topic string) (result0 string, err error) <span class="cov1" title="1">{
        if count &lt;= 0 </span><span class="cov0" title="0">{
                return "No questions needed", nil
        }</span>

        // Gather priority data for variety selection
        <span class="cov1" title="1">priorityData := w.getPriorityGenerationData(ctx, user.ID, language, level, qType)
        var userWeakAreas []string
        if priorityData != nil &amp;&amp; priorityData.FocusOnWeakAreas </span><span class="cov0" title="0">{
                userWeakAreas = priorityData.UserWeakAreas
        }</span>
        <span class="cov1" title="1">var highPriorityTopics []string
        if priorityData != nil </span><span class="cov1" title="1">{
                highPriorityTopics = priorityData.HighPriorityTopics
        }</span>
        <span class="cov1" title="1">var gapAnalysis map[string]int
        if priorityData != nil </span><span class="cov1" title="1">{
                gapAnalysis = priorityData.GapAnalysis
        }</span>

        <span class="cov1" title="1">variety := w.aiService.VarietyService().SelectVarietyElements(ctx, level, highPriorityTopics, userWeakAreas, gapAnalysis)

        // Log priority generation decisions
        generationReasoning := w.getGenerationReasoning(priorityData, variety)

        var freshQuestionRatio float64
        if priorityData != nil </span><span class="cov1" title="1">{
                freshQuestionRatio = priorityData.FreshQuestionRatio
        }</span>

        <span class="cov1" title="1">priorityLog := PriorityGenerationLog{
                UserID:              user.ID,
                Username:            user.Username,
                Language:            language,
                Level:               level,
                QuestionType:        string(qType),
                FocusOnWeakAreas:    priorityData != nil &amp;&amp; priorityData.FocusOnWeakAreas,
                UserWeakAreas:       userWeakAreas,
                HighPriorityTopics:  highPriorityTopics,
                GapAnalysis:         gapAnalysis,
                FreshQuestionRatio:  freshQuestionRatio,
                SelectedVariety:     variety,
                GenerationReasoning: generationReasoning,
                Timestamp:           time.Now(),
        }
        w.logPriorityGeneration(priorityLog)

        aiReq, recentQuestions, err := w.buildAIQuestionGenRequest(ctx, user, language, level, qType, count, topic)
        if err != nil </span><span class="cov0" title="0">{
                w.logger.Warn(ctx, "Worker failed to get recent questions", map[string]interface{}{
                        "instance": w.instance,
                        "error":    err.Error(),
                })
                recentQuestions = []string{}
        }</span>
        <span class="cov1" title="1">aiReq.RecentQuestionHistory = recentQuestions

        userConfig := w.getUserAIConfig(ctx, user)

        batchLogMsg := formatBatchLogMessage(user.Username, count, string(qType), language, level, variety, userConfig.Provider, userConfig.Model)
        w.logger.Info(ctx, batchLogMsg, map[string]interface{}{
                "instance": w.instance,
        })
        w.updateActivity(batchLogMsg)
        w.logActivity(ctx, "INFO", batchLogMsg, &amp;user.ID, &amp;user.Username)

        progressMsg, questions, errAI := w.handleAIQuestionStream(ctx, userConfig, aiReq, variety, count, language, level, qType, topic, user)

        if errAI != nil </span><span class="cov0" title="0">{
                w.recordUserFailure(user.ID, user.Username)
                return progressMsg, errAI
        }</span>
        <span class="cov1" title="1">if len(questions) == 0 </span><span class="cov0" title="0">{
                w.recordUserFailure(user.ID, user.Username)
                return progressMsg, contextutils.WrapErrorf(contextutils.ErrAIResponseInvalid, "AI service returned 0 questions for %s %s %s", language, level, qType)
        }</span>

        <span class="cov1" title="1">savedCount := w.saveGeneratedQuestions(ctx, user, questions, language, level, qType, topic, variety)

        if savedCount &gt; 0 </span><span class="cov1" title="1">{
                w.recordUserSuccess(user.ID, user.Username)
        }</span>
        <span class="cov1" title="1">if savedCount != len(questions) </span><span class="cov0" title="0">{
                w.recordUserFailure(user.ID, user.Username)
                return fmt.Sprintf("Generated %d %s questions for %s %s", savedCount, qType, language, level),
                        contextutils.WrapErrorf(contextutils.ErrDatabaseQuery, "only saved %d out of %d generated questions", savedCount, len(questions))
        }</span>
        <span class="cov1" title="1">return fmt.Sprintf("Generated %d %s questions for %s %s", savedCount, qType, language, level), nil</span>
}

// buildAIQuestionGenRequest prepares the AI request and gets recent questions
func (w *Worker) buildAIQuestionGenRequest(ctx context.Context, user *models.User, language, level string, qType models.QuestionType, count int, _ string) (result0 *models.AIQuestionGenRequest, result1 []string, err error) <span class="cov3" title="5">{
        recentQuestions, _ := w.questionService.GetRecentQuestionContentsForUser(ctx, user.ID, 10)
        aiReq := &amp;models.AIQuestionGenRequest{
                Language:     language,
                Level:        level,
                QuestionType: qType,
                Count:        count,
        }

        aiReq.RecentQuestionHistory = recentQuestions

        return aiReq, recentQuestions, nil
}</span>

// getUserAIConfig builds the UserAIConfig struct with API key
func (w *Worker) getUserAIConfig(ctx context.Context, user *models.User) *services.UserAIConfig <span class="cov2" title="3">{
        provider := ""
        if user.AIProvider.Valid </span><span class="cov2" title="3">{
                provider = user.AIProvider.String
        }</span>
        <span class="cov2" title="3">model := ""
        if user.AIModel.Valid </span><span class="cov2" title="3">{
                model = user.AIModel.String
        }</span>
        <span class="cov2" title="3">apiKey := ""
        if provider != "" </span><span class="cov2" title="3">{
                savedKey, err := w.userService.GetUserAPIKey(ctx, user.ID, provider)
                if err == nil &amp;&amp; savedKey != "" </span><span class="cov2" title="3">{
                        apiKey = savedKey
                }</span>
        }
        <span class="cov2" title="3">return &amp;services.UserAIConfig{
                Provider: provider,
                Model:    model,
                APIKey:   apiKey,
                Username: user.Username,
        }</span>
}

// handleAIQuestionStream handles the AI streaming and collects questions
func (w *Worker) handleAIQuestionStream(ctx context.Context, userConfig *services.UserAIConfig, req *models.AIQuestionGenRequest, variety *services.VarietyElements, count int, language, level string, qType models.QuestionType, topic string, user *models.User) (result0 string, result1 []*models.Question, err error) <span class="cov1" title="1">{
        progressChan := make(chan *models.Question)
        var questions []*models.Question
        var wg sync.WaitGroup
        var errAI error
        progressMsg := ""
        wg.Add(1)
        go func() </span><span class="cov1" title="1">{
                defer func() </span><span class="cov1" title="1">{
                        if r := recover(); r != nil </span><span class="cov0" title="0">{
                                w.logger.Error(ctx, "Panic in AI question stream goroutine", nil, map[string]interface{}{
                                        "instance": w.instance,
                                        "panic":    fmt.Sprintf("%v", r),
                                })
                        }</span>
                        <span class="cov1" title="1">wg.Done()</span>
                }()
                <span class="cov1" title="1">errAI = w.aiService.GenerateQuestionsStream(ctx, userConfig, req, progressChan, variety)</span>
        }()
        <span class="cov1" title="1">generatedCount := 0
        for question := range progressChan </span><span class="cov1" title="1">{
                generatedCount++
                progressMsg = fmt.Sprintf("Generated %d/%d %s questions for %s %s", generatedCount, count, qType, language, level)
                if topic != "" </span><span class="cov1" title="1">{
                        progressMsg = fmt.Sprintf("Generated %d/%d %s questions for %s %s (topic: %s)", generatedCount, count, qType, language, level, topic)
                }</span>
                <span class="cov1" title="1">w.logger.Info(ctx, progressMsg, map[string]interface{}{
                        "instance": w.instance,
                })
                w.updateActivity(progressMsg)
                w.logActivity(ctx, "INFO", progressMsg, &amp;user.ID, &amp;user.Username)
                questions = append(questions, question)</span>
        }
        <span class="cov1" title="1">wg.Wait()
        return progressMsg, questions, errAI</span>
}

// saveGeneratedQuestions saves questions to the DB and returns the count
func (w *Worker) saveGeneratedQuestions(ctx context.Context, user *models.User, questions []*models.Question, language, level string, qType models.QuestionType, topic string, variety *services.VarietyElements) int <span class="cov4" title="7">{
        savingMsg := fmt.Sprintf("Saving %d new %s questions for %s %s", len(questions), qType, language, level)
        if topic != "" </span><span class="cov2" title="3">{
                savingMsg = fmt.Sprintf("Saving %d new %s questions for %s %s (topic: %s)", len(questions), qType, language, level, topic)
        }</span>
        <span class="cov4" title="7">w.logger.Info(ctx, savingMsg, map[string]interface{}{
                "instance": w.instance,
        })
        w.updateActivity(savingMsg)
        w.logActivity(ctx, "INFO", savingMsg, &amp;user.ID, &amp;user.Username)
        savedCount := 0
        for _, q := range questions </span><span class="cov4" title="9">{
                // Populate variety fields from the variety elements used during generation
                if variety != nil </span><span class="cov4" title="7">{
                        q.TopicCategory = variety.TopicCategory
                        q.GrammarFocus = variety.GrammarFocus
                        q.VocabularyDomain = variety.VocabularyDomain
                        q.Scenario = variety.Scenario
                        q.StyleModifier = variety.StyleModifier
                        q.DifficultyModifier = variety.DifficultyModifier
                        q.TimeContext = variety.TimeContext
                }</span>
                <span class="cov4" title="9">if err := w.questionService.SaveQuestion(ctx, q); err != nil </span><span class="cov0" title="0">{
                        w.logger.Error(ctx, "Failed to save generated question", err, map[string]interface{}{
                                "instance":      w.instance,
                                "user_id":       user.ID,
                                "language":      language,
                                "level":         level,
                                "question_type": qType,
                        })
                }</span> else<span class="cov4" title="9"> {
                        // Assign the question to the user after saving
                        if err := w.questionService.AssignQuestionToUser(ctx, q.ID, user.ID); err != nil </span><span class="cov0" title="0">{
                                w.logger.Error(ctx, "Failed to assign question to user", err, map[string]interface{}{
                                        "instance":    w.instance,
                                        "question_id": q.ID,
                                        "user_id":     user.ID,
                                })
                        }</span> else<span class="cov4" title="9"> {
                                savedCount++
                        }</span>
                }
        }
        <span class="cov4" title="7">if savedCount &gt; 0 </span><span class="cov4" title="7">{
                successMsg := fmt.Sprintf("Successfully saved %d new '%s' questions for %s %s", savedCount, qType, language, level)
                if topic != "" </span><span class="cov2" title="3">{
                        successMsg = fmt.Sprintf("Successfully saved %d new '%s' questions for %s %s (topic: %s)", savedCount, qType, language, level, topic)
                }</span>
                <span class="cov4" title="7">w.logActivity(ctx, "INFO", successMsg, &amp;user.ID, &amp;user.Username)</span>
        }
        <span class="cov4" title="7">return savedCount</span>
}

func (w *Worker) updateActivity(activity string) <span class="cov6" title="23">{
        w.mu.Lock()
        defer w.mu.Unlock()
        w.status.CurrentActivity = activity
}</span>

// logActivity adds an activity log entry
func (w *Worker) logActivity(_ context.Context, level, message string, userID *int, username *string) <span class="cov10" title="247">{
        w.mu.Lock()
        defer w.mu.Unlock()

        logEntry := ActivityLog{
                Timestamp: time.Now(),
                Level:     level,
                Message:   message,
                UserID:    userID,
                Username:  username,
        }

        // Add to activity logs (circular buffer)
        w.activityLogs = append(w.activityLogs, logEntry)

        // Keep only the last maxActivityLogs entries
        if len(w.activityLogs) &gt; maxActivityLogs </span><span class="cov4" title="10">{
                w.activityLogs = w.activityLogs[len(w.activityLogs)-maxActivityLogs:]
        }</span>
}

// shouldRetryUser checks if enough time has passed since the last failure for exponential backoff
func (w *Worker) shouldRetryUser(userID int) bool <span class="cov4" title="7">{
        w.failureMu.RLock()
        defer w.failureMu.RUnlock()

        failure, exists := w.userFailures[userID]
        if !exists </span><span class="cov3" title="4">{
                return true // No previous failures, go ahead
        }</span>

        <span class="cov2" title="3">return time.Now().After(failure.NextRetryTime)</span>
}

// recordUserFailure records a failure and calculates the next retry time with exponential backoff
func (w *Worker) recordUserFailure(userID int, username string) <span class="cov4" title="11">{
        w.failureMu.Lock()
        defer w.failureMu.Unlock()

        failure, exists := w.userFailures[userID]
        if !exists </span><span class="cov4" title="7">{
                failure = &amp;UserFailureInfo{}
                w.userFailures[userID] = failure
        }</span>

        <span class="cov4" title="11">failure.ConsecutiveFailures++
        failure.LastFailureTime = time.Now()

        // Exponential backoff: 2^failures seconds, max 1 hour
        backoffSeconds := int(math.Pow(2, float64(failure.ConsecutiveFailures)))
        if backoffSeconds &gt; 3600 </span><span class="cov0" title="0">{
                backoffSeconds = 3600
        }</span>
        <span class="cov4" title="11">failure.NextRetryTime = time.Now().Add(time.Duration(backoffSeconds) * time.Second)

        w.logger.Info(w.shutdownCtx, "Worker recorded user failure", map[string]interface{}{
                "instance":           w.instance,
                "username":           username,
                "failure_count":      failure.ConsecutiveFailures,
                "next_retry_seconds": backoffSeconds,
        })</span>
}

// recordUserSuccess clears the failure count for a user
func (w *Worker) recordUserSuccess(userID int, username string) <span class="cov3" title="5">{
        w.failureMu.Lock()
        defer w.failureMu.Unlock()

        failure, exists := w.userFailures[userID]
        if exists &amp;&amp; failure.ConsecutiveFailures &gt; 0 </span><span class="cov1" title="1">{
                w.logger.Info(w.shutdownCtx, "Worker user success after failures, resetting backoff", map[string]interface{}{
                        "instance":          w.instance,
                        "username":          username,
                        "previous_failures": failure.ConsecutiveFailures,
                })
                delete(w.userFailures, userID)
        }</span>
}

// formatBatchLogMessage creates a formatted log message for batch question generation
func formatBatchLogMessage(username string, count int, qType, language, level string, variety *services.VarietyElements, provider, model string) string <span class="cov4" title="7">{
        var summaryFields []string
        if variety != nil </span><span class="cov3" title="5">{
                if variety.GrammarFocus != "" </span><span class="cov2" title="2">{
                        summaryFields = append(summaryFields, "grammar: "+variety.GrammarFocus)
                }</span>
                <span class="cov3" title="5">if variety.TopicCategory != "" </span><span class="cov2" title="2">{
                        summaryFields = append(summaryFields, "topic: "+variety.TopicCategory)
                }</span>
                <span class="cov3" title="5">if variety.Scenario != "" </span><span class="cov1" title="1">{
                        summaryFields = append(summaryFields, "scenario: "+variety.Scenario)
                }</span>
                <span class="cov3" title="5">if variety.StyleModifier != "" </span><span class="cov2" title="3">{
                        summaryFields = append(summaryFields, "style: "+variety.StyleModifier)
                }</span>
                <span class="cov3" title="5">if variety.DifficultyModifier != "" </span><span class="cov1" title="1">{
                        summaryFields = append(summaryFields, "difficulty: "+variety.DifficultyModifier)
                }</span>
                <span class="cov3" title="5">if variety.VocabularyDomain != "" </span><span class="cov2" title="3">{
                        summaryFields = append(summaryFields, "vocab: "+variety.VocabularyDomain)
                }</span>
                <span class="cov3" title="5">if variety.TimeContext != "" </span><span class="cov1" title="1">{
                        summaryFields = append(summaryFields, "time: "+variety.TimeContext)
                }</span>
        }
        <span class="cov4" title="7">providerModel := "provider: " + provider + ", model: " + model
        if len(summaryFields) &gt; 0 </span><span class="cov3" title="5">{
                summaryFields = append(summaryFields, providerModel)
        }</span> else<span class="cov1" title="1"> {
                summaryFields = []string{providerModel}
        }</span>
        <span class="cov4" title="7">return fmt.Sprintf("Worker [user=%s]: Batch %d %s questions (lang: %s, level: %s) | %s", username, count, qType, language, level, strings.Join(summaryFields, " | "))</span>
}

// PriorityGenerationData contains priority information to guide AI question generation
type PriorityGenerationData struct {
        UserWeakAreas        []string                        `json:"user_weak_areas,omitempty"`
        HighPriorityTopics   []string                        `json:"high_priority_topics,omitempty"`
        GapAnalysis          map[string]int                  `json:"gap_analysis,omitempty"`
        UserPreferences      *models.UserLearningPreferences `json:"user_preferences,omitempty"`
        PriorityDistribution map[string]int                  `json:"priority_distribution,omitempty"`
        FocusOnWeakAreas     bool                            `json:"focus_on_weak_areas"`
        FreshQuestionRatio   float64                         `json:"fresh_question_ratio"`
}

// PriorityGenerationLog contains structured data about priority-aware generation decisions
type PriorityGenerationLog struct {
        UserID              int                       `json:"user_id"`
        Username            string                    `json:"username"`
        Language            string                    `json:"language"`
        Level               string                    `json:"level"`
        QuestionType        string                    `json:"question_type"`
        FocusOnWeakAreas    bool                      `json:"focus_on_weak_areas"`
        UserWeakAreas       []string                  `json:"user_weak_areas,omitempty"`
        HighPriorityTopics  []string                  `json:"high_priority_topics,omitempty"`
        GapAnalysis         map[string]int            `json:"gap_analysis,omitempty"`
        FreshQuestionRatio  float64                   `json:"fresh_question_ratio"`
        SelectedVariety     *services.VarietyElements `json:"selected_variety"`
        GenerationReasoning string                    `json:"generation_reasoning"`
        Timestamp           time.Time                 `json:"timestamp"`
}

// logPriorityGeneration logs priority generation data as JSON
func (w *Worker) logPriorityGeneration(priorityLog PriorityGenerationLog) <span class="cov1" title="1">{
        logJSON, err := json.Marshal(priorityLog)
        if err != nil </span><span class="cov0" title="0">{
                w.logger.Error(w.shutdownCtx, "Failed to marshal priority generation log", err, map[string]interface{}{
                        "instance": w.instance,
                })
                return
        }</span>
        <span class="cov1" title="1">w.logger.Info(w.shutdownCtx, "Worker priority generation", map[string]interface{}{
                "instance": w.instance,
                "data":     string(logJSON),
        })</span>
}

// getGenerationReasoning provides a human-readable explanation of the generation strategy
func (w *Worker) getGenerationReasoning(priorityData *PriorityGenerationData, variety *services.VarietyElements) string <span class="cov5" title="17">{
        if priorityData == nil </span><span class="cov1" title="1">{
                return "standard generation"
        }</span>
        <span class="cov5" title="15">var reasons []string

        if priorityData.FocusOnWeakAreas &amp;&amp; len(priorityData.UserWeakAreas) &gt; 0 </span><span class="cov2" title="2">{
                reasons = append(reasons, fmt.Sprintf("focusing on weak areas: %s", strings.Join(priorityData.UserWeakAreas, ", ")))
        }</span>

        <span class="cov5" title="15">if len(priorityData.HighPriorityTopics) &gt; 0 </span><span class="cov2" title="2">{
                reasons = append(reasons, fmt.Sprintf("high priority topics: %s", strings.Join(priorityData.HighPriorityTopics, ", ")))
        }</span>

        <span class="cov5" title="15">if len(priorityData.GapAnalysis) &gt; 0 </span><span class="cov2" title="2">{
                var gaps []string
                for topic, count := range priorityData.GapAnalysis </span><span class="cov2" title="2">{
                        gaps = append(gaps, fmt.Sprintf("%s(%d)", topic, count))
                }</span>
                <span class="cov2" title="2">reasons = append(reasons, fmt.Sprintf("gap analysis: %s", strings.Join(gaps, ", ")))</span>
        }

        <span class="cov5" title="15">if priorityData.FreshQuestionRatio &gt; 0 </span><span class="cov4" title="9">{
                reasons = append(reasons, fmt.Sprintf("fresh ratio: %.1f%%", priorityData.FreshQuestionRatio*100))
        }</span>

        <span class="cov5" title="15">if variety != nil </span><span class="cov1" title="1">{
                var varietyElements []string
                if variety.TopicCategory != "" </span><span class="cov0" title="0">{
                        varietyElements = append(varietyElements, fmt.Sprintf("topic:%s", variety.TopicCategory))
                }</span>
                <span class="cov1" title="1">if variety.GrammarFocus != "" </span><span class="cov0" title="0">{
                        varietyElements = append(varietyElements, fmt.Sprintf("grammar:%s", variety.GrammarFocus))
                }</span>
                <span class="cov1" title="1">if variety.VocabularyDomain != "" </span><span class="cov1" title="1">{
                        varietyElements = append(varietyElements, fmt.Sprintf("vocab:%s", variety.VocabularyDomain))
                }</span>
                <span class="cov1" title="1">if variety.Scenario != "" </span><span class="cov0" title="0">{
                        varietyElements = append(varietyElements, fmt.Sprintf("scenario:%s", variety.Scenario))
                }</span>
                <span class="cov1" title="1">if len(varietyElements) &gt; 0 </span><span class="cov1" title="1">{
                        reasons = append(reasons, fmt.Sprintf("variety: %s", strings.Join(varietyElements, ", ")))
                }</span>
        }

        <span class="cov5" title="15">if len(reasons) == 0 </span><span class="cov0" title="0">{
                return "standard generation"
        }</span>

        <span class="cov5" title="15">return strings.Join(reasons, "; ")</span>
}

// getPriorityGenerationData gathers priority data for AI question generation
func (w *Worker) getPriorityGenerationData(ctx context.Context, userID int, language, level string, questionType models.QuestionType) *PriorityGenerationData <span class="cov1" title="1">{
        // Get user preferences
        prefs, err := w.learningService.GetUserLearningPreferences(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                w.logger.Warn(ctx, "Worker failed to get user preferences", map[string]interface{}{
                        "instance": w.instance,
                        "user_id":  userID,
                        "error":    err.Error(),
                })
                prefs = w.getDefaultLearningPreferences()
        }</span>

        // Get weak areas
        <span class="cov1" title="1">weakAreas, err := w.learningService.GetUserWeakAreas(ctx, userID, 5)
        if err != nil </span><span class="cov0" title="0">{
                w.logger.Warn(ctx, "Worker failed to get weak areas", map[string]interface{}{
                        "instance": w.instance,
                        "user_id":  userID,
                        "error":    err.Error(),
                })
                weakAreas = []map[string]interface{}{}
        }</span>

        // Convert weak areas to topic strings
        <span class="cov1" title="1">var weakAreaTopics []string
        for _, area := range weakAreas </span><span class="cov0" title="0">{
                if topic, ok := area["topic"].(string); ok &amp;&amp; topic != "" </span><span class="cov0" title="0">{
                        weakAreaTopics = append(weakAreaTopics, topic)
                }</span>
        }

        // Get high priority topics
        <span class="cov1" title="1">highPriorityTopics, err := w.getHighPriorityTopics(ctx, userID, language, level, questionType)
        if err != nil </span><span class="cov0" title="0">{
                w.logger.Warn(ctx, "Worker failed to get high priority topics", map[string]interface{}{
                        "instance": w.instance,
                        "user_id":  userID,
                        "error":    err.Error(),
                })
                highPriorityTopics = []string{}
        }</span>

        // Get gap analysis
        <span class="cov1" title="1">gapAnalysis, err := w.getGapAnalysis(ctx, userID, language, level, questionType)
        if err != nil </span><span class="cov0" title="0">{
                w.logger.Warn(ctx, "Worker failed to get gap analysis", map[string]interface{}{
                        "instance": w.instance,
                        "user_id":  userID,
                        "error":    err.Error(),
                })
                gapAnalysis = map[string]int{}
        }</span>

        // Get priority distribution
        <span class="cov1" title="1">priorityDistribution, err := w.getPriorityDistribution(ctx, userID, language, level, questionType)
        if err != nil </span><span class="cov0" title="0">{
                w.logger.Warn(ctx, "Worker failed to get priority distribution", map[string]interface{}{
                        "instance": w.instance,
                        "user_id":  userID,
                        "error":    err.Error(),
                })
                priorityDistribution = map[string]int{}
        }</span>

        // Determine if we should focus on weak areas
        <span class="cov1" title="1">focusOnWeakAreas := len(weakAreaTopics) &gt; 0 &amp;&amp; prefs != nil &amp;&amp; prefs.FocusOnWeakAreas

        return &amp;PriorityGenerationData{
                UserWeakAreas:        weakAreaTopics,
                HighPriorityTopics:   highPriorityTopics,
                GapAnalysis:          gapAnalysis,
                UserPreferences:      prefs,
                PriorityDistribution: priorityDistribution,
                FocusOnWeakAreas:     focusOnWeakAreas,
                FreshQuestionRatio:   prefs.FreshQuestionRatio,
        }</span>
}

// getDefaultLearningPreferences returns default learning preferences
func (w *Worker) getDefaultLearningPreferences() *models.UserLearningPreferences <span class="cov0" title="0">{
        return &amp;models.UserLearningPreferences{
                FocusOnWeakAreas:   false,
                FreshQuestionRatio: 0.3,
                WeakAreaBoost:      1.5,
        }
}</span>

// getHighPriorityTopics returns topics that have high average priority scores
func (w *Worker) getHighPriorityTopics(ctx context.Context, userID int, language, level string, questionType models.QuestionType) (result0 []string, err error) <span class="cov5" title="20">{
        return w.workerService.GetHighPriorityTopics(ctx, userID, language, level, string(questionType))
}</span>

// getGapAnalysis identifies areas with insufficient questions available
func (w *Worker) getGapAnalysis(ctx context.Context, userID int, language, level string, questionType models.QuestionType) (result0 map[string]int, err error) <span class="cov6" title="23">{
        return w.workerService.GetGapAnalysis(ctx, userID, language, level, string(questionType))
}</span>

// getPriorityDistribution returns the distribution of priority scores
func (w *Worker) getPriorityDistribution(ctx context.Context, userID int, language, level string, questionType models.QuestionType) (result0 map[string]int, err error) <span class="cov5" title="20">{
        return w.workerService.GetPriorityDistribution(ctx, userID, language, level, string(questionType))
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
