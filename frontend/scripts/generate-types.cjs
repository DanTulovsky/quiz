#!/usr/bin/env node

const fs = require('fs');
const path = require('path');
const yaml = require('js-yaml');

/**
 * Generate TypeScript types from OpenAPI specification
 * This script reads swagger.yaml and generates corresponding TypeScript interfaces
 */

const SWAGGER_PATH = path.join(__dirname, '../../swagger.yaml');
const OUTPUT_PATH = path.join(__dirname, '../src/types/api.ts');

// Read and parse the OpenAPI spec
function readSwaggerSpec() {
  try {
    const fileContents = fs.readFileSync(SWAGGER_PATH, 'utf8');
    return yaml.load(fileContents);
  } catch (error) {
    console.error('Error reading swagger.yaml:', error.message);
    process.exit(1);
  }
}

// Convert OpenAPI type to TypeScript type
function convertType(schema) {
  if (!schema) return 'any';

  if (schema.$ref) {
    const refName = schema.$ref.split('/').pop();
    return refName;
  }

  switch (schema.type) {
    case 'string':
      if (schema.enum) {
        return schema.enum.map(val => `'${val}'`).join(' | ');
      }
      return 'string';
    case 'number':
    case 'integer':
      return 'number';
    case 'boolean':
      return 'boolean';
    case 'array':
      return `Array<${convertType(schema.items)}>`;
    case 'object':
      if (schema.additionalProperties) {
        const valueType = convertType(schema.additionalProperties);
        return `Record<string, ${valueType}>`;
      }
      if (schema.properties) {
        return generateInterface(schema);
      }
      return 'Record<string, any>';
    default:
      return 'any';
  }
}

// Generate TypeScript interface from schema
function generateInterface(schema, interfaceName = '') {
  if (!schema.properties) return '{}';

  const properties = Object.entries(schema.properties).map(([propName, propSchema]) => {
    const isRequired = schema.required && schema.required.includes(propName);
    const optional = isRequired ? '' : '?';
    const type = convertType(propSchema);
    const nullable = propSchema.nullable ? ' | null' : '';

    return `  ${propName}${optional}: ${type}${nullable};`;
  });

  return interfaceName ?
    `{\n${properties.join('\n')}\n}` :
    properties.join('\n');
}

// Generate all TypeScript interfaces
function generateTypeScript(spec) {
  const schemas = spec.components?.schemas || {};

  let output = `// Auto-generated TypeScript types from OpenAPI specification
// Do not edit this file manually - run 'task generate-types' instead

`;

  // Generate interfaces for all schemas
  Object.entries(schemas).forEach(([name, schema]) => {
    if (schema.type === 'object') {
      output += `export interface ${name} ${generateInterface(schema, name)}\n\n`;
    } else if (schema.enum) {
      // Generate union types for enums
      const unionType = schema.enum.map(val => `'${val}'`).join(' | ');
      output += `export type ${name} = ${unionType};\n\n`;
    }
  });

  // Add some utility types based on the API
  output += `// Utility types
export type ApiResponse<T> = {
  data: T;
  status: number;
  message?: string;
};

export type ApiError = {
  error: string;
  details?: string;
  status: number;
};

// API endpoint response types
export type QuestionResponse = Question;
export type LoginResponseData = LoginResponse;
export type ProgressResponseData = UserProgress;
export type SettingsResponseData = SuccessResponse;

// API request types
export type LoginRequestData = LoginRequest;
export type AnswerRequestData = AnswerRequest;
export type SettingsRequestData = UserSettings;
export type TestAIRequestData = TestAIRequest;
`;

  return output;
}

// Main execution
function main() {
  console.log('üîÑ Generating TypeScript types from OpenAPI specification...');

  const spec = readSwaggerSpec();
  const typeScript = generateTypeScript(spec);

  // Ensure output directory exists
  const outputDir = path.dirname(OUTPUT_PATH);
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }

  // Write the generated types
  fs.writeFileSync(OUTPUT_PATH, typeScript);

  console.log('‚úÖ TypeScript types generated successfully!');
  console.log(`üìÅ Output: ${OUTPUT_PATH}`);
  console.log(`üìä Generated ${Object.keys(spec.components?.schemas || {}).length} type definitions`);
}

if (require.main === module) {
  main();
}

module.exports = { generateTypeScript, convertType };

