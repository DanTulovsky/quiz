/**
 * Generated by orval v7.10.0 üç∫
 * Do not edit manually.
 * Quiz Application API
 * API specification for the AI-powered adaptive language learning quiz application. All `date-time` fields in this specification use RFC3339 timestamps and include timezone offsets (e.g., `2025-08-15T16:33:19Z` or `2025-08-15T12:33:19-04:00`). Servers MUST return timestamps with offsets and clients MUST parse them respecting the offset.
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import {
  faker
} from '@faker-js/faker';

import {
  HttpResponse,
  delay,
  http
} from 'msw';

import { customInstance } from './axios';
export interface CreateConversationRequest {
  /**
   * Title for the conversation
   * @minLength 1
   * @maxLength 255
   */
  title: string;
}

export interface UpdateConversationRequest {
  /**
   * New title for the conversation
   * @minLength 1
   * @maxLength 255
   */
  title: string;
}

/**
 * Role of the message sender
 */
export type CreateMessageRequestRole = typeof CreateMessageRequestRole[keyof typeof CreateMessageRequestRole];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreateMessageRequestRole = {
  user: 'user',
  assistant: 'assistant',
} as const;

/**
 * Message content
 */
export type CreateMessageRequestContent = {
  /** The actual message text */
  text?: string;
};

export interface CreateMessageRequest {
  /** Role of the message sender */
  role: CreateMessageRequestRole;
  /** Message content */
  content: CreateMessageRequestContent;
  /** Optional question ID if this message relates to a specific question */
  question_id?: number;
}

export interface Conversation {
  /** Conversation UUID */
  id: string;
  /** ID of the user who owns this conversation */
  user_id: number;
  /** Conversation title */
  title: string;
  /** When the conversation was created */
  created_at: string;
  /** When the conversation was last updated */
  updated_at: string;
  /** Total number of messages in this conversation */
  message_count?: number;
  /** Array of messages in this conversation (optional, only included when requested) */
  messages?: ChatMessage[];
}

/**
 * Role of the message sender
 */
export type ChatMessageRole = typeof ChatMessageRole[keyof typeof ChatMessageRole];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ChatMessageRole = {
  user: 'user',
  assistant: 'assistant',
} as const;

/**
 * Message content
 */
export type ChatMessageContent = {
  /** The actual message text */
  text?: string;
};

export interface ChatMessage {
  /** Message UUID */
  id: string;
  /** ID of the conversation this message belongs to */
  conversation_id: string;
  /** Optional question ID if this message relates to a specific question */
  question_id?: number;
  /** Role of the message sender */
  role: ChatMessageRole;
  /** Message content */
  content: ChatMessageContent;
  /** Whether this message is bookmarked */
  bookmarked?: boolean;
  /** When the message was created */
  created_at: string;
  /** When the message was last updated */
  updated_at: string;
  /** Title of the conversation (optional, included in search results) */
  conversation_title?: string;
}

export interface LoginRequest {
  /**
   * Username (1-100 characters, alphanumeric + underscore + email characters, cannot be empty or whitespace-only)
   * @minLength 1
   * @maxLength 100
   * @pattern ^[a-zA-Z0-9_@.+-]+$
   */
  username: string;
  /**
   * Password (minimum 8 characters)
   * @minLength 8
   * @maxLength 128
   */
  password: string;
}

export interface LoginResponse {
  success?: boolean;
  message?: string;
  user?: User;
  /** Redirect URI for OAuth flows (optional) */
  redirect_uri?: string;
}

export interface AuthStatusResponse {
  /** Whether the user is currently authenticated */
  authenticated: boolean;
  /**
   * User object if authenticated, null otherwise
   * @nullable
   */
  user: User;
}

export interface User {
  id?: number;
  /**
   * Username (1-100 characters, alphanumeric + underscore + email characters, cannot be empty or whitespace-only)
   * @maxLength 100
   * @pattern ^[a-zA-Z0-9_@.+-]+$
   */
  username?: string;
  /** @nullable */
  email?: string | null;
  /** @nullable */
  timezone?: string | null;
  /** @nullable */
  preferred_language?: string | null;
  /** @nullable */
  current_level?: string | null;
  /** @nullable */
  ai_provider?: string | null;
  /** @nullable */
  ai_model?: string | null;
  /**
   * Whether AI features are enabled for this user
   * @nullable
   */
  ai_enabled?: boolean | null;
  /** Whether the user is paused (question generation disabled) */
  is_paused?: boolean;
  /** Whether the user has a valid API key saved for their current AI provider */
  has_api_key?: boolean;
  created_at?: string;
  /** @nullable */
  last_active?: string | null;
  /**
   * List of roles assigned to the user
   * @maxItems 20
   */
  roles?: Role[];
}

export interface Question {
  id?: number;
  language?: Language;
  level?: Level;
  type?: QuestionType;
  status?: QuestionStatus;
  difficulty_score?: number;
  explanation?: string;
  /** All question types now use multiple choice format with 4 options */
  content?: QuestionContent;
  created_at?: string;
  /** Number of times this question was answered correctly */
  correct_count?: number;
  /** Number of times this question was answered incorrectly */
  incorrect_count?: number;
  /** Total number of responses to this question (used for 'Shown' in the UI) */
  total_responses?: number;
  /** Number of users assigned to this question */
  user_count?: number;
  /** Index of the correct answer in the options array (0-based) */
  correct_answer?: number;
  /** Comma-separated list of usernames who reported this question */
  reporters?: string;
  /** General topic category for question context (e.g., daily_life, travel, work) */
  topic_category?: string;
  /** Grammar focus area for the question (e.g., present_perfect, conditionals) */
  grammar_focus?: string;
  /** Vocabulary domain for the question (e.g., food_and_dining, transportation) */
  vocabulary_domain?: string;
  /** Scenario context for the question (e.g., at_the_airport, in_a_restaurant) */
  scenario?: string;
  /** Style modifier for the question (e.g., conversational, formal) */
  style_modifier?: string;
  /** Difficulty modifier for the question (e.g., basic, intermediate) */
  difficulty_modifier?: string;
  /** Time context for the question (e.g., morning_routine, workday) */
  time_context?: string;
  /**
   * Confidence level when question was marked as known (1-5)
   * @minimum 1
   * @maximum 5
   */
  confidence_level?: number;
}

/**
 * All question types now use multiple choice format with 4 options
 */
export interface QuestionContent {
  /**
   * @minLength 1
   * @maxLength 1000
   */
  question: string;
  /**
   * @minItems 4
   * @maxItems 10
   */
  options: string[];
  /**
   * Only present for vocabulary questions (context sentence)
   * @maxLength 2000
   */
  sentence?: string;
  /**
   * Only present for reading comprehension questions
   * @maxLength 5000
   */
  passage?: string;
  /**
   * Optional hint for fill-in-blank questions
   * @maxLength 500
   */
  hint?: string;
}

export interface AnswerRequest {
  /**
   * ID of the question being answered
   * @minimum 1
   */
  question_id: number;
  /**
   * Index of the user's selected answer in the original options array (0-based)
   * @minimum 0
   * @maximum 3
   */
  user_answer_index: number;
  /**
   * Response time in milliseconds (0-5 minutes)
   * @minimum 0
   * @maximum 300000
   */
  response_time_ms?: number;
}

export interface AnswerResponse {
  is_correct?: boolean;
  /** The answer selected by the user */
  user_answer?: string;
  /** Index of the user's selected answer in the original options array (0-based) */
  user_answer_index?: number;
  explanation?: string;
  next_difficulty?: string;
  /** Index of the correct answer in the options array (0-based) */
  correct_answer_index?: number;
}

export type UserProgressPerformanceByTopic = {[key: string]: PerformanceMetrics};

/**
 * Analysis of learning gaps and areas needing attention
 */
export type UserProgressGapAnalysis = { [key: string]: unknown };

/**
 * Distribution of question priorities (high, medium, low counts)
 */
export type UserProgressPriorityDistribution = {[key: string]: number};

export interface UserProgress {
  current_level?: Level;
  suggested_level?: Level;
  /**
   * @minimum 0
   * @maximum 1
   */
  accuracy_rate?: number;
  /** @minimum 0 */
  total_questions?: number;
  /** @minimum 0 */
  correct_answers?: number;
  performance_by_topic?: UserProgressPerformanceByTopic;
  /** @maxItems 50 */
  weak_areas?: string[];
  /** @maxItems 100 */
  recent_activity?: UserResponse[];
  worker_status?: WorkerStatus;
  learning_preferences?: UserLearningPreferences;
  priority_insights?: PriorityInsights;
  generation_focus?: GenerationFocus;
  /**
   * Topics that have high priority scores for the user
   * @maxItems 20
   */
  high_priority_topics?: string[];
  /** Analysis of learning gaps and areas needing attention */
  gap_analysis?: UserProgressGapAnalysis;
  /** Distribution of question priorities (high, medium, low counts) */
  priority_distribution?: UserProgressPriorityDistribution;
}

export interface PerformanceMetrics {
  /** @minimum 0 */
  correct_attempts?: number;
  /** @minimum 0 */
  total_attempts?: number;
  /** @minimum 0 */
  average_response_time_ms?: number;
  last_updated?: string;
}

export interface UserResponse {
  /** @minimum 1 */
  question_id?: number;
  is_correct?: boolean;
  created_at?: string;
}

export type UserSettings = (unknown & {
  language?: Language;
  level?: Level;
  /**
   * @maxLength 50
   * @pattern ^[a-zA-Z0-9_.-]*$
   */
  ai_provider?: string;
  /**
   * @maxLength 50
   * @pattern ^[a-zA-Z0-9_.:-]*$
   */
  ai_model?: string;
  /** Whether AI features are enabled for this user */
  ai_enabled?: boolean;
  /**
   * API key for AI provider (write-only)
   * @maxLength 1000
   */
  api_key?: string;
}) | (unknown & {
  language?: Language;
  level?: Level;
  /**
   * @maxLength 50
   * @pattern ^[a-zA-Z0-9_.-]*$
   */
  ai_provider?: string;
  /**
   * @maxLength 50
   * @pattern ^[a-zA-Z0-9_.:-]*$
   */
  ai_model?: string;
  /** Whether AI features are enabled for this user */
  ai_enabled?: boolean;
  /**
   * API key for AI provider (write-only)
   * @maxLength 1000
   */
  api_key?: string;
});

export interface TestAIRequest {
  /**
   * AI provider code (e.g., "ollama", "openai")
   * @maxLength 50
   * @pattern ^[a-zA-Z0-9_.-]+$
   */
  provider: string;
  /**
   * AI model code (e.g., "llama3", "gpt-4")
   * @maxLength 50
   * @pattern ^[a-zA-Z0-9_.:-]+$
   */
  model: string;
  /**
   * API key for the provider. If not provided, the server will try to use a saved key.
   * @maxLength 1000
   * @nullable
   */
  api_key?: string | null;
}

export interface SuccessResponse {
  success: boolean;
  /** @maxLength 500 */
  message?: string;
}

export interface DailyQuestionWithDetails {
  /** Daily question assignment ID */
  id: number;
  /** User ID */
  user_id: number;
  /** Question ID */
  question_id: number;
  /** Date-only assignment (YYYY-MM-DD) representing the logical calendar day the question was assigned (no timezone offset) */
  assignment_date: string;
  /** Whether the question has been completed */
  is_completed: boolean;
  /**
   * When the question was completed (if completed)
   * @nullable
   */
  completed_at?: string | null;
  /** When the assignment was created */
  created_at: string;
  /**
   * The index of the answer option the user selected (0-based)
   * @nullable
   */
  user_answer_index?: number | null;
  /**
   * When the user submitted their answer
   * @nullable
   */
  submitted_at?: string | null;
  /** Number of times this question was shown to this user in Daily view */
  user_shown_count?: number;
  /** Number of times this user answered this question */
  user_total_responses?: number;
  /** Number of times this user answered this question correctly */
  user_correct_count?: number;
  /** Number of times this user answered this question incorrectly */
  user_incorrect_count?: number;
  /** Full question details */
  question: Question;
}

export interface DailyProgress {
  /** Date for the progress report (YYYY-MM-DD) */
  date: string;
  /** Number of completed questions */
  completed: number;
  /** Total number of questions assigned for the date */
  total: number;
}

/**
 * Severity level of the error
 */
export type ErrorResponseSeverity = typeof ErrorResponseSeverity[keyof typeof ErrorResponseSeverity];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ErrorResponseSeverity = {
  info: 'info',
  warn: 'warn',
  error: 'error',
  fatal: 'fatal',
} as const;

export interface ErrorResponse {
  /** Error code identifying the type of error */
  code?: string;
  /** Human-readable error message */
  message?: string;
  /**
   * Error message (for backward compatibility)
   * @maxLength 500
   */
  error?: string;
  /**
   * Additional error details
   * @maxLength 1000
   */
  details?: string;
  /** Whether the operation can be retried */
  retryable?: boolean;
  /** Severity level of the error */
  severity?: ErrorResponseSeverity;
}

export interface SignupStatusResponse {
  /** Whether user signups are currently disabled */
  signups_disabled: boolean;
}

export interface ReportQuestionRequest {
  /**
   * Optional explanation for why the question is being reported
   * @maxLength 512
   */
  report_reason?: string;
}

export interface MarkQuestionKnownRequest {
  /**
   * User's confidence level (1-5, optional)
   * @minimum 1
   * @maximum 5
   */
  confidence_level?: number;
}

export interface GeneratingResponse {
  /** @maxLength 100 */
  status?: string;
  /** @maxLength 500 */
  message?: string;
  /** User's preferred AI model */
  ai_model?: string;
  /** User's API key for the selected provider (write-only) */
  api_key?: string;
}

export type AIProvidersProvidersItemModelsItem = {
  /** @maxLength 100 */
  name?: string;
  /**
   * @maxLength 50
   * @pattern ^[a-zA-Z0-9_.:-]+$
   */
  code?: string;
};

export type AIProvidersProvidersItem = {
  /** @maxLength 100 */
  name?: string;
  /**
   * @maxLength 50
   * @pattern ^[a-zA-Z0-9_.-]+$
   */
  code?: string;
  /** @maxLength 500 */
  url?: string;
  /** @maxItems 100 */
  models?: AIProvidersProvidersItemModelsItem[];
};

export interface AIProviders {
  /** @maxItems 50 */
  providers?: AIProvidersProvidersItem[];
  /** @maxItems 20 */
  levels?: string[];
}

/**
 * Learning language (dynamic). Allowed values come from config.yaml language_levels keys.
 */
export type Language = string;

/**
 * Proficiency level (dynamic). Allowed values depend on the selected language and are sourced from config.yaml (e.g., CEFR A1‚ÄìC2, JLPT N5‚ÄìN1, HSK1‚ÄìHSK6).
 */
export type Level = string;

export type QuestionType = typeof QuestionType[keyof typeof QuestionType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const QuestionType = {
  vocabulary: 'vocabulary',
  fill_blank: 'fill_blank',
  reading_comprehension: 'reading_comprehension',
  qa: 'qa',
} as const;

export type QuestionStatus = typeof QuestionStatus[keyof typeof QuestionStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const QuestionStatus = {
  active: 'active',
  reported: 'reported',
} as const;

export interface QuizChatRequest {
  /**
   * The user's message to the AI tutor.
   * @minLength 1
   * @maxLength 2000
   */
  user_message: string;
  question: Question;
  /** Context about the user's submitted answer. Omit if the user has not answered yet. */
  answer_context?: AnswerResponse;
  /**
   * Previous messages in the conversation
   * @maxItems 50
   */
  conversation_history?: ChatMessage[];
}

export interface QuizChatResponse {
  /** The response from the AI tutor. */
  ai_response?: string;
}

export interface UserProfile {
  id?: number;
  /**
   * Username (1-100 characters, alphanumeric + underscore + email characters, cannot be empty or whitespace-only)
   * @maxLength 100
   * @pattern ^[a-zA-Z0-9_@.+-]+$
   */
  username?: string;
  /** @nullable */
  email?: string | null;
  /** @nullable */
  timezone?: string | null;
  /** @nullable */
  last_active?: string | null;
  /** @nullable */
  preferred_language?: string | null;
  current_level?: string;
  /**
   * Whether AI features are enabled for this user
   * @nullable
   */
  ai_enabled?: boolean | null;
  /** Whether the user is paused (question generation disabled) */
  is_paused?: boolean;
  created_at?: string;
  updated_at?: string;
}

export interface UserCreateRequest {
  /**
   * Username (1-100 characters, alphanumeric + underscore + email characters, cannot be empty or whitespace-only)
   * @minLength 1
   * @maxLength 100
   * @pattern ^[a-zA-Z0-9_@.+-]+$
   */
  username: string;
  /**
   * Email address
   * @maxLength 255
   */
  email?: string;
  /**
   * Timezone (e.g., "UTC", "America/New_York")
   * @maxLength 100
   */
  timezone?: string;
  /**
   * Password (minimum 8 characters)
   * @minLength 8
   * @maxLength 128
   */
  password: string;
  /**
   * Preferred learning language
   * @maxLength 50
   */
  preferred_language?: string;
  /**
   * Current proficiency level
   * @maxLength 10
   */
  current_level?: string;
  /** Whether AI features are enabled for this user */
  ai_enabled?: boolean;
}

export type UserUpdateRequest = (unknown & {
  /**
   * Username (1-100 characters, alphanumeric + underscore + email characters, cannot be empty or whitespace-only)
   * @minLength 1
   * @maxLength 100
   * @pattern ^[a-zA-Z0-9_@.+-]+$
   */
  username?: string;
  /**
   * Email address
   * @maxLength 255
   */
  email?: string;
  /**
   * Timezone (e.g., "UTC", "America/New_York")
   * @maxLength 100
   */
  timezone?: string;
  /**
   * Preferred learning language
   * @maxLength 50
   */
  preferred_language?: string;
  /**
   * Current proficiency level
   * @maxLength 10
   */
  current_level?: string;
  /** Whether AI features are enabled for this user */
  ai_enabled?: boolean;
  /**
   * AI provider code
   * @maxLength 50
   * @pattern ^[a-zA-Z0-9_.-]*$
   */
  ai_provider?: string;
  /**
   * AI model code
   * @maxLength 50
   * @pattern ^[a-zA-Z0-9_.:-]*$
   */
  ai_model?: string;
  /**
   * API key for AI provider (write-only)
   * @maxLength 1000
   */
  api_key?: string;
  /**
   * Array of role names to assign to the user
   * @maxItems 20
   */
  selectedRoles?: string[];
}) | (unknown & {
  /**
   * Username (1-100 characters, alphanumeric + underscore + email characters, cannot be empty or whitespace-only)
   * @minLength 1
   * @maxLength 100
   * @pattern ^[a-zA-Z0-9_@.+-]+$
   */
  username?: string;
  /**
   * Email address
   * @maxLength 255
   */
  email?: string;
  /**
   * Timezone (e.g., "UTC", "America/New_York")
   * @maxLength 100
   */
  timezone?: string;
  /**
   * Preferred learning language
   * @maxLength 50
   */
  preferred_language?: string;
  /**
   * Current proficiency level
   * @maxLength 10
   */
  current_level?: string;
  /** Whether AI features are enabled for this user */
  ai_enabled?: boolean;
  /**
   * AI provider code
   * @maxLength 50
   * @pattern ^[a-zA-Z0-9_.-]*$
   */
  ai_provider?: string;
  /**
   * AI model code
   * @maxLength 50
   * @pattern ^[a-zA-Z0-9_.:-]*$
   */
  ai_model?: string;
  /**
   * API key for AI provider (write-only)
   * @maxLength 1000
   */
  api_key?: string;
  /**
   * Array of role names to assign to the user
   * @maxItems 20
   */
  selectedRoles?: string[];
});

export interface PasswordResetRequest {
  /**
   * New password (minimum 8 characters)
   * @minLength 8
   * @maxLength 128
   */
  new_password: string;
}

export interface ServiceVersion {
  /**
   * Service name (e.g., 'backend', 'worker')
   * @maxLength 50
   */
  service: string;
  /**
   * Version string (e.g., git tag or 'dev')
   * @maxLength 100
   */
  version: string;
  /**
   * Git commit hash
   * @maxLength 50
   */
  commit: string;
  /**
   * Build timestamp (ISO8601)
   * @maxLength 100
   */
  buildTime: string;
}

export type AggregatedVersionWorkerOneOf = {
  /** Error message when worker is unavailable */
  error: string;
};

export type AggregatedVersionWorker = ServiceVersion | AggregatedVersionWorkerOneOf;

export interface AggregatedVersion {
  /** Backend service version information */
  backend: ServiceVersion;
  worker: AggregatedVersionWorker;
}

export interface Role {
  /** Role ID */
  id: number;
  /**
   * Role name (e.g., "user", "admin")
   * @maxLength 50
   */
  name: string;
  /**
   * Role description
   * @maxLength 500
   */
  description: string;
  /** When the role was created */
  created_at: string;
  /** When the role was last updated */
  updated_at: string;
}

export interface UserLearningPreferences {
  /** Whether to focus on weak areas */
  focus_on_weak_areas: boolean;
  /**
   * Ratio of fresh (never seen) questions to show (0-1)
   * @minimum 0
   * @maximum 1
   */
  fresh_question_ratio: number;
  /**
   * Penalty multiplier for questions marked as known (0-1)
   * @minimum 0
   * @maximum 1
   */
  known_question_penalty: number;
  /**
   * Days between reviews of known questions
   * @minimum 1
   * @maximum 60
   */
  review_interval_days: number;
  /**
   * Multiplier for weak area questions
   * @minimum 1
   * @maximum 5
   */
  weak_area_boost: number;
  /** Whether to receive daily reminder emails */
  daily_reminder_enabled: boolean;
  /** Preferred TTS voice (e.g., it-IT-IsabellaNeural) */
  tts_voice?: string;
  /**
   * User-configurable number of daily questions
   * @minimum 1
   */
  daily_goal?: number;
}

export interface DashboardUser {
  user?: UserProfile;
  progress?: UserProgress;
  question_stats?: UserQuestionStats;
}

export interface DashboardResponse {
  users?: DashboardUser[];
  question_stats?: QuestionStats;
  ai_concurrency_stats?: AIConcurrencyStats;
  worker_health?: WorkerHealth;
  worker_port?: string;
  worker_base_url?: string;
}

export type AIConcurrencyStatsUserActiveCount = {[key: string]: number};

export interface AIConcurrencyStats {
  active_requests?: number;
  max_concurrent?: number;
  queued_requests?: number;
  total_requests?: number;
  user_active_count?: AIConcurrencyStatsUserActiveCount;
  max_per_user?: number;
}

export type WorkerHealthWorkerInstancesItemLastHeartbeat = {
  Time?: string;
  Valid?: boolean;
};

export type WorkerHealthWorkerInstancesItem = {
  healthy?: boolean;
  is_paused?: boolean;
  is_running?: boolean;
  last_heartbeat?: WorkerHealthWorkerInstancesItemLastHeartbeat;
  total_questions_generated?: number;
  total_runs?: number;
  worker_instance?: string;
};

export interface WorkerHealth {
  global_paused?: boolean;
  healthy_count?: number;
  total_count?: number;
  worker_instances?: WorkerHealthWorkerInstancesItem[];
}

export type PriorityAnalyticsDistribution = {
  high?: number;
  medium?: number;
  low?: number;
  average?: number;
};

export interface PriorityAnalytics {
  distribution?: PriorityAnalyticsDistribution;
}

export type UserPerformanceAnalyticsWeakAreasItem = { [key: string]: unknown };

export type UserPerformanceAnalyticsLearningPreferences = { [key: string]: unknown };

export interface UserPerformanceAnalytics {
  weakAreas?: UserPerformanceAnalyticsWeakAreasItem[];
  learningPreferences?: UserPerformanceAnalyticsLearningPreferences;
}

export type GenerationIntelligenceGapAnalysisItem = { [key: string]: unknown };

export type GenerationIntelligenceGenerationSuggestionsItem = { [key: string]: unknown };

export interface GenerationIntelligence {
  gapAnalysis?: GenerationIntelligenceGapAnalysisItem[];
  generationSuggestions?: GenerationIntelligenceGenerationSuggestionsItem[];
}

export type SystemHealthAnalyticsPerformance = { [key: string]: unknown };

export type SystemHealthAnalyticsBackgroundJobs = { [key: string]: unknown };

export interface SystemHealthAnalytics {
  performance?: SystemHealthAnalyticsPerformance;
  backgroundJobs?: SystemHealthAnalyticsBackgroundJobs;
}

export type UserQuestionStatsAnsweredByType = {[key: string]: number};

export type UserQuestionStatsAnsweredByLevel = {[key: string]: number};

export type UserQuestionStatsAccuracyByType = {[key: string]: number};

export type UserQuestionStatsAccuracyByLevel = {[key: string]: number};

export type UserQuestionStatsAvailableByType = {[key: string]: number};

export type UserQuestionStatsAvailableByLevel = {[key: string]: number};

export interface UserQuestionStats {
  user_id?: number;
  /** @minimum 0 */
  total_answered?: number;
  answered_by_type?: UserQuestionStatsAnsweredByType;
  answered_by_level?: UserQuestionStatsAnsweredByLevel;
  accuracy_by_type?: UserQuestionStatsAccuracyByType;
  accuracy_by_level?: UserQuestionStatsAccuracyByLevel;
  available_by_type?: UserQuestionStatsAvailableByType;
  available_by_level?: UserQuestionStatsAvailableByLevel;
}

/**
 * Breakdown of questions by type
 */
export type QuestionStatsQuestionsByType = {[key: string]: number};

/**
 * Breakdown of questions by level
 */
export type QuestionStatsQuestionsByLevel = {[key: string]: number};

/**
 * Breakdown of questions by language
 */
export type QuestionStatsQuestionsByLanguage = {[key: string]: number};

export interface QuestionStats {
  /**
   * Total number of questions
   * @minimum 0
   */
  total_questions?: number;
  /**
   * Total number of responses
   * @minimum 0
   */
  total_responses?: number;
  /** Breakdown of questions by type */
  questions_by_type?: QuestionStatsQuestionsByType;
  /** Breakdown of questions by level */
  questions_by_level?: QuestionStatsQuestionsByLevel;
  /** Breakdown of questions by language */
  questions_by_language?: QuestionStatsQuestionsByLanguage;
}

/**
 * Breakdown of notifications by type
 */
export type NotificationStatsNotificationsByType = {[key: string]: number};

export interface NotificationStats {
  /**
   * Total number of notifications sent
   * @minimum 0
   */
  total_sent?: number;
  /**
   * Total number of notifications that failed
   * @minimum 0
   */
  total_failed?: number;
  /**
   * Success rate as a percentage (0-1)
   * @minimum 0
   * @maximum 1
   */
  success_rate?: number;
  /**
   * Number of notifications sent today
   * @minimum 0
   */
  sent_today?: number;
  /**
   * Number of notifications sent this week
   * @minimum 0
   */
  sent_this_week?: number;
  /** Breakdown of notifications by type */
  notifications_by_type?: NotificationStatsNotificationsByType;
}

/**
 * Breakdown of errors by type
 */
export type NotificationErrorStatsErrorsByType = {[key: string]: number};

/**
 * Breakdown of errors by notification type
 */
export type NotificationErrorStatsErrorsByNotificationType = {[key: string]: number};

export interface NotificationErrorStats {
  /**
   * Total number of errors
   * @minimum 0
   */
  total_errors?: number;
  /**
   * Number of unresolved errors
   * @minimum 0
   */
  unresolved_errors?: number;
  /** Breakdown of errors by type */
  errors_by_type?: NotificationErrorStatsErrorsByType;
  /** Breakdown of errors by notification type */
  errors_by_notification_type?: NotificationErrorStatsErrorsByNotificationType;
}

/**
 * Type of notification that failed
 */
export type NotificationErrorNotificationType = typeof NotificationErrorNotificationType[keyof typeof NotificationErrorNotificationType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const NotificationErrorNotificationType = {
  daily_reminder: 'daily_reminder',
  test_email: 'test_email',
} as const;

/**
 * Type of error that occurred
 */
export type NotificationErrorErrorType = typeof NotificationErrorErrorType[keyof typeof NotificationErrorErrorType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const NotificationErrorErrorType = {
  smtp_error: 'smtp_error',
  template_error: 'template_error',
  user_not_found: 'user_not_found',
  email_disabled: 'email_disabled',
  other: 'other',
} as const;

export interface NotificationError {
  id?: number;
  /** @nullable */
  user_id?: number | null;
  /** Username of the user (if available) */
  username?: string;
  /** Type of notification that failed */
  notification_type?: NotificationErrorNotificationType;
  /** Type of error that occurred */
  error_type?: NotificationErrorErrorType;
  /** Detailed error message */
  error_message?: string;
  /**
   * Email address that was being used
   * @nullable
   */
  email_address?: string | null;
  /** When the error occurred */
  occurred_at?: string;
  /**
   * When the error was resolved
   * @nullable
   */
  resolved_at?: string | null;
  /**
   * Notes about how the error was resolved
   * @nullable
   */
  resolution_notes?: string | null;
}

/**
 * Type of notification
 */
export type UpcomingNotificationNotificationType = typeof UpcomingNotificationNotificationType[keyof typeof UpcomingNotificationNotificationType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UpcomingNotificationNotificationType = {
  daily_reminder: 'daily_reminder',
  test_email: 'test_email',
} as const;

/**
 * Current status of the notification
 */
export type UpcomingNotificationStatus = typeof UpcomingNotificationStatus[keyof typeof UpcomingNotificationStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UpcomingNotificationStatus = {
  pending: 'pending',
  sent: 'sent',
  cancelled: 'cancelled',
} as const;

export interface UpcomingNotification {
  id?: number;
  user_id?: number;
  /** Username of the user */
  username?: string;
  /** Email address for the notification */
  email_address?: string;
  /** Type of notification */
  notification_type?: UpcomingNotificationNotificationType;
  /** When the notification is scheduled to be sent */
  scheduled_for?: string;
  /** Current status of the notification */
  status?: UpcomingNotificationStatus;
  /** When the notification was created */
  created_at?: string;
}

/**
 * Type of notification
 */
export type SentNotificationNotificationType = typeof SentNotificationNotificationType[keyof typeof SentNotificationNotificationType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SentNotificationNotificationType = {
  daily_reminder: 'daily_reminder',
  test_email: 'test_email',
} as const;

/**
 * Status of the notification
 */
export type SentNotificationStatus = typeof SentNotificationStatus[keyof typeof SentNotificationStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SentNotificationStatus = {
  sent: 'sent',
  failed: 'failed',
  bounced: 'bounced',
} as const;

export interface SentNotification {
  id?: number;
  user_id?: number;
  /** Username of the user */
  username?: string;
  /** Email address the notification was sent to */
  email_address?: string;
  /** Type of notification */
  notification_type?: SentNotificationNotificationType;
  /** Subject line of the email */
  subject?: string;
  /** Template used for the notification */
  template_name?: string;
  /** When the notification was sent */
  sent_at?: string;
  /** Status of the notification */
  status?: SentNotificationStatus;
  /**
   * Error message if the notification failed
   * @nullable
   */
  error_message?: string | null;
  /**
   * Number of times the notification was retried
   * @minimum 0
   */
  retry_count?: number;
}

export interface PaginationInfo {
  /**
   * Current page number
   * @minimum 1
   */
  page: number;
  /**
   * Number of items per page
   * @minimum 1
   * @maximum 100
   */
  page_size: number;
  /**
   * Total number of items
   * @minimum 0
   */
  total: number;
  /**
   * Total number of pages
   * @minimum 0
   */
  total_pages: number;
}

/**
 * Current status of the worker
 */
export type WorkerStatusStatus = typeof WorkerStatusStatus[keyof typeof WorkerStatusStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const WorkerStatusStatus = {
  idle: 'idle',
  busy: 'busy',
  error: 'error',
} as const;

export interface WorkerStatus {
  /** Current status of the worker */
  status?: WorkerStatusStatus;
  /** Timestamp of the last heartbeat from the worker */
  last_heartbeat?: string;
  /**
   * Error message if the worker is in an error state
   * @nullable
   */
  error_message?: string | null;
}

export interface WorkerStatusResponse {
  /** Whether the worker has encountered errors */
  has_errors: boolean;
  /** Error message if worker has errors */
  error_message: string;
  /** Whether the worker is globally paused */
  global_paused: boolean;
  /** Whether the user's question generation is paused */
  user_paused: boolean;
  /** Number of healthy worker instances */
  healthy_workers: number;
  /** Total number of worker instances */
  total_workers: number;
  /** Detailed error information if any */
  last_error_details: string;
  /** Whether the worker is currently running */
  worker_running: boolean;
}

/**
 * Mapping from level code to short label (e.g. Beginner, Intermediate)
 */
export type LevelsResponseLevelDescriptions = {[key: string]: string};

export interface LevelsResponse {
  /**
   * Array of available language proficiency levels
   * @maxItems 20
   */
  levels: string[];
  /** Mapping from level code to short label (e.g. Beginner, Intermediate) */
  level_descriptions: LevelsResponseLevelDescriptions;
}

/**
 * Array of available learning languages
 * @maxItems 20
 */
export type LanguagesResponse = string[];

export interface APIKeyAvailabilityResponse {
  /** Whether the user has a saved API key for this provider */
  has_api_key: boolean;
}

export interface GoogleOAuthLoginResponse {
  /** The Google OAuth authorization URL to redirect the user to */
  auth_url: string;
}

export interface PriorityInsights {
  /**
   * Total number of questions waiting to be processed
   * @minimum 0
   */
  total_questions_in_queue?: number;
  /**
   * Number of high-priority questions
   * @minimum 0
   */
  high_priority_questions?: number;
  /**
   * Number of medium-priority questions
   * @minimum 0
   */
  medium_priority_questions?: number;
  /**
   * Number of low-priority questions
   * @minimum 0
   */
  low_priority_questions?: number;
}

export interface GenerationFocus {
  /** The AI model currently being used for generation */
  current_generation_model?: string;
  /** Timestamp of the last time a question was generated */
  last_generation_time?: string;
  /**
   * Average number of questions generated per minute
   * @minimum 0
   */
  generation_rate?: number;
}

export interface UserNullable {
  id?: number;
  /**
   * Username (1-100 characters, alphanumeric + underscore + email characters, cannot be empty or whitespace-only)
   * @maxLength 100
   * @pattern ^[a-zA-Z0-9_@.+-]+$
   */
  username?: string;
  /** @nullable */
  email?: string | null;
  /** @nullable */
  timezone?: string | null;
  /** @nullable */
  preferred_language?: string | null;
  /** @nullable */
  current_level?: string | null;
  /** @nullable */
  ai_provider?: string | null;
  /** @nullable */
  ai_model?: string | null;
  /**
   * Whether AI features are enabled for this user
   * @nullable
   */
  ai_enabled?: boolean | null;
  /** Whether the user is paused (question generation disabled) */
  is_paused?: boolean;
  /** Whether the user has a valid API key saved for their current AI provider */
  has_api_key?: boolean;
  created_at?: string;
  /** @nullable */
  last_active?: string | null;
  /**
   * List of roles assigned to the user
   * @maxItems 20
   */
  roles?: Role[];
}

export type ForceSendNotificationResponseUser = {
  id?: number;
  username?: string;
  email?: string;
};

export type ForceSendNotificationResponseNotification = {
  type?: string;
  subject?: string;
  status?: string;
};

export interface ForceSendNotificationResponse {
  message?: string;
  user?: ForceSendNotificationResponseUser;
  notification?: ForceSendNotificationResponseNotification;
}

/**
 * The format for streaming audio data
 */
export type TTSRequestStreamFormat = typeof TTSRequestStreamFormat[keyof typeof TTSRequestStreamFormat];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TTSRequestStreamFormat = {
  sse: 'sse',
  mp3: 'mp3',
  wav: 'wav',
} as const;

export interface TTSRequest {
  /**
   * The text to convert to speech
   * @minLength 1
   * @maxLength 4000
   */
  input: string;
  /** The voice to use for speech generation */
  voice?: string;
  /** The TTS model to use */
  model?: string;
  /** The format for streaming audio data */
  stream_format?: TTSRequestStreamFormat;
}

/**
 * The type of SSE event
 */
export type TTSResponseType = typeof TTSResponseType[keyof typeof TTSResponseType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TTSResponseType = {
  audio: 'audio',
  usage: 'usage',
  error: 'error',
} as const;

/**
 * Usage statistics (for type=usage)
 */
export type TTSResponseUsage = {
  /** Number of input tokens processed */
  input_tokens?: number;
  /** Number of output tokens generated */
  output_tokens?: number;
  /** Total tokens used */
  total_tokens?: number;
};

export interface TTSResponse {
  /** The type of SSE event */
  type?: TTSResponseType;
  /** Base64 encoded audio chunk (for type=audio) */
  audio?: string;
  /** Usage statistics (for type=usage) */
  usage?: TTSResponseUsage;
  /** Error message (for type=error) */
  error?: string;
}

export interface DailyQuestionHistory {
  /** RFC3339 timestamp of when the question was assigned in the user's timezone (includes offset) */
  assignment_date: string;
  /** Whether the question was completed on this date */
  is_completed: boolean;
  /**
   * Whether the user's answer was correct (null if not attempted)
   * @nullable
   */
  is_correct?: boolean | null;
  /**
   * When the user submitted their answer
   * @nullable
   */
  submitted_at?: string | null;
}

export type StoryStatus = typeof StoryStatus[keyof typeof StoryStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const StoryStatus = {
  active: 'active',
  archived: 'archived',
  completed: 'completed',
} as const;

export type StorySectionLengthOverride = typeof StorySectionLengthOverride[keyof typeof StorySectionLengthOverride];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const StorySectionLengthOverride = {
  short: 'short',
  medium: 'medium',
  long: 'long',
} as const;

export type StoryStatusProperty = typeof StoryStatusProperty[keyof typeof StoryStatusProperty];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const StoryStatusProperty = {
  active: 'active',
  archived: 'archived',
  completed: 'completed',
} as const;

export interface Story {
  id?: number;
  user_id?: number;
  title?: string;
  language?: string;
  /** @nullable */
  subject?: string | null;
  /** @nullable */
  author_style?: string | null;
  /** @nullable */
  time_period?: string | null;
  /** @nullable */
  genre?: string | null;
  /** @nullable */
  tone?: string | null;
  /** @nullable */
  character_names?: string | null;
  /** @nullable */
  custom_instructions?: string | null;
  section_length_override?: StorySectionLengthOverride;
  status?: StoryStatusProperty;
  /** @nullable */
  last_section_generated_at?: string | null;
  created_at?: string;
  updated_at?: string;
  /** @minimum 0 */
  extra_generations_today?: number;
}

export interface StorySection {
  id?: number;
  story_id?: number;
  section_number?: number;
  content?: string;
  language_level?: string;
  word_count?: number;
  generated_at?: string;
  generation_date?: string;
}

export interface StorySectionQuestion {
  id?: number;
  section_id?: number;
  question_text?: string;
  options?: string[];
  /**
   * @minimum 0
   * @maximum 3
   */
  correct_answer_index?: number;
  /** @nullable */
  explanation?: string | null;
  created_at?: string;
}

export type StoryWithSectionsAllOf = {
  sections?: StorySection[];
};

export type StoryWithSections = Story & StoryWithSectionsAllOf;

export type StorySectionWithQuestionsAllOf = {
  questions?: StorySectionQuestion[];
};

export type StorySectionWithQuestions = StorySection & StorySectionWithQuestionsAllOf;

export type CreateStoryRequestSectionLengthOverride = typeof CreateStoryRequestSectionLengthOverride[keyof typeof CreateStoryRequestSectionLengthOverride];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreateStoryRequestSectionLengthOverride = {
  short: 'short',
  medium: 'medium',
  long: 'long',
} as const;

export interface CreateStoryRequest {
  /**
   * @minLength 1
   * @maxLength 200
   */
  title: string;
  /**
   * @maxLength 500
   * @nullable
   */
  subject?: string | null;
  /**
   * @maxLength 200
   * @nullable
   */
  author_style?: string | null;
  /**
   * @maxLength 200
   * @nullable
   */
  time_period?: string | null;
  /**
   * @maxLength 100
   * @nullable
   */
  genre?: string | null;
  /**
   * @maxLength 100
   * @nullable
   */
  tone?: string | null;
  /**
   * @maxLength 1000
   * @nullable
   */
  character_names?: string | null;
  /**
   * @maxLength 2000
   * @nullable
   */
  custom_instructions?: string | null;
  section_length_override?: CreateStoryRequestSectionLengthOverride;
}

/**
 * Empty request body for endpoints that don't require request data
 */
export interface EmptyRequest { [key: string]: unknown }

export interface UserIdRequest {
  /**
   * ID of the user
   * @minimum 1
   */
  user_id: number;
}

export type GetV1AuthGoogleCallbackParams = {
/**
 * Authorization code from Google
 */
code: string;
/**
 * State parameter for CSRF protection
 */
state?: string;
};

export type GetV1QuizQuestionParams = {
/**
 * Preferred language for the question
 */
language?: Language;
/**
 * Difficulty level for the question
 */
level?: Level;
/**
 * Specific question type(s) to retrieve (comma-separated list). If multiple types are provided, the first valid type will be used.
 * @pattern ^[a-zA-Z_]+(,[a-zA-Z_]+)*$
 */
type?: string;
/**
 * Question type(s) to exclude from random selection (comma-separated list). Useful for filtering out specific question types from the general quiz.
 * @pattern ^[a-zA-Z_]+(,[a-zA-Z_]+)*$
 */
exclude_type?: string;
};

export type GetV1SettingsLevelsParams = {
/**
 * Language to get levels for (optional - returns all levels if not specified)
 */
language?: string;
};

export type GetV1AiConversationsParams = {
/**
 * Maximum number of conversations to return
 * @minimum 1
 * @maximum 100
 */
limit?: number;
/**
 * Number of conversations to skip
 * @minimum 0
 */
offset?: number;
};

export type GetV1AiConversations200 = {
  conversations?: Conversation[];
  /** Total number of conversations */
  total?: number;
  /** Number of conversations returned */
  limit?: number;
  /** Number of conversations skipped */
  offset?: number;
};

export type GetV1AiSearchParams = {
/**
 * Search query string
 * @minLength 1
 * @maxLength 255
 */
q: string;
/**
 * Maximum number of results to return
 * @minimum 1
 * @maximum 100
 */
limit?: number;
/**
 * Number of results to skip
 * @minimum 0
 */
offset?: number;
};

export type GetV1AiSearch200 = {
  conversations?: Conversation[];
  /** The search query that was used */
  query?: string;
  /** Total number of matching conversations */
  total?: number;
  /** Number of conversations returned */
  limit?: number;
  /** Number of conversations skipped */
  offset?: number;
};

export type PutV1AiConversationsBookmarkBody = {
  /** ID of the conversation containing the message */
  conversation_id: string;
  /** ID of the message to bookmark/unbookmark */
  message_id: string;
};

export type PutV1AiConversationsBookmark200 = {
  /** The new bookmark status of the message */
  bookmarked?: boolean;
};

export type PutV1UserzProfile200 = {
  message?: string;
  user?: UserProfile;
};

export type GetV1AdminBackendUserz200 = {
  /** @maxItems 1000 */
  users?: UserProfile[];
};

export type PostV1AdminBackendUserzBody = {
  /**
   * Username (1-100 characters, alphanumeric + underscore + email characters, cannot be empty or whitespace-only)
   * @minLength 3
   * @maxLength 100
   * @pattern ^[a-zA-Z0-9_@.+-]+$
   */
  username: string;
  /** Email address for the new user */
  email: string;
  /**
   * Password for the new user
   * @minLength 8
   */
  password: string;
  /** Preferred language for the user */
  language?: string;
  /** Current level for the user */
  level?: string;
  /** AI provider preference */
  ai_provider?: string;
  /** AI model preference */
  ai_model?: string;
  /** Whether AI is enabled for this user */
  ai_enabled?: boolean;
};

export type PostV1AdminBackendUserz201 = {
  message?: string;
  user?: UserProfile;
};

export type GetV1AdminBackendUserzPaginatedParams = {
/**
 * Page number (1-based)
 * @minimum 1
 */
page?: number;
/**
 * Number of users per page
 * @minimum 1
 * @maximum 100
 */
page_size?: number;
/**
 * Search term for username or email
 */
search?: string;
/**
 * Filter by preferred language
 */
language?: Language;
/**
 * Filter by current level
 */
level?: Level;
/**
 * Filter by AI provider
 */
ai_provider?: string;
/**
 * Filter by AI model
 */
ai_model?: string;
/**
 * Filter by AI enabled status
 */
ai_enabled?: GetV1AdminBackendUserzPaginatedAiEnabled;
/**
 * Filter by active status (active within 7 days)
 */
active?: GetV1AdminBackendUserzPaginatedActive;
};

export type GetV1AdminBackendUserzPaginatedAiEnabled = typeof GetV1AdminBackendUserzPaginatedAiEnabled[keyof typeof GetV1AdminBackendUserzPaginatedAiEnabled];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetV1AdminBackendUserzPaginatedAiEnabled = {
  true: 'true',
  false: 'false',
} as const;

export type GetV1AdminBackendUserzPaginatedActive = typeof GetV1AdminBackendUserzPaginatedActive[keyof typeof GetV1AdminBackendUserzPaginatedActive];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetV1AdminBackendUserzPaginatedActive = {
  true: 'true',
  false: 'false',
} as const;

export type GetV1AdminBackendUserzPaginated200UsersItemQuestionStatsAnsweredByType = { [key: string]: unknown };

export type GetV1AdminBackendUserzPaginated200UsersItemQuestionStatsAnsweredByLevel = { [key: string]: unknown };

export type GetV1AdminBackendUserzPaginated200UsersItemQuestionStatsAccuracyByType = { [key: string]: unknown };

export type GetV1AdminBackendUserzPaginated200UsersItemQuestionStatsAccuracyByLevel = { [key: string]: unknown };

export type GetV1AdminBackendUserzPaginated200UsersItemQuestionStatsAvailableByType = { [key: string]: unknown };

export type GetV1AdminBackendUserzPaginated200UsersItemQuestionStatsAvailableByLevel = { [key: string]: unknown };

export type GetV1AdminBackendUserzPaginated200UsersItemQuestionStats = {
  user_id?: number;
  total_answered?: number;
  answered_by_type?: GetV1AdminBackendUserzPaginated200UsersItemQuestionStatsAnsweredByType;
  answered_by_level?: GetV1AdminBackendUserzPaginated200UsersItemQuestionStatsAnsweredByLevel;
  accuracy_by_type?: GetV1AdminBackendUserzPaginated200UsersItemQuestionStatsAccuracyByType;
  accuracy_by_level?: GetV1AdminBackendUserzPaginated200UsersItemQuestionStatsAccuracyByLevel;
  available_by_type?: GetV1AdminBackendUserzPaginated200UsersItemQuestionStatsAvailableByType;
  available_by_level?: GetV1AdminBackendUserzPaginated200UsersItemQuestionStatsAvailableByLevel;
};

export type GetV1AdminBackendUserzPaginated200UsersItem = {
  user?: UserProfile;
  progress?: UserProgress;
  question_stats?: GetV1AdminBackendUserzPaginated200UsersItemQuestionStats;
};

export type GetV1AdminBackendUserzPaginated200 = {
  users?: GetV1AdminBackendUserzPaginated200UsersItem[];
  pagination?: PaginationInfo;
};

export type PutV1AdminBackendUserzId200 = {
  message?: string;
  user?: UserProfile;
};

export type DeleteV1AdminBackendUserzId200 = {
  message?: string;
};

export type PostV1AdminBackendUserzIdResetPassword200 = {
  message?: string;
};

export type GetV1AdminBackendRoles200 = {
  /** @maxItems 50 */
  roles?: Role[];
};

export type GetV1AdminBackendUserzIdRoles200 = {
  /** @maxItems 50 */
  roles?: Role[];
};

export type PostV1AdminBackendUserzIdRolesBody = {
  /**
   * Role ID to assign
   * @minimum 1
   */
  role_id: number;
};

export type PostV1AdminBackendUserzIdRoles200 = {
  message?: string;
};

export type DeleteV1AdminBackendUserzIdRolesRoleId200 = {
  message?: string;
};

export type GetV1AdminWorkerDetails200 = { [key: string]: unknown };

export type PostV1AdminWorkerPause200 = {
  message?: string;
};

export type PostV1AdminWorkerResume200 = {
  message?: string;
};

export type PostV1AdminWorkerTrigger200 = {
  message?: string;
};

export type GetV1AdminWorkerLogs200LogsItem = { [key: string]: unknown };

export type GetV1AdminWorkerLogs200 = {
  logs?: GetV1AdminWorkerLogs200LogsItem[];
};

export type GetV1AdminWorkerAiConcurrency200 = {
  active_requests?: number;
  max_concurrent?: number;
  queued_requests?: number;
  total_requests?: number;
};

export type GetV1AdminWorkerUsers200UsersItem = {
  id?: number;
  username?: string;
  is_paused?: boolean;
};

export type GetV1AdminWorkerUsers200 = {
  users?: GetV1AdminWorkerUsers200UsersItem[];
};

export type PostV1AdminWorkerUsersPause200 = {
  message?: string;
};

export type PostV1AdminWorkerUsersResume200 = {
  message?: string;
};

export type GetV1AdminWorkerAnalyticsPriorityScores200Distribution = {
  high?: number;
  medium?: number;
  low?: number;
  average?: number;
};

export type GetV1AdminWorkerAnalyticsPriorityScores200 = {
  distribution?: GetV1AdminWorkerAnalyticsPriorityScores200Distribution;
};

export type GetV1AdminWorkerNotificationsErrorsParams = {
/**
 * Page number (1-based)
 * @minimum 1
 */
page?: number;
/**
 * Number of errors per page
 * @minimum 1
 * @maximum 100
 */
page_size?: number;
/**
 * Filter by error type
 */
error_type?: GetV1AdminWorkerNotificationsErrorsErrorType;
/**
 * Filter by notification type
 */
notification_type?: GetV1AdminWorkerNotificationsErrorsNotificationType;
/**
 * Filter by resolution status
 */
resolved?: GetV1AdminWorkerNotificationsErrorsResolved;
};

export type GetV1AdminWorkerNotificationsErrorsErrorType = typeof GetV1AdminWorkerNotificationsErrorsErrorType[keyof typeof GetV1AdminWorkerNotificationsErrorsErrorType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetV1AdminWorkerNotificationsErrorsErrorType = {
  smtp_error: 'smtp_error',
  template_error: 'template_error',
  user_not_found: 'user_not_found',
  email_disabled: 'email_disabled',
  other: 'other',
} as const;

export type GetV1AdminWorkerNotificationsErrorsNotificationType = typeof GetV1AdminWorkerNotificationsErrorsNotificationType[keyof typeof GetV1AdminWorkerNotificationsErrorsNotificationType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetV1AdminWorkerNotificationsErrorsNotificationType = {
  daily_reminder: 'daily_reminder',
  test_email: 'test_email',
} as const;

export type GetV1AdminWorkerNotificationsErrorsResolved = typeof GetV1AdminWorkerNotificationsErrorsResolved[keyof typeof GetV1AdminWorkerNotificationsErrorsResolved];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetV1AdminWorkerNotificationsErrorsResolved = {
  true: 'true',
  false: 'false',
} as const;

export type GetV1AdminWorkerNotificationsErrors200 = {
  errors?: NotificationError[];
  pagination?: PaginationInfo;
  stats?: NotificationErrorStats;
};

export type GetV1AdminWorkerNotificationsSentParams = {
/**
 * Page number (1-based)
 * @minimum 1
 */
page?: number;
/**
 * Number of notifications per page
 * @minimum 1
 * @maximum 100
 */
page_size?: number;
/**
 * Filter by notification type
 */
notification_type?: GetV1AdminWorkerNotificationsSentNotificationType;
/**
 * Filter by status
 */
status?: GetV1AdminWorkerNotificationsSentStatus;
/**
 * Filter notifications sent after this timestamp
 */
sent_after?: string;
/**
 * Filter notifications sent before this timestamp
 */
sent_before?: string;
};

export type GetV1AdminWorkerNotificationsSentNotificationType = typeof GetV1AdminWorkerNotificationsSentNotificationType[keyof typeof GetV1AdminWorkerNotificationsSentNotificationType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetV1AdminWorkerNotificationsSentNotificationType = {
  daily_reminder: 'daily_reminder',
  test_email: 'test_email',
} as const;

export type GetV1AdminWorkerNotificationsSentStatus = typeof GetV1AdminWorkerNotificationsSentStatus[keyof typeof GetV1AdminWorkerNotificationsSentStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetV1AdminWorkerNotificationsSentStatus = {
  sent: 'sent',
  failed: 'failed',
  bounced: 'bounced',
} as const;

export type GetV1AdminWorkerNotificationsSent200 = {
  notifications?: SentNotification[];
  pagination?: PaginationInfo;
  stats?: NotificationStats;
};

export type PostV1AdminWorkerNotificationsForceSendBody = {
  /** Username of the user to send notification to */
  username: string;
};

export type GetV1AdminBackendQuestionsParams = {
/**
 * Page number (1-based)
 * @minimum 1
 */
page?: number;
/**
 * Number of questions per page
 * @minimum 1
 * @maximum 100
 */
page_size?: number;
/**
 * Search term for question content
 */
search?: string;
/**
 * Filter by question type
 */
type?: QuestionType;
/**
 * Filter by question status
 */
status?: QuestionStatus;
/**
 * Filter by language
 */
language?: Language;
/**
 * Filter by level
 */
level?: Level;
/**
 * Filter by user ID (optional)
 * @minimum 1
 */
user_id?: number;
};

export type GetV1AdminBackendQuestions200 = {
  questions?: Question[];
  pagination?: PaginationInfo;
  stats?: QuestionStats;
};

export type GetV1AdminBackendQuestionsPaginatedParams = {
/**
 * Page number (1-based)
 * @minimum 1
 */
page?: number;
/**
 * Number of questions per page
 * @minimum 1
 * @maximum 100
 */
page_size?: number;
/**
 * Search term for question content
 */
search?: string;
/**
 * Filter by question type
 */
type?: QuestionType;
/**
 * Filter by question status
 */
status?: QuestionStatus;
/**
 * Filter by language
 */
language?: Language;
/**
 * Filter by level
 */
level?: Level;
/**
 * Filter by user ID (optional)
 * @minimum 1
 */
user_id?: number;
};

export type GetV1AdminBackendQuestionsPaginated200 = {
  questions?: Question[];
  pagination?: PaginationInfo;
  stats?: QuestionStats;
};

/**
 * Updated question content
 */
export type PutV1AdminBackendQuestionsIdBodyContent = { [key: string]: unknown };

export type PutV1AdminBackendQuestionsIdBody = {
  /** Updated question content */
  content: PutV1AdminBackendQuestionsIdBodyContent;
  /** Index of the correct answer */
  correct_answer?: number;
  /** Explanation for the correct answer */
  explanation: string;
};

export type PutV1AdminBackendQuestionsId200 = {
  message?: string;
};

export type DeleteV1AdminBackendQuestionsId200 = {
  message?: string;
};

export type GetV1AdminBackendQuestionsIdUsers200 = {
  /** @maxItems 5 */
  users?: UserProfile[];
  /** Total number of users assigned to this question */
  total_count?: number;
};

export type PostV1AdminBackendQuestionsIdAssignUsersBody = {
  /**
   * Array of user IDs to assign to the question
   * @minItems 1
   */
  user_ids: number[];
};

export type PostV1AdminBackendQuestionsIdAssignUsers200 = {
  message?: string;
};

export type PostV1AdminBackendQuestionsIdUnassignUsersBody = {
  /**
   * Array of user IDs to unassign from the question
   * @minItems 1
   */
  user_ids: number[];
};

export type PostV1AdminBackendQuestionsIdUnassignUsers200 = {
  message?: string;
};

export type PostV1AdminBackendQuestionsIdFix200 = {
  message?: string;
};

export type PostV1AdminBackendQuestionsIdAiFixBody = {
  additional_context?: string;
};

export type PostV1AdminBackendQuestionsIdAiFix200 = {
  message?: string;
};

export type PostV1AdminBackendClearUserData200 = {
  message?: string;
};

export type PostV1AdminBackendClearDatabase200 = {
  message?: string;
};

export type PostV1AdminBackendUserzIdClear200 = {
  message?: string;
};

export type GetV1AdminBackendReportedQuestionsParams = {
/**
 * Page number (1-based)
 * @minimum 1
 */
page?: number;
/**
 * Number of questions per page
 * @minimum 1
 * @maximum 100
 */
page_size?: number;
/**
 * Search term for question content
 */
search?: string;
/**
 * Filter by question type
 */
type?: QuestionType;
/**
 * Filter by language
 */
language?: Language;
/**
 * Filter by level
 */
level?: Level;
};

export type GetV1AdminBackendReportedQuestions200StatsReportedByType = { [key: string]: unknown };

export type GetV1AdminBackendReportedQuestions200StatsReportedByLevel = { [key: string]: unknown };

export type GetV1AdminBackendReportedQuestions200StatsReportedByLanguage = { [key: string]: unknown };

export type GetV1AdminBackendReportedQuestions200Stats = {
  total_reported?: number;
  reported_by_type?: GetV1AdminBackendReportedQuestions200StatsReportedByType;
  reported_by_level?: GetV1AdminBackendReportedQuestions200StatsReportedByLevel;
  reported_by_language?: GetV1AdminBackendReportedQuestions200StatsReportedByLanguage;
};

export type GetV1AdminBackendReportedQuestions200 = {
  questions?: Question[];
  pagination?: PaginationInfo;
  stats?: GetV1AdminBackendReportedQuestions200Stats;
};

export type GetV1AdminBackendStoriesParams = {
/**
 * Page number (1-based)
 * @minimum 1
 */
page?: number;
/**
 * Number of stories per page
 * @minimum 1
 * @maximum 100
 */
page_size?: number;
/**
 * Search term for story title
 */
search?: string;
/**
 * Filter by language
 */
language?: Language;
/**
 * Filter by story status
 */
status?: StoryStatus;
/**
 * Filter by user ID (optional)
 * @minimum 1
 */
user_id?: number;
};

export type GetV1AdminBackendStories200 = {
  stories?: Story[];
  pagination?: PaginationInfo;
};

export type GetV1DailyQuestionsDate200 = {
  questions?: DailyQuestionWithDetails[];
  date?: string;
};

export type GetV1DailyDates200 = {
  dates?: string[];
};

export type PostV1DailyQuestionsDateAnswerQuestionIdBody = {
  /**
   * Index of the user's selected answer (0-based)
   * @minimum 0
   * @maximum 3
   */
  user_answer_index: number;
};

export type PostV1DailyQuestionsDateAnswerQuestionId200AllOf = {
  /** Whether the question is now completed */
  is_completed?: boolean;
};

export type PostV1DailyQuestionsDateAnswerQuestionId200 = AnswerResponse & PostV1DailyQuestionsDateAnswerQuestionId200AllOf;

export type GetV1DailyHistoryQuestionId200 = {
  history?: DailyQuestionHistory[];
};

export type GetV1StoryParams = {
/**
 * Include archived stories in the response
 */
include_archived?: boolean;
};

/**
 * Health status of the service
 */
export type GetHealth200Status = typeof GetHealth200Status[keyof typeof GetHealth200Status];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetHealth200Status = {
  ok: 'ok',
} as const;

export type GetHealth200 = {
  /** Health status of the service */
  status?: GetHealth200Status;
  /** Service name */
  service?: string;
};

export type GetHealth503Status = typeof GetHealth503Status[keyof typeof GetHealth503Status];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetHealth503Status = {
  unhealthy: 'unhealthy',
} as const;

export type GetHealth503 = {
  status?: GetHealth503Status;
  timestamp?: string;
  /** Error message describing the health issue */
  error?: string;
};

export type GetV1AdminWorkerDailyUsersUserIdQuestionsDate200 = {
  questions?: DailyQuestionWithDetails[];
};

export type PostV1AdminWorkerDailyUsersUserIdQuestionsDateRegenerate200 = {
  success?: boolean;
  message?: string;
};

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * Authenticate a user with username and password. Creates new user if doesn't exist.
 * @summary User login
 */
export const postV1AuthLogin = (
    loginRequest: LoginRequest,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<LoginResponse>(
      {url: `/v1/auth/login`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: loginRequest, signal
    },
      options);
    }
  


export const getPostV1AuthLoginMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AuthLogin>>, TError,{data: LoginRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postV1AuthLogin>>, TError,{data: LoginRequest}, TContext> => {

const mutationKey = ['postV1AuthLogin'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1AuthLogin>>, {data: LoginRequest}> = (props) => {
          const {data} = props ?? {};

          return  postV1AuthLogin(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1AuthLoginMutationResult = NonNullable<Awaited<ReturnType<typeof postV1AuthLogin>>>
    export type PostV1AuthLoginMutationBody = LoginRequest
    export type PostV1AuthLoginMutationError = ErrorResponse

    /**
 * @summary User login
 */
export const usePostV1AuthLogin = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AuthLogin>>, TError,{data: LoginRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postV1AuthLogin>>,
        TError,
        {data: LoginRequest},
        TContext
      > => {

      const mutationOptions = getPostV1AuthLoginMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Log out the current user and clear session.
 * @summary User logout
 */
export const postV1AuthLogout = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<SuccessResponse>(
      {url: `/v1/auth/logout`, method: 'POST', signal
    },
      options);
    }
  


export const getPostV1AuthLogoutMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AuthLogout>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postV1AuthLogout>>, TError,void, TContext> => {

const mutationKey = ['postV1AuthLogout'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1AuthLogout>>, void> = () => {
          

          return  postV1AuthLogout(requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1AuthLogoutMutationResult = NonNullable<Awaited<ReturnType<typeof postV1AuthLogout>>>
    
    export type PostV1AuthLogoutMutationError = unknown

    /**
 * @summary User logout
 */
export const usePostV1AuthLogout = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AuthLogout>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postV1AuthLogout>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getPostV1AuthLogoutMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Check if user is currently authenticated.
 * @summary Get authentication status
 */
export const getV1AuthStatus = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<AuthStatusResponse>(
      {url: `/v1/auth/status`, method: 'GET', signal
    },
      options);
    }
  

export const getGetV1AuthStatusQueryKey = () => {
    return [`/v1/auth/status`] as const;
    }

    
export const getGetV1AuthStatusQueryOptions = <TData = Awaited<ReturnType<typeof getV1AuthStatus>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AuthStatus>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AuthStatusQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AuthStatus>>> = ({ signal }) => getV1AuthStatus(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AuthStatus>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AuthStatusQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AuthStatus>>>
export type GetV1AuthStatusQueryError = unknown


export function useGetV1AuthStatus<TData = Awaited<ReturnType<typeof getV1AuthStatus>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AuthStatus>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AuthStatus>>,
          TError,
          Awaited<ReturnType<typeof getV1AuthStatus>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AuthStatus<TData = Awaited<ReturnType<typeof getV1AuthStatus>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AuthStatus>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AuthStatus>>,
          TError,
          Awaited<ReturnType<typeof getV1AuthStatus>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AuthStatus<TData = Awaited<ReturnType<typeof getV1AuthStatus>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AuthStatus>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get authentication status
 */

export function useGetV1AuthStatus<TData = Awaited<ReturnType<typeof getV1AuthStatus>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AuthStatus>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AuthStatusQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Returns 204 when the user is authenticated; returns 401 when unauthenticated. Intended for reverse proxy auth_request.
 * @summary Authentication check
 */
export const getV1AuthCheck = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/v1/auth/check`, method: 'GET', signal
    },
      options);
    }
  

export const getGetV1AuthCheckQueryKey = () => {
    return [`/v1/auth/check`] as const;
    }

    
export const getGetV1AuthCheckQueryOptions = <TData = Awaited<ReturnType<typeof getV1AuthCheck>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AuthCheck>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AuthCheckQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AuthCheck>>> = ({ signal }) => getV1AuthCheck(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AuthCheck>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AuthCheckQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AuthCheck>>>
export type GetV1AuthCheckQueryError = ErrorResponse


export function useGetV1AuthCheck<TData = Awaited<ReturnType<typeof getV1AuthCheck>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AuthCheck>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AuthCheck>>,
          TError,
          Awaited<ReturnType<typeof getV1AuthCheck>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AuthCheck<TData = Awaited<ReturnType<typeof getV1AuthCheck>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AuthCheck>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AuthCheck>>,
          TError,
          Awaited<ReturnType<typeof getV1AuthCheck>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AuthCheck<TData = Awaited<ReturnType<typeof getV1AuthCheck>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AuthCheck>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Authentication check
 */

export function useGetV1AuthCheck<TData = Awaited<ReturnType<typeof getV1AuthCheck>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AuthCheck>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AuthCheckQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Create a new user account with username, email, and password
 * @summary User signup
 */
export const postV1AuthSignup = (
    userCreateRequest: UserCreateRequest,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<SuccessResponse>(
      {url: `/v1/auth/signup`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: userCreateRequest, signal
    },
      options);
    }
  


export const getPostV1AuthSignupMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AuthSignup>>, TError,{data: UserCreateRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postV1AuthSignup>>, TError,{data: UserCreateRequest}, TContext> => {

const mutationKey = ['postV1AuthSignup'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1AuthSignup>>, {data: UserCreateRequest}> = (props) => {
          const {data} = props ?? {};

          return  postV1AuthSignup(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1AuthSignupMutationResult = NonNullable<Awaited<ReturnType<typeof postV1AuthSignup>>>
    export type PostV1AuthSignupMutationBody = UserCreateRequest
    export type PostV1AuthSignupMutationError = ErrorResponse

    /**
 * @summary User signup
 */
export const usePostV1AuthSignup = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AuthSignup>>, TError,{data: UserCreateRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postV1AuthSignup>>,
        TError,
        {data: UserCreateRequest},
        TContext
      > => {

      const mutationOptions = getPostV1AuthSignupMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Check whether user signups are enabled or disabled
 * @summary Get signup status
 */
export const getV1AuthSignupStatus = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<SignupStatusResponse>(
      {url: `/v1/auth/signup/status`, method: 'GET', signal
    },
      options);
    }
  

export const getGetV1AuthSignupStatusQueryKey = () => {
    return [`/v1/auth/signup/status`] as const;
    }

    
export const getGetV1AuthSignupStatusQueryOptions = <TData = Awaited<ReturnType<typeof getV1AuthSignupStatus>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AuthSignupStatus>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AuthSignupStatusQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AuthSignupStatus>>> = ({ signal }) => getV1AuthSignupStatus(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AuthSignupStatus>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AuthSignupStatusQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AuthSignupStatus>>>
export type GetV1AuthSignupStatusQueryError = unknown


export function useGetV1AuthSignupStatus<TData = Awaited<ReturnType<typeof getV1AuthSignupStatus>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AuthSignupStatus>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AuthSignupStatus>>,
          TError,
          Awaited<ReturnType<typeof getV1AuthSignupStatus>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AuthSignupStatus<TData = Awaited<ReturnType<typeof getV1AuthSignupStatus>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AuthSignupStatus>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AuthSignupStatus>>,
          TError,
          Awaited<ReturnType<typeof getV1AuthSignupStatus>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AuthSignupStatus<TData = Awaited<ReturnType<typeof getV1AuthSignupStatus>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AuthSignupStatus>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get signup status
 */

export function useGetV1AuthSignupStatus<TData = Awaited<ReturnType<typeof getV1AuthSignupStatus>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AuthSignupStatus>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AuthSignupStatusQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Redirects user to Google OAuth for authentication
 * @summary Initiate Google OAuth login
 */
export const getV1AuthGoogleLogin = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GoogleOAuthLoginResponse>(
      {url: `/v1/auth/google/login`, method: 'GET', signal
    },
      options);
    }
  

export const getGetV1AuthGoogleLoginQueryKey = () => {
    return [`/v1/auth/google/login`] as const;
    }

    
export const getGetV1AuthGoogleLoginQueryOptions = <TData = Awaited<ReturnType<typeof getV1AuthGoogleLogin>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AuthGoogleLogin>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AuthGoogleLoginQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AuthGoogleLogin>>> = ({ signal }) => getV1AuthGoogleLogin(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AuthGoogleLogin>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AuthGoogleLoginQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AuthGoogleLogin>>>
export type GetV1AuthGoogleLoginQueryError = unknown


export function useGetV1AuthGoogleLogin<TData = Awaited<ReturnType<typeof getV1AuthGoogleLogin>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AuthGoogleLogin>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AuthGoogleLogin>>,
          TError,
          Awaited<ReturnType<typeof getV1AuthGoogleLogin>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AuthGoogleLogin<TData = Awaited<ReturnType<typeof getV1AuthGoogleLogin>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AuthGoogleLogin>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AuthGoogleLogin>>,
          TError,
          Awaited<ReturnType<typeof getV1AuthGoogleLogin>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AuthGoogleLogin<TData = Awaited<ReturnType<typeof getV1AuthGoogleLogin>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AuthGoogleLogin>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Initiate Google OAuth login
 */

export function useGetV1AuthGoogleLogin<TData = Awaited<ReturnType<typeof getV1AuthGoogleLogin>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AuthGoogleLogin>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AuthGoogleLoginQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Handle the callback from Google OAuth after successful authentication
 * @summary Google OAuth callback
 */
export const getV1AuthGoogleCallback = (
    params: GetV1AuthGoogleCallbackParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<LoginResponse>(
      {url: `/v1/auth/google/callback`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetV1AuthGoogleCallbackQueryKey = (params: GetV1AuthGoogleCallbackParams,) => {
    return [`/v1/auth/google/callback`, ...(params ? [params]: [])] as const;
    }

    
export const getGetV1AuthGoogleCallbackQueryOptions = <TData = Awaited<ReturnType<typeof getV1AuthGoogleCallback>>, TError = ErrorResponse>(params: GetV1AuthGoogleCallbackParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AuthGoogleCallback>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AuthGoogleCallbackQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AuthGoogleCallback>>> = ({ signal }) => getV1AuthGoogleCallback(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AuthGoogleCallback>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AuthGoogleCallbackQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AuthGoogleCallback>>>
export type GetV1AuthGoogleCallbackQueryError = ErrorResponse


export function useGetV1AuthGoogleCallback<TData = Awaited<ReturnType<typeof getV1AuthGoogleCallback>>, TError = ErrorResponse>(
 params: GetV1AuthGoogleCallbackParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AuthGoogleCallback>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AuthGoogleCallback>>,
          TError,
          Awaited<ReturnType<typeof getV1AuthGoogleCallback>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AuthGoogleCallback<TData = Awaited<ReturnType<typeof getV1AuthGoogleCallback>>, TError = ErrorResponse>(
 params: GetV1AuthGoogleCallbackParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AuthGoogleCallback>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AuthGoogleCallback>>,
          TError,
          Awaited<ReturnType<typeof getV1AuthGoogleCallback>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AuthGoogleCallback<TData = Awaited<ReturnType<typeof getV1AuthGoogleCallback>>, TError = ErrorResponse>(
 params: GetV1AuthGoogleCallbackParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AuthGoogleCallback>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Google OAuth callback
 */

export function useGetV1AuthGoogleCallback<TData = Awaited<ReturnType<typeof getV1AuthGoogleCallback>>, TError = ErrorResponse>(
 params: GetV1AuthGoogleCallbackParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AuthGoogleCallback>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AuthGoogleCallbackQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get the next question for the authenticated user. If a specific `type` is requested and no eligible questions are currently available, the server returns 202 with a generating status and prioritizes generation of that type for the user.
 * @summary Get next question
 */
export const getV1QuizQuestion = (
    params?: GetV1QuizQuestionParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<Question | GeneratingResponse>(
      {url: `/v1/quiz/question`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetV1QuizQuestionQueryKey = (params?: GetV1QuizQuestionParams,) => {
    return [`/v1/quiz/question`, ...(params ? [params]: [])] as const;
    }

    
export const getGetV1QuizQuestionQueryOptions = <TData = Awaited<ReturnType<typeof getV1QuizQuestion>>, TError = ErrorResponse>(params?: GetV1QuizQuestionParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1QuizQuestion>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1QuizQuestionQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1QuizQuestion>>> = ({ signal }) => getV1QuizQuestion(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1QuizQuestion>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1QuizQuestionQueryResult = NonNullable<Awaited<ReturnType<typeof getV1QuizQuestion>>>
export type GetV1QuizQuestionQueryError = ErrorResponse


export function useGetV1QuizQuestion<TData = Awaited<ReturnType<typeof getV1QuizQuestion>>, TError = ErrorResponse>(
 params: undefined |  GetV1QuizQuestionParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1QuizQuestion>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1QuizQuestion>>,
          TError,
          Awaited<ReturnType<typeof getV1QuizQuestion>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1QuizQuestion<TData = Awaited<ReturnType<typeof getV1QuizQuestion>>, TError = ErrorResponse>(
 params?: GetV1QuizQuestionParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1QuizQuestion>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1QuizQuestion>>,
          TError,
          Awaited<ReturnType<typeof getV1QuizQuestion>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1QuizQuestion<TData = Awaited<ReturnType<typeof getV1QuizQuestion>>, TError = ErrorResponse>(
 params?: GetV1QuizQuestionParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1QuizQuestion>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get next question
 */

export function useGetV1QuizQuestion<TData = Awaited<ReturnType<typeof getV1QuizQuestion>>, TError = ErrorResponse>(
 params?: GetV1QuizQuestionParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1QuizQuestion>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1QuizQuestionQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Retrieve a specific question by its ID
 * @summary Get specific question by ID
 */
export const getV1QuizQuestionId = (
    id: number,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<Question>(
      {url: `/v1/quiz/question/${id}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetV1QuizQuestionIdQueryKey = (id: number,) => {
    return [`/v1/quiz/question/${id}`] as const;
    }

    
export const getGetV1QuizQuestionIdQueryOptions = <TData = Awaited<ReturnType<typeof getV1QuizQuestionId>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1QuizQuestionId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1QuizQuestionIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1QuizQuestionId>>> = ({ signal }) => getV1QuizQuestionId(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1QuizQuestionId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1QuizQuestionIdQueryResult = NonNullable<Awaited<ReturnType<typeof getV1QuizQuestionId>>>
export type GetV1QuizQuestionIdQueryError = ErrorResponse


export function useGetV1QuizQuestionId<TData = Awaited<ReturnType<typeof getV1QuizQuestionId>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1QuizQuestionId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1QuizQuestionId>>,
          TError,
          Awaited<ReturnType<typeof getV1QuizQuestionId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1QuizQuestionId<TData = Awaited<ReturnType<typeof getV1QuizQuestionId>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1QuizQuestionId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1QuizQuestionId>>,
          TError,
          Awaited<ReturnType<typeof getV1QuizQuestionId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1QuizQuestionId<TData = Awaited<ReturnType<typeof getV1QuizQuestionId>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1QuizQuestionId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get specific question by ID
 */

export function useGetV1QuizQuestionId<TData = Awaited<ReturnType<typeof getV1QuizQuestionId>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1QuizQuestionId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1QuizQuestionIdQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Submit an answer for a question and get feedback
 * @summary Submit answer
 */
export const postV1QuizAnswer = (
    answerRequest: AnswerRequest,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<AnswerResponse>(
      {url: `/v1/quiz/answer`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: answerRequest, signal
    },
      options);
    }
  


export const getPostV1QuizAnswerMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1QuizAnswer>>, TError,{data: AnswerRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postV1QuizAnswer>>, TError,{data: AnswerRequest}, TContext> => {

const mutationKey = ['postV1QuizAnswer'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1QuizAnswer>>, {data: AnswerRequest}> = (props) => {
          const {data} = props ?? {};

          return  postV1QuizAnswer(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1QuizAnswerMutationResult = NonNullable<Awaited<ReturnType<typeof postV1QuizAnswer>>>
    export type PostV1QuizAnswerMutationBody = AnswerRequest
    export type PostV1QuizAnswerMutationError = ErrorResponse

    /**
 * @summary Submit answer
 */
export const usePostV1QuizAnswer = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1QuizAnswer>>, TError,{data: AnswerRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postV1QuizAnswer>>,
        TError,
        {data: AnswerRequest},
        TContext
      > => {

      const mutationOptions = getPostV1QuizAnswerMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Get detailed progress information for the authenticated user
 * @summary Get user progress
 */
export const getV1QuizProgress = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<UserProgress>(
      {url: `/v1/quiz/progress`, method: 'GET', signal
    },
      options);
    }
  

export const getGetV1QuizProgressQueryKey = () => {
    return [`/v1/quiz/progress`] as const;
    }

    
export const getGetV1QuizProgressQueryOptions = <TData = Awaited<ReturnType<typeof getV1QuizProgress>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1QuizProgress>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1QuizProgressQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1QuizProgress>>> = ({ signal }) => getV1QuizProgress(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1QuizProgress>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1QuizProgressQueryResult = NonNullable<Awaited<ReturnType<typeof getV1QuizProgress>>>
export type GetV1QuizProgressQueryError = ErrorResponse


export function useGetV1QuizProgress<TData = Awaited<ReturnType<typeof getV1QuizProgress>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1QuizProgress>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1QuizProgress>>,
          TError,
          Awaited<ReturnType<typeof getV1QuizProgress>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1QuizProgress<TData = Awaited<ReturnType<typeof getV1QuizProgress>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1QuizProgress>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1QuizProgress>>,
          TError,
          Awaited<ReturnType<typeof getV1QuizProgress>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1QuizProgress<TData = Awaited<ReturnType<typeof getV1QuizProgress>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1QuizProgress>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get user progress
 */

export function useGetV1QuizProgress<TData = Awaited<ReturnType<typeof getV1QuizProgress>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1QuizProgress>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1QuizProgressQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Report a question as incorrect or problematic with optional explanation
 * @summary Report question
 */
export const postV1QuizQuestionIdReport = (
    id: number,
    reportQuestionRequest?: ReportQuestionRequest,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<SuccessResponse>(
      {url: `/v1/quiz/question/${id}/report`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: reportQuestionRequest, signal
    },
      options);
    }
  


export const getPostV1QuizQuestionIdReportMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1QuizQuestionIdReport>>, TError,{id: number;data: ReportQuestionRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postV1QuizQuestionIdReport>>, TError,{id: number;data: ReportQuestionRequest}, TContext> => {

const mutationKey = ['postV1QuizQuestionIdReport'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1QuizQuestionIdReport>>, {id: number;data: ReportQuestionRequest}> = (props) => {
          const {id,data} = props ?? {};

          return  postV1QuizQuestionIdReport(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1QuizQuestionIdReportMutationResult = NonNullable<Awaited<ReturnType<typeof postV1QuizQuestionIdReport>>>
    export type PostV1QuizQuestionIdReportMutationBody = ReportQuestionRequest
    export type PostV1QuizQuestionIdReportMutationError = ErrorResponse

    /**
 * @summary Report question
 */
export const usePostV1QuizQuestionIdReport = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1QuizQuestionIdReport>>, TError,{id: number;data: ReportQuestionRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postV1QuizQuestionIdReport>>,
        TError,
        {id: number;data: ReportQuestionRequest},
        TContext
      > => {

      const mutationOptions = getPostV1QuizQuestionIdReportMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Mark a question as known by the user, which affects priority scoring
 * @summary Mark question as known
 */
export const postV1QuizQuestionIdMarkKnown = (
    id: number,
    markQuestionKnownRequest?: MarkQuestionKnownRequest,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<SuccessResponse>(
      {url: `/v1/quiz/question/${id}/mark-known`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: markQuestionKnownRequest, signal
    },
      options);
    }
  


export const getPostV1QuizQuestionIdMarkKnownMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1QuizQuestionIdMarkKnown>>, TError,{id: number;data: MarkQuestionKnownRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postV1QuizQuestionIdMarkKnown>>, TError,{id: number;data: MarkQuestionKnownRequest}, TContext> => {

const mutationKey = ['postV1QuizQuestionIdMarkKnown'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1QuizQuestionIdMarkKnown>>, {id: number;data: MarkQuestionKnownRequest}> = (props) => {
          const {id,data} = props ?? {};

          return  postV1QuizQuestionIdMarkKnown(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1QuizQuestionIdMarkKnownMutationResult = NonNullable<Awaited<ReturnType<typeof postV1QuizQuestionIdMarkKnown>>>
    export type PostV1QuizQuestionIdMarkKnownMutationBody = MarkQuestionKnownRequest
    export type PostV1QuizQuestionIdMarkKnownMutationError = ErrorResponse

    /**
 * @summary Mark question as known
 */
export const usePostV1QuizQuestionIdMarkKnown = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1QuizQuestionIdMarkKnown>>, TError,{id: number;data: MarkQuestionKnownRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postV1QuizQuestionIdMarkKnown>>,
        TError,
        {id: number;data: MarkQuestionKnownRequest},
        TContext
      > => {

      const mutationOptions = getPostV1QuizQuestionIdMarkKnownMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Get the current status of the question generation worker
 * @summary Get worker status
 */
export const getV1QuizWorkerStatus = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<WorkerStatusResponse>(
      {url: `/v1/quiz/worker-status`, method: 'GET', signal
    },
      options);
    }
  

export const getGetV1QuizWorkerStatusQueryKey = () => {
    return [`/v1/quiz/worker-status`] as const;
    }

    
export const getGetV1QuizWorkerStatusQueryOptions = <TData = Awaited<ReturnType<typeof getV1QuizWorkerStatus>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1QuizWorkerStatus>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1QuizWorkerStatusQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1QuizWorkerStatus>>> = ({ signal }) => getV1QuizWorkerStatus(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1QuizWorkerStatus>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1QuizWorkerStatusQueryResult = NonNullable<Awaited<ReturnType<typeof getV1QuizWorkerStatus>>>
export type GetV1QuizWorkerStatusQueryError = ErrorResponse


export function useGetV1QuizWorkerStatus<TData = Awaited<ReturnType<typeof getV1QuizWorkerStatus>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1QuizWorkerStatus>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1QuizWorkerStatus>>,
          TError,
          Awaited<ReturnType<typeof getV1QuizWorkerStatus>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1QuizWorkerStatus<TData = Awaited<ReturnType<typeof getV1QuizWorkerStatus>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1QuizWorkerStatus>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1QuizWorkerStatus>>,
          TError,
          Awaited<ReturnType<typeof getV1QuizWorkerStatus>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1QuizWorkerStatus<TData = Awaited<ReturnType<typeof getV1QuizWorkerStatus>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1QuizWorkerStatus>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get worker status
 */

export function useGetV1QuizWorkerStatus<TData = Awaited<ReturnType<typeof getV1QuizWorkerStatus>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1QuizWorkerStatus>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1QuizWorkerStatusQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update various settings for the authenticated user
 * @summary Update user settings
 */
export const putV1Settings = (
    userSettings: UserSettings,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<SuccessResponse>(
      {url: `/v1/settings`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: userSettings
    },
      options);
    }
  


export const getPutV1SettingsMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putV1Settings>>, TError,{data: UserSettings}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof putV1Settings>>, TError,{data: UserSettings}, TContext> => {

const mutationKey = ['putV1Settings'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putV1Settings>>, {data: UserSettings}> = (props) => {
          const {data} = props ?? {};

          return  putV1Settings(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PutV1SettingsMutationResult = NonNullable<Awaited<ReturnType<typeof putV1Settings>>>
    export type PutV1SettingsMutationBody = UserSettings
    export type PutV1SettingsMutationError = ErrorResponse

    /**
 * @summary Update user settings
 */
export const usePutV1Settings = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putV1Settings>>, TError,{data: UserSettings}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof putV1Settings>>,
        TError,
        {data: UserSettings},
        TContext
      > => {

      const mutationOptions = getPutV1SettingsMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Retrieve the list of configured AI providers and their models
 * @summary Get available AI providers
 */
export const getV1SettingsAiProviders = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<AIProviders>(
      {url: `/v1/settings/ai-providers`, method: 'GET', signal
    },
      options);
    }
  

export const getGetV1SettingsAiProvidersQueryKey = () => {
    return [`/v1/settings/ai-providers`] as const;
    }

    
export const getGetV1SettingsAiProvidersQueryOptions = <TData = Awaited<ReturnType<typeof getV1SettingsAiProviders>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1SettingsAiProviders>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1SettingsAiProvidersQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1SettingsAiProviders>>> = ({ signal }) => getV1SettingsAiProviders(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1SettingsAiProviders>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1SettingsAiProvidersQueryResult = NonNullable<Awaited<ReturnType<typeof getV1SettingsAiProviders>>>
export type GetV1SettingsAiProvidersQueryError = unknown


export function useGetV1SettingsAiProviders<TData = Awaited<ReturnType<typeof getV1SettingsAiProviders>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1SettingsAiProviders>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1SettingsAiProviders>>,
          TError,
          Awaited<ReturnType<typeof getV1SettingsAiProviders>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1SettingsAiProviders<TData = Awaited<ReturnType<typeof getV1SettingsAiProviders>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1SettingsAiProviders>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1SettingsAiProviders>>,
          TError,
          Awaited<ReturnType<typeof getV1SettingsAiProviders>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1SettingsAiProviders<TData = Awaited<ReturnType<typeof getV1SettingsAiProviders>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1SettingsAiProviders>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get available AI providers
 */

export function useGetV1SettingsAiProviders<TData = Awaited<ReturnType<typeof getV1SettingsAiProviders>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1SettingsAiProviders>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1SettingsAiProvidersQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Test the connection to the selected AI provider with given credentials
 * @summary Test AI connection
 */
export const postV1SettingsTestAi = (
    testAIRequest: TestAIRequest,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<SuccessResponse>(
      {url: `/v1/settings/test-ai`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: testAIRequest, signal
    },
      options);
    }
  


export const getPostV1SettingsTestAiMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1SettingsTestAi>>, TError,{data: TestAIRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postV1SettingsTestAi>>, TError,{data: TestAIRequest}, TContext> => {

const mutationKey = ['postV1SettingsTestAi'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1SettingsTestAi>>, {data: TestAIRequest}> = (props) => {
          const {data} = props ?? {};

          return  postV1SettingsTestAi(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1SettingsTestAiMutationResult = NonNullable<Awaited<ReturnType<typeof postV1SettingsTestAi>>>
    export type PostV1SettingsTestAiMutationBody = TestAIRequest
    export type PostV1SettingsTestAiMutationError = ErrorResponse

    /**
 * @summary Test AI connection
 */
export const usePostV1SettingsTestAi = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1SettingsTestAi>>, TError,{data: TestAIRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postV1SettingsTestAi>>,
        TError,
        {data: TestAIRequest},
        TContext
      > => {

      const mutationOptions = getPostV1SettingsTestAiMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Send a test email to the current user to verify email configuration
 * @summary Send test email
 */
export const postV1SettingsTestEmail = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<SuccessResponse>(
      {url: `/v1/settings/test-email`, method: 'POST', signal
    },
      options);
    }
  


export const getPostV1SettingsTestEmailMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1SettingsTestEmail>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postV1SettingsTestEmail>>, TError,void, TContext> => {

const mutationKey = ['postV1SettingsTestEmail'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1SettingsTestEmail>>, void> = () => {
          

          return  postV1SettingsTestEmail(requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1SettingsTestEmailMutationResult = NonNullable<Awaited<ReturnType<typeof postV1SettingsTestEmail>>>
    
    export type PostV1SettingsTestEmailMutationError = ErrorResponse

    /**
 * @summary Send test email
 */
export const usePostV1SettingsTestEmail = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1SettingsTestEmail>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postV1SettingsTestEmail>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getPostV1SettingsTestEmailMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Retrieve the list of available language proficiency levels and their short descriptions
 * @summary Get available levels
 */
export const getV1SettingsLevels = (
    params?: GetV1SettingsLevelsParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<LevelsResponse>(
      {url: `/v1/settings/levels`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetV1SettingsLevelsQueryKey = (params?: GetV1SettingsLevelsParams,) => {
    return [`/v1/settings/levels`, ...(params ? [params]: [])] as const;
    }

    
export const getGetV1SettingsLevelsQueryOptions = <TData = Awaited<ReturnType<typeof getV1SettingsLevels>>, TError = unknown>(params?: GetV1SettingsLevelsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1SettingsLevels>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1SettingsLevelsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1SettingsLevels>>> = ({ signal }) => getV1SettingsLevels(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1SettingsLevels>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1SettingsLevelsQueryResult = NonNullable<Awaited<ReturnType<typeof getV1SettingsLevels>>>
export type GetV1SettingsLevelsQueryError = unknown


export function useGetV1SettingsLevels<TData = Awaited<ReturnType<typeof getV1SettingsLevels>>, TError = unknown>(
 params: undefined |  GetV1SettingsLevelsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1SettingsLevels>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1SettingsLevels>>,
          TError,
          Awaited<ReturnType<typeof getV1SettingsLevels>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1SettingsLevels<TData = Awaited<ReturnType<typeof getV1SettingsLevels>>, TError = unknown>(
 params?: GetV1SettingsLevelsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1SettingsLevels>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1SettingsLevels>>,
          TError,
          Awaited<ReturnType<typeof getV1SettingsLevels>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1SettingsLevels<TData = Awaited<ReturnType<typeof getV1SettingsLevels>>, TError = unknown>(
 params?: GetV1SettingsLevelsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1SettingsLevels>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get available levels
 */

export function useGetV1SettingsLevels<TData = Awaited<ReturnType<typeof getV1SettingsLevels>>, TError = unknown>(
 params?: GetV1SettingsLevelsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1SettingsLevels>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1SettingsLevelsQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Retrieve the list of available learning languages
 * @summary Get available languages
 */
export const getV1SettingsLanguages = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<LanguagesResponse>(
      {url: `/v1/settings/languages`, method: 'GET', signal
    },
      options);
    }
  

export const getGetV1SettingsLanguagesQueryKey = () => {
    return [`/v1/settings/languages`] as const;
    }

    
export const getGetV1SettingsLanguagesQueryOptions = <TData = Awaited<ReturnType<typeof getV1SettingsLanguages>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1SettingsLanguages>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1SettingsLanguagesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1SettingsLanguages>>> = ({ signal }) => getV1SettingsLanguages(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1SettingsLanguages>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1SettingsLanguagesQueryResult = NonNullable<Awaited<ReturnType<typeof getV1SettingsLanguages>>>
export type GetV1SettingsLanguagesQueryError = unknown


export function useGetV1SettingsLanguages<TData = Awaited<ReturnType<typeof getV1SettingsLanguages>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1SettingsLanguages>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1SettingsLanguages>>,
          TError,
          Awaited<ReturnType<typeof getV1SettingsLanguages>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1SettingsLanguages<TData = Awaited<ReturnType<typeof getV1SettingsLanguages>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1SettingsLanguages>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1SettingsLanguages>>,
          TError,
          Awaited<ReturnType<typeof getV1SettingsLanguages>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1SettingsLanguages<TData = Awaited<ReturnType<typeof getV1SettingsLanguages>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1SettingsLanguages>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get available languages
 */

export function useGetV1SettingsLanguages<TData = Awaited<ReturnType<typeof getV1SettingsLanguages>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1SettingsLanguages>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1SettingsLanguagesQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Check if the authenticated user has a saved API key for the specified provider
 * @summary Check if user has API key for provider
 */
export const getV1SettingsApiKeyProvider = (
    provider: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<APIKeyAvailabilityResponse>(
      {url: `/v1/settings/api-key/${provider}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetV1SettingsApiKeyProviderQueryKey = (provider: string,) => {
    return [`/v1/settings/api-key/${provider}`] as const;
    }

    
export const getGetV1SettingsApiKeyProviderQueryOptions = <TData = Awaited<ReturnType<typeof getV1SettingsApiKeyProvider>>, TError = ErrorResponse>(provider: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1SettingsApiKeyProvider>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1SettingsApiKeyProviderQueryKey(provider);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1SettingsApiKeyProvider>>> = ({ signal }) => getV1SettingsApiKeyProvider(provider, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(provider), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1SettingsApiKeyProvider>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1SettingsApiKeyProviderQueryResult = NonNullable<Awaited<ReturnType<typeof getV1SettingsApiKeyProvider>>>
export type GetV1SettingsApiKeyProviderQueryError = ErrorResponse


export function useGetV1SettingsApiKeyProvider<TData = Awaited<ReturnType<typeof getV1SettingsApiKeyProvider>>, TError = ErrorResponse>(
 provider: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1SettingsApiKeyProvider>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1SettingsApiKeyProvider>>,
          TError,
          Awaited<ReturnType<typeof getV1SettingsApiKeyProvider>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1SettingsApiKeyProvider<TData = Awaited<ReturnType<typeof getV1SettingsApiKeyProvider>>, TError = ErrorResponse>(
 provider: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1SettingsApiKeyProvider>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1SettingsApiKeyProvider>>,
          TError,
          Awaited<ReturnType<typeof getV1SettingsApiKeyProvider>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1SettingsApiKeyProvider<TData = Awaited<ReturnType<typeof getV1SettingsApiKeyProvider>>, TError = ErrorResponse>(
 provider: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1SettingsApiKeyProvider>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Check if user has API key for provider
 */

export function useGetV1SettingsApiKeyProvider<TData = Awaited<ReturnType<typeof getV1SettingsApiKeyProvider>>, TError = ErrorResponse>(
 provider: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1SettingsApiKeyProvider>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1SettingsApiKeyProviderQueryOptions(provider,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Create a new AI conversation for the authenticated user
 * @summary Create a new AI conversation
 */
export const postV1AiConversations = (
    createConversationRequest: CreateConversationRequest,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<Conversation>(
      {url: `/v1/ai/conversations`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createConversationRequest, signal
    },
      options);
    }
  


export const getPostV1AiConversationsMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AiConversations>>, TError,{data: CreateConversationRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postV1AiConversations>>, TError,{data: CreateConversationRequest}, TContext> => {

const mutationKey = ['postV1AiConversations'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1AiConversations>>, {data: CreateConversationRequest}> = (props) => {
          const {data} = props ?? {};

          return  postV1AiConversations(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1AiConversationsMutationResult = NonNullable<Awaited<ReturnType<typeof postV1AiConversations>>>
    export type PostV1AiConversationsMutationBody = CreateConversationRequest
    export type PostV1AiConversationsMutationError = ErrorResponse

    /**
 * @summary Create a new AI conversation
 */
export const usePostV1AiConversations = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AiConversations>>, TError,{data: CreateConversationRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postV1AiConversations>>,
        TError,
        {data: CreateConversationRequest},
        TContext
      > => {

      const mutationOptions = getPostV1AiConversationsMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Retrieve a list of all AI conversations for the authenticated user
 * @summary List user's AI conversations
 */
export const getV1AiConversations = (
    params?: GetV1AiConversationsParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetV1AiConversations200>(
      {url: `/v1/ai/conversations`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetV1AiConversationsQueryKey = (params?: GetV1AiConversationsParams,) => {
    return [`/v1/ai/conversations`, ...(params ? [params]: [])] as const;
    }

    
export const getGetV1AiConversationsQueryOptions = <TData = Awaited<ReturnType<typeof getV1AiConversations>>, TError = ErrorResponse>(params?: GetV1AiConversationsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AiConversations>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AiConversationsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AiConversations>>> = ({ signal }) => getV1AiConversations(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AiConversations>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AiConversationsQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AiConversations>>>
export type GetV1AiConversationsQueryError = ErrorResponse


export function useGetV1AiConversations<TData = Awaited<ReturnType<typeof getV1AiConversations>>, TError = ErrorResponse>(
 params: undefined |  GetV1AiConversationsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AiConversations>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AiConversations>>,
          TError,
          Awaited<ReturnType<typeof getV1AiConversations>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AiConversations<TData = Awaited<ReturnType<typeof getV1AiConversations>>, TError = ErrorResponse>(
 params?: GetV1AiConversationsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AiConversations>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AiConversations>>,
          TError,
          Awaited<ReturnType<typeof getV1AiConversations>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AiConversations<TData = Awaited<ReturnType<typeof getV1AiConversations>>, TError = ErrorResponse>(
 params?: GetV1AiConversationsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AiConversations>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List user's AI conversations
 */

export function useGetV1AiConversations<TData = Awaited<ReturnType<typeof getV1AiConversations>>, TError = ErrorResponse>(
 params?: GetV1AiConversationsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AiConversations>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AiConversationsQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Retrieve a specific AI conversation and all its associated messages
 * @summary Get AI conversation with messages
 */
export const getV1AiConversationsId = (
    id: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<Conversation>(
      {url: `/v1/ai/conversations/${id}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetV1AiConversationsIdQueryKey = (id: string,) => {
    return [`/v1/ai/conversations/${id}`] as const;
    }

    
export const getGetV1AiConversationsIdQueryOptions = <TData = Awaited<ReturnType<typeof getV1AiConversationsId>>, TError = ErrorResponse>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AiConversationsId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AiConversationsIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AiConversationsId>>> = ({ signal }) => getV1AiConversationsId(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AiConversationsId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AiConversationsIdQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AiConversationsId>>>
export type GetV1AiConversationsIdQueryError = ErrorResponse


export function useGetV1AiConversationsId<TData = Awaited<ReturnType<typeof getV1AiConversationsId>>, TError = ErrorResponse>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AiConversationsId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AiConversationsId>>,
          TError,
          Awaited<ReturnType<typeof getV1AiConversationsId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AiConversationsId<TData = Awaited<ReturnType<typeof getV1AiConversationsId>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AiConversationsId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AiConversationsId>>,
          TError,
          Awaited<ReturnType<typeof getV1AiConversationsId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AiConversationsId<TData = Awaited<ReturnType<typeof getV1AiConversationsId>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AiConversationsId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get AI conversation with messages
 */

export function useGetV1AiConversationsId<TData = Awaited<ReturnType<typeof getV1AiConversationsId>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AiConversationsId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AiConversationsIdQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update an AI conversation (e.g., change its title)
 * @summary Update AI conversation
 */
export const putV1AiConversationsId = (
    id: string,
    updateConversationRequest: UpdateConversationRequest,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<Conversation>(
      {url: `/v1/ai/conversations/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: updateConversationRequest
    },
      options);
    }
  


export const getPutV1AiConversationsIdMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putV1AiConversationsId>>, TError,{id: string;data: UpdateConversationRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof putV1AiConversationsId>>, TError,{id: string;data: UpdateConversationRequest}, TContext> => {

const mutationKey = ['putV1AiConversationsId'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putV1AiConversationsId>>, {id: string;data: UpdateConversationRequest}> = (props) => {
          const {id,data} = props ?? {};

          return  putV1AiConversationsId(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PutV1AiConversationsIdMutationResult = NonNullable<Awaited<ReturnType<typeof putV1AiConversationsId>>>
    export type PutV1AiConversationsIdMutationBody = UpdateConversationRequest
    export type PutV1AiConversationsIdMutationError = ErrorResponse

    /**
 * @summary Update AI conversation
 */
export const usePutV1AiConversationsId = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putV1AiConversationsId>>, TError,{id: string;data: UpdateConversationRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof putV1AiConversationsId>>,
        TError,
        {id: string;data: UpdateConversationRequest},
        TContext
      > => {

      const mutationOptions = getPutV1AiConversationsIdMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Delete an AI conversation and all its associated messages
 * @summary Delete AI conversation
 */
export const deleteV1AiConversationsId = (
    id: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/v1/ai/conversations/${id}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteV1AiConversationsIdMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteV1AiConversationsId>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteV1AiConversationsId>>, TError,{id: string}, TContext> => {

const mutationKey = ['deleteV1AiConversationsId'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteV1AiConversationsId>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  deleteV1AiConversationsId(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteV1AiConversationsIdMutationResult = NonNullable<Awaited<ReturnType<typeof deleteV1AiConversationsId>>>
    
    export type DeleteV1AiConversationsIdMutationError = ErrorResponse

    /**
 * @summary Delete AI conversation
 */
export const useDeleteV1AiConversationsId = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteV1AiConversationsId>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteV1AiConversationsId>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getDeleteV1AiConversationsIdMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Add a new AI chat message to an existing conversation
 * @summary Add message to conversation
 */
export const postV1AiConversationsConversationIdMessages = (
    conversationId: string,
    createMessageRequest: CreateMessageRequest,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<ChatMessage>(
      {url: `/v1/ai/conversations/${conversationId}/messages`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createMessageRequest, signal
    },
      options);
    }
  


export const getPostV1AiConversationsConversationIdMessagesMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AiConversationsConversationIdMessages>>, TError,{conversationId: string;data: CreateMessageRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postV1AiConversationsConversationIdMessages>>, TError,{conversationId: string;data: CreateMessageRequest}, TContext> => {

const mutationKey = ['postV1AiConversationsConversationIdMessages'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1AiConversationsConversationIdMessages>>, {conversationId: string;data: CreateMessageRequest}> = (props) => {
          const {conversationId,data} = props ?? {};

          return  postV1AiConversationsConversationIdMessages(conversationId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1AiConversationsConversationIdMessagesMutationResult = NonNullable<Awaited<ReturnType<typeof postV1AiConversationsConversationIdMessages>>>
    export type PostV1AiConversationsConversationIdMessagesMutationBody = CreateMessageRequest
    export type PostV1AiConversationsConversationIdMessagesMutationError = ErrorResponse

    /**
 * @summary Add message to conversation
 */
export const usePostV1AiConversationsConversationIdMessages = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AiConversationsConversationIdMessages>>, TError,{conversationId: string;data: CreateMessageRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postV1AiConversationsConversationIdMessages>>,
        TError,
        {conversationId: string;data: CreateMessageRequest},
        TContext
      > => {

      const mutationOptions = getPostV1AiConversationsConversationIdMessagesMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Search across all AI conversations belonging to the authenticated user
 * @summary Search AI conversations
 */
export const getV1AiSearch = (
    params: GetV1AiSearchParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetV1AiSearch200>(
      {url: `/v1/ai/search`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetV1AiSearchQueryKey = (params: GetV1AiSearchParams,) => {
    return [`/v1/ai/search`, ...(params ? [params]: [])] as const;
    }

    
export const getGetV1AiSearchQueryOptions = <TData = Awaited<ReturnType<typeof getV1AiSearch>>, TError = ErrorResponse>(params: GetV1AiSearchParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AiSearch>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AiSearchQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AiSearch>>> = ({ signal }) => getV1AiSearch(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AiSearch>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AiSearchQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AiSearch>>>
export type GetV1AiSearchQueryError = ErrorResponse


export function useGetV1AiSearch<TData = Awaited<ReturnType<typeof getV1AiSearch>>, TError = ErrorResponse>(
 params: GetV1AiSearchParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AiSearch>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AiSearch>>,
          TError,
          Awaited<ReturnType<typeof getV1AiSearch>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AiSearch<TData = Awaited<ReturnType<typeof getV1AiSearch>>, TError = ErrorResponse>(
 params: GetV1AiSearchParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AiSearch>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AiSearch>>,
          TError,
          Awaited<ReturnType<typeof getV1AiSearch>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AiSearch<TData = Awaited<ReturnType<typeof getV1AiSearch>>, TError = ErrorResponse>(
 params: GetV1AiSearchParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AiSearch>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Search AI conversations
 */

export function useGetV1AiSearch<TData = Awaited<ReturnType<typeof getV1AiSearch>>, TError = ErrorResponse>(
 params: GetV1AiSearchParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AiSearch>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AiSearchQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Toggle the bookmark status of a specific message in a conversation
 * @summary Toggle message bookmark
 */
export const putV1AiConversationsBookmark = (
    putV1AiConversationsBookmarkBody: PutV1AiConversationsBookmarkBody,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<PutV1AiConversationsBookmark200>(
      {url: `/v1/ai/conversations/bookmark`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: putV1AiConversationsBookmarkBody
    },
      options);
    }
  


export const getPutV1AiConversationsBookmarkMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putV1AiConversationsBookmark>>, TError,{data: PutV1AiConversationsBookmarkBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof putV1AiConversationsBookmark>>, TError,{data: PutV1AiConversationsBookmarkBody}, TContext> => {

const mutationKey = ['putV1AiConversationsBookmark'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putV1AiConversationsBookmark>>, {data: PutV1AiConversationsBookmarkBody}> = (props) => {
          const {data} = props ?? {};

          return  putV1AiConversationsBookmark(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PutV1AiConversationsBookmarkMutationResult = NonNullable<Awaited<ReturnType<typeof putV1AiConversationsBookmark>>>
    export type PutV1AiConversationsBookmarkMutationBody = PutV1AiConversationsBookmarkBody
    export type PutV1AiConversationsBookmarkMutationError = ErrorResponse

    /**
 * @summary Toggle message bookmark
 */
export const usePutV1AiConversationsBookmark = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putV1AiConversationsBookmark>>, TError,{data: PutV1AiConversationsBookmarkBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof putV1AiConversationsBookmark>>,
        TError,
        {data: PutV1AiConversationsBookmarkBody},
        TContext
      > => {

      const mutationOptions = getPutV1AiConversationsBookmarkMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Update the profile of the currently authenticated user
 * @summary Update current user profile
 */
export const putV1UserzProfile = (
    userUpdateRequest: UserUpdateRequest,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<PutV1UserzProfile200>(
      {url: `/v1/userz/profile`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: userUpdateRequest
    },
      options);
    }
  


export const getPutV1UserzProfileMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putV1UserzProfile>>, TError,{data: UserUpdateRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof putV1UserzProfile>>, TError,{data: UserUpdateRequest}, TContext> => {

const mutationKey = ['putV1UserzProfile'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putV1UserzProfile>>, {data: UserUpdateRequest}> = (props) => {
          const {data} = props ?? {};

          return  putV1UserzProfile(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PutV1UserzProfileMutationResult = NonNullable<Awaited<ReturnType<typeof putV1UserzProfile>>>
    export type PutV1UserzProfileMutationBody = UserUpdateRequest
    export type PutV1UserzProfileMutationError = ErrorResponse

    /**
 * @summary Update current user profile
 */
export const usePutV1UserzProfile = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putV1UserzProfile>>, TError,{data: UserUpdateRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof putV1UserzProfile>>,
        TError,
        {data: UserUpdateRequest},
        TContext
      > => {

      const mutationOptions = getPutV1UserzProfileMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Get the backend admin interface HTML page (admin only)
 * @summary Get backend admin page
 */
export const getV1AdminBackend = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<string>(
      {url: `/v1/admin/backend`, method: 'GET', signal
    },
      options);
    }
  

export const getGetV1AdminBackendQueryKey = () => {
    return [`/v1/admin/backend`] as const;
    }

    
export const getGetV1AdminBackendQueryOptions = <TData = Awaited<ReturnType<typeof getV1AdminBackend>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackend>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AdminBackendQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AdminBackend>>> = ({ signal }) => getV1AdminBackend(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackend>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AdminBackendQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AdminBackend>>>
export type GetV1AdminBackendQueryError = ErrorResponse


export function useGetV1AdminBackend<TData = Awaited<ReturnType<typeof getV1AdminBackend>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackend>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminBackend>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminBackend>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminBackend<TData = Awaited<ReturnType<typeof getV1AdminBackend>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackend>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminBackend>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminBackend>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminBackend<TData = Awaited<ReturnType<typeof getV1AdminBackend>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackend>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get backend admin page
 */

export function useGetV1AdminBackend<TData = Awaited<ReturnType<typeof getV1AdminBackend>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackend>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AdminBackendQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get a list of all users (admin only)
 * @summary List all users
 */
export const getV1AdminBackendUserz = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetV1AdminBackendUserz200>(
      {url: `/v1/admin/backend/userz`, method: 'GET', signal
    },
      options);
    }
  

export const getGetV1AdminBackendUserzQueryKey = () => {
    return [`/v1/admin/backend/userz`] as const;
    }

    
export const getGetV1AdminBackendUserzQueryOptions = <TData = Awaited<ReturnType<typeof getV1AdminBackendUserz>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendUserz>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AdminBackendUserzQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AdminBackendUserz>>> = ({ signal }) => getV1AdminBackendUserz(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendUserz>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AdminBackendUserzQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AdminBackendUserz>>>
export type GetV1AdminBackendUserzQueryError = ErrorResponse


export function useGetV1AdminBackendUserz<TData = Awaited<ReturnType<typeof getV1AdminBackendUserz>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendUserz>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminBackendUserz>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminBackendUserz>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminBackendUserz<TData = Awaited<ReturnType<typeof getV1AdminBackendUserz>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendUserz>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminBackendUserz>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminBackendUserz>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminBackendUserz<TData = Awaited<ReturnType<typeof getV1AdminBackendUserz>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendUserz>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List all users
 */

export function useGetV1AdminBackendUserz<TData = Awaited<ReturnType<typeof getV1AdminBackendUserz>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendUserz>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AdminBackendUserzQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Create a new user account (admin only)
 * @summary Create a new user
 */
export const postV1AdminBackendUserz = (
    postV1AdminBackendUserzBody: PostV1AdminBackendUserzBody,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<PostV1AdminBackendUserz201>(
      {url: `/v1/admin/backend/userz`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: postV1AdminBackendUserzBody, signal
    },
      options);
    }
  


export const getPostV1AdminBackendUserzMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AdminBackendUserz>>, TError,{data: PostV1AdminBackendUserzBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postV1AdminBackendUserz>>, TError,{data: PostV1AdminBackendUserzBody}, TContext> => {

const mutationKey = ['postV1AdminBackendUserz'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1AdminBackendUserz>>, {data: PostV1AdminBackendUserzBody}> = (props) => {
          const {data} = props ?? {};

          return  postV1AdminBackendUserz(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1AdminBackendUserzMutationResult = NonNullable<Awaited<ReturnType<typeof postV1AdminBackendUserz>>>
    export type PostV1AdminBackendUserzMutationBody = PostV1AdminBackendUserzBody
    export type PostV1AdminBackendUserzMutationError = ErrorResponse

    /**
 * @summary Create a new user
 */
export const usePostV1AdminBackendUserz = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AdminBackendUserz>>, TError,{data: PostV1AdminBackendUserzBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postV1AdminBackendUserz>>,
        TError,
        {data: PostV1AdminBackendUserzBody},
        TContext
      > => {

      const mutationOptions = getPostV1AdminBackendUserzMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Permanently deletes all stories, sections, and story-generated questions belonging to the authenticated user. This action is irreversible.
 * @summary Delete all stories for the authenticated user
 */
export const postV1SettingsClearStories = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<SuccessResponse>(
      {url: `/v1/settings/clear-stories`, method: 'POST', signal
    },
      options);
    }
  


export const getPostV1SettingsClearStoriesMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1SettingsClearStories>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postV1SettingsClearStories>>, TError,void, TContext> => {

const mutationKey = ['postV1SettingsClearStories'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1SettingsClearStories>>, void> = () => {
          

          return  postV1SettingsClearStories(requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1SettingsClearStoriesMutationResult = NonNullable<Awaited<ReturnType<typeof postV1SettingsClearStories>>>
    
    export type PostV1SettingsClearStoriesMutationError = ErrorResponse

    /**
 * @summary Delete all stories for the authenticated user
 */
export const usePostV1SettingsClearStories = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1SettingsClearStories>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postV1SettingsClearStories>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getPostV1SettingsClearStoriesMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Clears the authenticated user's activity (questions, responses, performance metrics) and deletes all stories. This is irreversible.
 * @summary Reset the authenticated user's account
 */
export const postV1SettingsResetAccount = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<SuccessResponse>(
      {url: `/v1/settings/reset-account`, method: 'POST', signal
    },
      options);
    }
  


export const getPostV1SettingsResetAccountMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1SettingsResetAccount>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postV1SettingsResetAccount>>, TError,void, TContext> => {

const mutationKey = ['postV1SettingsResetAccount'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1SettingsResetAccount>>, void> = () => {
          

          return  postV1SettingsResetAccount(requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1SettingsResetAccountMutationResult = NonNullable<Awaited<ReturnType<typeof postV1SettingsResetAccount>>>
    
    export type PostV1SettingsResetAccountMutationError = ErrorResponse

    /**
 * @summary Reset the authenticated user's account
 */
export const usePostV1SettingsResetAccount = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1SettingsResetAccount>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postV1SettingsResetAccount>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getPostV1SettingsResetAccountMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Permanently deletes all AI conversations and their associated messages belonging to the authenticated user. This action is irreversible.
 * @summary Delete all AI chats for the authenticated user
 */
export const postV1SettingsClearAiChats = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<SuccessResponse>(
      {url: `/v1/settings/clear-ai-chats`, method: 'POST', signal
    },
      options);
    }
  


export const getPostV1SettingsClearAiChatsMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1SettingsClearAiChats>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postV1SettingsClearAiChats>>, TError,void, TContext> => {

const mutationKey = ['postV1SettingsClearAiChats'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1SettingsClearAiChats>>, void> = () => {
          

          return  postV1SettingsClearAiChats(requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1SettingsClearAiChatsMutationResult = NonNullable<Awaited<ReturnType<typeof postV1SettingsClearAiChats>>>
    
    export type PostV1SettingsClearAiChatsMutationError = ErrorResponse

    /**
 * @summary Delete all AI chats for the authenticated user
 */
export const usePostV1SettingsClearAiChats = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1SettingsClearAiChats>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postV1SettingsClearAiChats>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getPostV1SettingsClearAiChatsMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Get paginated users with search and filtering options (admin only)
 * @summary Get paginated users with filtering
 */
export const getV1AdminBackendUserzPaginated = (
    params?: GetV1AdminBackendUserzPaginatedParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetV1AdminBackendUserzPaginated200>(
      {url: `/v1/admin/backend/userz/paginated`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetV1AdminBackendUserzPaginatedQueryKey = (params?: GetV1AdminBackendUserzPaginatedParams,) => {
    return [`/v1/admin/backend/userz/paginated`, ...(params ? [params]: [])] as const;
    }

    
export const getGetV1AdminBackendUserzPaginatedQueryOptions = <TData = Awaited<ReturnType<typeof getV1AdminBackendUserzPaginated>>, TError = ErrorResponse>(params?: GetV1AdminBackendUserzPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendUserzPaginated>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AdminBackendUserzPaginatedQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AdminBackendUserzPaginated>>> = ({ signal }) => getV1AdminBackendUserzPaginated(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendUserzPaginated>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AdminBackendUserzPaginatedQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AdminBackendUserzPaginated>>>
export type GetV1AdminBackendUserzPaginatedQueryError = ErrorResponse


export function useGetV1AdminBackendUserzPaginated<TData = Awaited<ReturnType<typeof getV1AdminBackendUserzPaginated>>, TError = ErrorResponse>(
 params: undefined |  GetV1AdminBackendUserzPaginatedParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendUserzPaginated>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminBackendUserzPaginated>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminBackendUserzPaginated>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminBackendUserzPaginated<TData = Awaited<ReturnType<typeof getV1AdminBackendUserzPaginated>>, TError = ErrorResponse>(
 params?: GetV1AdminBackendUserzPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendUserzPaginated>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminBackendUserzPaginated>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminBackendUserzPaginated>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminBackendUserzPaginated<TData = Awaited<ReturnType<typeof getV1AdminBackendUserzPaginated>>, TError = ErrorResponse>(
 params?: GetV1AdminBackendUserzPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendUserzPaginated>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get paginated users with filtering
 */

export function useGetV1AdminBackendUserzPaginated<TData = Awaited<ReturnType<typeof getV1AdminBackendUserzPaginated>>, TError = ErrorResponse>(
 params?: GetV1AdminBackendUserzPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendUserzPaginated>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AdminBackendUserzPaginatedQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update user details (admin only)
 * @summary Update user details
 */
export const putV1AdminBackendUserzId = (
    id: number,
    userUpdateRequest: UserUpdateRequest,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<PutV1AdminBackendUserzId200>(
      {url: `/v1/admin/backend/userz/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: userUpdateRequest
    },
      options);
    }
  


export const getPutV1AdminBackendUserzIdMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putV1AdminBackendUserzId>>, TError,{id: number;data: UserUpdateRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof putV1AdminBackendUserzId>>, TError,{id: number;data: UserUpdateRequest}, TContext> => {

const mutationKey = ['putV1AdminBackendUserzId'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putV1AdminBackendUserzId>>, {id: number;data: UserUpdateRequest}> = (props) => {
          const {id,data} = props ?? {};

          return  putV1AdminBackendUserzId(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PutV1AdminBackendUserzIdMutationResult = NonNullable<Awaited<ReturnType<typeof putV1AdminBackendUserzId>>>
    export type PutV1AdminBackendUserzIdMutationBody = UserUpdateRequest
    export type PutV1AdminBackendUserzIdMutationError = ErrorResponse

    /**
 * @summary Update user details
 */
export const usePutV1AdminBackendUserzId = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putV1AdminBackendUserzId>>, TError,{id: number;data: UserUpdateRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof putV1AdminBackendUserzId>>,
        TError,
        {id: number;data: UserUpdateRequest},
        TContext
      > => {

      const mutationOptions = getPutV1AdminBackendUserzIdMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Delete a user (admin only)
 * @summary Delete user
 */
export const deleteV1AdminBackendUserzId = (
    id: number,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<DeleteV1AdminBackendUserzId200>(
      {url: `/v1/admin/backend/userz/${id}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteV1AdminBackendUserzIdMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteV1AdminBackendUserzId>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteV1AdminBackendUserzId>>, TError,{id: number}, TContext> => {

const mutationKey = ['deleteV1AdminBackendUserzId'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteV1AdminBackendUserzId>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteV1AdminBackendUserzId(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteV1AdminBackendUserzIdMutationResult = NonNullable<Awaited<ReturnType<typeof deleteV1AdminBackendUserzId>>>
    
    export type DeleteV1AdminBackendUserzIdMutationError = ErrorResponse

    /**
 * @summary Delete user
 */
export const useDeleteV1AdminBackendUserzId = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteV1AdminBackendUserzId>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteV1AdminBackendUserzId>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteV1AdminBackendUserzIdMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Reset a user's password (admin only)
 * @summary Reset user password
 */
export const postV1AdminBackendUserzIdResetPassword = (
    id: number,
    passwordResetRequest: PasswordResetRequest,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<PostV1AdminBackendUserzIdResetPassword200>(
      {url: `/v1/admin/backend/userz/${id}/reset-password`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: passwordResetRequest, signal
    },
      options);
    }
  


export const getPostV1AdminBackendUserzIdResetPasswordMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AdminBackendUserzIdResetPassword>>, TError,{id: number;data: PasswordResetRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postV1AdminBackendUserzIdResetPassword>>, TError,{id: number;data: PasswordResetRequest}, TContext> => {

const mutationKey = ['postV1AdminBackendUserzIdResetPassword'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1AdminBackendUserzIdResetPassword>>, {id: number;data: PasswordResetRequest}> = (props) => {
          const {id,data} = props ?? {};

          return  postV1AdminBackendUserzIdResetPassword(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1AdminBackendUserzIdResetPasswordMutationResult = NonNullable<Awaited<ReturnType<typeof postV1AdminBackendUserzIdResetPassword>>>
    export type PostV1AdminBackendUserzIdResetPasswordMutationBody = PasswordResetRequest
    export type PostV1AdminBackendUserzIdResetPasswordMutationError = ErrorResponse

    /**
 * @summary Reset user password
 */
export const usePostV1AdminBackendUserzIdResetPassword = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AdminBackendUserzIdResetPassword>>, TError,{id: number;data: PasswordResetRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postV1AdminBackendUserzIdResetPassword>>,
        TError,
        {id: number;data: PasswordResetRequest},
        TContext
      > => {

      const mutationOptions = getPostV1AdminBackendUserzIdResetPasswordMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Get all available roles in the system (admin only)
 * @summary Get all roles
 */
export const getV1AdminBackendRoles = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetV1AdminBackendRoles200>(
      {url: `/v1/admin/backend/roles`, method: 'GET', signal
    },
      options);
    }
  

export const getGetV1AdminBackendRolesQueryKey = () => {
    return [`/v1/admin/backend/roles`] as const;
    }

    
export const getGetV1AdminBackendRolesQueryOptions = <TData = Awaited<ReturnType<typeof getV1AdminBackendRoles>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendRoles>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AdminBackendRolesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AdminBackendRoles>>> = ({ signal }) => getV1AdminBackendRoles(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendRoles>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AdminBackendRolesQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AdminBackendRoles>>>
export type GetV1AdminBackendRolesQueryError = ErrorResponse


export function useGetV1AdminBackendRoles<TData = Awaited<ReturnType<typeof getV1AdminBackendRoles>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendRoles>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminBackendRoles>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminBackendRoles>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminBackendRoles<TData = Awaited<ReturnType<typeof getV1AdminBackendRoles>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendRoles>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminBackendRoles>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminBackendRoles>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminBackendRoles<TData = Awaited<ReturnType<typeof getV1AdminBackendRoles>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendRoles>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get all roles
 */

export function useGetV1AdminBackendRoles<TData = Awaited<ReturnType<typeof getV1AdminBackendRoles>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendRoles>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AdminBackendRolesQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get all roles for a specific user (admin only)
 * @summary Get user roles
 */
export const getV1AdminBackendUserzIdRoles = (
    id: number,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetV1AdminBackendUserzIdRoles200>(
      {url: `/v1/admin/backend/userz/${id}/roles`, method: 'GET', signal
    },
      options);
    }
  

export const getGetV1AdminBackendUserzIdRolesQueryKey = (id: number,) => {
    return [`/v1/admin/backend/userz/${id}/roles`] as const;
    }

    
export const getGetV1AdminBackendUserzIdRolesQueryOptions = <TData = Awaited<ReturnType<typeof getV1AdminBackendUserzIdRoles>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendUserzIdRoles>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AdminBackendUserzIdRolesQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AdminBackendUserzIdRoles>>> = ({ signal }) => getV1AdminBackendUserzIdRoles(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendUserzIdRoles>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AdminBackendUserzIdRolesQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AdminBackendUserzIdRoles>>>
export type GetV1AdminBackendUserzIdRolesQueryError = ErrorResponse


export function useGetV1AdminBackendUserzIdRoles<TData = Awaited<ReturnType<typeof getV1AdminBackendUserzIdRoles>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendUserzIdRoles>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminBackendUserzIdRoles>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminBackendUserzIdRoles>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminBackendUserzIdRoles<TData = Awaited<ReturnType<typeof getV1AdminBackendUserzIdRoles>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendUserzIdRoles>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminBackendUserzIdRoles>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminBackendUserzIdRoles>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminBackendUserzIdRoles<TData = Awaited<ReturnType<typeof getV1AdminBackendUserzIdRoles>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendUserzIdRoles>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get user roles
 */

export function useGetV1AdminBackendUserzIdRoles<TData = Awaited<ReturnType<typeof getV1AdminBackendUserzIdRoles>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendUserzIdRoles>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AdminBackendUserzIdRolesQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Assign a role to a specific user (admin only)
 * @summary Assign role to user
 */
export const postV1AdminBackendUserzIdRoles = (
    id: number,
    postV1AdminBackendUserzIdRolesBody: PostV1AdminBackendUserzIdRolesBody,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<PostV1AdminBackendUserzIdRoles200>(
      {url: `/v1/admin/backend/userz/${id}/roles`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: postV1AdminBackendUserzIdRolesBody, signal
    },
      options);
    }
  


export const getPostV1AdminBackendUserzIdRolesMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AdminBackendUserzIdRoles>>, TError,{id: number;data: PostV1AdminBackendUserzIdRolesBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postV1AdminBackendUserzIdRoles>>, TError,{id: number;data: PostV1AdminBackendUserzIdRolesBody}, TContext> => {

const mutationKey = ['postV1AdminBackendUserzIdRoles'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1AdminBackendUserzIdRoles>>, {id: number;data: PostV1AdminBackendUserzIdRolesBody}> = (props) => {
          const {id,data} = props ?? {};

          return  postV1AdminBackendUserzIdRoles(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1AdminBackendUserzIdRolesMutationResult = NonNullable<Awaited<ReturnType<typeof postV1AdminBackendUserzIdRoles>>>
    export type PostV1AdminBackendUserzIdRolesMutationBody = PostV1AdminBackendUserzIdRolesBody
    export type PostV1AdminBackendUserzIdRolesMutationError = ErrorResponse

    /**
 * @summary Assign role to user
 */
export const usePostV1AdminBackendUserzIdRoles = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AdminBackendUserzIdRoles>>, TError,{id: number;data: PostV1AdminBackendUserzIdRolesBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postV1AdminBackendUserzIdRoles>>,
        TError,
        {id: number;data: PostV1AdminBackendUserzIdRolesBody},
        TContext
      > => {

      const mutationOptions = getPostV1AdminBackendUserzIdRolesMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Remove a role from a specific user (admin only)
 * @summary Remove role from user
 */
export const deleteV1AdminBackendUserzIdRolesRoleId = (
    id: number,
    roleId: number,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<DeleteV1AdminBackendUserzIdRolesRoleId200>(
      {url: `/v1/admin/backend/userz/${id}/roles/${roleId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteV1AdminBackendUserzIdRolesRoleIdMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteV1AdminBackendUserzIdRolesRoleId>>, TError,{id: number;roleId: number}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteV1AdminBackendUserzIdRolesRoleId>>, TError,{id: number;roleId: number}, TContext> => {

const mutationKey = ['deleteV1AdminBackendUserzIdRolesRoleId'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteV1AdminBackendUserzIdRolesRoleId>>, {id: number;roleId: number}> = (props) => {
          const {id,roleId} = props ?? {};

          return  deleteV1AdminBackendUserzIdRolesRoleId(id,roleId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteV1AdminBackendUserzIdRolesRoleIdMutationResult = NonNullable<Awaited<ReturnType<typeof deleteV1AdminBackendUserzIdRolesRoleId>>>
    
    export type DeleteV1AdminBackendUserzIdRolesRoleIdMutationError = ErrorResponse

    /**
 * @summary Remove role from user
 */
export const useDeleteV1AdminBackendUserzIdRolesRoleId = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteV1AdminBackendUserzIdRolesRoleId>>, TError,{id: number;roleId: number}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteV1AdminBackendUserzIdRolesRoleId>>,
        TError,
        {id: number;roleId: number},
        TContext
      > => {

      const mutationOptions = getDeleteV1AdminBackendUserzIdRolesRoleIdMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Get comprehensive admin dashboard data including user stats, worker health, and AI concurrency (admin only)
 * @summary Get backend admin dashboard data
 */
export const getV1AdminBackendDashboard = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<DashboardResponse>(
      {url: `/v1/admin/backend/dashboard`, method: 'GET', signal
    },
      options);
    }
  

export const getGetV1AdminBackendDashboardQueryKey = () => {
    return [`/v1/admin/backend/dashboard`] as const;
    }

    
export const getGetV1AdminBackendDashboardQueryOptions = <TData = Awaited<ReturnType<typeof getV1AdminBackendDashboard>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendDashboard>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AdminBackendDashboardQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AdminBackendDashboard>>> = ({ signal }) => getV1AdminBackendDashboard(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendDashboard>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AdminBackendDashboardQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AdminBackendDashboard>>>
export type GetV1AdminBackendDashboardQueryError = ErrorResponse


export function useGetV1AdminBackendDashboard<TData = Awaited<ReturnType<typeof getV1AdminBackendDashboard>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendDashboard>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminBackendDashboard>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminBackendDashboard>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminBackendDashboard<TData = Awaited<ReturnType<typeof getV1AdminBackendDashboard>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendDashboard>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminBackendDashboard>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminBackendDashboard>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminBackendDashboard<TData = Awaited<ReturnType<typeof getV1AdminBackendDashboard>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendDashboard>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get backend admin dashboard data
 */

export function useGetV1AdminBackendDashboard<TData = Awaited<ReturnType<typeof getV1AdminBackendDashboard>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendDashboard>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AdminBackendDashboardQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get real-time AI concurrency statistics (admin only)
 * @summary Get AI concurrency statistics
 */
export const getV1AdminBackendAiConcurrency = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<AIConcurrencyStats>(
      {url: `/v1/admin/backend/ai-concurrency`, method: 'GET', signal
    },
      options);
    }
  

export const getGetV1AdminBackendAiConcurrencyQueryKey = () => {
    return [`/v1/admin/backend/ai-concurrency`] as const;
    }

    
export const getGetV1AdminBackendAiConcurrencyQueryOptions = <TData = Awaited<ReturnType<typeof getV1AdminBackendAiConcurrency>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendAiConcurrency>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AdminBackendAiConcurrencyQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AdminBackendAiConcurrency>>> = ({ signal }) => getV1AdminBackendAiConcurrency(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendAiConcurrency>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AdminBackendAiConcurrencyQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AdminBackendAiConcurrency>>>
export type GetV1AdminBackendAiConcurrencyQueryError = ErrorResponse


export function useGetV1AdminBackendAiConcurrency<TData = Awaited<ReturnType<typeof getV1AdminBackendAiConcurrency>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendAiConcurrency>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminBackendAiConcurrency>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminBackendAiConcurrency>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminBackendAiConcurrency<TData = Awaited<ReturnType<typeof getV1AdminBackendAiConcurrency>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendAiConcurrency>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminBackendAiConcurrency>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminBackendAiConcurrency>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminBackendAiConcurrency<TData = Awaited<ReturnType<typeof getV1AdminBackendAiConcurrency>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendAiConcurrency>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get AI concurrency statistics
 */

export function useGetV1AdminBackendAiConcurrency<TData = Awaited<ReturnType<typeof getV1AdminBackendAiConcurrency>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendAiConcurrency>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AdminBackendAiConcurrencyQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get the current status of the worker (admin only)
 * @summary Get worker status
 */
export const getV1AdminWorkerStatus = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<WorkerStatus>(
      {url: `/v1/admin/worker/status`, method: 'GET', signal
    },
      options);
    }
  

export const getGetV1AdminWorkerStatusQueryKey = () => {
    return [`/v1/admin/worker/status`] as const;
    }

    
export const getGetV1AdminWorkerStatusQueryOptions = <TData = Awaited<ReturnType<typeof getV1AdminWorkerStatus>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerStatus>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AdminWorkerStatusQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AdminWorkerStatus>>> = ({ signal }) => getV1AdminWorkerStatus(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerStatus>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AdminWorkerStatusQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AdminWorkerStatus>>>
export type GetV1AdminWorkerStatusQueryError = ErrorResponse


export function useGetV1AdminWorkerStatus<TData = Awaited<ReturnType<typeof getV1AdminWorkerStatus>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerStatus>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminWorkerStatus>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminWorkerStatus>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminWorkerStatus<TData = Awaited<ReturnType<typeof getV1AdminWorkerStatus>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerStatus>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminWorkerStatus>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminWorkerStatus>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminWorkerStatus<TData = Awaited<ReturnType<typeof getV1AdminWorkerStatus>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerStatus>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get worker status
 */

export function useGetV1AdminWorkerStatus<TData = Awaited<ReturnType<typeof getV1AdminWorkerStatus>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerStatus>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AdminWorkerStatusQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get detailed information about the worker (admin only)
 * @summary Get worker details
 */
export const getV1AdminWorkerDetails = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetV1AdminWorkerDetails200>(
      {url: `/v1/admin/worker/details`, method: 'GET', signal
    },
      options);
    }
  

export const getGetV1AdminWorkerDetailsQueryKey = () => {
    return [`/v1/admin/worker/details`] as const;
    }

    
export const getGetV1AdminWorkerDetailsQueryOptions = <TData = Awaited<ReturnType<typeof getV1AdminWorkerDetails>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerDetails>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AdminWorkerDetailsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AdminWorkerDetails>>> = ({ signal }) => getV1AdminWorkerDetails(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerDetails>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AdminWorkerDetailsQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AdminWorkerDetails>>>
export type GetV1AdminWorkerDetailsQueryError = ErrorResponse


export function useGetV1AdminWorkerDetails<TData = Awaited<ReturnType<typeof getV1AdminWorkerDetails>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerDetails>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminWorkerDetails>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminWorkerDetails>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminWorkerDetails<TData = Awaited<ReturnType<typeof getV1AdminWorkerDetails>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerDetails>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminWorkerDetails>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminWorkerDetails>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminWorkerDetails<TData = Awaited<ReturnType<typeof getV1AdminWorkerDetails>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerDetails>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get worker details
 */

export function useGetV1AdminWorkerDetails<TData = Awaited<ReturnType<typeof getV1AdminWorkerDetails>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerDetails>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AdminWorkerDetailsQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Pause the worker (admin only)
 * @summary Pause worker
 */
export const postV1AdminWorkerPause = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<PostV1AdminWorkerPause200>(
      {url: `/v1/admin/worker/pause`, method: 'POST', signal
    },
      options);
    }
  


export const getPostV1AdminWorkerPauseMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AdminWorkerPause>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postV1AdminWorkerPause>>, TError,void, TContext> => {

const mutationKey = ['postV1AdminWorkerPause'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1AdminWorkerPause>>, void> = () => {
          

          return  postV1AdminWorkerPause(requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1AdminWorkerPauseMutationResult = NonNullable<Awaited<ReturnType<typeof postV1AdminWorkerPause>>>
    
    export type PostV1AdminWorkerPauseMutationError = ErrorResponse

    /**
 * @summary Pause worker
 */
export const usePostV1AdminWorkerPause = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AdminWorkerPause>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postV1AdminWorkerPause>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getPostV1AdminWorkerPauseMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Resume the worker (admin only)
 * @summary Resume worker
 */
export const postV1AdminWorkerResume = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<PostV1AdminWorkerResume200>(
      {url: `/v1/admin/worker/resume`, method: 'POST', signal
    },
      options);
    }
  


export const getPostV1AdminWorkerResumeMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AdminWorkerResume>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postV1AdminWorkerResume>>, TError,void, TContext> => {

const mutationKey = ['postV1AdminWorkerResume'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1AdminWorkerResume>>, void> = () => {
          

          return  postV1AdminWorkerResume(requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1AdminWorkerResumeMutationResult = NonNullable<Awaited<ReturnType<typeof postV1AdminWorkerResume>>>
    
    export type PostV1AdminWorkerResumeMutationError = ErrorResponse

    /**
 * @summary Resume worker
 */
export const usePostV1AdminWorkerResume = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AdminWorkerResume>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postV1AdminWorkerResume>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getPostV1AdminWorkerResumeMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Trigger a manual worker run (admin only)
 * @summary Trigger worker run
 */
export const postV1AdminWorkerTrigger = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<PostV1AdminWorkerTrigger200>(
      {url: `/v1/admin/worker/trigger`, method: 'POST', signal
    },
      options);
    }
  


export const getPostV1AdminWorkerTriggerMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AdminWorkerTrigger>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postV1AdminWorkerTrigger>>, TError,void, TContext> => {

const mutationKey = ['postV1AdminWorkerTrigger'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1AdminWorkerTrigger>>, void> = () => {
          

          return  postV1AdminWorkerTrigger(requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1AdminWorkerTriggerMutationResult = NonNullable<Awaited<ReturnType<typeof postV1AdminWorkerTrigger>>>
    
    export type PostV1AdminWorkerTriggerMutationError = ErrorResponse

    /**
 * @summary Trigger worker run
 */
export const usePostV1AdminWorkerTrigger = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AdminWorkerTrigger>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postV1AdminWorkerTrigger>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getPostV1AdminWorkerTriggerMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Get worker activity logs (admin only)
 * @summary Get worker logs
 */
export const getV1AdminWorkerLogs = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetV1AdminWorkerLogs200>(
      {url: `/v1/admin/worker/logs`, method: 'GET', signal
    },
      options);
    }
  

export const getGetV1AdminWorkerLogsQueryKey = () => {
    return [`/v1/admin/worker/logs`] as const;
    }

    
export const getGetV1AdminWorkerLogsQueryOptions = <TData = Awaited<ReturnType<typeof getV1AdminWorkerLogs>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerLogs>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AdminWorkerLogsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AdminWorkerLogs>>> = ({ signal }) => getV1AdminWorkerLogs(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerLogs>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AdminWorkerLogsQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AdminWorkerLogs>>>
export type GetV1AdminWorkerLogsQueryError = ErrorResponse


export function useGetV1AdminWorkerLogs<TData = Awaited<ReturnType<typeof getV1AdminWorkerLogs>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerLogs>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminWorkerLogs>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminWorkerLogs>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminWorkerLogs<TData = Awaited<ReturnType<typeof getV1AdminWorkerLogs>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerLogs>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminWorkerLogs>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminWorkerLogs>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminWorkerLogs<TData = Awaited<ReturnType<typeof getV1AdminWorkerLogs>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerLogs>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get worker logs
 */

export function useGetV1AdminWorkerLogs<TData = Awaited<ReturnType<typeof getV1AdminWorkerLogs>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerLogs>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AdminWorkerLogsQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get AI concurrency statistics from the worker (admin only)
 * @summary Get worker AI concurrency statistics
 */
export const getV1AdminWorkerAiConcurrency = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetV1AdminWorkerAiConcurrency200>(
      {url: `/v1/admin/worker/ai-concurrency`, method: 'GET', signal
    },
      options);
    }
  

export const getGetV1AdminWorkerAiConcurrencyQueryKey = () => {
    return [`/v1/admin/worker/ai-concurrency`] as const;
    }

    
export const getGetV1AdminWorkerAiConcurrencyQueryOptions = <TData = Awaited<ReturnType<typeof getV1AdminWorkerAiConcurrency>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerAiConcurrency>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AdminWorkerAiConcurrencyQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AdminWorkerAiConcurrency>>> = ({ signal }) => getV1AdminWorkerAiConcurrency(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerAiConcurrency>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AdminWorkerAiConcurrencyQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AdminWorkerAiConcurrency>>>
export type GetV1AdminWorkerAiConcurrencyQueryError = ErrorResponse


export function useGetV1AdminWorkerAiConcurrency<TData = Awaited<ReturnType<typeof getV1AdminWorkerAiConcurrency>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerAiConcurrency>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminWorkerAiConcurrency>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminWorkerAiConcurrency>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminWorkerAiConcurrency<TData = Awaited<ReturnType<typeof getV1AdminWorkerAiConcurrency>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerAiConcurrency>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminWorkerAiConcurrency>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminWorkerAiConcurrency>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminWorkerAiConcurrency<TData = Awaited<ReturnType<typeof getV1AdminWorkerAiConcurrency>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerAiConcurrency>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get worker AI concurrency statistics
 */

export function useGetV1AdminWorkerAiConcurrency<TData = Awaited<ReturnType<typeof getV1AdminWorkerAiConcurrency>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerAiConcurrency>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AdminWorkerAiConcurrencyQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get list of users with their worker pause status (admin only)
 * @summary Get worker user list with pause status
 */
export const getV1AdminWorkerUsers = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetV1AdminWorkerUsers200>(
      {url: `/v1/admin/worker/users`, method: 'GET', signal
    },
      options);
    }
  

export const getGetV1AdminWorkerUsersQueryKey = () => {
    return [`/v1/admin/worker/users`] as const;
    }

    
export const getGetV1AdminWorkerUsersQueryOptions = <TData = Awaited<ReturnType<typeof getV1AdminWorkerUsers>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerUsers>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AdminWorkerUsersQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AdminWorkerUsers>>> = ({ signal }) => getV1AdminWorkerUsers(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerUsers>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AdminWorkerUsersQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AdminWorkerUsers>>>
export type GetV1AdminWorkerUsersQueryError = ErrorResponse


export function useGetV1AdminWorkerUsers<TData = Awaited<ReturnType<typeof getV1AdminWorkerUsers>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerUsers>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminWorkerUsers>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminWorkerUsers>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminWorkerUsers<TData = Awaited<ReturnType<typeof getV1AdminWorkerUsers>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerUsers>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminWorkerUsers>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminWorkerUsers>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminWorkerUsers<TData = Awaited<ReturnType<typeof getV1AdminWorkerUsers>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerUsers>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get worker user list with pause status
 */

export function useGetV1AdminWorkerUsers<TData = Awaited<ReturnType<typeof getV1AdminWorkerUsers>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerUsers>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AdminWorkerUsersQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Pause question generation for a specific user (admin only)
 * @summary Pause worker for a specific user
 */
export const postV1AdminWorkerUsersPause = (
    userIdRequest: UserIdRequest,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<PostV1AdminWorkerUsersPause200>(
      {url: `/v1/admin/worker/users/pause`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: userIdRequest, signal
    },
      options);
    }
  


export const getPostV1AdminWorkerUsersPauseMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AdminWorkerUsersPause>>, TError,{data: UserIdRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postV1AdminWorkerUsersPause>>, TError,{data: UserIdRequest}, TContext> => {

const mutationKey = ['postV1AdminWorkerUsersPause'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1AdminWorkerUsersPause>>, {data: UserIdRequest}> = (props) => {
          const {data} = props ?? {};

          return  postV1AdminWorkerUsersPause(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1AdminWorkerUsersPauseMutationResult = NonNullable<Awaited<ReturnType<typeof postV1AdminWorkerUsersPause>>>
    export type PostV1AdminWorkerUsersPauseMutationBody = UserIdRequest
    export type PostV1AdminWorkerUsersPauseMutationError = ErrorResponse

    /**
 * @summary Pause worker for a specific user
 */
export const usePostV1AdminWorkerUsersPause = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AdminWorkerUsersPause>>, TError,{data: UserIdRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postV1AdminWorkerUsersPause>>,
        TError,
        {data: UserIdRequest},
        TContext
      > => {

      const mutationOptions = getPostV1AdminWorkerUsersPauseMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Resume question generation for a specific user (admin only)
 * @summary Resume worker for a specific user
 */
export const postV1AdminWorkerUsersResume = (
    userIdRequest: UserIdRequest,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<PostV1AdminWorkerUsersResume200>(
      {url: `/v1/admin/worker/users/resume`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: userIdRequest, signal
    },
      options);
    }
  


export const getPostV1AdminWorkerUsersResumeMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AdminWorkerUsersResume>>, TError,{data: UserIdRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postV1AdminWorkerUsersResume>>, TError,{data: UserIdRequest}, TContext> => {

const mutationKey = ['postV1AdminWorkerUsersResume'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1AdminWorkerUsersResume>>, {data: UserIdRequest}> = (props) => {
          const {data} = props ?? {};

          return  postV1AdminWorkerUsersResume(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1AdminWorkerUsersResumeMutationResult = NonNullable<Awaited<ReturnType<typeof postV1AdminWorkerUsersResume>>>
    export type PostV1AdminWorkerUsersResumeMutationBody = UserIdRequest
    export type PostV1AdminWorkerUsersResumeMutationError = ErrorResponse

    /**
 * @summary Resume worker for a specific user
 */
export const usePostV1AdminWorkerUsersResume = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AdminWorkerUsersResume>>, TError,{data: UserIdRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postV1AdminWorkerUsersResume>>,
        TError,
        {data: UserIdRequest},
        TContext
      > => {

      const mutationOptions = getPostV1AdminWorkerUsersResumeMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Get priority analytics from the worker (admin only)
 * @summary Get worker priority analytics
 */
export const getV1AdminWorkerAnalyticsPriorityScores = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetV1AdminWorkerAnalyticsPriorityScores200>(
      {url: `/v1/admin/worker/analytics/priority-scores`, method: 'GET', signal
    },
      options);
    }
  

export const getGetV1AdminWorkerAnalyticsPriorityScoresQueryKey = () => {
    return [`/v1/admin/worker/analytics/priority-scores`] as const;
    }

    
export const getGetV1AdminWorkerAnalyticsPriorityScoresQueryOptions = <TData = Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsPriorityScores>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsPriorityScores>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AdminWorkerAnalyticsPriorityScoresQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsPriorityScores>>> = ({ signal }) => getV1AdminWorkerAnalyticsPriorityScores(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsPriorityScores>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AdminWorkerAnalyticsPriorityScoresQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsPriorityScores>>>
export type GetV1AdminWorkerAnalyticsPriorityScoresQueryError = ErrorResponse


export function useGetV1AdminWorkerAnalyticsPriorityScores<TData = Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsPriorityScores>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsPriorityScores>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsPriorityScores>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsPriorityScores>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminWorkerAnalyticsPriorityScores<TData = Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsPriorityScores>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsPriorityScores>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsPriorityScores>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsPriorityScores>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminWorkerAnalyticsPriorityScores<TData = Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsPriorityScores>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsPriorityScores>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get worker priority analytics
 */

export function useGetV1AdminWorkerAnalyticsPriorityScores<TData = Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsPriorityScores>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsPriorityScores>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AdminWorkerAnalyticsPriorityScoresQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get user performance analytics from the worker (admin only)
 * @summary Get worker user performance analytics
 */
export const getV1AdminWorkerAnalyticsUserPerformance = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<UserPerformanceAnalytics>(
      {url: `/v1/admin/worker/analytics/user-performance`, method: 'GET', signal
    },
      options);
    }
  

export const getGetV1AdminWorkerAnalyticsUserPerformanceQueryKey = () => {
    return [`/v1/admin/worker/analytics/user-performance`] as const;
    }

    
export const getGetV1AdminWorkerAnalyticsUserPerformanceQueryOptions = <TData = Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsUserPerformance>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsUserPerformance>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AdminWorkerAnalyticsUserPerformanceQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsUserPerformance>>> = ({ signal }) => getV1AdminWorkerAnalyticsUserPerformance(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsUserPerformance>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AdminWorkerAnalyticsUserPerformanceQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsUserPerformance>>>
export type GetV1AdminWorkerAnalyticsUserPerformanceQueryError = ErrorResponse


export function useGetV1AdminWorkerAnalyticsUserPerformance<TData = Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsUserPerformance>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsUserPerformance>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsUserPerformance>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsUserPerformance>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminWorkerAnalyticsUserPerformance<TData = Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsUserPerformance>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsUserPerformance>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsUserPerformance>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsUserPerformance>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminWorkerAnalyticsUserPerformance<TData = Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsUserPerformance>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsUserPerformance>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get worker user performance analytics
 */

export function useGetV1AdminWorkerAnalyticsUserPerformance<TData = Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsUserPerformance>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsUserPerformance>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AdminWorkerAnalyticsUserPerformanceQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get generation intelligence from the worker (admin only)
 * @summary Get worker generation intelligence
 */
export const getV1AdminWorkerAnalyticsGenerationIntelligence = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GenerationIntelligence>(
      {url: `/v1/admin/worker/analytics/generation-intelligence`, method: 'GET', signal
    },
      options);
    }
  

export const getGetV1AdminWorkerAnalyticsGenerationIntelligenceQueryKey = () => {
    return [`/v1/admin/worker/analytics/generation-intelligence`] as const;
    }

    
export const getGetV1AdminWorkerAnalyticsGenerationIntelligenceQueryOptions = <TData = Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsGenerationIntelligence>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsGenerationIntelligence>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AdminWorkerAnalyticsGenerationIntelligenceQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsGenerationIntelligence>>> = ({ signal }) => getV1AdminWorkerAnalyticsGenerationIntelligence(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsGenerationIntelligence>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AdminWorkerAnalyticsGenerationIntelligenceQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsGenerationIntelligence>>>
export type GetV1AdminWorkerAnalyticsGenerationIntelligenceQueryError = ErrorResponse


export function useGetV1AdminWorkerAnalyticsGenerationIntelligence<TData = Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsGenerationIntelligence>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsGenerationIntelligence>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsGenerationIntelligence>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsGenerationIntelligence>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminWorkerAnalyticsGenerationIntelligence<TData = Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsGenerationIntelligence>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsGenerationIntelligence>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsGenerationIntelligence>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsGenerationIntelligence>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminWorkerAnalyticsGenerationIntelligence<TData = Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsGenerationIntelligence>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsGenerationIntelligence>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get worker generation intelligence
 */

export function useGetV1AdminWorkerAnalyticsGenerationIntelligence<TData = Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsGenerationIntelligence>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsGenerationIntelligence>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AdminWorkerAnalyticsGenerationIntelligenceQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get system health analytics from the worker (admin only)
 * @summary Get worker system health analytics
 */
export const getV1AdminWorkerAnalyticsSystemHealth = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<SystemHealthAnalytics>(
      {url: `/v1/admin/worker/analytics/system-health`, method: 'GET', signal
    },
      options);
    }
  

export const getGetV1AdminWorkerAnalyticsSystemHealthQueryKey = () => {
    return [`/v1/admin/worker/analytics/system-health`] as const;
    }

    
export const getGetV1AdminWorkerAnalyticsSystemHealthQueryOptions = <TData = Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsSystemHealth>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsSystemHealth>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AdminWorkerAnalyticsSystemHealthQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsSystemHealth>>> = ({ signal }) => getV1AdminWorkerAnalyticsSystemHealth(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsSystemHealth>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AdminWorkerAnalyticsSystemHealthQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsSystemHealth>>>
export type GetV1AdminWorkerAnalyticsSystemHealthQueryError = ErrorResponse


export function useGetV1AdminWorkerAnalyticsSystemHealth<TData = Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsSystemHealth>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsSystemHealth>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsSystemHealth>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsSystemHealth>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminWorkerAnalyticsSystemHealth<TData = Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsSystemHealth>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsSystemHealth>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsSystemHealth>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsSystemHealth>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminWorkerAnalyticsSystemHealth<TData = Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsSystemHealth>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsSystemHealth>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get worker system health analytics
 */

export function useGetV1AdminWorkerAnalyticsSystemHealth<TData = Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsSystemHealth>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsSystemHealth>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AdminWorkerAnalyticsSystemHealthQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get comprehensive notification statistics including sent count, error count, and user statistics (admin only)
 * @summary Get notification statistics
 */
export const getV1AdminWorkerNotificationsStats = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<NotificationStats>(
      {url: `/v1/admin/worker/notifications/stats`, method: 'GET', signal
    },
      options);
    }
  

export const getGetV1AdminWorkerNotificationsStatsQueryKey = () => {
    return [`/v1/admin/worker/notifications/stats`] as const;
    }

    
export const getGetV1AdminWorkerNotificationsStatsQueryOptions = <TData = Awaited<ReturnType<typeof getV1AdminWorkerNotificationsStats>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerNotificationsStats>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AdminWorkerNotificationsStatsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AdminWorkerNotificationsStats>>> = ({ signal }) => getV1AdminWorkerNotificationsStats(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerNotificationsStats>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AdminWorkerNotificationsStatsQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AdminWorkerNotificationsStats>>>
export type GetV1AdminWorkerNotificationsStatsQueryError = ErrorResponse


export function useGetV1AdminWorkerNotificationsStats<TData = Awaited<ReturnType<typeof getV1AdminWorkerNotificationsStats>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerNotificationsStats>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminWorkerNotificationsStats>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminWorkerNotificationsStats>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminWorkerNotificationsStats<TData = Awaited<ReturnType<typeof getV1AdminWorkerNotificationsStats>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerNotificationsStats>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminWorkerNotificationsStats>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminWorkerNotificationsStats>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminWorkerNotificationsStats<TData = Awaited<ReturnType<typeof getV1AdminWorkerNotificationsStats>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerNotificationsStats>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get notification statistics
 */

export function useGetV1AdminWorkerNotificationsStats<TData = Awaited<ReturnType<typeof getV1AdminWorkerNotificationsStats>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerNotificationsStats>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AdminWorkerNotificationsStatsQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get paginated list of notification errors with filtering options (admin only)
 * @summary Get notification errors
 */
export const getV1AdminWorkerNotificationsErrors = (
    params?: GetV1AdminWorkerNotificationsErrorsParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetV1AdminWorkerNotificationsErrors200>(
      {url: `/v1/admin/worker/notifications/errors`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetV1AdminWorkerNotificationsErrorsQueryKey = (params?: GetV1AdminWorkerNotificationsErrorsParams,) => {
    return [`/v1/admin/worker/notifications/errors`, ...(params ? [params]: [])] as const;
    }

    
export const getGetV1AdminWorkerNotificationsErrorsQueryOptions = <TData = Awaited<ReturnType<typeof getV1AdminWorkerNotificationsErrors>>, TError = ErrorResponse>(params?: GetV1AdminWorkerNotificationsErrorsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerNotificationsErrors>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AdminWorkerNotificationsErrorsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AdminWorkerNotificationsErrors>>> = ({ signal }) => getV1AdminWorkerNotificationsErrors(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerNotificationsErrors>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AdminWorkerNotificationsErrorsQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AdminWorkerNotificationsErrors>>>
export type GetV1AdminWorkerNotificationsErrorsQueryError = ErrorResponse


export function useGetV1AdminWorkerNotificationsErrors<TData = Awaited<ReturnType<typeof getV1AdminWorkerNotificationsErrors>>, TError = ErrorResponse>(
 params: undefined |  GetV1AdminWorkerNotificationsErrorsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerNotificationsErrors>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminWorkerNotificationsErrors>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminWorkerNotificationsErrors>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminWorkerNotificationsErrors<TData = Awaited<ReturnType<typeof getV1AdminWorkerNotificationsErrors>>, TError = ErrorResponse>(
 params?: GetV1AdminWorkerNotificationsErrorsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerNotificationsErrors>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminWorkerNotificationsErrors>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminWorkerNotificationsErrors>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminWorkerNotificationsErrors<TData = Awaited<ReturnType<typeof getV1AdminWorkerNotificationsErrors>>, TError = ErrorResponse>(
 params?: GetV1AdminWorkerNotificationsErrorsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerNotificationsErrors>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get notification errors
 */

export function useGetV1AdminWorkerNotificationsErrors<TData = Awaited<ReturnType<typeof getV1AdminWorkerNotificationsErrors>>, TError = ErrorResponse>(
 params?: GetV1AdminWorkerNotificationsErrorsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerNotificationsErrors>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AdminWorkerNotificationsErrorsQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get paginated list of sent notifications with filtering options (admin only)
 * @summary Get sent notifications
 */
export const getV1AdminWorkerNotificationsSent = (
    params?: GetV1AdminWorkerNotificationsSentParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetV1AdminWorkerNotificationsSent200>(
      {url: `/v1/admin/worker/notifications/sent`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetV1AdminWorkerNotificationsSentQueryKey = (params?: GetV1AdminWorkerNotificationsSentParams,) => {
    return [`/v1/admin/worker/notifications/sent`, ...(params ? [params]: [])] as const;
    }

    
export const getGetV1AdminWorkerNotificationsSentQueryOptions = <TData = Awaited<ReturnType<typeof getV1AdminWorkerNotificationsSent>>, TError = ErrorResponse>(params?: GetV1AdminWorkerNotificationsSentParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerNotificationsSent>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AdminWorkerNotificationsSentQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AdminWorkerNotificationsSent>>> = ({ signal }) => getV1AdminWorkerNotificationsSent(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerNotificationsSent>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AdminWorkerNotificationsSentQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AdminWorkerNotificationsSent>>>
export type GetV1AdminWorkerNotificationsSentQueryError = ErrorResponse


export function useGetV1AdminWorkerNotificationsSent<TData = Awaited<ReturnType<typeof getV1AdminWorkerNotificationsSent>>, TError = ErrorResponse>(
 params: undefined |  GetV1AdminWorkerNotificationsSentParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerNotificationsSent>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminWorkerNotificationsSent>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminWorkerNotificationsSent>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminWorkerNotificationsSent<TData = Awaited<ReturnType<typeof getV1AdminWorkerNotificationsSent>>, TError = ErrorResponse>(
 params?: GetV1AdminWorkerNotificationsSentParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerNotificationsSent>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminWorkerNotificationsSent>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminWorkerNotificationsSent>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminWorkerNotificationsSent<TData = Awaited<ReturnType<typeof getV1AdminWorkerNotificationsSent>>, TError = ErrorResponse>(
 params?: GetV1AdminWorkerNotificationsSentParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerNotificationsSent>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get sent notifications
 */

export function useGetV1AdminWorkerNotificationsSent<TData = Awaited<ReturnType<typeof getV1AdminWorkerNotificationsSent>>, TError = ErrorResponse>(
 params?: GetV1AdminWorkerNotificationsSentParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerNotificationsSent>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AdminWorkerNotificationsSentQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Force send a daily reminder notification to a specific user, bypassing normal time and date checks (admin only)
 * @summary Force send notification to user
 */
export const postV1AdminWorkerNotificationsForceSend = (
    postV1AdminWorkerNotificationsForceSendBody: PostV1AdminWorkerNotificationsForceSendBody,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<ForceSendNotificationResponse>(
      {url: `/v1/admin/worker/notifications/force-send`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: postV1AdminWorkerNotificationsForceSendBody, signal
    },
      options);
    }
  


export const getPostV1AdminWorkerNotificationsForceSendMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AdminWorkerNotificationsForceSend>>, TError,{data: PostV1AdminWorkerNotificationsForceSendBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postV1AdminWorkerNotificationsForceSend>>, TError,{data: PostV1AdminWorkerNotificationsForceSendBody}, TContext> => {

const mutationKey = ['postV1AdminWorkerNotificationsForceSend'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1AdminWorkerNotificationsForceSend>>, {data: PostV1AdminWorkerNotificationsForceSendBody}> = (props) => {
          const {data} = props ?? {};

          return  postV1AdminWorkerNotificationsForceSend(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1AdminWorkerNotificationsForceSendMutationResult = NonNullable<Awaited<ReturnType<typeof postV1AdminWorkerNotificationsForceSend>>>
    export type PostV1AdminWorkerNotificationsForceSendMutationBody = PostV1AdminWorkerNotificationsForceSendBody
    export type PostV1AdminWorkerNotificationsForceSendMutationError = ErrorResponse

    /**
 * @summary Force send notification to user
 */
export const usePostV1AdminWorkerNotificationsForceSend = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AdminWorkerNotificationsForceSend>>, TError,{data: PostV1AdminWorkerNotificationsForceSendBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postV1AdminWorkerNotificationsForceSend>>,
        TError,
        {data: PostV1AdminWorkerNotificationsForceSendBody},
        TContext
      > => {

      const mutationOptions = getPostV1AdminWorkerNotificationsForceSendMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Get all questions in the system with pagination, search, and filtering options (admin only)
 * @summary Get all questions with pagination and filtering
 */
export const getV1AdminBackendQuestions = (
    params?: GetV1AdminBackendQuestionsParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetV1AdminBackendQuestions200>(
      {url: `/v1/admin/backend/questions`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetV1AdminBackendQuestionsQueryKey = (params?: GetV1AdminBackendQuestionsParams,) => {
    return [`/v1/admin/backend/questions`, ...(params ? [params]: [])] as const;
    }

    
export const getGetV1AdminBackendQuestionsQueryOptions = <TData = Awaited<ReturnType<typeof getV1AdminBackendQuestions>>, TError = ErrorResponse>(params?: GetV1AdminBackendQuestionsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendQuestions>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AdminBackendQuestionsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AdminBackendQuestions>>> = ({ signal }) => getV1AdminBackendQuestions(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendQuestions>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AdminBackendQuestionsQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AdminBackendQuestions>>>
export type GetV1AdminBackendQuestionsQueryError = ErrorResponse


export function useGetV1AdminBackendQuestions<TData = Awaited<ReturnType<typeof getV1AdminBackendQuestions>>, TError = ErrorResponse>(
 params: undefined |  GetV1AdminBackendQuestionsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendQuestions>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminBackendQuestions>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminBackendQuestions>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminBackendQuestions<TData = Awaited<ReturnType<typeof getV1AdminBackendQuestions>>, TError = ErrorResponse>(
 params?: GetV1AdminBackendQuestionsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendQuestions>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminBackendQuestions>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminBackendQuestions>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminBackendQuestions<TData = Awaited<ReturnType<typeof getV1AdminBackendQuestions>>, TError = ErrorResponse>(
 params?: GetV1AdminBackendQuestionsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendQuestions>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get all questions with pagination and filtering
 */

export function useGetV1AdminBackendQuestions<TData = Awaited<ReturnType<typeof getV1AdminBackendQuestions>>, TError = ErrorResponse>(
 params?: GetV1AdminBackendQuestionsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendQuestions>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AdminBackendQuestionsQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get questions with pagination support (admin only)
 * @summary Get paginated questions
 */
export const getV1AdminBackendQuestionsPaginated = (
    params?: GetV1AdminBackendQuestionsPaginatedParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetV1AdminBackendQuestionsPaginated200>(
      {url: `/v1/admin/backend/questions/paginated`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetV1AdminBackendQuestionsPaginatedQueryKey = (params?: GetV1AdminBackendQuestionsPaginatedParams,) => {
    return [`/v1/admin/backend/questions/paginated`, ...(params ? [params]: [])] as const;
    }

    
export const getGetV1AdminBackendQuestionsPaginatedQueryOptions = <TData = Awaited<ReturnType<typeof getV1AdminBackendQuestionsPaginated>>, TError = ErrorResponse>(params?: GetV1AdminBackendQuestionsPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendQuestionsPaginated>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AdminBackendQuestionsPaginatedQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AdminBackendQuestionsPaginated>>> = ({ signal }) => getV1AdminBackendQuestionsPaginated(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendQuestionsPaginated>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AdminBackendQuestionsPaginatedQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AdminBackendQuestionsPaginated>>>
export type GetV1AdminBackendQuestionsPaginatedQueryError = ErrorResponse


export function useGetV1AdminBackendQuestionsPaginated<TData = Awaited<ReturnType<typeof getV1AdminBackendQuestionsPaginated>>, TError = ErrorResponse>(
 params: undefined |  GetV1AdminBackendQuestionsPaginatedParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendQuestionsPaginated>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminBackendQuestionsPaginated>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminBackendQuestionsPaginated>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminBackendQuestionsPaginated<TData = Awaited<ReturnType<typeof getV1AdminBackendQuestionsPaginated>>, TError = ErrorResponse>(
 params?: GetV1AdminBackendQuestionsPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendQuestionsPaginated>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminBackendQuestionsPaginated>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminBackendQuestionsPaginated>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminBackendQuestionsPaginated<TData = Awaited<ReturnType<typeof getV1AdminBackendQuestionsPaginated>>, TError = ErrorResponse>(
 params?: GetV1AdminBackendQuestionsPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendQuestionsPaginated>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get paginated questions
 */

export function useGetV1AdminBackendQuestionsPaginated<TData = Awaited<ReturnType<typeof getV1AdminBackendQuestionsPaginated>>, TError = ErrorResponse>(
 params?: GetV1AdminBackendQuestionsPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendQuestionsPaginated>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AdminBackendQuestionsPaginatedQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get a specific question by its ID for editing (admin only)
 * @summary Get a single question by ID
 */
export const getV1AdminBackendQuestionsId = (
    id: number,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<Question>(
      {url: `/v1/admin/backend/questions/${id}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetV1AdminBackendQuestionsIdQueryKey = (id: number,) => {
    return [`/v1/admin/backend/questions/${id}`] as const;
    }

    
export const getGetV1AdminBackendQuestionsIdQueryOptions = <TData = Awaited<ReturnType<typeof getV1AdminBackendQuestionsId>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendQuestionsId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AdminBackendQuestionsIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AdminBackendQuestionsId>>> = ({ signal }) => getV1AdminBackendQuestionsId(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendQuestionsId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AdminBackendQuestionsIdQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AdminBackendQuestionsId>>>
export type GetV1AdminBackendQuestionsIdQueryError = ErrorResponse


export function useGetV1AdminBackendQuestionsId<TData = Awaited<ReturnType<typeof getV1AdminBackendQuestionsId>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendQuestionsId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminBackendQuestionsId>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminBackendQuestionsId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminBackendQuestionsId<TData = Awaited<ReturnType<typeof getV1AdminBackendQuestionsId>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendQuestionsId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminBackendQuestionsId>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminBackendQuestionsId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminBackendQuestionsId<TData = Awaited<ReturnType<typeof getV1AdminBackendQuestionsId>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendQuestionsId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get a single question by ID
 */

export function useGetV1AdminBackendQuestionsId<TData = Awaited<ReturnType<typeof getV1AdminBackendQuestionsId>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendQuestionsId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AdminBackendQuestionsIdQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update a specific question by its ID (admin only)
 * @summary Update a question
 */
export const putV1AdminBackendQuestionsId = (
    id: number,
    putV1AdminBackendQuestionsIdBody: PutV1AdminBackendQuestionsIdBody,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<PutV1AdminBackendQuestionsId200>(
      {url: `/v1/admin/backend/questions/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: putV1AdminBackendQuestionsIdBody
    },
      options);
    }
  


export const getPutV1AdminBackendQuestionsIdMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putV1AdminBackendQuestionsId>>, TError,{id: number;data: PutV1AdminBackendQuestionsIdBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof putV1AdminBackendQuestionsId>>, TError,{id: number;data: PutV1AdminBackendQuestionsIdBody}, TContext> => {

const mutationKey = ['putV1AdminBackendQuestionsId'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putV1AdminBackendQuestionsId>>, {id: number;data: PutV1AdminBackendQuestionsIdBody}> = (props) => {
          const {id,data} = props ?? {};

          return  putV1AdminBackendQuestionsId(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PutV1AdminBackendQuestionsIdMutationResult = NonNullable<Awaited<ReturnType<typeof putV1AdminBackendQuestionsId>>>
    export type PutV1AdminBackendQuestionsIdMutationBody = PutV1AdminBackendQuestionsIdBody
    export type PutV1AdminBackendQuestionsIdMutationError = ErrorResponse

    /**
 * @summary Update a question
 */
export const usePutV1AdminBackendQuestionsId = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putV1AdminBackendQuestionsId>>, TError,{id: number;data: PutV1AdminBackendQuestionsIdBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof putV1AdminBackendQuestionsId>>,
        TError,
        {id: number;data: PutV1AdminBackendQuestionsIdBody},
        TContext
      > => {

      const mutationOptions = getPutV1AdminBackendQuestionsIdMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Delete a specific question by its ID (admin only)
 * @summary Delete a question
 */
export const deleteV1AdminBackendQuestionsId = (
    id: number,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<DeleteV1AdminBackendQuestionsId200>(
      {url: `/v1/admin/backend/questions/${id}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteV1AdminBackendQuestionsIdMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteV1AdminBackendQuestionsId>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteV1AdminBackendQuestionsId>>, TError,{id: number}, TContext> => {

const mutationKey = ['deleteV1AdminBackendQuestionsId'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteV1AdminBackendQuestionsId>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteV1AdminBackendQuestionsId(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteV1AdminBackendQuestionsIdMutationResult = NonNullable<Awaited<ReturnType<typeof deleteV1AdminBackendQuestionsId>>>
    
    export type DeleteV1AdminBackendQuestionsIdMutationError = ErrorResponse

    /**
 * @summary Delete a question
 */
export const useDeleteV1AdminBackendQuestionsId = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteV1AdminBackendQuestionsId>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteV1AdminBackendQuestionsId>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteV1AdminBackendQuestionsIdMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Get the users assigned to a specific question, showing up to 5 users and the total count (admin only)
 * @summary Get users assigned to a question
 */
export const getV1AdminBackendQuestionsIdUsers = (
    id: number,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetV1AdminBackendQuestionsIdUsers200>(
      {url: `/v1/admin/backend/questions/${id}/users`, method: 'GET', signal
    },
      options);
    }
  

export const getGetV1AdminBackendQuestionsIdUsersQueryKey = (id: number,) => {
    return [`/v1/admin/backend/questions/${id}/users`] as const;
    }

    
export const getGetV1AdminBackendQuestionsIdUsersQueryOptions = <TData = Awaited<ReturnType<typeof getV1AdminBackendQuestionsIdUsers>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendQuestionsIdUsers>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AdminBackendQuestionsIdUsersQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AdminBackendQuestionsIdUsers>>> = ({ signal }) => getV1AdminBackendQuestionsIdUsers(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendQuestionsIdUsers>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AdminBackendQuestionsIdUsersQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AdminBackendQuestionsIdUsers>>>
export type GetV1AdminBackendQuestionsIdUsersQueryError = ErrorResponse


export function useGetV1AdminBackendQuestionsIdUsers<TData = Awaited<ReturnType<typeof getV1AdminBackendQuestionsIdUsers>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendQuestionsIdUsers>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminBackendQuestionsIdUsers>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminBackendQuestionsIdUsers>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminBackendQuestionsIdUsers<TData = Awaited<ReturnType<typeof getV1AdminBackendQuestionsIdUsers>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendQuestionsIdUsers>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminBackendQuestionsIdUsers>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminBackendQuestionsIdUsers>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminBackendQuestionsIdUsers<TData = Awaited<ReturnType<typeof getV1AdminBackendQuestionsIdUsers>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendQuestionsIdUsers>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get users assigned to a question
 */

export function useGetV1AdminBackendQuestionsIdUsers<TData = Awaited<ReturnType<typeof getV1AdminBackendQuestionsIdUsers>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendQuestionsIdUsers>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AdminBackendQuestionsIdUsersQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Assign multiple users to a specific question (admin only)
 * @summary Assign users to a question
 */
export const postV1AdminBackendQuestionsIdAssignUsers = (
    id: number,
    postV1AdminBackendQuestionsIdAssignUsersBody: PostV1AdminBackendQuestionsIdAssignUsersBody,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<PostV1AdminBackendQuestionsIdAssignUsers200>(
      {url: `/v1/admin/backend/questions/${id}/assign-users`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: postV1AdminBackendQuestionsIdAssignUsersBody, signal
    },
      options);
    }
  


export const getPostV1AdminBackendQuestionsIdAssignUsersMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AdminBackendQuestionsIdAssignUsers>>, TError,{id: number;data: PostV1AdminBackendQuestionsIdAssignUsersBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postV1AdminBackendQuestionsIdAssignUsers>>, TError,{id: number;data: PostV1AdminBackendQuestionsIdAssignUsersBody}, TContext> => {

const mutationKey = ['postV1AdminBackendQuestionsIdAssignUsers'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1AdminBackendQuestionsIdAssignUsers>>, {id: number;data: PostV1AdminBackendQuestionsIdAssignUsersBody}> = (props) => {
          const {id,data} = props ?? {};

          return  postV1AdminBackendQuestionsIdAssignUsers(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1AdminBackendQuestionsIdAssignUsersMutationResult = NonNullable<Awaited<ReturnType<typeof postV1AdminBackendQuestionsIdAssignUsers>>>
    export type PostV1AdminBackendQuestionsIdAssignUsersMutationBody = PostV1AdminBackendQuestionsIdAssignUsersBody
    export type PostV1AdminBackendQuestionsIdAssignUsersMutationError = ErrorResponse

    /**
 * @summary Assign users to a question
 */
export const usePostV1AdminBackendQuestionsIdAssignUsers = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AdminBackendQuestionsIdAssignUsers>>, TError,{id: number;data: PostV1AdminBackendQuestionsIdAssignUsersBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postV1AdminBackendQuestionsIdAssignUsers>>,
        TError,
        {id: number;data: PostV1AdminBackendQuestionsIdAssignUsersBody},
        TContext
      > => {

      const mutationOptions = getPostV1AdminBackendQuestionsIdAssignUsersMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Remove multiple users from a specific question (admin only)
 * @summary Unassign users from a question
 */
export const postV1AdminBackendQuestionsIdUnassignUsers = (
    id: number,
    postV1AdminBackendQuestionsIdUnassignUsersBody: PostV1AdminBackendQuestionsIdUnassignUsersBody,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<PostV1AdminBackendQuestionsIdUnassignUsers200>(
      {url: `/v1/admin/backend/questions/${id}/unassign-users`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: postV1AdminBackendQuestionsIdUnassignUsersBody, signal
    },
      options);
    }
  


export const getPostV1AdminBackendQuestionsIdUnassignUsersMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AdminBackendQuestionsIdUnassignUsers>>, TError,{id: number;data: PostV1AdminBackendQuestionsIdUnassignUsersBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postV1AdminBackendQuestionsIdUnassignUsers>>, TError,{id: number;data: PostV1AdminBackendQuestionsIdUnassignUsersBody}, TContext> => {

const mutationKey = ['postV1AdminBackendQuestionsIdUnassignUsers'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1AdminBackendQuestionsIdUnassignUsers>>, {id: number;data: PostV1AdminBackendQuestionsIdUnassignUsersBody}> = (props) => {
          const {id,data} = props ?? {};

          return  postV1AdminBackendQuestionsIdUnassignUsers(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1AdminBackendQuestionsIdUnassignUsersMutationResult = NonNullable<Awaited<ReturnType<typeof postV1AdminBackendQuestionsIdUnassignUsers>>>
    export type PostV1AdminBackendQuestionsIdUnassignUsersMutationBody = PostV1AdminBackendQuestionsIdUnassignUsersBody
    export type PostV1AdminBackendQuestionsIdUnassignUsersMutationError = ErrorResponse

    /**
 * @summary Unassign users from a question
 */
export const usePostV1AdminBackendQuestionsIdUnassignUsers = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AdminBackendQuestionsIdUnassignUsers>>, TError,{id: number;data: PostV1AdminBackendQuestionsIdUnassignUsersBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postV1AdminBackendQuestionsIdUnassignUsers>>,
        TError,
        {id: number;data: PostV1AdminBackendQuestionsIdUnassignUsersBody},
        TContext
      > => {

      const mutationOptions = getPostV1AdminBackendQuestionsIdUnassignUsersMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Mark a reported question as fixed (admin only)
 * @summary Mark question as fixed
 */
export const postV1AdminBackendQuestionsIdFix = (
    id: number,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<PostV1AdminBackendQuestionsIdFix200>(
      {url: `/v1/admin/backend/questions/${id}/fix`, method: 'POST', signal
    },
      options);
    }
  


export const getPostV1AdminBackendQuestionsIdFixMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AdminBackendQuestionsIdFix>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postV1AdminBackendQuestionsIdFix>>, TError,{id: number}, TContext> => {

const mutationKey = ['postV1AdminBackendQuestionsIdFix'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1AdminBackendQuestionsIdFix>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  postV1AdminBackendQuestionsIdFix(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1AdminBackendQuestionsIdFixMutationResult = NonNullable<Awaited<ReturnType<typeof postV1AdminBackendQuestionsIdFix>>>
    
    export type PostV1AdminBackendQuestionsIdFixMutationError = ErrorResponse

    /**
 * @summary Mark question as fixed
 */
export const usePostV1AdminBackendQuestionsIdFix = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AdminBackendQuestionsIdFix>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postV1AdminBackendQuestionsIdFix>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getPostV1AdminBackendQuestionsIdFixMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Use AI to automatically fix a reported question (admin only)
 * @summary Fix question with AI
 */
export const postV1AdminBackendQuestionsIdAiFix = (
    id: number,
    postV1AdminBackendQuestionsIdAiFixBody?: PostV1AdminBackendQuestionsIdAiFixBody,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<PostV1AdminBackendQuestionsIdAiFix200>(
      {url: `/v1/admin/backend/questions/${id}/ai-fix`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: postV1AdminBackendQuestionsIdAiFixBody, signal
    },
      options);
    }
  


export const getPostV1AdminBackendQuestionsIdAiFixMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AdminBackendQuestionsIdAiFix>>, TError,{id: number;data: PostV1AdminBackendQuestionsIdAiFixBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postV1AdminBackendQuestionsIdAiFix>>, TError,{id: number;data: PostV1AdminBackendQuestionsIdAiFixBody}, TContext> => {

const mutationKey = ['postV1AdminBackendQuestionsIdAiFix'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1AdminBackendQuestionsIdAiFix>>, {id: number;data: PostV1AdminBackendQuestionsIdAiFixBody}> = (props) => {
          const {id,data} = props ?? {};

          return  postV1AdminBackendQuestionsIdAiFix(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1AdminBackendQuestionsIdAiFixMutationResult = NonNullable<Awaited<ReturnType<typeof postV1AdminBackendQuestionsIdAiFix>>>
    export type PostV1AdminBackendQuestionsIdAiFixMutationBody = PostV1AdminBackendQuestionsIdAiFixBody
    export type PostV1AdminBackendQuestionsIdAiFixMutationError = ErrorResponse

    /**
 * @summary Fix question with AI
 */
export const usePostV1AdminBackendQuestionsIdAiFix = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AdminBackendQuestionsIdAiFix>>, TError,{id: number;data: PostV1AdminBackendQuestionsIdAiFixBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postV1AdminBackendQuestionsIdAiFix>>,
        TError,
        {id: number;data: PostV1AdminBackendQuestionsIdAiFixBody},
        TContext
      > => {

      const mutationOptions = getPostV1AdminBackendQuestionsIdAiFixMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Clear all user data including questions, responses, and stats (admin only)
 * @summary Clear all user data
 */
export const postV1AdminBackendClearUserData = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<PostV1AdminBackendClearUserData200>(
      {url: `/v1/admin/backend/clear-user-data`, method: 'POST', signal
    },
      options);
    }
  


export const getPostV1AdminBackendClearUserDataMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AdminBackendClearUserData>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postV1AdminBackendClearUserData>>, TError,void, TContext> => {

const mutationKey = ['postV1AdminBackendClearUserData'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1AdminBackendClearUserData>>, void> = () => {
          

          return  postV1AdminBackendClearUserData(requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1AdminBackendClearUserDataMutationResult = NonNullable<Awaited<ReturnType<typeof postV1AdminBackendClearUserData>>>
    
    export type PostV1AdminBackendClearUserDataMutationError = ErrorResponse

    /**
 * @summary Clear all user data
 */
export const usePostV1AdminBackendClearUserData = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AdminBackendClearUserData>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postV1AdminBackendClearUserData>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getPostV1AdminBackendClearUserDataMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Clear all data from the database (admin only)
 * @summary Clear entire database
 */
export const postV1AdminBackendClearDatabase = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<PostV1AdminBackendClearDatabase200>(
      {url: `/v1/admin/backend/clear-database`, method: 'POST', signal
    },
      options);
    }
  


export const getPostV1AdminBackendClearDatabaseMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AdminBackendClearDatabase>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postV1AdminBackendClearDatabase>>, TError,void, TContext> => {

const mutationKey = ['postV1AdminBackendClearDatabase'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1AdminBackendClearDatabase>>, void> = () => {
          

          return  postV1AdminBackendClearDatabase(requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1AdminBackendClearDatabaseMutationResult = NonNullable<Awaited<ReturnType<typeof postV1AdminBackendClearDatabase>>>
    
    export type PostV1AdminBackendClearDatabaseMutationError = ErrorResponse

    /**
 * @summary Clear entire database
 */
export const usePostV1AdminBackendClearDatabase = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AdminBackendClearDatabase>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postV1AdminBackendClearDatabase>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getPostV1AdminBackendClearDatabaseMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Clear all data for a specific user including questions, responses, and stats (admin only)
 * @summary Clear user data for specific user
 */
export const postV1AdminBackendUserzIdClear = (
    id: number,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<PostV1AdminBackendUserzIdClear200>(
      {url: `/v1/admin/backend/userz/${id}/clear`, method: 'POST', signal
    },
      options);
    }
  


export const getPostV1AdminBackendUserzIdClearMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AdminBackendUserzIdClear>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postV1AdminBackendUserzIdClear>>, TError,{id: number}, TContext> => {

const mutationKey = ['postV1AdminBackendUserzIdClear'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1AdminBackendUserzIdClear>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  postV1AdminBackendUserzIdClear(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1AdminBackendUserzIdClearMutationResult = NonNullable<Awaited<ReturnType<typeof postV1AdminBackendUserzIdClear>>>
    
    export type PostV1AdminBackendUserzIdClearMutationError = ErrorResponse

    /**
 * @summary Clear user data for specific user
 */
export const usePostV1AdminBackendUserzIdClear = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AdminBackendUserzIdClear>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postV1AdminBackendUserzIdClear>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getPostV1AdminBackendUserzIdClearMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Get all reported questions with pagination, search, and filtering options (admin only)
 * @summary Get reported questions with pagination and filtering
 */
export const getV1AdminBackendReportedQuestions = (
    params?: GetV1AdminBackendReportedQuestionsParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetV1AdminBackendReportedQuestions200>(
      {url: `/v1/admin/backend/reported-questions`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetV1AdminBackendReportedQuestionsQueryKey = (params?: GetV1AdminBackendReportedQuestionsParams,) => {
    return [`/v1/admin/backend/reported-questions`, ...(params ? [params]: [])] as const;
    }

    
export const getGetV1AdminBackendReportedQuestionsQueryOptions = <TData = Awaited<ReturnType<typeof getV1AdminBackendReportedQuestions>>, TError = ErrorResponse>(params?: GetV1AdminBackendReportedQuestionsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendReportedQuestions>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AdminBackendReportedQuestionsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AdminBackendReportedQuestions>>> = ({ signal }) => getV1AdminBackendReportedQuestions(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendReportedQuestions>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AdminBackendReportedQuestionsQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AdminBackendReportedQuestions>>>
export type GetV1AdminBackendReportedQuestionsQueryError = ErrorResponse


export function useGetV1AdminBackendReportedQuestions<TData = Awaited<ReturnType<typeof getV1AdminBackendReportedQuestions>>, TError = ErrorResponse>(
 params: undefined |  GetV1AdminBackendReportedQuestionsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendReportedQuestions>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminBackendReportedQuestions>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminBackendReportedQuestions>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminBackendReportedQuestions<TData = Awaited<ReturnType<typeof getV1AdminBackendReportedQuestions>>, TError = ErrorResponse>(
 params?: GetV1AdminBackendReportedQuestionsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendReportedQuestions>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminBackendReportedQuestions>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminBackendReportedQuestions>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminBackendReportedQuestions<TData = Awaited<ReturnType<typeof getV1AdminBackendReportedQuestions>>, TError = ErrorResponse>(
 params?: GetV1AdminBackendReportedQuestionsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendReportedQuestions>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get reported questions with pagination and filtering
 */

export function useGetV1AdminBackendReportedQuestions<TData = Awaited<ReturnType<typeof getV1AdminBackendReportedQuestions>>, TError = ErrorResponse>(
 params?: GetV1AdminBackendReportedQuestionsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendReportedQuestions>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AdminBackendReportedQuestionsQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get all user stories with pagination, search, and filtering options (admin only)
 * @summary Get all stories with pagination and filtering
 */
export const getV1AdminBackendStories = (
    params?: GetV1AdminBackendStoriesParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetV1AdminBackendStories200>(
      {url: `/v1/admin/backend/stories`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetV1AdminBackendStoriesQueryKey = (params?: GetV1AdminBackendStoriesParams,) => {
    return [`/v1/admin/backend/stories`, ...(params ? [params]: [])] as const;
    }

    
export const getGetV1AdminBackendStoriesQueryOptions = <TData = Awaited<ReturnType<typeof getV1AdminBackendStories>>, TError = ErrorResponse>(params?: GetV1AdminBackendStoriesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendStories>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AdminBackendStoriesQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AdminBackendStories>>> = ({ signal }) => getV1AdminBackendStories(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendStories>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AdminBackendStoriesQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AdminBackendStories>>>
export type GetV1AdminBackendStoriesQueryError = ErrorResponse


export function useGetV1AdminBackendStories<TData = Awaited<ReturnType<typeof getV1AdminBackendStories>>, TError = ErrorResponse>(
 params: undefined |  GetV1AdminBackendStoriesParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendStories>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminBackendStories>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminBackendStories>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminBackendStories<TData = Awaited<ReturnType<typeof getV1AdminBackendStories>>, TError = ErrorResponse>(
 params?: GetV1AdminBackendStoriesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendStories>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminBackendStories>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminBackendStories>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminBackendStories<TData = Awaited<ReturnType<typeof getV1AdminBackendStories>>, TError = ErrorResponse>(
 params?: GetV1AdminBackendStoriesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendStories>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get all stories with pagination and filtering
 */

export function useGetV1AdminBackendStories<TData = Awaited<ReturnType<typeof getV1AdminBackendStories>>, TError = ErrorResponse>(
 params?: GetV1AdminBackendStoriesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendStories>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AdminBackendStoriesQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get a specific story with its sections (admin only)
 * @summary Get a single story by ID (with sections)
 */
export const getV1AdminBackendStoriesId = (
    id: number,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<StoryWithSections>(
      {url: `/v1/admin/backend/stories/${id}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetV1AdminBackendStoriesIdQueryKey = (id: number,) => {
    return [`/v1/admin/backend/stories/${id}`] as const;
    }

    
export const getGetV1AdminBackendStoriesIdQueryOptions = <TData = Awaited<ReturnType<typeof getV1AdminBackendStoriesId>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendStoriesId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AdminBackendStoriesIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AdminBackendStoriesId>>> = ({ signal }) => getV1AdminBackendStoriesId(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendStoriesId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AdminBackendStoriesIdQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AdminBackendStoriesId>>>
export type GetV1AdminBackendStoriesIdQueryError = ErrorResponse


export function useGetV1AdminBackendStoriesId<TData = Awaited<ReturnType<typeof getV1AdminBackendStoriesId>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendStoriesId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminBackendStoriesId>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminBackendStoriesId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminBackendStoriesId<TData = Awaited<ReturnType<typeof getV1AdminBackendStoriesId>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendStoriesId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminBackendStoriesId>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminBackendStoriesId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminBackendStoriesId<TData = Awaited<ReturnType<typeof getV1AdminBackendStoriesId>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendStoriesId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get a single story by ID (with sections)
 */

export function useGetV1AdminBackendStoriesId<TData = Awaited<ReturnType<typeof getV1AdminBackendStoriesId>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendStoriesId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AdminBackendStoriesIdQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Delete a user story by ID. Admins can delete stories regardless of status. Admin only.
 * @summary Delete a story (admin)
 */
export const deleteV1AdminBackendStoriesId = (
    id: number,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/v1/admin/backend/stories/${id}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteV1AdminBackendStoriesIdMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteV1AdminBackendStoriesId>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteV1AdminBackendStoriesId>>, TError,{id: number}, TContext> => {

const mutationKey = ['deleteV1AdminBackendStoriesId'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteV1AdminBackendStoriesId>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteV1AdminBackendStoriesId(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteV1AdminBackendStoriesIdMutationResult = NonNullable<Awaited<ReturnType<typeof deleteV1AdminBackendStoriesId>>>
    
    export type DeleteV1AdminBackendStoriesIdMutationError = ErrorResponse

    /**
 * @summary Delete a story (admin)
 */
export const useDeleteV1AdminBackendStoriesId = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteV1AdminBackendStoriesId>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteV1AdminBackendStoriesId>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteV1AdminBackendStoriesIdMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Get a specific story section and its questions (admin only)
 * @summary Get a story section with questions by ID
 */
export const getV1AdminBackendStorySectionsId = (
    id: number,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<StorySectionWithQuestions>(
      {url: `/v1/admin/backend/story-sections/${id}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetV1AdminBackendStorySectionsIdQueryKey = (id: number,) => {
    return [`/v1/admin/backend/story-sections/${id}`] as const;
    }

    
export const getGetV1AdminBackendStorySectionsIdQueryOptions = <TData = Awaited<ReturnType<typeof getV1AdminBackendStorySectionsId>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendStorySectionsId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AdminBackendStorySectionsIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AdminBackendStorySectionsId>>> = ({ signal }) => getV1AdminBackendStorySectionsId(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendStorySectionsId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AdminBackendStorySectionsIdQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AdminBackendStorySectionsId>>>
export type GetV1AdminBackendStorySectionsIdQueryError = ErrorResponse


export function useGetV1AdminBackendStorySectionsId<TData = Awaited<ReturnType<typeof getV1AdminBackendStorySectionsId>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendStorySectionsId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminBackendStorySectionsId>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminBackendStorySectionsId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminBackendStorySectionsId<TData = Awaited<ReturnType<typeof getV1AdminBackendStorySectionsId>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendStorySectionsId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminBackendStorySectionsId>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminBackendStorySectionsId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminBackendStorySectionsId<TData = Awaited<ReturnType<typeof getV1AdminBackendStorySectionsId>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendStorySectionsId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get a story section with questions by ID
 */

export function useGetV1AdminBackendStorySectionsId<TData = Awaited<ReturnType<typeof getV1AdminBackendStorySectionsId>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendStorySectionsId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AdminBackendStorySectionsIdQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get a streaming AI-powered explanation or chat about a question.
 */
export const postV1QuizChatStream = (
    quizChatRequest: QuizChatRequest,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<string>(
      {url: `/v1/quiz/chat/stream`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: quizChatRequest, signal
    },
      options);
    }
  


export const getPostV1QuizChatStreamMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1QuizChatStream>>, TError,{data: QuizChatRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postV1QuizChatStream>>, TError,{data: QuizChatRequest}, TContext> => {

const mutationKey = ['postV1QuizChatStream'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1QuizChatStream>>, {data: QuizChatRequest}> = (props) => {
          const {data} = props ?? {};

          return  postV1QuizChatStream(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1QuizChatStreamMutationResult = NonNullable<Awaited<ReturnType<typeof postV1QuizChatStream>>>
    export type PostV1QuizChatStreamMutationBody = QuizChatRequest
    export type PostV1QuizChatStreamMutationError = ErrorResponse

    /**
 * @summary Get a streaming AI-powered explanation or chat about a question.
 */
export const usePostV1QuizChatStream = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1QuizChatStream>>, TError,{data: QuizChatRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postV1QuizChatStream>>,
        TError,
        {data: QuizChatRequest},
        TContext
      > => {

      const mutationOptions = getPostV1QuizChatStreamMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Retrieve all daily questions assigned to the user for a specific date
 * @summary Get daily questions for a specific date
 */
export const getV1DailyQuestionsDate = (
    date: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetV1DailyQuestionsDate200>(
      {url: `/v1/daily/questions/${date}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetV1DailyQuestionsDateQueryKey = (date: string,) => {
    return [`/v1/daily/questions/${date}`] as const;
    }

    
export const getGetV1DailyQuestionsDateQueryOptions = <TData = Awaited<ReturnType<typeof getV1DailyQuestionsDate>>, TError = ErrorResponse>(date: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1DailyQuestionsDate>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1DailyQuestionsDateQueryKey(date);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1DailyQuestionsDate>>> = ({ signal }) => getV1DailyQuestionsDate(date, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(date), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1DailyQuestionsDate>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1DailyQuestionsDateQueryResult = NonNullable<Awaited<ReturnType<typeof getV1DailyQuestionsDate>>>
export type GetV1DailyQuestionsDateQueryError = ErrorResponse


export function useGetV1DailyQuestionsDate<TData = Awaited<ReturnType<typeof getV1DailyQuestionsDate>>, TError = ErrorResponse>(
 date: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1DailyQuestionsDate>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1DailyQuestionsDate>>,
          TError,
          Awaited<ReturnType<typeof getV1DailyQuestionsDate>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1DailyQuestionsDate<TData = Awaited<ReturnType<typeof getV1DailyQuestionsDate>>, TError = ErrorResponse>(
 date: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1DailyQuestionsDate>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1DailyQuestionsDate>>,
          TError,
          Awaited<ReturnType<typeof getV1DailyQuestionsDate>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1DailyQuestionsDate<TData = Awaited<ReturnType<typeof getV1DailyQuestionsDate>>, TError = ErrorResponse>(
 date: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1DailyQuestionsDate>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get daily questions for a specific date
 */

export function useGetV1DailyQuestionsDate<TData = Awaited<ReturnType<typeof getV1DailyQuestionsDate>>, TError = ErrorResponse>(
 date: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1DailyQuestionsDate>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1DailyQuestionsDateQueryOptions(date,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Mark a specific daily question as completed for the given date
 * @summary Mark daily question as completed
 */
export const postV1DailyQuestionsDateCompleteQuestionId = (
    date: string,
    questionId: number,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<SuccessResponse>(
      {url: `/v1/daily/questions/${date}/complete/${questionId}`, method: 'POST', signal
    },
      options);
    }
  


export const getPostV1DailyQuestionsDateCompleteQuestionIdMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1DailyQuestionsDateCompleteQuestionId>>, TError,{date: string;questionId: number}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postV1DailyQuestionsDateCompleteQuestionId>>, TError,{date: string;questionId: number}, TContext> => {

const mutationKey = ['postV1DailyQuestionsDateCompleteQuestionId'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1DailyQuestionsDateCompleteQuestionId>>, {date: string;questionId: number}> = (props) => {
          const {date,questionId} = props ?? {};

          return  postV1DailyQuestionsDateCompleteQuestionId(date,questionId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1DailyQuestionsDateCompleteQuestionIdMutationResult = NonNullable<Awaited<ReturnType<typeof postV1DailyQuestionsDateCompleteQuestionId>>>
    
    export type PostV1DailyQuestionsDateCompleteQuestionIdMutationError = ErrorResponse

    /**
 * @summary Mark daily question as completed
 */
export const usePostV1DailyQuestionsDateCompleteQuestionId = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1DailyQuestionsDateCompleteQuestionId>>, TError,{date: string;questionId: number}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postV1DailyQuestionsDateCompleteQuestionId>>,
        TError,
        {date: string;questionId: number},
        TContext
      > => {

      const mutationOptions = getPostV1DailyQuestionsDateCompleteQuestionIdMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Reset a specific daily question completion status for the given date
 * @summary Reset daily question completion
 */
export const deleteV1DailyQuestionsDateCompleteQuestionId = (
    date: string,
    questionId: number,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<SuccessResponse>(
      {url: `/v1/daily/questions/${date}/complete/${questionId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteV1DailyQuestionsDateCompleteQuestionIdMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteV1DailyQuestionsDateCompleteQuestionId>>, TError,{date: string;questionId: number}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteV1DailyQuestionsDateCompleteQuestionId>>, TError,{date: string;questionId: number}, TContext> => {

const mutationKey = ['deleteV1DailyQuestionsDateCompleteQuestionId'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteV1DailyQuestionsDateCompleteQuestionId>>, {date: string;questionId: number}> = (props) => {
          const {date,questionId} = props ?? {};

          return  deleteV1DailyQuestionsDateCompleteQuestionId(date,questionId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteV1DailyQuestionsDateCompleteQuestionIdMutationResult = NonNullable<Awaited<ReturnType<typeof deleteV1DailyQuestionsDateCompleteQuestionId>>>
    
    export type DeleteV1DailyQuestionsDateCompleteQuestionIdMutationError = ErrorResponse

    /**
 * @summary Reset daily question completion
 */
export const useDeleteV1DailyQuestionsDateCompleteQuestionId = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteV1DailyQuestionsDateCompleteQuestionId>>, TError,{date: string;questionId: number}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteV1DailyQuestionsDateCompleteQuestionId>>,
        TError,
        {date: string;questionId: number},
        TContext
      > => {

      const mutationOptions = getDeleteV1DailyQuestionsDateCompleteQuestionIdMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Retrieve all dates for which the user has daily question assignments
 * @summary Get available dates with daily question assignments
 */
export const getV1DailyDates = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetV1DailyDates200>(
      {url: `/v1/daily/dates`, method: 'GET', signal
    },
      options);
    }
  

export const getGetV1DailyDatesQueryKey = () => {
    return [`/v1/daily/dates`] as const;
    }

    
export const getGetV1DailyDatesQueryOptions = <TData = Awaited<ReturnType<typeof getV1DailyDates>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1DailyDates>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1DailyDatesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1DailyDates>>> = ({ signal }) => getV1DailyDates(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1DailyDates>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1DailyDatesQueryResult = NonNullable<Awaited<ReturnType<typeof getV1DailyDates>>>
export type GetV1DailyDatesQueryError = ErrorResponse


export function useGetV1DailyDates<TData = Awaited<ReturnType<typeof getV1DailyDates>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1DailyDates>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1DailyDates>>,
          TError,
          Awaited<ReturnType<typeof getV1DailyDates>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1DailyDates<TData = Awaited<ReturnType<typeof getV1DailyDates>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1DailyDates>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1DailyDates>>,
          TError,
          Awaited<ReturnType<typeof getV1DailyDates>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1DailyDates<TData = Awaited<ReturnType<typeof getV1DailyDates>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1DailyDates>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get available dates with daily question assignments
 */

export function useGetV1DailyDates<TData = Awaited<ReturnType<typeof getV1DailyDates>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1DailyDates>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1DailyDatesQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Submit an answer for a specific daily question and mark it as completed
 * @summary Submit answer for daily question
 */
export const postV1DailyQuestionsDateAnswerQuestionId = (
    date: string,
    questionId: number,
    postV1DailyQuestionsDateAnswerQuestionIdBody: PostV1DailyQuestionsDateAnswerQuestionIdBody,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<PostV1DailyQuestionsDateAnswerQuestionId200>(
      {url: `/v1/daily/questions/${date}/answer/${questionId}`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: postV1DailyQuestionsDateAnswerQuestionIdBody, signal
    },
      options);
    }
  


export const getPostV1DailyQuestionsDateAnswerQuestionIdMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1DailyQuestionsDateAnswerQuestionId>>, TError,{date: string;questionId: number;data: PostV1DailyQuestionsDateAnswerQuestionIdBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postV1DailyQuestionsDateAnswerQuestionId>>, TError,{date: string;questionId: number;data: PostV1DailyQuestionsDateAnswerQuestionIdBody}, TContext> => {

const mutationKey = ['postV1DailyQuestionsDateAnswerQuestionId'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1DailyQuestionsDateAnswerQuestionId>>, {date: string;questionId: number;data: PostV1DailyQuestionsDateAnswerQuestionIdBody}> = (props) => {
          const {date,questionId,data} = props ?? {};

          return  postV1DailyQuestionsDateAnswerQuestionId(date,questionId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1DailyQuestionsDateAnswerQuestionIdMutationResult = NonNullable<Awaited<ReturnType<typeof postV1DailyQuestionsDateAnswerQuestionId>>>
    export type PostV1DailyQuestionsDateAnswerQuestionIdMutationBody = PostV1DailyQuestionsDateAnswerQuestionIdBody
    export type PostV1DailyQuestionsDateAnswerQuestionIdMutationError = ErrorResponse

    /**
 * @summary Submit answer for daily question
 */
export const usePostV1DailyQuestionsDateAnswerQuestionId = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1DailyQuestionsDateAnswerQuestionId>>, TError,{date: string;questionId: number;data: PostV1DailyQuestionsDateAnswerQuestionIdBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postV1DailyQuestionsDateAnswerQuestionId>>,
        TError,
        {date: string;questionId: number;data: PostV1DailyQuestionsDateAnswerQuestionIdBody},
        TContext
      > => {

      const mutationOptions = getPostV1DailyQuestionsDateAnswerQuestionIdMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Get progress information (completed vs total questions) for a specific date
 * @summary Get daily progress for a specific date
 */
export const getV1DailyProgressDate = (
    date: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<DailyProgress>(
      {url: `/v1/daily/progress/${date}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetV1DailyProgressDateQueryKey = (date: string,) => {
    return [`/v1/daily/progress/${date}`] as const;
    }

    
export const getGetV1DailyProgressDateQueryOptions = <TData = Awaited<ReturnType<typeof getV1DailyProgressDate>>, TError = ErrorResponse>(date: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1DailyProgressDate>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1DailyProgressDateQueryKey(date);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1DailyProgressDate>>> = ({ signal }) => getV1DailyProgressDate(date, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(date), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1DailyProgressDate>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1DailyProgressDateQueryResult = NonNullable<Awaited<ReturnType<typeof getV1DailyProgressDate>>>
export type GetV1DailyProgressDateQueryError = ErrorResponse


export function useGetV1DailyProgressDate<TData = Awaited<ReturnType<typeof getV1DailyProgressDate>>, TError = ErrorResponse>(
 date: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1DailyProgressDate>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1DailyProgressDate>>,
          TError,
          Awaited<ReturnType<typeof getV1DailyProgressDate>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1DailyProgressDate<TData = Awaited<ReturnType<typeof getV1DailyProgressDate>>, TError = ErrorResponse>(
 date: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1DailyProgressDate>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1DailyProgressDate>>,
          TError,
          Awaited<ReturnType<typeof getV1DailyProgressDate>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1DailyProgressDate<TData = Awaited<ReturnType<typeof getV1DailyProgressDate>>, TError = ErrorResponse>(
 date: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1DailyProgressDate>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get daily progress for a specific date
 */

export function useGetV1DailyProgressDate<TData = Awaited<ReturnType<typeof getV1DailyProgressDate>>, TError = ErrorResponse>(
 date: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1DailyProgressDate>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1DailyProgressDateQueryOptions(date,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Retrieve the history of a specific question for the user over the last 14 days
 * @summary Get question history
 */
export const getV1DailyHistoryQuestionId = (
    questionId: number,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetV1DailyHistoryQuestionId200>(
      {url: `/v1/daily/history/${questionId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetV1DailyHistoryQuestionIdQueryKey = (questionId: number,) => {
    return [`/v1/daily/history/${questionId}`] as const;
    }

    
export const getGetV1DailyHistoryQuestionIdQueryOptions = <TData = Awaited<ReturnType<typeof getV1DailyHistoryQuestionId>>, TError = ErrorResponse>(questionId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1DailyHistoryQuestionId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1DailyHistoryQuestionIdQueryKey(questionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1DailyHistoryQuestionId>>> = ({ signal }) => getV1DailyHistoryQuestionId(questionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(questionId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1DailyHistoryQuestionId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1DailyHistoryQuestionIdQueryResult = NonNullable<Awaited<ReturnType<typeof getV1DailyHistoryQuestionId>>>
export type GetV1DailyHistoryQuestionIdQueryError = ErrorResponse


export function useGetV1DailyHistoryQuestionId<TData = Awaited<ReturnType<typeof getV1DailyHistoryQuestionId>>, TError = ErrorResponse>(
 questionId: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1DailyHistoryQuestionId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1DailyHistoryQuestionId>>,
          TError,
          Awaited<ReturnType<typeof getV1DailyHistoryQuestionId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1DailyHistoryQuestionId<TData = Awaited<ReturnType<typeof getV1DailyHistoryQuestionId>>, TError = ErrorResponse>(
 questionId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1DailyHistoryQuestionId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1DailyHistoryQuestionId>>,
          TError,
          Awaited<ReturnType<typeof getV1DailyHistoryQuestionId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1DailyHistoryQuestionId<TData = Awaited<ReturnType<typeof getV1DailyHistoryQuestionId>>, TError = ErrorResponse>(
 questionId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1DailyHistoryQuestionId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get question history
 */

export function useGetV1DailyHistoryQuestionId<TData = Awaited<ReturnType<typeof getV1DailyHistoryQuestionId>>, TError = ErrorResponse>(
 questionId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1DailyHistoryQuestionId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1DailyHistoryQuestionIdQueryOptions(questionId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Create a new story for the authenticated user. The story will automatically become their current active story.
 * @summary Create a new story
 */
export const postV1Story = (
    createStoryRequest: CreateStoryRequest,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<Story>(
      {url: `/v1/story`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createStoryRequest, signal
    },
      options);
    }
  


export const getPostV1StoryMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1Story>>, TError,{data: CreateStoryRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postV1Story>>, TError,{data: CreateStoryRequest}, TContext> => {

const mutationKey = ['postV1Story'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1Story>>, {data: CreateStoryRequest}> = (props) => {
          const {data} = props ?? {};

          return  postV1Story(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1StoryMutationResult = NonNullable<Awaited<ReturnType<typeof postV1Story>>>
    export type PostV1StoryMutationBody = CreateStoryRequest
    export type PostV1StoryMutationError = ErrorResponse

    /**
 * @summary Create a new story
 */
export const usePostV1Story = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1Story>>, TError,{data: CreateStoryRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postV1Story>>,
        TError,
        {data: CreateStoryRequest},
        TContext
      > => {

      const mutationOptions = getPostV1StoryMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Retrieve all stories for the authenticated user, optionally including archived stories.
 * @summary Get user stories
 */
export const getV1Story = (
    params?: GetV1StoryParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<Story[]>(
      {url: `/v1/story`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetV1StoryQueryKey = (params?: GetV1StoryParams,) => {
    return [`/v1/story`, ...(params ? [params]: [])] as const;
    }

    
export const getGetV1StoryQueryOptions = <TData = Awaited<ReturnType<typeof getV1Story>>, TError = ErrorResponse>(params?: GetV1StoryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1Story>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1StoryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1Story>>> = ({ signal }) => getV1Story(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1Story>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1StoryQueryResult = NonNullable<Awaited<ReturnType<typeof getV1Story>>>
export type GetV1StoryQueryError = ErrorResponse


export function useGetV1Story<TData = Awaited<ReturnType<typeof getV1Story>>, TError = ErrorResponse>(
 params: undefined |  GetV1StoryParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1Story>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1Story>>,
          TError,
          Awaited<ReturnType<typeof getV1Story>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1Story<TData = Awaited<ReturnType<typeof getV1Story>>, TError = ErrorResponse>(
 params?: GetV1StoryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1Story>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1Story>>,
          TError,
          Awaited<ReturnType<typeof getV1Story>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1Story<TData = Awaited<ReturnType<typeof getV1Story>>, TError = ErrorResponse>(
 params?: GetV1StoryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1Story>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get user stories
 */

export function useGetV1Story<TData = Awaited<ReturnType<typeof getV1Story>>, TError = ErrorResponse>(
 params?: GetV1StoryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1Story>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1StoryQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Retrieve the user's current active story with all sections. If a story exists but has no sections yet, returns 202 with generating status as the first section is being created.
 * @summary Get current story
 */
export const getV1StoryCurrent = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<StoryWithSections | GeneratingResponse>(
      {url: `/v1/story/current`, method: 'GET', signal
    },
      options);
    }
  

export const getGetV1StoryCurrentQueryKey = () => {
    return [`/v1/story/current`] as const;
    }

    
export const getGetV1StoryCurrentQueryOptions = <TData = Awaited<ReturnType<typeof getV1StoryCurrent>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1StoryCurrent>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1StoryCurrentQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1StoryCurrent>>> = ({ signal }) => getV1StoryCurrent(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1StoryCurrent>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1StoryCurrentQueryResult = NonNullable<Awaited<ReturnType<typeof getV1StoryCurrent>>>
export type GetV1StoryCurrentQueryError = ErrorResponse


export function useGetV1StoryCurrent<TData = Awaited<ReturnType<typeof getV1StoryCurrent>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1StoryCurrent>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1StoryCurrent>>,
          TError,
          Awaited<ReturnType<typeof getV1StoryCurrent>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1StoryCurrent<TData = Awaited<ReturnType<typeof getV1StoryCurrent>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1StoryCurrent>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1StoryCurrent>>,
          TError,
          Awaited<ReturnType<typeof getV1StoryCurrent>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1StoryCurrent<TData = Awaited<ReturnType<typeof getV1StoryCurrent>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1StoryCurrent>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get current story
 */

export function useGetV1StoryCurrent<TData = Awaited<ReturnType<typeof getV1StoryCurrent>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1StoryCurrent>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1StoryCurrentQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Retrieve a specific story by ID with all sections.
 * @summary Get a specific story
 */
export const getV1StoryId = (
    id: number,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<StoryWithSections>(
      {url: `/v1/story/${id}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetV1StoryIdQueryKey = (id: number,) => {
    return [`/v1/story/${id}`] as const;
    }

    
export const getGetV1StoryIdQueryOptions = <TData = Awaited<ReturnType<typeof getV1StoryId>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1StoryId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1StoryIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1StoryId>>> = ({ signal }) => getV1StoryId(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1StoryId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1StoryIdQueryResult = NonNullable<Awaited<ReturnType<typeof getV1StoryId>>>
export type GetV1StoryIdQueryError = ErrorResponse


export function useGetV1StoryId<TData = Awaited<ReturnType<typeof getV1StoryId>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1StoryId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1StoryId>>,
          TError,
          Awaited<ReturnType<typeof getV1StoryId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1StoryId<TData = Awaited<ReturnType<typeof getV1StoryId>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1StoryId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1StoryId>>,
          TError,
          Awaited<ReturnType<typeof getV1StoryId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1StoryId<TData = Awaited<ReturnType<typeof getV1StoryId>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1StoryId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get a specific story
 */

export function useGetV1StoryId<TData = Awaited<ReturnType<typeof getV1StoryId>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1StoryId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1StoryIdQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Delete a story. Only archived or completed stories can be deleted.
 * @summary Delete a story
 */
export const deleteV1StoryId = (
    id: number,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/v1/story/${id}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteV1StoryIdMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteV1StoryId>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteV1StoryId>>, TError,{id: number}, TContext> => {

const mutationKey = ['deleteV1StoryId'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteV1StoryId>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteV1StoryId(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteV1StoryIdMutationResult = NonNullable<Awaited<ReturnType<typeof deleteV1StoryId>>>
    
    export type DeleteV1StoryIdMutationError = ErrorResponse

    /**
 * @summary Delete a story
 */
export const useDeleteV1StoryId = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteV1StoryId>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteV1StoryId>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteV1StoryIdMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Manually generate the next section for a story. Only allowed once per day.
 * @summary Generate next section
 */
export const postV1StoryIdGenerate = (
    id: number,
    emptyRequest?: EmptyRequest,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<StorySection>(
      {url: `/v1/story/${id}/generate`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: emptyRequest, signal
    },
      options);
    }
  


export const getPostV1StoryIdGenerateMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1StoryIdGenerate>>, TError,{id: number;data: EmptyRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postV1StoryIdGenerate>>, TError,{id: number;data: EmptyRequest}, TContext> => {

const mutationKey = ['postV1StoryIdGenerate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1StoryIdGenerate>>, {id: number;data: EmptyRequest}> = (props) => {
          const {id,data} = props ?? {};

          return  postV1StoryIdGenerate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1StoryIdGenerateMutationResult = NonNullable<Awaited<ReturnType<typeof postV1StoryIdGenerate>>>
    export type PostV1StoryIdGenerateMutationBody = EmptyRequest
    export type PostV1StoryIdGenerateMutationError = ErrorResponse

    /**
 * @summary Generate next section
 */
export const usePostV1StoryIdGenerate = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1StoryIdGenerate>>, TError,{id: number;data: EmptyRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postV1StoryIdGenerate>>,
        TError,
        {id: number;data: EmptyRequest},
        TContext
      > => {

      const mutationOptions = getPostV1StoryIdGenerateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Archive a story, removing it from the current active story.
 * @summary Archive a story
 */
export const postV1StoryIdArchive = (
    id: number,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/v1/story/${id}/archive`, method: 'POST', signal
    },
      options);
    }
  


export const getPostV1StoryIdArchiveMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1StoryIdArchive>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postV1StoryIdArchive>>, TError,{id: number}, TContext> => {

const mutationKey = ['postV1StoryIdArchive'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1StoryIdArchive>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  postV1StoryIdArchive(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1StoryIdArchiveMutationResult = NonNullable<Awaited<ReturnType<typeof postV1StoryIdArchive>>>
    
    export type PostV1StoryIdArchiveMutationError = ErrorResponse

    /**
 * @summary Archive a story
 */
export const usePostV1StoryIdArchive = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1StoryIdArchive>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postV1StoryIdArchive>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getPostV1StoryIdArchiveMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Mark a story as completed.
 * @summary Complete a story
 */
export const postV1StoryIdComplete = (
    id: number,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/v1/story/${id}/complete`, method: 'POST', signal
    },
      options);
    }
  


export const getPostV1StoryIdCompleteMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1StoryIdComplete>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postV1StoryIdComplete>>, TError,{id: number}, TContext> => {

const mutationKey = ['postV1StoryIdComplete'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1StoryIdComplete>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  postV1StoryIdComplete(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1StoryIdCompleteMutationResult = NonNullable<Awaited<ReturnType<typeof postV1StoryIdComplete>>>
    
    export type PostV1StoryIdCompleteMutationError = ErrorResponse

    /**
 * @summary Complete a story
 */
export const usePostV1StoryIdComplete = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1StoryIdComplete>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postV1StoryIdComplete>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getPostV1StoryIdCompleteMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Set a story as the user's current active story.
 * @summary Set story as current
 */
export const postV1StoryIdSetCurrent = (
    id: number,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/v1/story/${id}/set-current`, method: 'POST', signal
    },
      options);
    }
  


export const getPostV1StoryIdSetCurrentMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1StoryIdSetCurrent>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postV1StoryIdSetCurrent>>, TError,{id: number}, TContext> => {

const mutationKey = ['postV1StoryIdSetCurrent'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1StoryIdSetCurrent>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  postV1StoryIdSetCurrent(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1StoryIdSetCurrentMutationResult = NonNullable<Awaited<ReturnType<typeof postV1StoryIdSetCurrent>>>
    
    export type PostV1StoryIdSetCurrentMutationError = ErrorResponse

    /**
 * @summary Set story as current
 */
export const usePostV1StoryIdSetCurrent = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1StoryIdSetCurrent>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postV1StoryIdSetCurrent>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getPostV1StoryIdSetCurrentMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Retrieve a specific story section with its questions.
 * @summary Get a story section
 */
export const getV1StorySectionId = (
    id: number,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<StorySectionWithQuestions>(
      {url: `/v1/story/section/${id}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetV1StorySectionIdQueryKey = (id: number,) => {
    return [`/v1/story/section/${id}`] as const;
    }

    
export const getGetV1StorySectionIdQueryOptions = <TData = Awaited<ReturnType<typeof getV1StorySectionId>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1StorySectionId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1StorySectionIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1StorySectionId>>> = ({ signal }) => getV1StorySectionId(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1StorySectionId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1StorySectionIdQueryResult = NonNullable<Awaited<ReturnType<typeof getV1StorySectionId>>>
export type GetV1StorySectionIdQueryError = ErrorResponse


export function useGetV1StorySectionId<TData = Awaited<ReturnType<typeof getV1StorySectionId>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1StorySectionId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1StorySectionId>>,
          TError,
          Awaited<ReturnType<typeof getV1StorySectionId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1StorySectionId<TData = Awaited<ReturnType<typeof getV1StorySectionId>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1StorySectionId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1StorySectionId>>,
          TError,
          Awaited<ReturnType<typeof getV1StorySectionId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1StorySectionId<TData = Awaited<ReturnType<typeof getV1StorySectionId>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1StorySectionId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get a story section
 */

export function useGetV1StorySectionId<TData = Awaited<ReturnType<typeof getV1StorySectionId>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1StorySectionId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1StorySectionIdQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Generate and download a PDF file containing the complete story.
 * @summary Export story as PDF
 */
export const getV1StoryIdExport = (
    id: number,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<Blob>(
      {url: `/v1/story/${id}/export`, method: 'GET',
        responseType: 'blob', signal
    },
      options);
    }
  

export const getGetV1StoryIdExportQueryKey = (id: number,) => {
    return [`/v1/story/${id}/export`] as const;
    }

    
export const getGetV1StoryIdExportQueryOptions = <TData = Awaited<ReturnType<typeof getV1StoryIdExport>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1StoryIdExport>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1StoryIdExportQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1StoryIdExport>>> = ({ signal }) => getV1StoryIdExport(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1StoryIdExport>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1StoryIdExportQueryResult = NonNullable<Awaited<ReturnType<typeof getV1StoryIdExport>>>
export type GetV1StoryIdExportQueryError = ErrorResponse


export function useGetV1StoryIdExport<TData = Awaited<ReturnType<typeof getV1StoryIdExport>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1StoryIdExport>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1StoryIdExport>>,
          TError,
          Awaited<ReturnType<typeof getV1StoryIdExport>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1StoryIdExport<TData = Awaited<ReturnType<typeof getV1StoryIdExport>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1StoryIdExport>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1StoryIdExport>>,
          TError,
          Awaited<ReturnType<typeof getV1StoryIdExport>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1StoryIdExport<TData = Awaited<ReturnType<typeof getV1StoryIdExport>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1StoryIdExport>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Export story as PDF
 */

export function useGetV1StoryIdExport<TData = Awaited<ReturnType<typeof getV1StoryIdExport>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1StoryIdExport>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1StoryIdExportQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Retrieve the current user's learning preferences
 * @summary Get user learning preferences
 */
export const getV1PreferencesLearning = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<UserLearningPreferences>(
      {url: `/v1/preferences/learning`, method: 'GET', signal
    },
      options);
    }
  

export const getGetV1PreferencesLearningQueryKey = () => {
    return [`/v1/preferences/learning`] as const;
    }

    
export const getGetV1PreferencesLearningQueryOptions = <TData = Awaited<ReturnType<typeof getV1PreferencesLearning>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1PreferencesLearning>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1PreferencesLearningQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1PreferencesLearning>>> = ({ signal }) => getV1PreferencesLearning(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1PreferencesLearning>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1PreferencesLearningQueryResult = NonNullable<Awaited<ReturnType<typeof getV1PreferencesLearning>>>
export type GetV1PreferencesLearningQueryError = ErrorResponse


export function useGetV1PreferencesLearning<TData = Awaited<ReturnType<typeof getV1PreferencesLearning>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1PreferencesLearning>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1PreferencesLearning>>,
          TError,
          Awaited<ReturnType<typeof getV1PreferencesLearning>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1PreferencesLearning<TData = Awaited<ReturnType<typeof getV1PreferencesLearning>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1PreferencesLearning>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1PreferencesLearning>>,
          TError,
          Awaited<ReturnType<typeof getV1PreferencesLearning>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1PreferencesLearning<TData = Awaited<ReturnType<typeof getV1PreferencesLearning>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1PreferencesLearning>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get user learning preferences
 */

export function useGetV1PreferencesLearning<TData = Awaited<ReturnType<typeof getV1PreferencesLearning>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1PreferencesLearning>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1PreferencesLearningQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update the current user's learning preferences
 * @summary Update user learning preferences
 */
export const putV1PreferencesLearning = (
    userLearningPreferences: UserLearningPreferences,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<UserLearningPreferences>(
      {url: `/v1/preferences/learning`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: userLearningPreferences
    },
      options);
    }
  


export const getPutV1PreferencesLearningMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putV1PreferencesLearning>>, TError,{data: UserLearningPreferences}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof putV1PreferencesLearning>>, TError,{data: UserLearningPreferences}, TContext> => {

const mutationKey = ['putV1PreferencesLearning'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putV1PreferencesLearning>>, {data: UserLearningPreferences}> = (props) => {
          const {data} = props ?? {};

          return  putV1PreferencesLearning(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PutV1PreferencesLearningMutationResult = NonNullable<Awaited<ReturnType<typeof putV1PreferencesLearning>>>
    export type PutV1PreferencesLearningMutationBody = UserLearningPreferences
    export type PutV1PreferencesLearningMutationError = ErrorResponse

    /**
 * @summary Update user learning preferences
 */
export const usePutV1PreferencesLearning = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putV1PreferencesLearning>>, TError,{data: UserLearningPreferences}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof putV1PreferencesLearning>>,
        TError,
        {data: UserLearningPreferences},
        TContext
      > => {

      const mutationOptions = getPutV1PreferencesLearningMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Returns aggregated version information for backend and worker services
 * @summary Get service version info
 */
export const getV1Version = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<AggregatedVersion>(
      {url: `/v1/version`, method: 'GET', signal
    },
      options);
    }
  

export const getGetV1VersionQueryKey = () => {
    return [`/v1/version`] as const;
    }

    
export const getGetV1VersionQueryOptions = <TData = Awaited<ReturnType<typeof getV1Version>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1Version>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1VersionQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1Version>>> = ({ signal }) => getV1Version(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1Version>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1VersionQueryResult = NonNullable<Awaited<ReturnType<typeof getV1Version>>>
export type GetV1VersionQueryError = unknown


export function useGetV1Version<TData = Awaited<ReturnType<typeof getV1Version>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1Version>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1Version>>,
          TError,
          Awaited<ReturnType<typeof getV1Version>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1Version<TData = Awaited<ReturnType<typeof getV1Version>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1Version>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1Version>>,
          TError,
          Awaited<ReturnType<typeof getV1Version>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1Version<TData = Awaited<ReturnType<typeof getV1Version>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1Version>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get service version info
 */

export function useGetV1Version<TData = Awaited<ReturnType<typeof getV1Version>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1Version>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1VersionQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Returns the health status of the service
 * @summary Health check
 */
export const getHealth = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetHealth200>(
      {url: `/health`, method: 'GET', signal
    },
      options);
    }
  

export const getGetHealthQueryKey = () => {
    return [`/health`] as const;
    }

    
export const getGetHealthQueryOptions = <TData = Awaited<ReturnType<typeof getHealth>>, TError = GetHealth503>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getHealth>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetHealthQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getHealth>>> = ({ signal }) => getHealth(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getHealth>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetHealthQueryResult = NonNullable<Awaited<ReturnType<typeof getHealth>>>
export type GetHealthQueryError = GetHealth503


export function useGetHealth<TData = Awaited<ReturnType<typeof getHealth>>, TError = GetHealth503>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getHealth>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getHealth>>,
          TError,
          Awaited<ReturnType<typeof getHealth>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetHealth<TData = Awaited<ReturnType<typeof getHealth>>, TError = GetHealth503>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getHealth>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getHealth>>,
          TError,
          Awaited<ReturnType<typeof getHealth>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetHealth<TData = Awaited<ReturnType<typeof getHealth>>, TError = GetHealth503>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getHealth>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Health check
 */

export function useGetHealth<TData = Awaited<ReturnType<typeof getHealth>>, TError = GetHealth503>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getHealth>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetHealthQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Retrieve all daily questions assigned to a specific user for a given date (admin only)
 * @summary Get daily questions for a specific user and date
 */
export const getV1AdminWorkerDailyUsersUserIdQuestionsDate = (
    userId: number,
    date: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetV1AdminWorkerDailyUsersUserIdQuestionsDate200>(
      {url: `/v1/admin/worker/daily/users/${userId}/questions/${date}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetV1AdminWorkerDailyUsersUserIdQuestionsDateQueryKey = (userId: number,
    date: string,) => {
    return [`/v1/admin/worker/daily/users/${userId}/questions/${date}`] as const;
    }

    
export const getGetV1AdminWorkerDailyUsersUserIdQuestionsDateQueryOptions = <TData = Awaited<ReturnType<typeof getV1AdminWorkerDailyUsersUserIdQuestionsDate>>, TError = ErrorResponse>(userId: number,
    date: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerDailyUsersUserIdQuestionsDate>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AdminWorkerDailyUsersUserIdQuestionsDateQueryKey(userId,date);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AdminWorkerDailyUsersUserIdQuestionsDate>>> = ({ signal }) => getV1AdminWorkerDailyUsersUserIdQuestionsDate(userId,date, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(userId && date), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerDailyUsersUserIdQuestionsDate>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AdminWorkerDailyUsersUserIdQuestionsDateQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AdminWorkerDailyUsersUserIdQuestionsDate>>>
export type GetV1AdminWorkerDailyUsersUserIdQuestionsDateQueryError = ErrorResponse


export function useGetV1AdminWorkerDailyUsersUserIdQuestionsDate<TData = Awaited<ReturnType<typeof getV1AdminWorkerDailyUsersUserIdQuestionsDate>>, TError = ErrorResponse>(
 userId: number,
    date: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerDailyUsersUserIdQuestionsDate>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminWorkerDailyUsersUserIdQuestionsDate>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminWorkerDailyUsersUserIdQuestionsDate>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminWorkerDailyUsersUserIdQuestionsDate<TData = Awaited<ReturnType<typeof getV1AdminWorkerDailyUsersUserIdQuestionsDate>>, TError = ErrorResponse>(
 userId: number,
    date: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerDailyUsersUserIdQuestionsDate>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminWorkerDailyUsersUserIdQuestionsDate>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminWorkerDailyUsersUserIdQuestionsDate>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminWorkerDailyUsersUserIdQuestionsDate<TData = Awaited<ReturnType<typeof getV1AdminWorkerDailyUsersUserIdQuestionsDate>>, TError = ErrorResponse>(
 userId: number,
    date: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerDailyUsersUserIdQuestionsDate>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get daily questions for a specific user and date
 */

export function useGetV1AdminWorkerDailyUsersUserIdQuestionsDate<TData = Awaited<ReturnType<typeof getV1AdminWorkerDailyUsersUserIdQuestionsDate>>, TError = ErrorResponse>(
 userId: number,
    date: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerDailyUsersUserIdQuestionsDate>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AdminWorkerDailyUsersUserIdQuestionsDateQueryOptions(userId,date,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Clear and regenerate daily questions for a specific user and date (admin only)
 * @summary Regenerate daily questions for a specific user and date
 */
export const postV1AdminWorkerDailyUsersUserIdQuestionsDateRegenerate = (
    userId: number,
    date: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<PostV1AdminWorkerDailyUsersUserIdQuestionsDateRegenerate200>(
      {url: `/v1/admin/worker/daily/users/${userId}/questions/${date}/regenerate`, method: 'POST', signal
    },
      options);
    }
  


export const getPostV1AdminWorkerDailyUsersUserIdQuestionsDateRegenerateMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AdminWorkerDailyUsersUserIdQuestionsDateRegenerate>>, TError,{userId: number;date: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postV1AdminWorkerDailyUsersUserIdQuestionsDateRegenerate>>, TError,{userId: number;date: string}, TContext> => {

const mutationKey = ['postV1AdminWorkerDailyUsersUserIdQuestionsDateRegenerate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1AdminWorkerDailyUsersUserIdQuestionsDateRegenerate>>, {userId: number;date: string}> = (props) => {
          const {userId,date} = props ?? {};

          return  postV1AdminWorkerDailyUsersUserIdQuestionsDateRegenerate(userId,date,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1AdminWorkerDailyUsersUserIdQuestionsDateRegenerateMutationResult = NonNullable<Awaited<ReturnType<typeof postV1AdminWorkerDailyUsersUserIdQuestionsDateRegenerate>>>
    
    export type PostV1AdminWorkerDailyUsersUserIdQuestionsDateRegenerateMutationError = ErrorResponse

    /**
 * @summary Regenerate daily questions for a specific user and date
 */
export const usePostV1AdminWorkerDailyUsersUserIdQuestionsDateRegenerate = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AdminWorkerDailyUsersUserIdQuestionsDateRegenerate>>, TError,{userId: number;date: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postV1AdminWorkerDailyUsersUserIdQuestionsDateRegenerate>>,
        TError,
        {userId: number;date: string},
        TContext
      > => {

      const mutationOptions = getPostV1AdminWorkerDailyUsersUserIdQuestionsDateRegenerateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Convert text to speech using the TTS service with SSE streaming support
 * @summary Generate speech from text
 */
export const postV1AudioSpeech = (
    tTSRequest: TTSRequest,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<TTSResponse>(
      {url: `/v1/audio/speech`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: tTSRequest, signal
    },
      options);
    }
  


export const getPostV1AudioSpeechMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AudioSpeech>>, TError,{data: TTSRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postV1AudioSpeech>>, TError,{data: TTSRequest}, TContext> => {

const mutationKey = ['postV1AudioSpeech'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1AudioSpeech>>, {data: TTSRequest}> = (props) => {
          const {data} = props ?? {};

          return  postV1AudioSpeech(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1AudioSpeechMutationResult = NonNullable<Awaited<ReturnType<typeof postV1AudioSpeech>>>
    export type PostV1AudioSpeechMutationBody = TTSRequest
    export type PostV1AudioSpeechMutationError = ErrorResponse

    /**
 * @summary Generate speech from text
 */
export const usePostV1AudioSpeech = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AudioSpeech>>, TError,{data: TTSRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postV1AudioSpeech>>,
        TError,
        {data: TTSRequest},
        TContext
      > => {

      const mutationOptions = getPostV1AudioSpeechMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }


export const getPostV1AuthLoginResponseMock = (overrideResponse: Partial< LoginResponse > = {}): LoginResponse => ({success: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), message: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), user: faker.helpers.arrayElement([{id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), username: faker.helpers.arrayElement([faker.helpers.fromRegExp('^[a-zA-Z0-9_@.+-]+$'), undefined]), email: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), timezone: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), preferred_language: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), current_level: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), ai_provider: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), ai_model: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), ai_enabled: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), is_paused: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), has_api_key: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), created_at: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), last_active: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), roles: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 20 }) }, (_, i) => i + 1).map(() => ({id: faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), name: faker.string.alpha({length: {min: 10, max: 50}}), description: faker.string.alpha({length: {min: 10, max: 500}}), created_at: faker.string.alpha({length: {min: 10, max: 20}}), updated_at: faker.string.alpha({length: {min: 10, max: 20}})})), undefined])}, undefined]), redirect_uri: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), ...overrideResponse})

export const getPostV1AuthLogoutResponseMock = (overrideResponse: Partial< SuccessResponse > = {}): SuccessResponse => ({success: faker.datatype.boolean(), message: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 500}}), undefined]), ...overrideResponse})

export const getGetV1AuthStatusResponseMock = (overrideResponse: Partial< AuthStatusResponse > = {}): AuthStatusResponse => ({authenticated: faker.datatype.boolean(), user: {id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), username: faker.helpers.arrayElement([faker.helpers.fromRegExp('^[a-zA-Z0-9_@.+-]+$'), undefined]), email: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), timezone: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), preferred_language: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), current_level: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), ai_provider: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), ai_model: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), ai_enabled: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), is_paused: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), has_api_key: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), created_at: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), last_active: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), roles: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 20 }) }, (_, i) => i + 1).map(() => ({id: faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), name: faker.string.alpha({length: {min: 10, max: 50}}), description: faker.string.alpha({length: {min: 10, max: 500}}), created_at: faker.string.alpha({length: {min: 10, max: 20}}), updated_at: faker.string.alpha({length: {min: 10, max: 20}})})), undefined])}, ...overrideResponse})

export const getPostV1AuthSignupResponseMock = (overrideResponse: Partial< SuccessResponse > = {}): SuccessResponse => ({success: faker.datatype.boolean(), message: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 500}}), undefined]), ...overrideResponse})

export const getGetV1AuthSignupStatusResponseMock = (overrideResponse: Partial< SignupStatusResponse > = {}): SignupStatusResponse => ({signups_disabled: faker.datatype.boolean(), ...overrideResponse})

export const getGetV1AuthGoogleLoginResponseMock = (overrideResponse: Partial< GoogleOAuthLoginResponse > = {}): GoogleOAuthLoginResponse => ({auth_url: faker.string.alpha({length: {min: 10, max: 20}}), ...overrideResponse})

export const getGetV1AuthGoogleCallbackResponseMock = (overrideResponse: Partial< LoginResponse > = {}): LoginResponse => ({success: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), message: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), user: faker.helpers.arrayElement([{id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), username: faker.helpers.arrayElement([faker.helpers.fromRegExp('^[a-zA-Z0-9_@.+-]+$'), undefined]), email: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), timezone: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), preferred_language: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), current_level: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), ai_provider: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), ai_model: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), ai_enabled: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), is_paused: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), has_api_key: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), created_at: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), last_active: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), roles: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 20 }) }, (_, i) => i + 1).map(() => ({id: faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), name: faker.string.alpha({length: {min: 10, max: 50}}), description: faker.string.alpha({length: {min: 10, max: 500}}), created_at: faker.string.alpha({length: {min: 10, max: 20}}), updated_at: faker.string.alpha({length: {min: 10, max: 20}})})), undefined])}, undefined]), redirect_uri: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), ...overrideResponse})

export const getGetV1QuizQuestionResponseMock = (overrideResponse: Partial< Question | GeneratingResponse > = {}): Question | GeneratingResponse => (faker.helpers.arrayElement([{id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), language: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), level: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), type: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(QuestionType)), undefined]), status: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(QuestionStatus)), undefined]), difficulty_score: faker.helpers.arrayElement([faker.number.float({min: undefined, max: undefined, fractionDigits: 2}), undefined]), explanation: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), content: faker.helpers.arrayElement([{question: faker.string.alpha({length: {min: 1, max: 1000}}), options: Array.from({ length: faker.number.int({ min: 4, max: 10 }) }, (_, i) => i + 1).map(() => (faker.string.alpha({length: {min: 1, max: 500}}))), sentence: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 2000}}), undefined]), passage: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 5000}}), undefined]), hint: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 500}}), undefined])}, undefined]), created_at: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), correct_count: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), incorrect_count: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), total_responses: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), user_count: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), correct_answer: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), reporters: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), topic_category: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), grammar_focus: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), vocabulary_domain: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), scenario: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), style_modifier: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), difficulty_modifier: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), time_context: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), confidence_level: faker.helpers.arrayElement([faker.number.int({min: 1, max: 5, multipleOf: undefined}), undefined]), ...overrideResponse}, {status: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 100}}), undefined]), message: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 500}}), undefined]), ai_model: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), api_key: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), ...overrideResponse}]))

export const getGetV1QuizQuestionIdResponseMock = (overrideResponse: Partial< Question > = {}): Question => ({id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), language: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), level: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), type: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(QuestionType)), undefined]), status: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(QuestionStatus)), undefined]), difficulty_score: faker.helpers.arrayElement([faker.number.float({min: undefined, max: undefined, fractionDigits: 2}), undefined]), explanation: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), content: faker.helpers.arrayElement([{question: faker.string.alpha({length: {min: 1, max: 1000}}), options: Array.from({ length: faker.number.int({ min: 4, max: 10 }) }, (_, i) => i + 1).map(() => (faker.string.alpha({length: {min: 1, max: 500}}))), sentence: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 2000}}), undefined]), passage: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 5000}}), undefined]), hint: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 500}}), undefined])}, undefined]), created_at: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), correct_count: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), incorrect_count: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), total_responses: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), user_count: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), correct_answer: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), reporters: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), topic_category: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), grammar_focus: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), vocabulary_domain: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), scenario: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), style_modifier: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), difficulty_modifier: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), time_context: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), confidence_level: faker.helpers.arrayElement([faker.number.int({min: 1, max: 5, multipleOf: undefined}), undefined]), ...overrideResponse})

export const getPostV1QuizAnswerResponseMock = (overrideResponse: Partial< AnswerResponse > = {}): AnswerResponse => ({is_correct: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), user_answer: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), user_answer_index: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), explanation: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), next_difficulty: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), correct_answer_index: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), ...overrideResponse})

export const getGetV1QuizProgressResponseMock = (overrideResponse: Partial< UserProgress > = {}): UserProgress => ({current_level: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), suggested_level: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), accuracy_rate: faker.helpers.arrayElement([faker.number.float({min: 0, max: 1, fractionDigits: 2}), undefined]), total_questions: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined, multipleOf: undefined}), undefined]), correct_answers: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined, multipleOf: undefined}), undefined]), performance_by_topic: faker.helpers.arrayElement([{
        [faker.string.alphanumeric(5)]: {correct_attempts: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined, multipleOf: undefined}), undefined]), total_attempts: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined, multipleOf: undefined}), undefined]), average_response_time_ms: faker.helpers.arrayElement([faker.number.float({min: 0, max: undefined, fractionDigits: 2}), undefined]), last_updated: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined])}
      }, undefined]), weak_areas: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 50 }) }, (_, i) => i + 1).map(() => (faker.string.alpha({length: {min: 10, max: 20}}))), undefined]), recent_activity: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 100 }) }, (_, i) => i + 1).map(() => ({question_id: faker.helpers.arrayElement([faker.number.int({min: 1, max: undefined, multipleOf: undefined}), undefined]), is_correct: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), created_at: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined])})), undefined]), worker_status: faker.helpers.arrayElement([{status: faker.helpers.arrayElement([faker.helpers.arrayElement(['idle','busy','error'] as const), undefined]), last_heartbeat: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), error_message: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined])}, undefined]), learning_preferences: faker.helpers.arrayElement([{focus_on_weak_areas: faker.datatype.boolean(), fresh_question_ratio: faker.number.float({min: 0, max: 1, fractionDigits: 2}), known_question_penalty: faker.number.float({min: 0, max: 1, fractionDigits: 2}), review_interval_days: faker.number.int({min: 1, max: 60, multipleOf: undefined}), weak_area_boost: faker.number.float({min: 1, max: 5, fractionDigits: 2}), daily_reminder_enabled: faker.datatype.boolean(), tts_voice: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), daily_goal: faker.helpers.arrayElement([faker.number.int({min: 1, max: undefined, multipleOf: undefined}), undefined])}, undefined]), priority_insights: faker.helpers.arrayElement([{total_questions_in_queue: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined, multipleOf: undefined}), undefined]), high_priority_questions: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined, multipleOf: undefined}), undefined]), medium_priority_questions: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined, multipleOf: undefined}), undefined]), low_priority_questions: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined, multipleOf: undefined}), undefined])}, undefined]), generation_focus: faker.helpers.arrayElement([{current_generation_model: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), last_generation_time: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), generation_rate: faker.helpers.arrayElement([faker.number.float({min: 0, max: undefined, fractionDigits: 2}), undefined])}, undefined]), high_priority_topics: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 20 }) }, (_, i) => i + 1).map(() => (faker.string.alpha({length: {min: 10, max: 20}}))), undefined]), gap_analysis: faker.helpers.arrayElement([{}, undefined]), priority_distribution: faker.helpers.arrayElement([{
        [faker.string.alphanumeric(5)]: faker.number.int({min: 0, max: undefined, multipleOf: undefined})
      }, undefined]), ...overrideResponse})

export const getPostV1QuizQuestionIdReportResponseMock = (overrideResponse: Partial< SuccessResponse > = {}): SuccessResponse => ({success: faker.datatype.boolean(), message: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 500}}), undefined]), ...overrideResponse})

export const getPostV1QuizQuestionIdMarkKnownResponseMock = (overrideResponse: Partial< SuccessResponse > = {}): SuccessResponse => ({success: faker.datatype.boolean(), message: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 500}}), undefined]), ...overrideResponse})

export const getGetV1QuizWorkerStatusResponseMock = (overrideResponse: Partial< WorkerStatusResponse > = {}): WorkerStatusResponse => ({has_errors: faker.datatype.boolean(), error_message: faker.string.alpha({length: {min: 10, max: 20}}), global_paused: faker.datatype.boolean(), user_paused: faker.datatype.boolean(), healthy_workers: faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), total_workers: faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), last_error_details: faker.string.alpha({length: {min: 10, max: 20}}), worker_running: faker.datatype.boolean(), ...overrideResponse})

export const getPutV1SettingsResponseMock = (overrideResponse: Partial< SuccessResponse > = {}): SuccessResponse => ({success: faker.datatype.boolean(), message: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 500}}), undefined]), ...overrideResponse})

export const getGetV1SettingsAiProvidersResponseMock = (overrideResponse: Partial< AIProviders > = {}): AIProviders => ({providers: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 50 }) }, (_, i) => i + 1).map(() => ({name: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 100}}), undefined]), code: faker.helpers.arrayElement([faker.helpers.fromRegExp('^[a-zA-Z0-9_.-]+$'), undefined]), url: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 500}}), undefined]), models: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 100 }) }, (_, i) => i + 1).map(() => ({name: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 100}}), undefined]), code: faker.helpers.arrayElement([faker.helpers.fromRegExp('^[a-zA-Z0-9_.:-]+$'), undefined])})), undefined])})), undefined]), levels: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 20 }) }, (_, i) => i + 1).map(() => (faker.string.alpha({length: {min: 10, max: 20}}))), undefined]), ...overrideResponse})

export const getPostV1SettingsTestAiResponseMock = (overrideResponse: Partial< SuccessResponse > = {}): SuccessResponse => ({success: faker.datatype.boolean(), message: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 500}}), undefined]), ...overrideResponse})

export const getPostV1SettingsTestEmailResponseMock = (overrideResponse: Partial< SuccessResponse > = {}): SuccessResponse => ({success: faker.datatype.boolean(), message: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 500}}), undefined]), ...overrideResponse})

export const getGetV1SettingsLevelsResponseMock = (overrideResponse: Partial< LevelsResponse > = {}): LevelsResponse => ({levels: Array.from({ length: faker.number.int({ min: 1, max: 20 }) }, (_, i) => i + 1).map(() => (faker.string.alpha({length: {min: 10, max: 20}}))), level_descriptions: {
        [faker.string.alphanumeric(5)]: faker.string.alpha({length: {min: 10, max: 20}})
      }, ...overrideResponse})

export const getGetV1SettingsLanguagesResponseMock = (): LanguagesResponse => (Array.from({ length: faker.number.int({ min: 1, max: 20 }) }, (_, i) => i + 1).map(() => (faker.string.alpha({length: {min: 10, max: 20}}))))

export const getGetV1SettingsApiKeyProviderResponseMock = (overrideResponse: Partial< APIKeyAvailabilityResponse > = {}): APIKeyAvailabilityResponse => ({has_api_key: faker.datatype.boolean(), ...overrideResponse})

export const getPostV1AiConversationsResponseMock = (overrideResponse: Partial< Conversation > = {}): Conversation => ({id: faker.string.uuid(), user_id: faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), title: faker.string.alpha({length: {min: 10, max: 20}}), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, message_count: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), messages: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.uuid(), conversation_id: faker.string.uuid(), question_id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), role: faker.helpers.arrayElement(['user','assistant'] as const), content: {text: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined])}, bookmarked: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, conversation_title: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined])})), undefined]), ...overrideResponse})

export const getGetV1AiConversationsResponseMock = (overrideResponse: Partial< GetV1AiConversations200 > = {}): GetV1AiConversations200 => ({conversations: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.uuid(), user_id: faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), title: faker.string.alpha({length: {min: 10, max: 20}}), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, message_count: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), messages: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.uuid(), conversation_id: faker.string.uuid(), question_id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), role: faker.helpers.arrayElement(['user','assistant'] as const), content: {text: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined])}, bookmarked: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, conversation_title: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined])})), undefined])})), undefined]), total: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), limit: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), offset: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), ...overrideResponse})

export const getGetV1AiConversationsIdResponseMock = (overrideResponse: Partial< Conversation > = {}): Conversation => ({id: faker.string.uuid(), user_id: faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), title: faker.string.alpha({length: {min: 10, max: 20}}), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, message_count: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), messages: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.uuid(), conversation_id: faker.string.uuid(), question_id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), role: faker.helpers.arrayElement(['user','assistant'] as const), content: {text: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined])}, bookmarked: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, conversation_title: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined])})), undefined]), ...overrideResponse})

export const getPutV1AiConversationsIdResponseMock = (overrideResponse: Partial< Conversation > = {}): Conversation => ({id: faker.string.uuid(), user_id: faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), title: faker.string.alpha({length: {min: 10, max: 20}}), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, message_count: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), messages: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.uuid(), conversation_id: faker.string.uuid(), question_id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), role: faker.helpers.arrayElement(['user','assistant'] as const), content: {text: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined])}, bookmarked: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, conversation_title: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined])})), undefined]), ...overrideResponse})

export const getPostV1AiConversationsConversationIdMessagesResponseMock = (overrideResponse: Partial< ChatMessage > = {}): ChatMessage => ({id: faker.string.uuid(), conversation_id: faker.string.uuid(), question_id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), role: faker.helpers.arrayElement(['user','assistant'] as const), content: {text: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined])}, bookmarked: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, conversation_title: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), ...overrideResponse})

export const getGetV1AiSearchResponseMock = (overrideResponse: Partial< GetV1AiSearch200 > = {}): GetV1AiSearch200 => ({conversations: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.uuid(), user_id: faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), title: faker.string.alpha({length: {min: 10, max: 20}}), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, message_count: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), messages: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.uuid(), conversation_id: faker.string.uuid(), question_id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), role: faker.helpers.arrayElement(['user','assistant'] as const), content: {text: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined])}, bookmarked: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, conversation_title: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined])})), undefined])})), undefined]), query: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), total: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), limit: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), offset: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), ...overrideResponse})

export const getPutV1AiConversationsBookmarkResponseMock = (overrideResponse: Partial< PutV1AiConversationsBookmark200 > = {}): PutV1AiConversationsBookmark200 => ({bookmarked: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), ...overrideResponse})

export const getPutV1UserzProfileResponseMock = (overrideResponse: Partial< PutV1UserzProfile200 > = {}): PutV1UserzProfile200 => ({message: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), user: faker.helpers.arrayElement([{id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), username: faker.helpers.arrayElement([faker.helpers.fromRegExp('^[a-zA-Z0-9_@.+-]+$'), undefined]), email: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), timezone: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), last_active: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), preferred_language: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), current_level: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), ai_enabled: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), is_paused: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), created_at: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), updated_at: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined])}, undefined]), ...overrideResponse})

export const getGetV1AdminBackendResponseMock = (): string => (faker.word.sample())

export const getGetV1AdminBackendUserzResponseMock = (overrideResponse: Partial< GetV1AdminBackendUserz200 > = {}): GetV1AdminBackendUserz200 => ({users: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 1000 }) }, (_, i) => i + 1).map(() => ({id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), username: faker.helpers.arrayElement([faker.helpers.fromRegExp('^[a-zA-Z0-9_@.+-]+$'), undefined]), email: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), timezone: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), last_active: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), preferred_language: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), current_level: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), ai_enabled: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), is_paused: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), created_at: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), updated_at: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined])})), undefined]), ...overrideResponse})

export const getPostV1AdminBackendUserzResponseMock = (overrideResponse: Partial< PostV1AdminBackendUserz201 > = {}): PostV1AdminBackendUserz201 => ({message: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), user: faker.helpers.arrayElement([{id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), username: faker.helpers.arrayElement([faker.helpers.fromRegExp('^[a-zA-Z0-9_@.+-]+$'), undefined]), email: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), timezone: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), last_active: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), preferred_language: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), current_level: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), ai_enabled: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), is_paused: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), created_at: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), updated_at: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined])}, undefined]), ...overrideResponse})

export const getPostV1SettingsClearStoriesResponseMock = (overrideResponse: Partial< SuccessResponse > = {}): SuccessResponse => ({success: faker.datatype.boolean(), message: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 500}}), undefined]), ...overrideResponse})

export const getPostV1SettingsResetAccountResponseMock = (overrideResponse: Partial< SuccessResponse > = {}): SuccessResponse => ({success: faker.datatype.boolean(), message: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 500}}), undefined]), ...overrideResponse})

export const getPostV1SettingsClearAiChatsResponseMock = (overrideResponse: Partial< SuccessResponse > = {}): SuccessResponse => ({success: faker.datatype.boolean(), message: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 500}}), undefined]), ...overrideResponse})

export const getGetV1AdminBackendUserzPaginatedResponseMock = (overrideResponse: Partial< GetV1AdminBackendUserzPaginated200 > = {}): GetV1AdminBackendUserzPaginated200 => ({users: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({user: faker.helpers.arrayElement([{id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), username: faker.helpers.arrayElement([faker.helpers.fromRegExp('^[a-zA-Z0-9_@.+-]+$'), undefined]), email: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), timezone: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), last_active: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), preferred_language: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), current_level: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), ai_enabled: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), is_paused: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), created_at: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), updated_at: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined])}, undefined]), progress: faker.helpers.arrayElement([{current_level: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), suggested_level: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), accuracy_rate: faker.helpers.arrayElement([faker.number.float({min: 0, max: 1, fractionDigits: 2}), undefined]), total_questions: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined, multipleOf: undefined}), undefined]), correct_answers: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined, multipleOf: undefined}), undefined]), performance_by_topic: faker.helpers.arrayElement([{
        [faker.string.alphanumeric(5)]: {correct_attempts: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined, multipleOf: undefined}), undefined]), total_attempts: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined, multipleOf: undefined}), undefined]), average_response_time_ms: faker.helpers.arrayElement([faker.number.float({min: 0, max: undefined, fractionDigits: 2}), undefined]), last_updated: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined])}
      }, undefined]), weak_areas: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 50 }) }, (_, i) => i + 1).map(() => (faker.string.alpha({length: {min: 10, max: 20}}))), undefined]), recent_activity: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 100 }) }, (_, i) => i + 1).map(() => ({question_id: faker.helpers.arrayElement([faker.number.int({min: 1, max: undefined, multipleOf: undefined}), undefined]), is_correct: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), created_at: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined])})), undefined]), worker_status: faker.helpers.arrayElement([{status: faker.helpers.arrayElement([faker.helpers.arrayElement(['idle','busy','error'] as const), undefined]), last_heartbeat: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), error_message: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined])}, undefined]), learning_preferences: faker.helpers.arrayElement([{focus_on_weak_areas: faker.datatype.boolean(), fresh_question_ratio: faker.number.float({min: 0, max: 1, fractionDigits: 2}), known_question_penalty: faker.number.float({min: 0, max: 1, fractionDigits: 2}), review_interval_days: faker.number.int({min: 1, max: 60, multipleOf: undefined}), weak_area_boost: faker.number.float({min: 1, max: 5, fractionDigits: 2}), daily_reminder_enabled: faker.datatype.boolean(), tts_voice: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), daily_goal: faker.helpers.arrayElement([faker.number.int({min: 1, max: undefined, multipleOf: undefined}), undefined])}, undefined]), priority_insights: faker.helpers.arrayElement([{total_questions_in_queue: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined, multipleOf: undefined}), undefined]), high_priority_questions: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined, multipleOf: undefined}), undefined]), medium_priority_questions: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined, multipleOf: undefined}), undefined]), low_priority_questions: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined, multipleOf: undefined}), undefined])}, undefined]), generation_focus: faker.helpers.arrayElement([{current_generation_model: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), last_generation_time: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), generation_rate: faker.helpers.arrayElement([faker.number.float({min: 0, max: undefined, fractionDigits: 2}), undefined])}, undefined]), high_priority_topics: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 20 }) }, (_, i) => i + 1).map(() => (faker.string.alpha({length: {min: 10, max: 20}}))), undefined]), gap_analysis: faker.helpers.arrayElement([{}, undefined]), priority_distribution: faker.helpers.arrayElement([{
        [faker.string.alphanumeric(5)]: faker.number.int({min: 0, max: undefined, multipleOf: undefined})
      }, undefined])}, undefined]), question_stats: faker.helpers.arrayElement([{user_id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), total_answered: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), answered_by_type: faker.helpers.arrayElement([{}, undefined]), answered_by_level: faker.helpers.arrayElement([{}, undefined]), accuracy_by_type: faker.helpers.arrayElement([{}, undefined]), accuracy_by_level: faker.helpers.arrayElement([{}, undefined]), available_by_type: faker.helpers.arrayElement([{}, undefined]), available_by_level: faker.helpers.arrayElement([{}, undefined])}, undefined])})), undefined]), pagination: faker.helpers.arrayElement([{page: faker.number.int({min: 1, max: undefined, multipleOf: undefined}), page_size: faker.number.int({min: 1, max: 100, multipleOf: undefined}), total: faker.number.int({min: 0, max: undefined, multipleOf: undefined}), total_pages: faker.number.int({min: 0, max: undefined, multipleOf: undefined})}, undefined]), ...overrideResponse})

export const getPutV1AdminBackendUserzIdResponseMock = (overrideResponse: Partial< PutV1AdminBackendUserzId200 > = {}): PutV1AdminBackendUserzId200 => ({message: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), user: faker.helpers.arrayElement([{id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), username: faker.helpers.arrayElement([faker.helpers.fromRegExp('^[a-zA-Z0-9_@.+-]+$'), undefined]), email: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), timezone: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), last_active: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), preferred_language: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), current_level: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), ai_enabled: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), is_paused: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), created_at: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), updated_at: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined])}, undefined]), ...overrideResponse})

export const getDeleteV1AdminBackendUserzIdResponseMock = (overrideResponse: Partial< DeleteV1AdminBackendUserzId200 > = {}): DeleteV1AdminBackendUserzId200 => ({message: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), ...overrideResponse})

export const getPostV1AdminBackendUserzIdResetPasswordResponseMock = (overrideResponse: Partial< PostV1AdminBackendUserzIdResetPassword200 > = {}): PostV1AdminBackendUserzIdResetPassword200 => ({message: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), ...overrideResponse})

export const getGetV1AdminBackendRolesResponseMock = (overrideResponse: Partial< GetV1AdminBackendRoles200 > = {}): GetV1AdminBackendRoles200 => ({roles: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 50 }) }, (_, i) => i + 1).map(() => ({id: faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), name: faker.string.alpha({length: {min: 10, max: 50}}), description: faker.string.alpha({length: {min: 10, max: 500}}), created_at: faker.string.alpha({length: {min: 10, max: 20}}), updated_at: faker.string.alpha({length: {min: 10, max: 20}})})), undefined]), ...overrideResponse})

export const getGetV1AdminBackendUserzIdRolesResponseMock = (overrideResponse: Partial< GetV1AdminBackendUserzIdRoles200 > = {}): GetV1AdminBackendUserzIdRoles200 => ({roles: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 50 }) }, (_, i) => i + 1).map(() => ({id: faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), name: faker.string.alpha({length: {min: 10, max: 50}}), description: faker.string.alpha({length: {min: 10, max: 500}}), created_at: faker.string.alpha({length: {min: 10, max: 20}}), updated_at: faker.string.alpha({length: {min: 10, max: 20}})})), undefined]), ...overrideResponse})

export const getPostV1AdminBackendUserzIdRolesResponseMock = (overrideResponse: Partial< PostV1AdminBackendUserzIdRoles200 > = {}): PostV1AdminBackendUserzIdRoles200 => ({message: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), ...overrideResponse})

export const getDeleteV1AdminBackendUserzIdRolesRoleIdResponseMock = (overrideResponse: Partial< DeleteV1AdminBackendUserzIdRolesRoleId200 > = {}): DeleteV1AdminBackendUserzIdRolesRoleId200 => ({message: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), ...overrideResponse})

export const getGetV1AdminBackendDashboardResponseMock = (overrideResponse: Partial< DashboardResponse > = {}): DashboardResponse => ({users: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({user: faker.helpers.arrayElement([{id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), username: faker.helpers.arrayElement([faker.helpers.fromRegExp('^[a-zA-Z0-9_@.+-]+$'), undefined]), email: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), timezone: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), last_active: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), preferred_language: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), current_level: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), ai_enabled: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), is_paused: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), created_at: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), updated_at: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined])}, undefined]), progress: faker.helpers.arrayElement([{current_level: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), suggested_level: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), accuracy_rate: faker.helpers.arrayElement([faker.number.float({min: 0, max: 1, fractionDigits: 2}), undefined]), total_questions: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined, multipleOf: undefined}), undefined]), correct_answers: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined, multipleOf: undefined}), undefined]), performance_by_topic: faker.helpers.arrayElement([{
        [faker.string.alphanumeric(5)]: {correct_attempts: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined, multipleOf: undefined}), undefined]), total_attempts: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined, multipleOf: undefined}), undefined]), average_response_time_ms: faker.helpers.arrayElement([faker.number.float({min: 0, max: undefined, fractionDigits: 2}), undefined]), last_updated: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined])}
      }, undefined]), weak_areas: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 50 }) }, (_, i) => i + 1).map(() => (faker.string.alpha({length: {min: 10, max: 20}}))), undefined]), recent_activity: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 100 }) }, (_, i) => i + 1).map(() => ({question_id: faker.helpers.arrayElement([faker.number.int({min: 1, max: undefined, multipleOf: undefined}), undefined]), is_correct: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), created_at: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined])})), undefined]), worker_status: faker.helpers.arrayElement([{status: faker.helpers.arrayElement([faker.helpers.arrayElement(['idle','busy','error'] as const), undefined]), last_heartbeat: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), error_message: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined])}, undefined]), learning_preferences: faker.helpers.arrayElement([{focus_on_weak_areas: faker.datatype.boolean(), fresh_question_ratio: faker.number.float({min: 0, max: 1, fractionDigits: 2}), known_question_penalty: faker.number.float({min: 0, max: 1, fractionDigits: 2}), review_interval_days: faker.number.int({min: 1, max: 60, multipleOf: undefined}), weak_area_boost: faker.number.float({min: 1, max: 5, fractionDigits: 2}), daily_reminder_enabled: faker.datatype.boolean(), tts_voice: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), daily_goal: faker.helpers.arrayElement([faker.number.int({min: 1, max: undefined, multipleOf: undefined}), undefined])}, undefined]), priority_insights: faker.helpers.arrayElement([{total_questions_in_queue: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined, multipleOf: undefined}), undefined]), high_priority_questions: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined, multipleOf: undefined}), undefined]), medium_priority_questions: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined, multipleOf: undefined}), undefined]), low_priority_questions: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined, multipleOf: undefined}), undefined])}, undefined]), generation_focus: faker.helpers.arrayElement([{current_generation_model: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), last_generation_time: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), generation_rate: faker.helpers.arrayElement([faker.number.float({min: 0, max: undefined, fractionDigits: 2}), undefined])}, undefined]), high_priority_topics: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 20 }) }, (_, i) => i + 1).map(() => (faker.string.alpha({length: {min: 10, max: 20}}))), undefined]), gap_analysis: faker.helpers.arrayElement([{}, undefined]), priority_distribution: faker.helpers.arrayElement([{
        [faker.string.alphanumeric(5)]: faker.number.int({min: 0, max: undefined, multipleOf: undefined})
      }, undefined])}, undefined]), question_stats: faker.helpers.arrayElement([{user_id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), total_answered: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined, multipleOf: undefined}), undefined]), answered_by_type: faker.helpers.arrayElement([{
        [faker.string.alphanumeric(5)]: faker.number.int({min: undefined, max: undefined, multipleOf: undefined})
      }, undefined]), answered_by_level: faker.helpers.arrayElement([{
        [faker.string.alphanumeric(5)]: faker.number.int({min: undefined, max: undefined, multipleOf: undefined})
      }, undefined]), accuracy_by_type: faker.helpers.arrayElement([{
        [faker.string.alphanumeric(5)]: faker.number.float({min: undefined, max: undefined, fractionDigits: 2})
      }, undefined]), accuracy_by_level: faker.helpers.arrayElement([{
        [faker.string.alphanumeric(5)]: faker.number.float({min: undefined, max: undefined, fractionDigits: 2})
      }, undefined]), available_by_type: faker.helpers.arrayElement([{
        [faker.string.alphanumeric(5)]: faker.number.int({min: undefined, max: undefined, multipleOf: undefined})
      }, undefined]), available_by_level: faker.helpers.arrayElement([{
        [faker.string.alphanumeric(5)]: faker.number.int({min: undefined, max: undefined, multipleOf: undefined})
      }, undefined])}, undefined])})), undefined]), question_stats: faker.helpers.arrayElement([{total_questions: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined, multipleOf: undefined}), undefined]), total_responses: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined, multipleOf: undefined}), undefined]), questions_by_type: faker.helpers.arrayElement([{
        [faker.string.alphanumeric(5)]: faker.number.int({min: undefined, max: undefined, multipleOf: undefined})
      }, undefined]), questions_by_level: faker.helpers.arrayElement([{
        [faker.string.alphanumeric(5)]: faker.number.int({min: undefined, max: undefined, multipleOf: undefined})
      }, undefined]), questions_by_language: faker.helpers.arrayElement([{
        [faker.string.alphanumeric(5)]: faker.number.int({min: undefined, max: undefined, multipleOf: undefined})
      }, undefined])}, undefined]), ai_concurrency_stats: faker.helpers.arrayElement([{active_requests: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), max_concurrent: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), queued_requests: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), total_requests: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), user_active_count: faker.helpers.arrayElement([{
        [faker.string.alphanumeric(5)]: faker.number.int({min: undefined, max: undefined, multipleOf: undefined})
      }, undefined]), max_per_user: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined])}, undefined]), worker_health: faker.helpers.arrayElement([{global_paused: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), healthy_count: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), total_count: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), worker_instances: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({healthy: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), is_paused: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), is_running: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), last_heartbeat: faker.helpers.arrayElement([{Time: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), Valid: faker.helpers.arrayElement([faker.datatype.boolean(), undefined])}, undefined]), total_questions_generated: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), total_runs: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), worker_instance: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined])})), undefined])}, undefined]), worker_port: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), worker_base_url: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), ...overrideResponse})

export const getGetV1AdminBackendAiConcurrencyResponseMock = (overrideResponse: Partial< AIConcurrencyStats > = {}): AIConcurrencyStats => ({active_requests: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), max_concurrent: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), queued_requests: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), total_requests: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), user_active_count: faker.helpers.arrayElement([{
        [faker.string.alphanumeric(5)]: faker.number.int({min: undefined, max: undefined, multipleOf: undefined})
      }, undefined]), max_per_user: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), ...overrideResponse})

export const getGetV1AdminWorkerStatusResponseMock = (overrideResponse: Partial< WorkerStatus > = {}): WorkerStatus => ({status: faker.helpers.arrayElement([faker.helpers.arrayElement(['idle','busy','error'] as const), undefined]), last_heartbeat: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), error_message: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), ...overrideResponse})

export const getGetV1AdminWorkerDetailsResponseMock = (): GetV1AdminWorkerDetails200 => ({})

export const getPostV1AdminWorkerPauseResponseMock = (overrideResponse: Partial< PostV1AdminWorkerPause200 > = {}): PostV1AdminWorkerPause200 => ({message: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), ...overrideResponse})

export const getPostV1AdminWorkerResumeResponseMock = (overrideResponse: Partial< PostV1AdminWorkerResume200 > = {}): PostV1AdminWorkerResume200 => ({message: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), ...overrideResponse})

export const getPostV1AdminWorkerTriggerResponseMock = (overrideResponse: Partial< PostV1AdminWorkerTrigger200 > = {}): PostV1AdminWorkerTrigger200 => ({message: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), ...overrideResponse})

export const getGetV1AdminWorkerLogsResponseMock = (overrideResponse: Partial< GetV1AdminWorkerLogs200 > = {}): GetV1AdminWorkerLogs200 => ({logs: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({})), undefined]), ...overrideResponse})

export const getGetV1AdminWorkerAiConcurrencyResponseMock = (overrideResponse: Partial< GetV1AdminWorkerAiConcurrency200 > = {}): GetV1AdminWorkerAiConcurrency200 => ({active_requests: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), max_concurrent: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), queued_requests: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), total_requests: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), ...overrideResponse})

export const getGetV1AdminWorkerUsersResponseMock = (overrideResponse: Partial< GetV1AdminWorkerUsers200 > = {}): GetV1AdminWorkerUsers200 => ({users: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), username: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), is_paused: faker.helpers.arrayElement([faker.datatype.boolean(), undefined])})), undefined]), ...overrideResponse})

export const getPostV1AdminWorkerUsersPauseResponseMock = (overrideResponse: Partial< PostV1AdminWorkerUsersPause200 > = {}): PostV1AdminWorkerUsersPause200 => ({message: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), ...overrideResponse})

export const getPostV1AdminWorkerUsersResumeResponseMock = (overrideResponse: Partial< PostV1AdminWorkerUsersResume200 > = {}): PostV1AdminWorkerUsersResume200 => ({message: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), ...overrideResponse})

export const getGetV1AdminWorkerAnalyticsPriorityScoresResponseMock = (overrideResponse: Partial< GetV1AdminWorkerAnalyticsPriorityScores200 > = {}): GetV1AdminWorkerAnalyticsPriorityScores200 => ({distribution: faker.helpers.arrayElement([{high: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), medium: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), low: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), average: faker.helpers.arrayElement([faker.number.float({min: undefined, max: undefined, fractionDigits: 2}), undefined])}, undefined]), ...overrideResponse})

export const getGetV1AdminWorkerAnalyticsUserPerformanceResponseMock = (overrideResponse: Partial< UserPerformanceAnalytics > = {}): UserPerformanceAnalytics => ({weakAreas: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({})), undefined]), learningPreferences: faker.helpers.arrayElement([{}, undefined]), ...overrideResponse})

export const getGetV1AdminWorkerAnalyticsGenerationIntelligenceResponseMock = (overrideResponse: Partial< GenerationIntelligence > = {}): GenerationIntelligence => ({gapAnalysis: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({})), undefined]), generationSuggestions: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({})), undefined]), ...overrideResponse})

export const getGetV1AdminWorkerAnalyticsSystemHealthResponseMock = (overrideResponse: Partial< SystemHealthAnalytics > = {}): SystemHealthAnalytics => ({performance: faker.helpers.arrayElement([{}, undefined]), backgroundJobs: faker.helpers.arrayElement([{}, undefined]), ...overrideResponse})

export const getGetV1AdminWorkerNotificationsStatsResponseMock = (overrideResponse: Partial< NotificationStats > = {}): NotificationStats => ({total_sent: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined, multipleOf: undefined}), undefined]), total_failed: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined, multipleOf: undefined}), undefined]), success_rate: faker.helpers.arrayElement([faker.number.float({min: 0, max: 1, fractionDigits: 2}), undefined]), sent_today: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined, multipleOf: undefined}), undefined]), sent_this_week: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined, multipleOf: undefined}), undefined]), notifications_by_type: faker.helpers.arrayElement([{
        [faker.string.alphanumeric(5)]: faker.number.int({min: undefined, max: undefined, multipleOf: undefined})
      }, undefined]), ...overrideResponse})

export const getGetV1AdminWorkerNotificationsErrorsResponseMock = (overrideResponse: Partial< GetV1AdminWorkerNotificationsErrors200 > = {}): GetV1AdminWorkerNotificationsErrors200 => ({errors: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), user_id: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), null]), undefined]), username: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), notification_type: faker.helpers.arrayElement([faker.helpers.arrayElement(['daily_reminder','test_email'] as const), undefined]), error_type: faker.helpers.arrayElement([faker.helpers.arrayElement(['smtp_error','template_error','user_not_found','email_disabled','other'] as const), undefined]), error_message: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), email_address: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), occurred_at: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), resolved_at: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), resolution_notes: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined])})), undefined]), pagination: faker.helpers.arrayElement([{page: faker.number.int({min: 1, max: undefined, multipleOf: undefined}), page_size: faker.number.int({min: 1, max: 100, multipleOf: undefined}), total: faker.number.int({min: 0, max: undefined, multipleOf: undefined}), total_pages: faker.number.int({min: 0, max: undefined, multipleOf: undefined})}, undefined]), stats: faker.helpers.arrayElement([{total_errors: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined, multipleOf: undefined}), undefined]), unresolved_errors: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined, multipleOf: undefined}), undefined]), errors_by_type: faker.helpers.arrayElement([{
        [faker.string.alphanumeric(5)]: faker.number.int({min: undefined, max: undefined, multipleOf: undefined})
      }, undefined]), errors_by_notification_type: faker.helpers.arrayElement([{
        [faker.string.alphanumeric(5)]: faker.number.int({min: undefined, max: undefined, multipleOf: undefined})
      }, undefined])}, undefined]), ...overrideResponse})

export const getGetV1AdminWorkerNotificationsSentResponseMock = (overrideResponse: Partial< GetV1AdminWorkerNotificationsSent200 > = {}): GetV1AdminWorkerNotificationsSent200 => ({notifications: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), user_id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), username: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), email_address: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), notification_type: faker.helpers.arrayElement([faker.helpers.arrayElement(['daily_reminder','test_email'] as const), undefined]), subject: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), template_name: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), sent_at: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), status: faker.helpers.arrayElement([faker.helpers.arrayElement(['sent','failed','bounced'] as const), undefined]), error_message: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), retry_count: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined, multipleOf: undefined}), undefined])})), undefined]), pagination: faker.helpers.arrayElement([{page: faker.number.int({min: 1, max: undefined, multipleOf: undefined}), page_size: faker.number.int({min: 1, max: 100, multipleOf: undefined}), total: faker.number.int({min: 0, max: undefined, multipleOf: undefined}), total_pages: faker.number.int({min: 0, max: undefined, multipleOf: undefined})}, undefined]), stats: faker.helpers.arrayElement([{total_sent: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined, multipleOf: undefined}), undefined]), total_failed: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined, multipleOf: undefined}), undefined]), success_rate: faker.helpers.arrayElement([faker.number.float({min: 0, max: 1, fractionDigits: 2}), undefined]), sent_today: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined, multipleOf: undefined}), undefined]), sent_this_week: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined, multipleOf: undefined}), undefined]), notifications_by_type: faker.helpers.arrayElement([{
        [faker.string.alphanumeric(5)]: faker.number.int({min: undefined, max: undefined, multipleOf: undefined})
      }, undefined])}, undefined]), ...overrideResponse})

export const getPostV1AdminWorkerNotificationsForceSendResponseMock = (overrideResponse: Partial< ForceSendNotificationResponse > = {}): ForceSendNotificationResponse => ({message: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), user: faker.helpers.arrayElement([{id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), username: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), email: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined])}, undefined]), notification: faker.helpers.arrayElement([{type: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), subject: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), status: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined])}, undefined]), ...overrideResponse})

export const getGetV1AdminBackendQuestionsResponseMock = (overrideResponse: Partial< GetV1AdminBackendQuestions200 > = {}): GetV1AdminBackendQuestions200 => ({questions: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), language: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), level: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), type: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(QuestionType)), undefined]), status: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(QuestionStatus)), undefined]), difficulty_score: faker.helpers.arrayElement([faker.number.float({min: undefined, max: undefined, fractionDigits: 2}), undefined]), explanation: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), content: faker.helpers.arrayElement([{question: faker.string.alpha({length: {min: 1, max: 1000}}), options: Array.from({ length: faker.number.int({ min: 4, max: 10 }) }, (_, i) => i + 1).map(() => (faker.string.alpha({length: {min: 1, max: 500}}))), sentence: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 2000}}), undefined]), passage: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 5000}}), undefined]), hint: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 500}}), undefined])}, undefined]), created_at: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), correct_count: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), incorrect_count: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), total_responses: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), user_count: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), correct_answer: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), reporters: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), topic_category: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), grammar_focus: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), vocabulary_domain: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), scenario: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), style_modifier: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), difficulty_modifier: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), time_context: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), confidence_level: faker.helpers.arrayElement([faker.number.int({min: 1, max: 5, multipleOf: undefined}), undefined])})), undefined]), pagination: faker.helpers.arrayElement([{page: faker.number.int({min: 1, max: undefined, multipleOf: undefined}), page_size: faker.number.int({min: 1, max: 100, multipleOf: undefined}), total: faker.number.int({min: 0, max: undefined, multipleOf: undefined}), total_pages: faker.number.int({min: 0, max: undefined, multipleOf: undefined})}, undefined]), stats: faker.helpers.arrayElement([{total_questions: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined, multipleOf: undefined}), undefined]), total_responses: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined, multipleOf: undefined}), undefined]), questions_by_type: faker.helpers.arrayElement([{
        [faker.string.alphanumeric(5)]: faker.number.int({min: undefined, max: undefined, multipleOf: undefined})
      }, undefined]), questions_by_level: faker.helpers.arrayElement([{
        [faker.string.alphanumeric(5)]: faker.number.int({min: undefined, max: undefined, multipleOf: undefined})
      }, undefined]), questions_by_language: faker.helpers.arrayElement([{
        [faker.string.alphanumeric(5)]: faker.number.int({min: undefined, max: undefined, multipleOf: undefined})
      }, undefined])}, undefined]), ...overrideResponse})

export const getGetV1AdminBackendQuestionsPaginatedResponseMock = (overrideResponse: Partial< GetV1AdminBackendQuestionsPaginated200 > = {}): GetV1AdminBackendQuestionsPaginated200 => ({questions: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), language: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), level: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), type: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(QuestionType)), undefined]), status: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(QuestionStatus)), undefined]), difficulty_score: faker.helpers.arrayElement([faker.number.float({min: undefined, max: undefined, fractionDigits: 2}), undefined]), explanation: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), content: faker.helpers.arrayElement([{question: faker.string.alpha({length: {min: 1, max: 1000}}), options: Array.from({ length: faker.number.int({ min: 4, max: 10 }) }, (_, i) => i + 1).map(() => (faker.string.alpha({length: {min: 1, max: 500}}))), sentence: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 2000}}), undefined]), passage: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 5000}}), undefined]), hint: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 500}}), undefined])}, undefined]), created_at: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), correct_count: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), incorrect_count: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), total_responses: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), user_count: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), correct_answer: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), reporters: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), topic_category: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), grammar_focus: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), vocabulary_domain: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), scenario: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), style_modifier: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), difficulty_modifier: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), time_context: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), confidence_level: faker.helpers.arrayElement([faker.number.int({min: 1, max: 5, multipleOf: undefined}), undefined])})), undefined]), pagination: faker.helpers.arrayElement([{page: faker.number.int({min: 1, max: undefined, multipleOf: undefined}), page_size: faker.number.int({min: 1, max: 100, multipleOf: undefined}), total: faker.number.int({min: 0, max: undefined, multipleOf: undefined}), total_pages: faker.number.int({min: 0, max: undefined, multipleOf: undefined})}, undefined]), stats: faker.helpers.arrayElement([{total_questions: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined, multipleOf: undefined}), undefined]), total_responses: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined, multipleOf: undefined}), undefined]), questions_by_type: faker.helpers.arrayElement([{
        [faker.string.alphanumeric(5)]: faker.number.int({min: undefined, max: undefined, multipleOf: undefined})
      }, undefined]), questions_by_level: faker.helpers.arrayElement([{
        [faker.string.alphanumeric(5)]: faker.number.int({min: undefined, max: undefined, multipleOf: undefined})
      }, undefined]), questions_by_language: faker.helpers.arrayElement([{
        [faker.string.alphanumeric(5)]: faker.number.int({min: undefined, max: undefined, multipleOf: undefined})
      }, undefined])}, undefined]), ...overrideResponse})

export const getGetV1AdminBackendQuestionsIdResponseMock = (overrideResponse: Partial< Question > = {}): Question => ({id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), language: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), level: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), type: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(QuestionType)), undefined]), status: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(QuestionStatus)), undefined]), difficulty_score: faker.helpers.arrayElement([faker.number.float({min: undefined, max: undefined, fractionDigits: 2}), undefined]), explanation: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), content: faker.helpers.arrayElement([{question: faker.string.alpha({length: {min: 1, max: 1000}}), options: Array.from({ length: faker.number.int({ min: 4, max: 10 }) }, (_, i) => i + 1).map(() => (faker.string.alpha({length: {min: 1, max: 500}}))), sentence: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 2000}}), undefined]), passage: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 5000}}), undefined]), hint: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 500}}), undefined])}, undefined]), created_at: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), correct_count: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), incorrect_count: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), total_responses: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), user_count: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), correct_answer: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), reporters: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), topic_category: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), grammar_focus: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), vocabulary_domain: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), scenario: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), style_modifier: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), difficulty_modifier: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), time_context: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), confidence_level: faker.helpers.arrayElement([faker.number.int({min: 1, max: 5, multipleOf: undefined}), undefined]), ...overrideResponse})

export const getPutV1AdminBackendQuestionsIdResponseMock = (overrideResponse: Partial< PutV1AdminBackendQuestionsId200 > = {}): PutV1AdminBackendQuestionsId200 => ({message: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), ...overrideResponse})

export const getDeleteV1AdminBackendQuestionsIdResponseMock = (overrideResponse: Partial< DeleteV1AdminBackendQuestionsId200 > = {}): DeleteV1AdminBackendQuestionsId200 => ({message: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), ...overrideResponse})

export const getGetV1AdminBackendQuestionsIdUsersResponseMock = (overrideResponse: Partial< GetV1AdminBackendQuestionsIdUsers200 > = {}): GetV1AdminBackendQuestionsIdUsers200 => ({users: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 5 }) }, (_, i) => i + 1).map(() => ({id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), username: faker.helpers.arrayElement([faker.helpers.fromRegExp('^[a-zA-Z0-9_@.+-]+$'), undefined]), email: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), timezone: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), last_active: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), preferred_language: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), current_level: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), ai_enabled: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), is_paused: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), created_at: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), updated_at: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined])})), undefined]), total_count: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), ...overrideResponse})

export const getPostV1AdminBackendQuestionsIdAssignUsersResponseMock = (overrideResponse: Partial< PostV1AdminBackendQuestionsIdAssignUsers200 > = {}): PostV1AdminBackendQuestionsIdAssignUsers200 => ({message: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), ...overrideResponse})

export const getPostV1AdminBackendQuestionsIdUnassignUsersResponseMock = (overrideResponse: Partial< PostV1AdminBackendQuestionsIdUnassignUsers200 > = {}): PostV1AdminBackendQuestionsIdUnassignUsers200 => ({message: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), ...overrideResponse})

export const getPostV1AdminBackendQuestionsIdFixResponseMock = (overrideResponse: Partial< PostV1AdminBackendQuestionsIdFix200 > = {}): PostV1AdminBackendQuestionsIdFix200 => ({message: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), ...overrideResponse})

export const getPostV1AdminBackendQuestionsIdAiFixResponseMock = (overrideResponse: Partial< PostV1AdminBackendQuestionsIdAiFix200 > = {}): PostV1AdminBackendQuestionsIdAiFix200 => ({message: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), ...overrideResponse})

export const getPostV1AdminBackendClearUserDataResponseMock = (overrideResponse: Partial< PostV1AdminBackendClearUserData200 > = {}): PostV1AdminBackendClearUserData200 => ({message: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), ...overrideResponse})

export const getPostV1AdminBackendClearDatabaseResponseMock = (overrideResponse: Partial< PostV1AdminBackendClearDatabase200 > = {}): PostV1AdminBackendClearDatabase200 => ({message: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), ...overrideResponse})

export const getPostV1AdminBackendUserzIdClearResponseMock = (overrideResponse: Partial< PostV1AdminBackendUserzIdClear200 > = {}): PostV1AdminBackendUserzIdClear200 => ({message: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), ...overrideResponse})

export const getGetV1AdminBackendReportedQuestionsResponseMock = (overrideResponse: Partial< GetV1AdminBackendReportedQuestions200 > = {}): GetV1AdminBackendReportedQuestions200 => ({questions: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), language: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), level: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), type: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(QuestionType)), undefined]), status: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(QuestionStatus)), undefined]), difficulty_score: faker.helpers.arrayElement([faker.number.float({min: undefined, max: undefined, fractionDigits: 2}), undefined]), explanation: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), content: faker.helpers.arrayElement([{question: faker.string.alpha({length: {min: 1, max: 1000}}), options: Array.from({ length: faker.number.int({ min: 4, max: 10 }) }, (_, i) => i + 1).map(() => (faker.string.alpha({length: {min: 1, max: 500}}))), sentence: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 2000}}), undefined]), passage: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 5000}}), undefined]), hint: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 500}}), undefined])}, undefined]), created_at: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), correct_count: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), incorrect_count: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), total_responses: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), user_count: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), correct_answer: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), reporters: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), topic_category: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), grammar_focus: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), vocabulary_domain: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), scenario: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), style_modifier: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), difficulty_modifier: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), time_context: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), confidence_level: faker.helpers.arrayElement([faker.number.int({min: 1, max: 5, multipleOf: undefined}), undefined])})), undefined]), pagination: faker.helpers.arrayElement([{page: faker.number.int({min: 1, max: undefined, multipleOf: undefined}), page_size: faker.number.int({min: 1, max: 100, multipleOf: undefined}), total: faker.number.int({min: 0, max: undefined, multipleOf: undefined}), total_pages: faker.number.int({min: 0, max: undefined, multipleOf: undefined})}, undefined]), stats: faker.helpers.arrayElement([{total_reported: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), reported_by_type: faker.helpers.arrayElement([{}, undefined]), reported_by_level: faker.helpers.arrayElement([{}, undefined]), reported_by_language: faker.helpers.arrayElement([{}, undefined])}, undefined]), ...overrideResponse})

export const getGetV1AdminBackendStoriesResponseMock = (overrideResponse: Partial< GetV1AdminBackendStories200 > = {}): GetV1AdminBackendStories200 => ({stories: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), user_id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), title: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), language: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), subject: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), author_style: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), time_period: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), genre: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), tone: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), character_names: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), custom_instructions: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), section_length_override: faker.helpers.arrayElement([faker.helpers.arrayElement(['short','medium','long'] as const), undefined]), status: faker.helpers.arrayElement([faker.helpers.arrayElement(['active','archived','completed'] as const), undefined]), last_section_generated_at: faker.helpers.arrayElement([faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), undefined]), created_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), updated_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), extra_generations_today: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined, multipleOf: undefined}), undefined])})), undefined]), pagination: faker.helpers.arrayElement([{page: faker.number.int({min: 1, max: undefined, multipleOf: undefined}), page_size: faker.number.int({min: 1, max: 100, multipleOf: undefined}), total: faker.number.int({min: 0, max: undefined, multipleOf: undefined}), total_pages: faker.number.int({min: 0, max: undefined, multipleOf: undefined})}, undefined]), ...overrideResponse})

export const getGetV1AdminBackendStoriesIdResponseMock = (): StoryWithSections => ({...{id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), user_id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), title: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), language: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), subject: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), author_style: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), time_period: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), genre: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), tone: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), character_names: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), custom_instructions: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), section_length_override: faker.helpers.arrayElement([faker.helpers.arrayElement(['short','medium','long'] as const), undefined]), status: faker.helpers.arrayElement([faker.helpers.arrayElement(['active','archived','completed'] as const), undefined]), last_section_generated_at: faker.helpers.arrayElement([faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), undefined]), created_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), updated_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), extra_generations_today: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined, multipleOf: undefined}), undefined])},...{sections: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), story_id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), section_number: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), content: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), language_level: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), word_count: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), generated_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), generation_date: faker.helpers.arrayElement([faker.date.past().toISOString().split('T')[0], undefined])})), undefined])},})

export const getGetV1AdminBackendStorySectionsIdResponseMock = (): StorySectionWithQuestions => ({...{id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), story_id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), section_number: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), content: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), language_level: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), word_count: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), generated_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), generation_date: faker.helpers.arrayElement([faker.date.past().toISOString().split('T')[0], undefined])},...{questions: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), section_id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), question_text: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), options: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => (faker.string.alpha({length: {min: 10, max: 20}}))), undefined]), correct_answer_index: faker.helpers.arrayElement([faker.number.int({min: 0, max: 3, multipleOf: undefined}), undefined]), explanation: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), created_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined])})), undefined])},})

export const getPostV1QuizChatStreamResponseMock = (): string => (faker.word.sample())

export const getGetV1DailyQuestionsDateResponseMock = (overrideResponse: Partial< GetV1DailyQuestionsDate200 > = {}): GetV1DailyQuestionsDate200 => ({questions: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), user_id: faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), question_id: faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), assignment_date: faker.date.past().toISOString().split('T')[0], is_completed: faker.datatype.boolean(), completed_at: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), created_at: faker.string.alpha({length: {min: 10, max: 20}}), user_answer_index: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), null]), undefined]), submitted_at: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), user_shown_count: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), user_total_responses: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), user_correct_count: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), user_incorrect_count: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), question: {id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), language: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), level: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), type: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(QuestionType)), undefined]), status: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(QuestionStatus)), undefined]), difficulty_score: faker.helpers.arrayElement([faker.number.float({min: undefined, max: undefined, fractionDigits: 2}), undefined]), explanation: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), content: faker.helpers.arrayElement([{question: faker.string.alpha({length: {min: 1, max: 1000}}), options: Array.from({ length: faker.number.int({ min: 4, max: 10 }) }, (_, i) => i + 1).map(() => (faker.string.alpha({length: {min: 1, max: 500}}))), sentence: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 2000}}), undefined]), passage: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 5000}}), undefined]), hint: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 500}}), undefined])}, undefined]), created_at: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), correct_count: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), incorrect_count: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), total_responses: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), user_count: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), correct_answer: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), reporters: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), topic_category: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), grammar_focus: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), vocabulary_domain: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), scenario: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), style_modifier: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), difficulty_modifier: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), time_context: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), confidence_level: faker.helpers.arrayElement([faker.number.int({min: 1, max: 5, multipleOf: undefined}), undefined])}})), undefined]), date: faker.helpers.arrayElement([faker.date.past().toISOString().split('T')[0], undefined]), ...overrideResponse})

export const getPostV1DailyQuestionsDateCompleteQuestionIdResponseMock = (overrideResponse: Partial< SuccessResponse > = {}): SuccessResponse => ({success: faker.datatype.boolean(), message: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 500}}), undefined]), ...overrideResponse})

export const getDeleteV1DailyQuestionsDateCompleteQuestionIdResponseMock = (overrideResponse: Partial< SuccessResponse > = {}): SuccessResponse => ({success: faker.datatype.boolean(), message: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 500}}), undefined]), ...overrideResponse})

export const getGetV1DailyDatesResponseMock = (overrideResponse: Partial< GetV1DailyDates200 > = {}): GetV1DailyDates200 => ({dates: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => (faker.date.past().toISOString().split('T')[0])), undefined]), ...overrideResponse})

export const getPostV1DailyQuestionsDateAnswerQuestionIdResponseMock = (): PostV1DailyQuestionsDateAnswerQuestionId200 => ({...{is_correct: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), user_answer: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), user_answer_index: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), explanation: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), next_difficulty: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), correct_answer_index: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined])},...{is_completed: faker.helpers.arrayElement([faker.datatype.boolean(), undefined])},})

export const getGetV1DailyProgressDateResponseMock = (overrideResponse: Partial< DailyProgress > = {}): DailyProgress => ({date: faker.date.past().toISOString().split('T')[0], completed: faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), total: faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), ...overrideResponse})

export const getGetV1DailyHistoryQuestionIdResponseMock = (overrideResponse: Partial< GetV1DailyHistoryQuestionId200 > = {}): GetV1DailyHistoryQuestionId200 => ({history: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({assignment_date: faker.string.alpha({length: {min: 10, max: 20}}), is_completed: faker.datatype.boolean(), is_correct: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), submitted_at: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined])})), undefined]), ...overrideResponse})

export const getPostV1StoryResponseMock = (overrideResponse: Partial< Story > = {}): Story => ({id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), user_id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), title: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), language: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), subject: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), author_style: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), time_period: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), genre: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), tone: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), character_names: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), custom_instructions: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), section_length_override: faker.helpers.arrayElement([faker.helpers.arrayElement(['short','medium','long'] as const), undefined]), status: faker.helpers.arrayElement([faker.helpers.arrayElement(['active','archived','completed'] as const), undefined]), last_section_generated_at: faker.helpers.arrayElement([faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), undefined]), created_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), updated_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), extra_generations_today: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined, multipleOf: undefined}), undefined]), ...overrideResponse})

export const getGetV1StoryResponseMock = (): Story[] => (Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), user_id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), title: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), language: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), subject: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), author_style: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), time_period: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), genre: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), tone: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), character_names: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), custom_instructions: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), section_length_override: faker.helpers.arrayElement([faker.helpers.arrayElement(['short','medium','long'] as const), undefined]), status: faker.helpers.arrayElement([faker.helpers.arrayElement(['active','archived','completed'] as const), undefined]), last_section_generated_at: faker.helpers.arrayElement([faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), undefined]), created_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), updated_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), extra_generations_today: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined, multipleOf: undefined}), undefined])})))

export const getGetV1StoryCurrentResponseMock = (overrideResponse: Partial< StoryWithSections | GeneratingResponse > = {}): StoryWithSections | GeneratingResponse => (faker.helpers.arrayElement([{...{id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), user_id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), title: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), language: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), subject: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), author_style: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), time_period: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), genre: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), tone: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), character_names: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), custom_instructions: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), section_length_override: faker.helpers.arrayElement([faker.helpers.arrayElement(['short','medium','long'] as const), undefined]), status: faker.helpers.arrayElement([faker.helpers.arrayElement(['active','archived','completed'] as const), undefined]), last_section_generated_at: faker.helpers.arrayElement([faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), undefined]), created_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), updated_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), extra_generations_today: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined, multipleOf: undefined}), undefined])},...{sections: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), story_id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), section_number: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), content: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), language_level: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), word_count: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), generated_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), generation_date: faker.helpers.arrayElement([faker.date.past().toISOString().split('T')[0], undefined])})), undefined])},}, {status: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 100}}), undefined]), message: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 500}}), undefined]), ai_model: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), api_key: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), ...overrideResponse}]))

export const getGetV1StoryIdResponseMock = (): StoryWithSections => ({...{id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), user_id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), title: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), language: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), subject: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), author_style: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), time_period: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), genre: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), tone: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), character_names: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), custom_instructions: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), section_length_override: faker.helpers.arrayElement([faker.helpers.arrayElement(['short','medium','long'] as const), undefined]), status: faker.helpers.arrayElement([faker.helpers.arrayElement(['active','archived','completed'] as const), undefined]), last_section_generated_at: faker.helpers.arrayElement([faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), undefined]), created_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), updated_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), extra_generations_today: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined, multipleOf: undefined}), undefined])},...{sections: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), story_id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), section_number: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), content: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), language_level: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), word_count: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), generated_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), generation_date: faker.helpers.arrayElement([faker.date.past().toISOString().split('T')[0], undefined])})), undefined])},})

export const getPostV1StoryIdGenerateResponseMock = (overrideResponse: Partial< StorySection > = {}): StorySection => ({id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), story_id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), section_number: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), content: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), language_level: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), word_count: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), generated_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), generation_date: faker.helpers.arrayElement([faker.date.past().toISOString().split('T')[0], undefined]), ...overrideResponse})

export const getGetV1StorySectionIdResponseMock = (): StorySectionWithQuestions => ({...{id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), story_id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), section_number: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), content: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), language_level: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), word_count: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), generated_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), generation_date: faker.helpers.arrayElement([faker.date.past().toISOString().split('T')[0], undefined])},...{questions: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), section_id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), question_text: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), options: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => (faker.string.alpha({length: {min: 10, max: 20}}))), undefined]), correct_answer_index: faker.helpers.arrayElement([faker.number.int({min: 0, max: 3, multipleOf: undefined}), undefined]), explanation: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), created_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined])})), undefined])},})

export const getGetV1StoryIdExportResponseMock = (): Blob => (new Blob(faker.helpers.arrayElements(faker.word.words(10).split(' '))))

export const getGetV1PreferencesLearningResponseMock = (overrideResponse: Partial< UserLearningPreferences > = {}): UserLearningPreferences => ({focus_on_weak_areas: faker.datatype.boolean(), fresh_question_ratio: faker.number.float({min: 0, max: 1, fractionDigits: 2}), known_question_penalty: faker.number.float({min: 0, max: 1, fractionDigits: 2}), review_interval_days: faker.number.int({min: 1, max: 60, multipleOf: undefined}), weak_area_boost: faker.number.float({min: 1, max: 5, fractionDigits: 2}), daily_reminder_enabled: faker.datatype.boolean(), tts_voice: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), daily_goal: faker.helpers.arrayElement([faker.number.int({min: 1, max: undefined, multipleOf: undefined}), undefined]), ...overrideResponse})

export const getPutV1PreferencesLearningResponseMock = (overrideResponse: Partial< UserLearningPreferences > = {}): UserLearningPreferences => ({focus_on_weak_areas: faker.datatype.boolean(), fresh_question_ratio: faker.number.float({min: 0, max: 1, fractionDigits: 2}), known_question_penalty: faker.number.float({min: 0, max: 1, fractionDigits: 2}), review_interval_days: faker.number.int({min: 1, max: 60, multipleOf: undefined}), weak_area_boost: faker.number.float({min: 1, max: 5, fractionDigits: 2}), daily_reminder_enabled: faker.datatype.boolean(), tts_voice: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), daily_goal: faker.helpers.arrayElement([faker.number.int({min: 1, max: undefined, multipleOf: undefined}), undefined]), ...overrideResponse})

export const getGetV1VersionResponseServiceVersionMock = (overrideResponse: Partial<ServiceVersion> = {}): ServiceVersion => ({...{service: faker.string.alpha({length: {min: 10, max: 50}}), version: faker.string.alpha({length: {min: 10, max: 100}}), commit: faker.string.alpha({length: {min: 10, max: 50}}), buildTime: faker.string.alpha({length: {min: 10, max: 100}})}, ...overrideResponse});

export const getGetV1VersionResponseMock = (overrideResponse: Partial< AggregatedVersion > = {}): AggregatedVersion => ({backend: {service: faker.string.alpha({length: {min: 10, max: 50}}), version: faker.string.alpha({length: {min: 10, max: 100}}), commit: faker.string.alpha({length: {min: 10, max: 50}}), buildTime: faker.string.alpha({length: {min: 10, max: 100}})}, worker: faker.helpers.arrayElement([{...getGetV1VersionResponseServiceVersionMock()},{error: faker.string.alpha({length: {min: 10, max: 20}})},]), ...overrideResponse})

export const getGetHealthResponseMock = (overrideResponse: Partial< GetHealth200 > = {}): GetHealth200 => ({status: faker.helpers.arrayElement([faker.helpers.arrayElement(['ok'] as const), undefined]), service: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), ...overrideResponse})

export const getGetV1AdminWorkerDailyUsersUserIdQuestionsDateResponseMock = (overrideResponse: Partial< GetV1AdminWorkerDailyUsersUserIdQuestionsDate200 > = {}): GetV1AdminWorkerDailyUsersUserIdQuestionsDate200 => ({questions: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), user_id: faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), question_id: faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), assignment_date: faker.date.past().toISOString().split('T')[0], is_completed: faker.datatype.boolean(), completed_at: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), created_at: faker.string.alpha({length: {min: 10, max: 20}}), user_answer_index: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), null]), undefined]), submitted_at: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), user_shown_count: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), user_total_responses: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), user_correct_count: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), user_incorrect_count: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), question: {id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), language: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), level: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), type: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(QuestionType)), undefined]), status: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(QuestionStatus)), undefined]), difficulty_score: faker.helpers.arrayElement([faker.number.float({min: undefined, max: undefined, fractionDigits: 2}), undefined]), explanation: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), content: faker.helpers.arrayElement([{question: faker.string.alpha({length: {min: 1, max: 1000}}), options: Array.from({ length: faker.number.int({ min: 4, max: 10 }) }, (_, i) => i + 1).map(() => (faker.string.alpha({length: {min: 1, max: 500}}))), sentence: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 2000}}), undefined]), passage: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 5000}}), undefined]), hint: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 500}}), undefined])}, undefined]), created_at: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), correct_count: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), incorrect_count: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), total_responses: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), user_count: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), correct_answer: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), reporters: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), topic_category: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), grammar_focus: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), vocabulary_domain: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), scenario: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), style_modifier: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), difficulty_modifier: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), time_context: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), confidence_level: faker.helpers.arrayElement([faker.number.int({min: 1, max: 5, multipleOf: undefined}), undefined])}})), undefined]), ...overrideResponse})

export const getPostV1AdminWorkerDailyUsersUserIdQuestionsDateRegenerateResponseMock = (overrideResponse: Partial< PostV1AdminWorkerDailyUsersUserIdQuestionsDateRegenerate200 > = {}): PostV1AdminWorkerDailyUsersUserIdQuestionsDateRegenerate200 => ({success: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), message: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), ...overrideResponse})

export const getPostV1AudioSpeechResponseMock = (overrideResponse: Partial< TTSResponse > = {}): TTSResponse => ({type: faker.helpers.arrayElement([faker.helpers.arrayElement(['audio','usage','error'] as const), undefined]), audio: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), usage: faker.helpers.arrayElement([{input_tokens: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), output_tokens: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined]), total_tokens: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined, multipleOf: undefined}), undefined])}, undefined]), error: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), ...overrideResponse})


export const getPostV1AuthLoginMockHandler = (overrideResponse?: LoginResponse | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<LoginResponse> | LoginResponse)) => {
  return http.post('*/v1/auth/login', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPostV1AuthLoginResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getPostV1AuthLogoutMockHandler = (overrideResponse?: SuccessResponse | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<SuccessResponse> | SuccessResponse)) => {
  return http.post('*/v1/auth/logout', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPostV1AuthLogoutResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getGetV1AuthStatusMockHandler = (overrideResponse?: AuthStatusResponse | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<AuthStatusResponse> | AuthStatusResponse)) => {
  return http.get('*/v1/auth/status', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1AuthStatusResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getGetV1AuthCheckMockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<void> | void)) => {
  return http.get('*/v1/auth/check', async (info) => {await delay(1000);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 204,
        
      })
  })
}

export const getPostV1AuthSignupMockHandler = (overrideResponse?: SuccessResponse | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<SuccessResponse> | SuccessResponse)) => {
  return http.post('*/v1/auth/signup', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPostV1AuthSignupResponseMock()),
      { status: 201,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getGetV1AuthSignupStatusMockHandler = (overrideResponse?: SignupStatusResponse | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<SignupStatusResponse> | SignupStatusResponse)) => {
  return http.get('*/v1/auth/signup/status', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1AuthSignupStatusResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getGetV1AuthGoogleLoginMockHandler = (overrideResponse?: GoogleOAuthLoginResponse | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<GoogleOAuthLoginResponse> | GoogleOAuthLoginResponse)) => {
  return http.get('*/v1/auth/google/login', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1AuthGoogleLoginResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getGetV1AuthGoogleCallbackMockHandler = (overrideResponse?: LoginResponse | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<LoginResponse> | LoginResponse)) => {
  return http.get('*/v1/auth/google/callback', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1AuthGoogleCallbackResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getGetV1QuizQuestionMockHandler = (overrideResponse?: Question | GeneratingResponse | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<Question | GeneratingResponse> | Question | GeneratingResponse)) => {
  return http.get('*/v1/quiz/question', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1QuizQuestionResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getGetV1QuizQuestionIdMockHandler = (overrideResponse?: Question | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<Question> | Question)) => {
  return http.get('*/v1/quiz/question/:id', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1QuizQuestionIdResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getPostV1QuizAnswerMockHandler = (overrideResponse?: AnswerResponse | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<AnswerResponse> | AnswerResponse)) => {
  return http.post('*/v1/quiz/answer', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPostV1QuizAnswerResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getGetV1QuizProgressMockHandler = (overrideResponse?: UserProgress | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<UserProgress> | UserProgress)) => {
  return http.get('*/v1/quiz/progress', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1QuizProgressResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getPostV1QuizQuestionIdReportMockHandler = (overrideResponse?: SuccessResponse | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<SuccessResponse> | SuccessResponse)) => {
  return http.post('*/v1/quiz/question/:id/report', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPostV1QuizQuestionIdReportResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getPostV1QuizQuestionIdMarkKnownMockHandler = (overrideResponse?: SuccessResponse | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<SuccessResponse> | SuccessResponse)) => {
  return http.post('*/v1/quiz/question/:id/mark-known', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPostV1QuizQuestionIdMarkKnownResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getGetV1QuizWorkerStatusMockHandler = (overrideResponse?: WorkerStatusResponse | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<WorkerStatusResponse> | WorkerStatusResponse)) => {
  return http.get('*/v1/quiz/worker-status', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1QuizWorkerStatusResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getPutV1SettingsMockHandler = (overrideResponse?: SuccessResponse | ((info: Parameters<Parameters<typeof http.put>[1]>[0]) => Promise<SuccessResponse> | SuccessResponse)) => {
  return http.put('*/v1/settings', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPutV1SettingsResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getGetV1SettingsAiProvidersMockHandler = (overrideResponse?: AIProviders | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<AIProviders> | AIProviders)) => {
  return http.get('*/v1/settings/ai-providers', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1SettingsAiProvidersResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getPostV1SettingsTestAiMockHandler = (overrideResponse?: SuccessResponse | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<SuccessResponse> | SuccessResponse)) => {
  return http.post('*/v1/settings/test-ai', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPostV1SettingsTestAiResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getPostV1SettingsTestEmailMockHandler = (overrideResponse?: SuccessResponse | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<SuccessResponse> | SuccessResponse)) => {
  return http.post('*/v1/settings/test-email', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPostV1SettingsTestEmailResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getGetV1SettingsLevelsMockHandler = (overrideResponse?: LevelsResponse | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<LevelsResponse> | LevelsResponse)) => {
  return http.get('*/v1/settings/levels', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1SettingsLevelsResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getGetV1SettingsLanguagesMockHandler = (overrideResponse?: LanguagesResponse | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<LanguagesResponse> | LanguagesResponse)) => {
  return http.get('*/v1/settings/languages', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1SettingsLanguagesResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getGetV1SettingsApiKeyProviderMockHandler = (overrideResponse?: APIKeyAvailabilityResponse | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<APIKeyAvailabilityResponse> | APIKeyAvailabilityResponse)) => {
  return http.get('*/v1/settings/api-key/:provider', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1SettingsApiKeyProviderResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getPostV1AiConversationsMockHandler = (overrideResponse?: Conversation | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<Conversation> | Conversation)) => {
  return http.post('*/v1/ai/conversations', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPostV1AiConversationsResponseMock()),
      { status: 201,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getGetV1AiConversationsMockHandler = (overrideResponse?: GetV1AiConversations200 | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<GetV1AiConversations200> | GetV1AiConversations200)) => {
  return http.get('*/v1/ai/conversations', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1AiConversationsResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getGetV1AiConversationsIdMockHandler = (overrideResponse?: Conversation | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<Conversation> | Conversation)) => {
  return http.get('*/v1/ai/conversations/:id', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1AiConversationsIdResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getPutV1AiConversationsIdMockHandler = (overrideResponse?: Conversation | ((info: Parameters<Parameters<typeof http.put>[1]>[0]) => Promise<Conversation> | Conversation)) => {
  return http.put('*/v1/ai/conversations/:id', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPutV1AiConversationsIdResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getDeleteV1AiConversationsIdMockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.delete>[1]>[0]) => Promise<void> | void)) => {
  return http.delete('*/v1/ai/conversations/:id', async (info) => {await delay(1000);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 204,
        
      })
  })
}

export const getPostV1AiConversationsConversationIdMessagesMockHandler = (overrideResponse?: ChatMessage | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<ChatMessage> | ChatMessage)) => {
  return http.post('*/v1/ai/conversations/:conversationId/messages', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPostV1AiConversationsConversationIdMessagesResponseMock()),
      { status: 201,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getGetV1AiSearchMockHandler = (overrideResponse?: GetV1AiSearch200 | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<GetV1AiSearch200> | GetV1AiSearch200)) => {
  return http.get('*/v1/ai/search', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1AiSearchResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getPutV1AiConversationsBookmarkMockHandler = (overrideResponse?: PutV1AiConversationsBookmark200 | ((info: Parameters<Parameters<typeof http.put>[1]>[0]) => Promise<PutV1AiConversationsBookmark200> | PutV1AiConversationsBookmark200)) => {
  return http.put('*/v1/ai/conversations/bookmark', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPutV1AiConversationsBookmarkResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getPutV1UserzProfileMockHandler = (overrideResponse?: PutV1UserzProfile200 | ((info: Parameters<Parameters<typeof http.put>[1]>[0]) => Promise<PutV1UserzProfile200> | PutV1UserzProfile200)) => {
  return http.put('*/v1/userz/profile', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPutV1UserzProfileResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getGetV1AdminBackendMockHandler = (overrideResponse?: string | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<string> | string)) => {
  return http.get('*/v1/admin/backend', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1AdminBackendResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getGetV1AdminBackendUserzMockHandler = (overrideResponse?: GetV1AdminBackendUserz200 | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<GetV1AdminBackendUserz200> | GetV1AdminBackendUserz200)) => {
  return http.get('*/v1/admin/backend/userz', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1AdminBackendUserzResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getPostV1AdminBackendUserzMockHandler = (overrideResponse?: PostV1AdminBackendUserz201 | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<PostV1AdminBackendUserz201> | PostV1AdminBackendUserz201)) => {
  return http.post('*/v1/admin/backend/userz', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPostV1AdminBackendUserzResponseMock()),
      { status: 201,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getPostV1SettingsClearStoriesMockHandler = (overrideResponse?: SuccessResponse | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<SuccessResponse> | SuccessResponse)) => {
  return http.post('*/v1/settings/clear-stories', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPostV1SettingsClearStoriesResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getPostV1SettingsResetAccountMockHandler = (overrideResponse?: SuccessResponse | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<SuccessResponse> | SuccessResponse)) => {
  return http.post('*/v1/settings/reset-account', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPostV1SettingsResetAccountResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getPostV1SettingsClearAiChatsMockHandler = (overrideResponse?: SuccessResponse | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<SuccessResponse> | SuccessResponse)) => {
  return http.post('*/v1/settings/clear-ai-chats', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPostV1SettingsClearAiChatsResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getGetV1AdminBackendUserzPaginatedMockHandler = (overrideResponse?: GetV1AdminBackendUserzPaginated200 | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<GetV1AdminBackendUserzPaginated200> | GetV1AdminBackendUserzPaginated200)) => {
  return http.get('*/v1/admin/backend/userz/paginated', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1AdminBackendUserzPaginatedResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getPutV1AdminBackendUserzIdMockHandler = (overrideResponse?: PutV1AdminBackendUserzId200 | ((info: Parameters<Parameters<typeof http.put>[1]>[0]) => Promise<PutV1AdminBackendUserzId200> | PutV1AdminBackendUserzId200)) => {
  return http.put('*/v1/admin/backend/userz/:id', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPutV1AdminBackendUserzIdResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getDeleteV1AdminBackendUserzIdMockHandler = (overrideResponse?: DeleteV1AdminBackendUserzId200 | ((info: Parameters<Parameters<typeof http.delete>[1]>[0]) => Promise<DeleteV1AdminBackendUserzId200> | DeleteV1AdminBackendUserzId200)) => {
  return http.delete('*/v1/admin/backend/userz/:id', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getDeleteV1AdminBackendUserzIdResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getPostV1AdminBackendUserzIdResetPasswordMockHandler = (overrideResponse?: PostV1AdminBackendUserzIdResetPassword200 | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<PostV1AdminBackendUserzIdResetPassword200> | PostV1AdminBackendUserzIdResetPassword200)) => {
  return http.post('*/v1/admin/backend/userz/:id/reset-password', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPostV1AdminBackendUserzIdResetPasswordResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getGetV1AdminBackendRolesMockHandler = (overrideResponse?: GetV1AdminBackendRoles200 | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<GetV1AdminBackendRoles200> | GetV1AdminBackendRoles200)) => {
  return http.get('*/v1/admin/backend/roles', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1AdminBackendRolesResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getGetV1AdminBackendUserzIdRolesMockHandler = (overrideResponse?: GetV1AdminBackendUserzIdRoles200 | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<GetV1AdminBackendUserzIdRoles200> | GetV1AdminBackendUserzIdRoles200)) => {
  return http.get('*/v1/admin/backend/userz/:id/roles', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1AdminBackendUserzIdRolesResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getPostV1AdminBackendUserzIdRolesMockHandler = (overrideResponse?: PostV1AdminBackendUserzIdRoles200 | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<PostV1AdminBackendUserzIdRoles200> | PostV1AdminBackendUserzIdRoles200)) => {
  return http.post('*/v1/admin/backend/userz/:id/roles', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPostV1AdminBackendUserzIdRolesResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getDeleteV1AdminBackendUserzIdRolesRoleIdMockHandler = (overrideResponse?: DeleteV1AdminBackendUserzIdRolesRoleId200 | ((info: Parameters<Parameters<typeof http.delete>[1]>[0]) => Promise<DeleteV1AdminBackendUserzIdRolesRoleId200> | DeleteV1AdminBackendUserzIdRolesRoleId200)) => {
  return http.delete('*/v1/admin/backend/userz/:id/roles/:roleId', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getDeleteV1AdminBackendUserzIdRolesRoleIdResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getGetV1AdminBackendDashboardMockHandler = (overrideResponse?: DashboardResponse | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<DashboardResponse> | DashboardResponse)) => {
  return http.get('*/v1/admin/backend/dashboard', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1AdminBackendDashboardResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getGetV1AdminBackendAiConcurrencyMockHandler = (overrideResponse?: AIConcurrencyStats | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<AIConcurrencyStats> | AIConcurrencyStats)) => {
  return http.get('*/v1/admin/backend/ai-concurrency', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1AdminBackendAiConcurrencyResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getGetV1AdminWorkerStatusMockHandler = (overrideResponse?: WorkerStatus | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<WorkerStatus> | WorkerStatus)) => {
  return http.get('*/v1/admin/worker/status', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1AdminWorkerStatusResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getGetV1AdminWorkerDetailsMockHandler = (overrideResponse?: GetV1AdminWorkerDetails200 | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<GetV1AdminWorkerDetails200> | GetV1AdminWorkerDetails200)) => {
  return http.get('*/v1/admin/worker/details', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1AdminWorkerDetailsResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getPostV1AdminWorkerPauseMockHandler = (overrideResponse?: PostV1AdminWorkerPause200 | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<PostV1AdminWorkerPause200> | PostV1AdminWorkerPause200)) => {
  return http.post('*/v1/admin/worker/pause', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPostV1AdminWorkerPauseResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getPostV1AdminWorkerResumeMockHandler = (overrideResponse?: PostV1AdminWorkerResume200 | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<PostV1AdminWorkerResume200> | PostV1AdminWorkerResume200)) => {
  return http.post('*/v1/admin/worker/resume', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPostV1AdminWorkerResumeResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getPostV1AdminWorkerTriggerMockHandler = (overrideResponse?: PostV1AdminWorkerTrigger200 | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<PostV1AdminWorkerTrigger200> | PostV1AdminWorkerTrigger200)) => {
  return http.post('*/v1/admin/worker/trigger', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPostV1AdminWorkerTriggerResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getGetV1AdminWorkerLogsMockHandler = (overrideResponse?: GetV1AdminWorkerLogs200 | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<GetV1AdminWorkerLogs200> | GetV1AdminWorkerLogs200)) => {
  return http.get('*/v1/admin/worker/logs', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1AdminWorkerLogsResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getGetV1AdminWorkerAiConcurrencyMockHandler = (overrideResponse?: GetV1AdminWorkerAiConcurrency200 | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<GetV1AdminWorkerAiConcurrency200> | GetV1AdminWorkerAiConcurrency200)) => {
  return http.get('*/v1/admin/worker/ai-concurrency', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1AdminWorkerAiConcurrencyResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getGetV1AdminWorkerUsersMockHandler = (overrideResponse?: GetV1AdminWorkerUsers200 | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<GetV1AdminWorkerUsers200> | GetV1AdminWorkerUsers200)) => {
  return http.get('*/v1/admin/worker/users', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1AdminWorkerUsersResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getPostV1AdminWorkerUsersPauseMockHandler = (overrideResponse?: PostV1AdminWorkerUsersPause200 | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<PostV1AdminWorkerUsersPause200> | PostV1AdminWorkerUsersPause200)) => {
  return http.post('*/v1/admin/worker/users/pause', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPostV1AdminWorkerUsersPauseResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getPostV1AdminWorkerUsersResumeMockHandler = (overrideResponse?: PostV1AdminWorkerUsersResume200 | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<PostV1AdminWorkerUsersResume200> | PostV1AdminWorkerUsersResume200)) => {
  return http.post('*/v1/admin/worker/users/resume', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPostV1AdminWorkerUsersResumeResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getGetV1AdminWorkerAnalyticsPriorityScoresMockHandler = (overrideResponse?: GetV1AdminWorkerAnalyticsPriorityScores200 | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<GetV1AdminWorkerAnalyticsPriorityScores200> | GetV1AdminWorkerAnalyticsPriorityScores200)) => {
  return http.get('*/v1/admin/worker/analytics/priority-scores', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1AdminWorkerAnalyticsPriorityScoresResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getGetV1AdminWorkerAnalyticsUserPerformanceMockHandler = (overrideResponse?: UserPerformanceAnalytics | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<UserPerformanceAnalytics> | UserPerformanceAnalytics)) => {
  return http.get('*/v1/admin/worker/analytics/user-performance', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1AdminWorkerAnalyticsUserPerformanceResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getGetV1AdminWorkerAnalyticsGenerationIntelligenceMockHandler = (overrideResponse?: GenerationIntelligence | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<GenerationIntelligence> | GenerationIntelligence)) => {
  return http.get('*/v1/admin/worker/analytics/generation-intelligence', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1AdminWorkerAnalyticsGenerationIntelligenceResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getGetV1AdminWorkerAnalyticsSystemHealthMockHandler = (overrideResponse?: SystemHealthAnalytics | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<SystemHealthAnalytics> | SystemHealthAnalytics)) => {
  return http.get('*/v1/admin/worker/analytics/system-health', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1AdminWorkerAnalyticsSystemHealthResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getGetV1AdminWorkerNotificationsStatsMockHandler = (overrideResponse?: NotificationStats | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<NotificationStats> | NotificationStats)) => {
  return http.get('*/v1/admin/worker/notifications/stats', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1AdminWorkerNotificationsStatsResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getGetV1AdminWorkerNotificationsErrorsMockHandler = (overrideResponse?: GetV1AdminWorkerNotificationsErrors200 | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<GetV1AdminWorkerNotificationsErrors200> | GetV1AdminWorkerNotificationsErrors200)) => {
  return http.get('*/v1/admin/worker/notifications/errors', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1AdminWorkerNotificationsErrorsResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getGetV1AdminWorkerNotificationsSentMockHandler = (overrideResponse?: GetV1AdminWorkerNotificationsSent200 | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<GetV1AdminWorkerNotificationsSent200> | GetV1AdminWorkerNotificationsSent200)) => {
  return http.get('*/v1/admin/worker/notifications/sent', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1AdminWorkerNotificationsSentResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getPostV1AdminWorkerNotificationsForceSendMockHandler = (overrideResponse?: ForceSendNotificationResponse | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<ForceSendNotificationResponse> | ForceSendNotificationResponse)) => {
  return http.post('*/v1/admin/worker/notifications/force-send', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPostV1AdminWorkerNotificationsForceSendResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getGetV1AdminBackendQuestionsMockHandler = (overrideResponse?: GetV1AdminBackendQuestions200 | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<GetV1AdminBackendQuestions200> | GetV1AdminBackendQuestions200)) => {
  return http.get('*/v1/admin/backend/questions', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1AdminBackendQuestionsResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getGetV1AdminBackendQuestionsPaginatedMockHandler = (overrideResponse?: GetV1AdminBackendQuestionsPaginated200 | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<GetV1AdminBackendQuestionsPaginated200> | GetV1AdminBackendQuestionsPaginated200)) => {
  return http.get('*/v1/admin/backend/questions/paginated', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1AdminBackendQuestionsPaginatedResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getGetV1AdminBackendQuestionsIdMockHandler = (overrideResponse?: Question | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<Question> | Question)) => {
  return http.get('*/v1/admin/backend/questions/:id', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1AdminBackendQuestionsIdResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getPutV1AdminBackendQuestionsIdMockHandler = (overrideResponse?: PutV1AdminBackendQuestionsId200 | ((info: Parameters<Parameters<typeof http.put>[1]>[0]) => Promise<PutV1AdminBackendQuestionsId200> | PutV1AdminBackendQuestionsId200)) => {
  return http.put('*/v1/admin/backend/questions/:id', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPutV1AdminBackendQuestionsIdResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getDeleteV1AdminBackendQuestionsIdMockHandler = (overrideResponse?: DeleteV1AdminBackendQuestionsId200 | ((info: Parameters<Parameters<typeof http.delete>[1]>[0]) => Promise<DeleteV1AdminBackendQuestionsId200> | DeleteV1AdminBackendQuestionsId200)) => {
  return http.delete('*/v1/admin/backend/questions/:id', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getDeleteV1AdminBackendQuestionsIdResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getGetV1AdminBackendQuestionsIdUsersMockHandler = (overrideResponse?: GetV1AdminBackendQuestionsIdUsers200 | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<GetV1AdminBackendQuestionsIdUsers200> | GetV1AdminBackendQuestionsIdUsers200)) => {
  return http.get('*/v1/admin/backend/questions/:id/users', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1AdminBackendQuestionsIdUsersResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getPostV1AdminBackendQuestionsIdAssignUsersMockHandler = (overrideResponse?: PostV1AdminBackendQuestionsIdAssignUsers200 | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<PostV1AdminBackendQuestionsIdAssignUsers200> | PostV1AdminBackendQuestionsIdAssignUsers200)) => {
  return http.post('*/v1/admin/backend/questions/:id/assign-users', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPostV1AdminBackendQuestionsIdAssignUsersResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getPostV1AdminBackendQuestionsIdUnassignUsersMockHandler = (overrideResponse?: PostV1AdminBackendQuestionsIdUnassignUsers200 | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<PostV1AdminBackendQuestionsIdUnassignUsers200> | PostV1AdminBackendQuestionsIdUnassignUsers200)) => {
  return http.post('*/v1/admin/backend/questions/:id/unassign-users', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPostV1AdminBackendQuestionsIdUnassignUsersResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getPostV1AdminBackendQuestionsIdFixMockHandler = (overrideResponse?: PostV1AdminBackendQuestionsIdFix200 | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<PostV1AdminBackendQuestionsIdFix200> | PostV1AdminBackendQuestionsIdFix200)) => {
  return http.post('*/v1/admin/backend/questions/:id/fix', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPostV1AdminBackendQuestionsIdFixResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getPostV1AdminBackendQuestionsIdAiFixMockHandler = (overrideResponse?: PostV1AdminBackendQuestionsIdAiFix200 | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<PostV1AdminBackendQuestionsIdAiFix200> | PostV1AdminBackendQuestionsIdAiFix200)) => {
  return http.post('*/v1/admin/backend/questions/:id/ai-fix', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPostV1AdminBackendQuestionsIdAiFixResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getPostV1AdminBackendClearUserDataMockHandler = (overrideResponse?: PostV1AdminBackendClearUserData200 | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<PostV1AdminBackendClearUserData200> | PostV1AdminBackendClearUserData200)) => {
  return http.post('*/v1/admin/backend/clear-user-data', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPostV1AdminBackendClearUserDataResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getPostV1AdminBackendClearDatabaseMockHandler = (overrideResponse?: PostV1AdminBackendClearDatabase200 | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<PostV1AdminBackendClearDatabase200> | PostV1AdminBackendClearDatabase200)) => {
  return http.post('*/v1/admin/backend/clear-database', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPostV1AdminBackendClearDatabaseResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getPostV1AdminBackendUserzIdClearMockHandler = (overrideResponse?: PostV1AdminBackendUserzIdClear200 | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<PostV1AdminBackendUserzIdClear200> | PostV1AdminBackendUserzIdClear200)) => {
  return http.post('*/v1/admin/backend/userz/:id/clear', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPostV1AdminBackendUserzIdClearResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getGetV1AdminBackendReportedQuestionsMockHandler = (overrideResponse?: GetV1AdminBackendReportedQuestions200 | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<GetV1AdminBackendReportedQuestions200> | GetV1AdminBackendReportedQuestions200)) => {
  return http.get('*/v1/admin/backend/reported-questions', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1AdminBackendReportedQuestionsResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getGetV1AdminBackendStoriesMockHandler = (overrideResponse?: GetV1AdminBackendStories200 | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<GetV1AdminBackendStories200> | GetV1AdminBackendStories200)) => {
  return http.get('*/v1/admin/backend/stories', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1AdminBackendStoriesResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getGetV1AdminBackendStoriesIdMockHandler = (overrideResponse?: StoryWithSections | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<StoryWithSections> | StoryWithSections)) => {
  return http.get('*/v1/admin/backend/stories/:id', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1AdminBackendStoriesIdResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getDeleteV1AdminBackendStoriesIdMockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.delete>[1]>[0]) => Promise<void> | void)) => {
  return http.delete('*/v1/admin/backend/stories/:id', async (info) => {await delay(1000);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 200,
        
      })
  })
}

export const getGetV1AdminBackendStorySectionsIdMockHandler = (overrideResponse?: StorySectionWithQuestions | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<StorySectionWithQuestions> | StorySectionWithQuestions)) => {
  return http.get('*/v1/admin/backend/story-sections/:id', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1AdminBackendStorySectionsIdResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getPostV1QuizChatStreamMockHandler = (overrideResponse?: string | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<string> | string)) => {
  return http.post('*/v1/quiz/chat/stream', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPostV1QuizChatStreamResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getGetV1DailyQuestionsDateMockHandler = (overrideResponse?: GetV1DailyQuestionsDate200 | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<GetV1DailyQuestionsDate200> | GetV1DailyQuestionsDate200)) => {
  return http.get('*/v1/daily/questions/:date', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1DailyQuestionsDateResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getPostV1DailyQuestionsDateCompleteQuestionIdMockHandler = (overrideResponse?: SuccessResponse | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<SuccessResponse> | SuccessResponse)) => {
  return http.post('*/v1/daily/questions/:date/complete/:questionId', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPostV1DailyQuestionsDateCompleteQuestionIdResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getDeleteV1DailyQuestionsDateCompleteQuestionIdMockHandler = (overrideResponse?: SuccessResponse | ((info: Parameters<Parameters<typeof http.delete>[1]>[0]) => Promise<SuccessResponse> | SuccessResponse)) => {
  return http.delete('*/v1/daily/questions/:date/complete/:questionId', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getDeleteV1DailyQuestionsDateCompleteQuestionIdResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getGetV1DailyDatesMockHandler = (overrideResponse?: GetV1DailyDates200 | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<GetV1DailyDates200> | GetV1DailyDates200)) => {
  return http.get('*/v1/daily/dates', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1DailyDatesResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getPostV1DailyQuestionsDateAnswerQuestionIdMockHandler = (overrideResponse?: PostV1DailyQuestionsDateAnswerQuestionId200 | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<PostV1DailyQuestionsDateAnswerQuestionId200> | PostV1DailyQuestionsDateAnswerQuestionId200)) => {
  return http.post('*/v1/daily/questions/:date/answer/:questionId', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPostV1DailyQuestionsDateAnswerQuestionIdResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getGetV1DailyProgressDateMockHandler = (overrideResponse?: DailyProgress | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<DailyProgress> | DailyProgress)) => {
  return http.get('*/v1/daily/progress/:date', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1DailyProgressDateResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getGetV1DailyHistoryQuestionIdMockHandler = (overrideResponse?: GetV1DailyHistoryQuestionId200 | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<GetV1DailyHistoryQuestionId200> | GetV1DailyHistoryQuestionId200)) => {
  return http.get('*/v1/daily/history/:questionId', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1DailyHistoryQuestionIdResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getPostV1StoryMockHandler = (overrideResponse?: Story | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<Story> | Story)) => {
  return http.post('*/v1/story', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPostV1StoryResponseMock()),
      { status: 201,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getGetV1StoryMockHandler = (overrideResponse?: Story[] | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<Story[]> | Story[])) => {
  return http.get('*/v1/story', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1StoryResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getGetV1StoryCurrentMockHandler = (overrideResponse?: StoryWithSections | GeneratingResponse | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<StoryWithSections | GeneratingResponse> | StoryWithSections | GeneratingResponse)) => {
  return http.get('*/v1/story/current', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1StoryCurrentResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getGetV1StoryIdMockHandler = (overrideResponse?: StoryWithSections | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<StoryWithSections> | StoryWithSections)) => {
  return http.get('*/v1/story/:id', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1StoryIdResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getDeleteV1StoryIdMockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.delete>[1]>[0]) => Promise<void> | void)) => {
  return http.delete('*/v1/story/:id', async (info) => {await delay(1000);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 200,
        
      })
  })
}

export const getPostV1StoryIdGenerateMockHandler = (overrideResponse?: StorySection | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<StorySection> | StorySection)) => {
  return http.post('*/v1/story/:id/generate', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPostV1StoryIdGenerateResponseMock()),
      { status: 201,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getPostV1StoryIdArchiveMockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<void> | void)) => {
  return http.post('*/v1/story/:id/archive', async (info) => {await delay(1000);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 200,
        
      })
  })
}

export const getPostV1StoryIdCompleteMockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<void> | void)) => {
  return http.post('*/v1/story/:id/complete', async (info) => {await delay(1000);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 200,
        
      })
  })
}

export const getPostV1StoryIdSetCurrentMockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<void> | void)) => {
  return http.post('*/v1/story/:id/set-current', async (info) => {await delay(1000);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 200,
        
      })
  })
}

export const getGetV1StorySectionIdMockHandler = (overrideResponse?: StorySectionWithQuestions | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<StorySectionWithQuestions> | StorySectionWithQuestions)) => {
  return http.get('*/v1/story/section/:id', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1StorySectionIdResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getGetV1StoryIdExportMockHandler = (overrideResponse?: Blob | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<Blob> | Blob)) => {
  return http.get('*/v1/story/:id/export', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1StoryIdExportResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getGetV1PreferencesLearningMockHandler = (overrideResponse?: UserLearningPreferences | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<UserLearningPreferences> | UserLearningPreferences)) => {
  return http.get('*/v1/preferences/learning', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1PreferencesLearningResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getPutV1PreferencesLearningMockHandler = (overrideResponse?: UserLearningPreferences | ((info: Parameters<Parameters<typeof http.put>[1]>[0]) => Promise<UserLearningPreferences> | UserLearningPreferences)) => {
  return http.put('*/v1/preferences/learning', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPutV1PreferencesLearningResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getGetV1VersionMockHandler = (overrideResponse?: AggregatedVersion | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<AggregatedVersion> | AggregatedVersion)) => {
  return http.get('*/v1/version', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1VersionResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getGetHealthMockHandler = (overrideResponse?: GetHealth200 | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<GetHealth200> | GetHealth200)) => {
  return http.get('*/health', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetHealthResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getGetV1AdminWorkerDailyUsersUserIdQuestionsDateMockHandler = (overrideResponse?: GetV1AdminWorkerDailyUsersUserIdQuestionsDate200 | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<GetV1AdminWorkerDailyUsersUserIdQuestionsDate200> | GetV1AdminWorkerDailyUsersUserIdQuestionsDate200)) => {
  return http.get('*/v1/admin/worker/daily/users/:userId/questions/:date', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1AdminWorkerDailyUsersUserIdQuestionsDateResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getPostV1AdminWorkerDailyUsersUserIdQuestionsDateRegenerateMockHandler = (overrideResponse?: PostV1AdminWorkerDailyUsersUserIdQuestionsDateRegenerate200 | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<PostV1AdminWorkerDailyUsersUserIdQuestionsDateRegenerate200> | PostV1AdminWorkerDailyUsersUserIdQuestionsDateRegenerate200)) => {
  return http.post('*/v1/admin/worker/daily/users/:userId/questions/:date/regenerate', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPostV1AdminWorkerDailyUsersUserIdQuestionsDateRegenerateResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getPostV1AudioSpeechMockHandler = (overrideResponse?: TTSResponse | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<TTSResponse> | TTSResponse)) => {
  return http.post('*/v1/audio/speech', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPostV1AudioSpeechResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}
export const getQuizApplicationAPIMock = () => [
  getPostV1AuthLoginMockHandler(),
  getPostV1AuthLogoutMockHandler(),
  getGetV1AuthStatusMockHandler(),
  getGetV1AuthCheckMockHandler(),
  getPostV1AuthSignupMockHandler(),
  getGetV1AuthSignupStatusMockHandler(),
  getGetV1AuthGoogleLoginMockHandler(),
  getGetV1AuthGoogleCallbackMockHandler(),
  getGetV1QuizQuestionMockHandler(),
  getGetV1QuizQuestionIdMockHandler(),
  getPostV1QuizAnswerMockHandler(),
  getGetV1QuizProgressMockHandler(),
  getPostV1QuizQuestionIdReportMockHandler(),
  getPostV1QuizQuestionIdMarkKnownMockHandler(),
  getGetV1QuizWorkerStatusMockHandler(),
  getPutV1SettingsMockHandler(),
  getGetV1SettingsAiProvidersMockHandler(),
  getPostV1SettingsTestAiMockHandler(),
  getPostV1SettingsTestEmailMockHandler(),
  getGetV1SettingsLevelsMockHandler(),
  getGetV1SettingsLanguagesMockHandler(),
  getGetV1SettingsApiKeyProviderMockHandler(),
  getPostV1AiConversationsMockHandler(),
  getGetV1AiConversationsMockHandler(),
  getGetV1AiConversationsIdMockHandler(),
  getPutV1AiConversationsIdMockHandler(),
  getDeleteV1AiConversationsIdMockHandler(),
  getPostV1AiConversationsConversationIdMessagesMockHandler(),
  getGetV1AiSearchMockHandler(),
  getPutV1AiConversationsBookmarkMockHandler(),
  getPutV1UserzProfileMockHandler(),
  getGetV1AdminBackendMockHandler(),
  getGetV1AdminBackendUserzMockHandler(),
  getPostV1AdminBackendUserzMockHandler(),
  getPostV1SettingsClearStoriesMockHandler(),
  getPostV1SettingsResetAccountMockHandler(),
  getPostV1SettingsClearAiChatsMockHandler(),
  getGetV1AdminBackendUserzPaginatedMockHandler(),
  getPutV1AdminBackendUserzIdMockHandler(),
  getDeleteV1AdminBackendUserzIdMockHandler(),
  getPostV1AdminBackendUserzIdResetPasswordMockHandler(),
  getGetV1AdminBackendRolesMockHandler(),
  getGetV1AdminBackendUserzIdRolesMockHandler(),
  getPostV1AdminBackendUserzIdRolesMockHandler(),
  getDeleteV1AdminBackendUserzIdRolesRoleIdMockHandler(),
  getGetV1AdminBackendDashboardMockHandler(),
  getGetV1AdminBackendAiConcurrencyMockHandler(),
  getGetV1AdminWorkerStatusMockHandler(),
  getGetV1AdminWorkerDetailsMockHandler(),
  getPostV1AdminWorkerPauseMockHandler(),
  getPostV1AdminWorkerResumeMockHandler(),
  getPostV1AdminWorkerTriggerMockHandler(),
  getGetV1AdminWorkerLogsMockHandler(),
  getGetV1AdminWorkerAiConcurrencyMockHandler(),
  getGetV1AdminWorkerUsersMockHandler(),
  getPostV1AdminWorkerUsersPauseMockHandler(),
  getPostV1AdminWorkerUsersResumeMockHandler(),
  getGetV1AdminWorkerAnalyticsPriorityScoresMockHandler(),
  getGetV1AdminWorkerAnalyticsUserPerformanceMockHandler(),
  getGetV1AdminWorkerAnalyticsGenerationIntelligenceMockHandler(),
  getGetV1AdminWorkerAnalyticsSystemHealthMockHandler(),
  getGetV1AdminWorkerNotificationsStatsMockHandler(),
  getGetV1AdminWorkerNotificationsErrorsMockHandler(),
  getGetV1AdminWorkerNotificationsSentMockHandler(),
  getPostV1AdminWorkerNotificationsForceSendMockHandler(),
  getGetV1AdminBackendQuestionsMockHandler(),
  getGetV1AdminBackendQuestionsPaginatedMockHandler(),
  getGetV1AdminBackendQuestionsIdMockHandler(),
  getPutV1AdminBackendQuestionsIdMockHandler(),
  getDeleteV1AdminBackendQuestionsIdMockHandler(),
  getGetV1AdminBackendQuestionsIdUsersMockHandler(),
  getPostV1AdminBackendQuestionsIdAssignUsersMockHandler(),
  getPostV1AdminBackendQuestionsIdUnassignUsersMockHandler(),
  getPostV1AdminBackendQuestionsIdFixMockHandler(),
  getPostV1AdminBackendQuestionsIdAiFixMockHandler(),
  getPostV1AdminBackendClearUserDataMockHandler(),
  getPostV1AdminBackendClearDatabaseMockHandler(),
  getPostV1AdminBackendUserzIdClearMockHandler(),
  getGetV1AdminBackendReportedQuestionsMockHandler(),
  getGetV1AdminBackendStoriesMockHandler(),
  getGetV1AdminBackendStoriesIdMockHandler(),
  getDeleteV1AdminBackendStoriesIdMockHandler(),
  getGetV1AdminBackendStorySectionsIdMockHandler(),
  getPostV1QuizChatStreamMockHandler(),
  getGetV1DailyQuestionsDateMockHandler(),
  getPostV1DailyQuestionsDateCompleteQuestionIdMockHandler(),
  getDeleteV1DailyQuestionsDateCompleteQuestionIdMockHandler(),
  getGetV1DailyDatesMockHandler(),
  getPostV1DailyQuestionsDateAnswerQuestionIdMockHandler(),
  getGetV1DailyProgressDateMockHandler(),
  getGetV1DailyHistoryQuestionIdMockHandler(),
  getPostV1StoryMockHandler(),
  getGetV1StoryMockHandler(),
  getGetV1StoryCurrentMockHandler(),
  getGetV1StoryIdMockHandler(),
  getDeleteV1StoryIdMockHandler(),
  getPostV1StoryIdGenerateMockHandler(),
  getPostV1StoryIdArchiveMockHandler(),
  getPostV1StoryIdCompleteMockHandler(),
  getPostV1StoryIdSetCurrentMockHandler(),
  getGetV1StorySectionIdMockHandler(),
  getGetV1StoryIdExportMockHandler(),
  getGetV1PreferencesLearningMockHandler(),
  getPutV1PreferencesLearningMockHandler(),
  getGetV1VersionMockHandler(),
  getGetHealthMockHandler(),
  getGetV1AdminWorkerDailyUsersUserIdQuestionsDateMockHandler(),
  getPostV1AdminWorkerDailyUsersUserIdQuestionsDateRegenerateMockHandler(),
  getPostV1AudioSpeechMockHandler()
]
