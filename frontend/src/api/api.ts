/**
 * Generated by orval v7.16.0 üç∫
 * Do not edit manually.
 * Quiz Application API
 * API specification for the AI-powered adaptive language learning quiz application. All `date-time` fields in this specification use RFC3339 timestamps and include timezone offsets (e.g., `2025-08-15T16:33:19Z` or `2025-08-15T12:33:19-04:00`). Servers MUST return timestamps with offsets and clients MUST parse them respecting the offset.
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import {
  faker
} from '@faker-js/faker';

import {
  HttpResponse,
  delay,
  http
} from 'msw';
import type {
  RequestHandlerOptions
} from 'msw';

import { customInstance } from './axios';
export interface WordOfDayEmailPreferenceRequest {
  /** Whether to enable Word of the Day emails */
  enabled: boolean;
}

export interface CreateConversationRequest {
  /**
   * Title for the conversation
   * @minLength 1
   * @maxLength 255
   */
  title: string;
}

export interface UpdateConversationRequest {
  /**
   * New title for the conversation
   * @minLength 1
   * @maxLength 255
   */
  title: string;
}

/**
 * Role of the message sender
 */
export type CreateMessageRequestRole = typeof CreateMessageRequestRole[keyof typeof CreateMessageRequestRole];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreateMessageRequestRole = {
  user: 'user',
  assistant: 'assistant',
} as const;

/**
 * Message content
 */
export type CreateMessageRequestContent = {
  /** The actual message text */
  text?: string;
};

export interface CreateMessageRequest {
  /** Role of the message sender */
  role: CreateMessageRequestRole;
  /** Message content */
  content: CreateMessageRequestContent;
  /** Optional question ID if this message relates to a specific question */
  question_id?: number;
}

export interface Conversation {
  /** Conversation UUID */
  id: string;
  /** ID of the user who owns this conversation */
  user_id: number;
  /** Conversation title */
  title: string;
  /** When the conversation was created */
  created_at: string;
  /** When the conversation was last updated */
  updated_at: string;
  /** Total number of messages in this conversation */
  message_count?: number;
  /** Array of messages in this conversation (optional, only included when requested) */
  messages?: ChatMessage[];
}

/**
 * Role of the message sender
 */
export type ChatMessageRole = typeof ChatMessageRole[keyof typeof ChatMessageRole];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ChatMessageRole = {
  user: 'user',
  assistant: 'assistant',
} as const;

/**
 * Message content
 */
export type ChatMessageContent = {
  /** The actual message text */
  text?: string;
};

export interface ChatMessage {
  /** Message UUID */
  id: string;
  /** ID of the conversation this message belongs to */
  conversation_id: string;
  /** Optional question ID if this message relates to a specific question */
  question_id?: number;
  /** Role of the message sender */
  role: ChatMessageRole;
  /** Message content */
  content: ChatMessageContent;
  /** Whether this message is bookmarked */
  bookmarked?: boolean;
  /** When the message was created */
  created_at: string;
  /** When the message was last updated */
  updated_at: string;
  /** Title of the conversation (optional, included in search results) */
  conversation_title?: string;
}

export interface LoginRequest {
  /**
   * Username (1-100 characters, alphanumeric + underscore + email characters, cannot be empty or whitespace-only)
   * @minLength 1
   * @maxLength 100
   * @pattern ^[a-zA-Z0-9_@.+-]+$
   */
  username: string;
  /**
   * Password (minimum 8 characters)
   * @minLength 8
   * @maxLength 128
   */
  password: string;
}

export interface LoginResponse {
  success?: boolean;
  message?: string;
  user?: User;
  /** Redirect URI for OAuth flows (optional) */
  redirect_uri?: string;
}

export interface AuthStatusResponse {
  /** Whether the user is currently authenticated */
  authenticated: boolean;
  /**
   * User object if authenticated, null otherwise
   * @nullable
   */
  user: User;
}

export interface User {
  id?: number;
  /**
   * Username (1-100 characters, alphanumeric + underscore + email characters, cannot be empty or whitespace-only)
   * @maxLength 100
   * @pattern ^[a-zA-Z0-9_@.+-]+$
   */
  username?: string;
  /** @nullable */
  email?: string | null;
  /** @nullable */
  timezone?: string | null;
  /** @nullable */
  preferred_language?: string | null;
  /** @nullable */
  current_level?: string | null;
  /** @nullable */
  ai_provider?: string | null;
  /** @nullable */
  ai_model?: string | null;
  /**
   * Whether AI features are enabled for this user
   * @nullable
   */
  ai_enabled?: boolean | null;
  /** Whether the user is paused (question generation disabled) */
  is_paused?: boolean;
  /** Whether the user has a valid API key saved for their current AI provider */
  has_api_key?: boolean;
  /** Whether the user has enabled Word of the Day emails */
  word_of_day_email_enabled?: boolean;
  created_at?: string;
  /** @nullable */
  last_active?: string | null;
  /**
   * List of roles assigned to the user
   * @maxItems 20
   */
  roles?: Role[];
}

export interface Question {
  id?: number;
  language?: Language;
  level?: Level;
  type?: QuestionType;
  status?: QuestionStatus;
  difficulty_score?: number;
  explanation?: string;
  /** All question types now use multiple choice format with 4 options */
  content?: QuestionContent;
  created_at?: string;
  /** Number of times this question was answered correctly */
  correct_count?: number;
  /** Number of times this question was answered incorrectly */
  incorrect_count?: number;
  /** Total number of responses to this question (used for 'Shown' in the UI) */
  total_responses?: number;
  /** Number of users assigned to this question */
  user_count?: number;
  /** Index of the correct answer in the options array (0-based) */
  correct_answer?: number;
  /** Comma-separated list of usernames who reported this question */
  reporters?: string;
  /** General topic category for question context (e.g., daily_life, travel, work) */
  topic_category?: string;
  /** Grammar focus area for the question (e.g., present_perfect, conditionals) */
  grammar_focus?: string;
  /** Vocabulary domain for the question (e.g., food_and_dining, transportation) */
  vocabulary_domain?: string;
  /** Scenario context for the question (e.g., at_the_airport, in_a_restaurant) */
  scenario?: string;
  /** Style modifier for the question (e.g., conversational, formal) */
  style_modifier?: string;
  /** Difficulty modifier for the question (e.g., basic, intermediate) */
  difficulty_modifier?: string;
  /** Time context for the question (e.g., morning_routine, workday) */
  time_context?: string;
  /**
   * Confidence level when question was marked as known (1-5)
   * @minimum 1
   * @maximum 5
   */
  confidence_level?: number;
}

/**
 * All question types now use multiple choice format with 4 options
 */
export interface QuestionContent {
  /**
   * @minLength 1
   * @maxLength 1000
   */
  question: string;
  /**
   * @minItems 4
   * @maxItems 10
   */
  options: string[];
  /**
   * Only present for vocabulary questions (context sentence)
   * @maxLength 2000
   */
  sentence?: string;
  /**
   * Only present for reading comprehension questions
   * @maxLength 5000
   */
  passage?: string;
  /**
   * Optional hint for fill-in-blank questions
   * @maxLength 500
   */
  hint?: string;
  /**
   * Specific topic for the question (e.g., "reading-comprehension-past-continuous", "clothing", "culture")
   * @maxLength 200
   */
  topic?: string;
}

export interface AnswerRequest {
  /**
   * ID of the question being answered
   * @minimum 1
   */
  question_id: number;
  /**
   * Index of the user's selected answer in the original options array (0-based)
   * @minimum 0
   * @maximum 3
   */
  user_answer_index: number;
  /**
   * Response time in milliseconds (0-5 minutes)
   * @minimum 0
   * @maximum 300000
   */
  response_time_ms?: number;
}

export interface AnswerResponse {
  is_correct?: boolean;
  /** The answer selected by the user */
  user_answer?: string;
  /** Index of the user's selected answer in the original options array (0-based) */
  user_answer_index?: number;
  explanation?: string;
  next_difficulty?: string;
  /** Index of the correct answer in the options array (0-based) */
  correct_answer_index?: number;
}

export type UserProgressPerformanceByTopic = {[key: string]: PerformanceMetrics};

/**
 * Analysis of learning gaps and areas needing attention
 */
export type UserProgressGapAnalysis = { [key: string]: unknown };

/**
 * Distribution of question priorities (high, medium, low counts)
 */
export type UserProgressPriorityDistribution = {[key: string]: number};

export interface UserProgress {
  current_level?: Level;
  suggested_level?: Level;
  /**
   * @minimum 0
   * @maximum 1
   */
  accuracy_rate?: number;
  /** @minimum 0 */
  total_questions?: number;
  /** @minimum 0 */
  correct_answers?: number;
  performance_by_topic?: UserProgressPerformanceByTopic;
  /** @maxItems 50 */
  weak_areas?: string[];
  /** @maxItems 100 */
  recent_activity?: UserResponse[];
  worker_status?: WorkerStatus;
  learning_preferences?: UserLearningPreferences;
  priority_insights?: PriorityInsights;
  generation_focus?: GenerationFocus;
  /**
   * Topics that have high priority scores for the user
   * @maxItems 20
   */
  high_priority_topics?: string[];
  /** Analysis of learning gaps and areas needing attention */
  gap_analysis?: UserProgressGapAnalysis;
  /** Distribution of question priorities (high, medium, low counts) */
  priority_distribution?: UserProgressPriorityDistribution;
}

export interface PerformanceMetrics {
  /** @minimum 0 */
  correct_attempts?: number;
  /** @minimum 0 */
  total_attempts?: number;
  /** @minimum 0 */
  average_response_time_ms?: number;
  last_updated?: string;
}

export interface UserResponse {
  /** @minimum 1 */
  question_id?: number;
  is_correct?: boolean;
  created_at?: string;
}

export interface UserUsageStats {
  /** @minimum 1 */
  id?: number;
  /** @minimum 1 */
  user_id?: number;
  /** @minimum 1 */
  api_key_id?: number;
  usage_date?: string;
  /**
   * @minimum 0
   * @maximum 23
   */
  usage_hour?: number;
  service_name?: string;
  provider?: string;
  model?: string;
  usage_type?: string;
  /** @minimum 0 */
  prompt_tokens?: number;
  /** @minimum 0 */
  completion_tokens?: number;
  /** @minimum 0 */
  total_tokens?: number;
  /** @minimum 0 */
  requests_made?: number;
  created_at?: string;
  updated_at?: string;
}

export interface UserUsageStatsDaily {
  usage_date?: string;
  service_name?: string;
  provider?: string;
  model?: string;
  usage_type?: string;
  /** @minimum 0 */
  total_prompt_tokens?: number;
  /** @minimum 0 */
  total_completion_tokens?: number;
  /** @minimum 0 */
  total_tokens?: number;
  /** @minimum 0 */
  total_requests?: number;
}

export interface UserUsageStatsHourly {
  /**
   * @minimum 0
   * @maximum 23
   */
  usage_hour?: number;
  service_name?: string;
  provider?: string;
  model?: string;
  usage_type?: string;
  /** @minimum 0 */
  total_prompt_tokens?: number;
  /** @minimum 0 */
  total_completion_tokens?: number;
  /** @minimum 0 */
  total_tokens?: number;
  /** @minimum 0 */
  total_requests?: number;
}

export type UserSettings = (unknown & {
  language?: Language;
  level?: Level;
  /**
   * @maxLength 50
   * @pattern ^[a-zA-Z0-9_.-]*$
   */
  ai_provider?: string;
  /**
   * @maxLength 50
   * @pattern ^[a-zA-Z0-9_.:-]*$
   */
  ai_model?: string;
  /** Whether AI features are enabled for this user */
  ai_enabled?: boolean;
  /**
   * API key for AI provider (write-only)
   * @maxLength 1000
   */
  api_key?: string;
}) | (unknown & {
  language?: Language;
  level?: Level;
  /**
   * @maxLength 50
   * @pattern ^[a-zA-Z0-9_.-]*$
   */
  ai_provider?: string;
  /**
   * @maxLength 50
   * @pattern ^[a-zA-Z0-9_.:-]*$
   */
  ai_model?: string;
  /** Whether AI features are enabled for this user */
  ai_enabled?: boolean;
  /**
   * API key for AI provider (write-only)
   * @maxLength 1000
   */
  api_key?: string;
});

export interface TestAIRequest {
  /**
   * AI provider code (e.g., "ollama", "openai")
   * @maxLength 50
   * @pattern ^[a-zA-Z0-9_.-]+$
   */
  provider: string;
  /**
   * AI model code (e.g., "llama3", "gpt-4")
   * @maxLength 50
   * @pattern ^[a-zA-Z0-9_.:-]+$
   */
  model: string;
  /**
   * API key for the provider. If not provided, the server will try to use a saved key.
   * @maxLength 1000
   * @nullable
   */
  api_key?: string | null;
}

export interface SuccessResponse {
  success: boolean;
  /** @maxLength 500 */
  message?: string;
}

export interface DailyQuestionWithDetails {
  /** Daily question assignment ID */
  id: number;
  /** User ID */
  user_id: number;
  /** Question ID */
  question_id: number;
  /** Date-only assignment (YYYY-MM-DD) representing the logical calendar day the question was assigned (no timezone offset) */
  assignment_date: string;
  /** Whether the question has been completed */
  is_completed: boolean;
  /**
   * When the question was completed (if completed)
   * @nullable
   */
  completed_at?: string | null;
  /** When the assignment was created */
  created_at: string;
  /**
   * The index of the answer option the user selected (0-based)
   * @nullable
   */
  user_answer_index?: number | null;
  /**
   * When the user submitted their answer
   * @nullable
   */
  submitted_at?: string | null;
  /** Number of times this question was shown to this user in Daily view */
  user_shown_count?: number;
  /** Number of times this user answered this question */
  user_total_responses?: number;
  /** Number of times this user answered this question correctly */
  user_correct_count?: number;
  /** Number of times this user answered this question incorrectly */
  user_incorrect_count?: number;
  /** Full question details */
  question: Question;
}

export interface DailyProgress {
  /** Date for the progress report (YYYY-MM-DD) */
  date: string;
  /** Number of completed questions */
  completed: number;
  /** Total number of questions assigned for the date */
  total: number;
}

/**
 * Source type of the word (from vocabulary question or user snippet)
 */
export type WordOfTheDayDisplaySourceType = typeof WordOfTheDayDisplaySourceType[keyof typeof WordOfTheDayDisplaySourceType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const WordOfTheDayDisplaySourceType = {
  vocabulary_question: 'vocabulary_question',
  snippet: 'snippet',
} as const;

export interface WordOfTheDayDisplay {
  /** Date for the word of the day (YYYY-MM-DD) */
  date: string;
  /** The word or phrase being featured */
  word: string;
  /** English translation of the word */
  translation: string;
  /** Example sentence using the word in context */
  sentence: string;
  /** Source type of the word (from vocabulary question or user snippet) */
  source_type: WordOfTheDayDisplaySourceType;
  /** ID of the source (question ID or snippet ID) */
  source_id: number;
  /** Source language of the word */
  language: string;
  /**
   * CEFR difficulty level
   * @nullable
   */
  level?: string | null;
  /**
   * Additional context for the word (primarily for snippets)
   * @nullable
   */
  context?: string | null;
  /**
   * Explanation of the word meaning or usage
   * @nullable
   */
  explanation?: string | null;
  /**
   * Topic category for the word
   * @nullable
   */
  topic_category?: string | null;
}

/**
 * Severity level of the error
 */
export type ErrorResponseSeverity = typeof ErrorResponseSeverity[keyof typeof ErrorResponseSeverity];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ErrorResponseSeverity = {
  info: 'info',
  warn: 'warn',
  error: 'error',
  fatal: 'fatal',
} as const;

export interface ErrorResponse {
  /** Error code identifying the type of error */
  code?: string;
  /** Human-readable error message */
  message?: string;
  /**
   * Error message (for backward compatibility)
   * @maxLength 500
   */
  error?: string;
  /**
   * Additional error details
   * @maxLength 1000
   */
  details?: string;
  /** Whether the operation can be retried */
  retryable?: boolean;
  /** Severity level of the error */
  severity?: ErrorResponseSeverity;
}

export interface SignupStatusResponse {
  /** Whether user signups are currently disabled */
  signups_disabled: boolean;
}

export interface ReportQuestionRequest {
  /**
   * Optional explanation for why the question is being reported
   * @maxLength 512
   */
  report_reason?: string;
}

export interface MarkQuestionKnownRequest {
  /**
   * User's confidence level (1-5, optional)
   * @minimum 1
   * @maximum 5
   */
  confidence_level?: number;
}

/**
 * Type of feedback
 */
export type FeedbackSubmissionRequestFeedbackType = typeof FeedbackSubmissionRequestFeedbackType[keyof typeof FeedbackSubmissionRequestFeedbackType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const FeedbackSubmissionRequestFeedbackType = {
  bug: 'bug',
  feature_request: 'feature_request',
  general: 'general',
  improvement: 'improvement',
} as const;

/**
 * Context metadata as JSON object
 */
export type FeedbackSubmissionRequestContextData = { [key: string]: unknown };

export interface FeedbackSubmissionRequest {
  /**
   * Feedback or issue description
   * @maxLength 5000
   */
  feedback_text: string;
  /** Type of feedback */
  feedback_type?: FeedbackSubmissionRequestFeedbackType;
  /** Context metadata as JSON object */
  context_data?: FeedbackSubmissionRequestContextData;
  /** Base64 encoded screenshot (optional) */
  screenshot_data?: string;
}

/**
 * Type of feedback
 */
export type FeedbackReportFeedbackType = typeof FeedbackReportFeedbackType[keyof typeof FeedbackReportFeedbackType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const FeedbackReportFeedbackType = {
  bug: 'bug',
  feature_request: 'feature_request',
  general: 'general',
  improvement: 'improvement',
} as const;

/**
 * Context metadata as JSON object
 */
export type FeedbackReportContextData = { [key: string]: unknown };

/**
 * Current status of the feedback
 */
export type FeedbackReportStatus = typeof FeedbackReportStatus[keyof typeof FeedbackReportStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const FeedbackReportStatus = {
  new: 'new',
  in_progress: 'in_progress',
  resolved: 'resolved',
  dismissed: 'dismissed',
} as const;

export interface FeedbackReport {
  /** Feedback report ID */
  id: number;
  /** User ID who submitted the feedback */
  user_id: number;
  /**
   * Feedback or issue description
   * @maxLength 5000
   */
  feedback_text: string;
  /** Type of feedback */
  feedback_type: FeedbackReportFeedbackType;
  /** Context metadata as JSON object */
  context_data?: FeedbackReportContextData;
  /**
   * Base64 encoded screenshot
   * @nullable
   */
  screenshot_data?: string | null;
  /**
   * URL to stored screenshot file
   * @nullable
   */
  screenshot_url?: string | null;
  /** Current status of the feedback */
  status: FeedbackReportStatus;
  /**
   * Notes from admin
   * @nullable
   */
  admin_notes?: string | null;
  /**
   * User ID assigned to handle this feedback
   * @nullable
   */
  assigned_to_user_id?: number | null;
  /**
   * When the feedback was resolved
   * @nullable
   */
  resolved_at?: string | null;
  /**
   * User ID who resolved the feedback
   * @nullable
   */
  resolved_by_user_id?: number | null;
  /** When the feedback was created */
  created_at: string;
  /** When the feedback was last updated */
  updated_at: string;
}

export interface FeedbackListResponse {
  /** List of feedback reports */
  items: FeedbackReport[];
  /**
   * Total number of feedback reports matching filters
   * @minimum 0
   */
  total: number;
  /**
   * Current page number
   * @minimum 1
   */
  page: number;
  /**
   * Number of items per page
   * @minimum 1
   */
  page_size: number;
}

/**
 * New status for the feedback
 */
export type FeedbackUpdateRequestStatus = typeof FeedbackUpdateRequestStatus[keyof typeof FeedbackUpdateRequestStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const FeedbackUpdateRequestStatus = {
  new: 'new',
  in_progress: 'in_progress',
  resolved: 'resolved',
  dismissed: 'dismissed',
} as const;

export interface FeedbackUpdateRequest {
  /** New status for the feedback */
  status?: FeedbackUpdateRequestStatus;
  /** Admin notes about this feedback */
  admin_notes?: string;
  /** User ID to assign this feedback to */
  assigned_to_user_id?: number;
  /** When the feedback was resolved (use current time if status is resolved) */
  resolved_at?: string;
  /** User ID who resolved the feedback */
  resolved_by_user_id?: number;
}

export interface CreateLinearIssueResponse {
  /** The Linear issue ID */
  issue_id: string;
  /** URL to the created Linear issue */
  issue_url: string;
  /** The title of the created Linear issue */
  title: string;
}

export interface GeneratingResponse {
  /** @maxLength 100 */
  status?: string;
  /** @maxLength 500 */
  message?: string;
  /** User's preferred AI model */
  ai_model?: string;
  /** User's API key for the selected provider (write-only) */
  api_key?: string;
}

export type AIProvidersProvidersItemModelsItem = {
  /** @maxLength 100 */
  name?: string;
  /**
   * @maxLength 50
   * @pattern ^[a-zA-Z0-9_.:-]+$
   */
  code?: string;
};

export type AIProvidersProvidersItem = {
  /** @maxLength 100 */
  name?: string;
  /**
   * @maxLength 50
   * @pattern ^[a-zA-Z0-9_.-]+$
   */
  code?: string;
  /** @maxLength 500 */
  url?: string;
  /** Whether the provider supports usage tracking in streaming responses */
  usage_supported?: boolean;
  /** @maxItems 100 */
  models?: AIProvidersProvidersItemModelsItem[];
};

export interface AIProviders {
  /** @maxItems 50 */
  providers?: AIProvidersProvidersItem[];
  /** @maxItems 20 */
  levels?: string[];
}

/**
 * Learning language (dynamic). Allowed values come from config.yaml language_levels keys.
 */
export type Language = string;

/**
 * Proficiency level (dynamic). Allowed values depend on the selected language and are sourced from config.yaml (e.g., CEFR A1‚ÄìC2, JLPT N5‚ÄìN1, HSK1‚ÄìHSK6).
 */
export type Level = string;

export type QuestionType = typeof QuestionType[keyof typeof QuestionType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const QuestionType = {
  vocabulary: 'vocabulary',
  fill_blank: 'fill_blank',
  reading_comprehension: 'reading_comprehension',
  qa: 'qa',
} as const;

export type QuestionStatus = typeof QuestionStatus[keyof typeof QuestionStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const QuestionStatus = {
  active: 'active',
  reported: 'reported',
} as const;

export interface QuizChatRequest {
  /**
   * The user's message to the AI tutor.
   * @minLength 1
   * @maxLength 2000
   */
  user_message: string;
  question: Question;
  /** Context about the user's submitted answer. Omit if the user has not answered yet. */
  answer_context?: AnswerResponse;
  /**
   * Previous messages in the conversation
   * @maxItems 50
   */
  conversation_history?: ChatMessage[];
}

export interface QuizChatResponse {
  /** The response from the AI tutor. */
  ai_response?: string;
}

export interface UserProfile {
  id?: number;
  /**
   * Username (1-100 characters, alphanumeric + underscore + email characters, cannot be empty or whitespace-only)
   * @maxLength 100
   * @pattern ^[a-zA-Z0-9_@.+-]+$
   */
  username?: string;
  /** @nullable */
  email?: string | null;
  /** @nullable */
  timezone?: string | null;
  /** @nullable */
  last_active?: string | null;
  /** @nullable */
  preferred_language?: string | null;
  current_level?: string;
  /**
   * Whether AI features are enabled for this user
   * @nullable
   */
  ai_enabled?: boolean | null;
  /** Whether the user is paused (question generation disabled) */
  is_paused?: boolean;
  /** Whether the user has enabled Word of the Day emails */
  word_of_day_email_enabled?: boolean;
  created_at?: string;
  updated_at?: string;
}

export interface UserCreateRequest {
  /**
   * Username (1-100 characters, alphanumeric + underscore + email characters, cannot be empty or whitespace-only)
   * @minLength 1
   * @maxLength 100
   * @pattern ^[a-zA-Z0-9_@.+-]+$
   */
  username: string;
  /**
   * Email address
   * @maxLength 255
   */
  email?: string;
  /**
   * Timezone (e.g., "UTC", "America/New_York")
   * @maxLength 100
   */
  timezone?: string;
  /**
   * Password (minimum 8 characters)
   * @minLength 8
   * @maxLength 128
   */
  password: string;
  /**
   * Preferred learning language
   * @maxLength 50
   */
  preferred_language?: string;
  /**
   * Current proficiency level
   * @maxLength 10
   */
  current_level?: string;
  /** Whether AI features are enabled for this user */
  ai_enabled?: boolean;
}

export type UserUpdateRequest = (unknown & {
  /**
   * Username (1-100 characters, alphanumeric + underscore + email characters, cannot be empty or whitespace-only)
   * @minLength 1
   * @maxLength 100
   * @pattern ^[a-zA-Z0-9_@.+-]+$
   */
  username?: string;
  /**
   * Email address
   * @maxLength 255
   */
  email?: string;
  /**
   * Timezone (e.g., "UTC", "America/New_York")
   * @maxLength 100
   */
  timezone?: string;
  /**
   * Preferred learning language
   * @maxLength 50
   */
  preferred_language?: string;
  /**
   * Current proficiency level
   * @maxLength 10
   */
  current_level?: string;
  /** Whether AI features are enabled for this user */
  ai_enabled?: boolean;
  /**
   * AI provider code
   * @maxLength 50
   * @pattern ^[a-zA-Z0-9_.-]*$
   */
  ai_provider?: string;
  /**
   * AI model code
   * @maxLength 50
   * @pattern ^[a-zA-Z0-9_.:-]*$
   */
  ai_model?: string;
  /**
   * API key for AI provider (write-only)
   * @maxLength 1000
   */
  api_key?: string;
  /**
   * Array of role names to assign to the user
   * @maxItems 20
   */
  selectedRoles?: string[];
}) | (unknown & {
  /**
   * Username (1-100 characters, alphanumeric + underscore + email characters, cannot be empty or whitespace-only)
   * @minLength 1
   * @maxLength 100
   * @pattern ^[a-zA-Z0-9_@.+-]+$
   */
  username?: string;
  /**
   * Email address
   * @maxLength 255
   */
  email?: string;
  /**
   * Timezone (e.g., "UTC", "America/New_York")
   * @maxLength 100
   */
  timezone?: string;
  /**
   * Preferred learning language
   * @maxLength 50
   */
  preferred_language?: string;
  /**
   * Current proficiency level
   * @maxLength 10
   */
  current_level?: string;
  /** Whether AI features are enabled for this user */
  ai_enabled?: boolean;
  /**
   * AI provider code
   * @maxLength 50
   * @pattern ^[a-zA-Z0-9_.-]*$
   */
  ai_provider?: string;
  /**
   * AI model code
   * @maxLength 50
   * @pattern ^[a-zA-Z0-9_.:-]*$
   */
  ai_model?: string;
  /**
   * API key for AI provider (write-only)
   * @maxLength 1000
   */
  api_key?: string;
  /**
   * Array of role names to assign to the user
   * @maxItems 20
   */
  selectedRoles?: string[];
});

export interface PasswordResetRequest {
  /**
   * New password (minimum 8 characters)
   * @minLength 8
   * @maxLength 128
   */
  new_password: string;
}

export interface ServiceVersion {
  /**
   * Service name (e.g., 'backend', 'worker')
   * @maxLength 50
   */
  service: string;
  /**
   * Version string (e.g., git tag or 'dev')
   * @maxLength 100
   */
  version: string;
  /**
   * Git commit hash
   * @maxLength 50
   */
  commit: string;
  /**
   * Build timestamp (ISO8601)
   * @maxLength 100
   */
  buildTime: string;
}

export type AggregatedVersionWorkerOneOf = {
  /** Error message when worker is unavailable */
  error: string;
};

export type AggregatedVersionWorker = ServiceVersion | AggregatedVersionWorkerOneOf;

export interface AggregatedVersion {
  /** Backend service version information */
  backend: ServiceVersion;
  worker: AggregatedVersionWorker;
}

export interface Role {
  /** Role ID */
  id: number;
  /**
   * Role name (e.g., "user", "admin")
   * @maxLength 50
   */
  name: string;
  /**
   * Role description
   * @maxLength 500
   */
  description: string;
  /** When the role was created */
  created_at: string;
  /** When the role was last updated */
  updated_at: string;
}

export interface UserLearningPreferences {
  /** Whether to focus on weak areas */
  focus_on_weak_areas: boolean;
  /**
   * Ratio of fresh (never seen) questions to show (0-1)
   * @minimum 0
   * @maximum 1
   */
  fresh_question_ratio: number;
  /**
   * Penalty multiplier for questions marked as known (0-1)
   * @minimum 0
   * @maximum 1
   */
  known_question_penalty: number;
  /**
   * Days between reviews of known questions
   * @minimum 1
   * @maximum 60
   */
  review_interval_days: number;
  /**
   * Multiplier for weak area questions
   * @minimum 1
   * @maximum 5
   */
  weak_area_boost: number;
  /** Whether to receive daily reminder emails */
  daily_reminder_enabled: boolean;
  /** Preferred TTS voice (e.g., it-IT-IsabellaNeural) */
  tts_voice?: string;
  /**
   * User-configurable number of daily questions
   * @minimum 1
   */
  daily_goal?: number;
}

export interface DashboardUser {
  user?: UserProfile;
  progress?: UserProgress;
  question_stats?: UserQuestionStats;
}

export interface DashboardResponse {
  users?: DashboardUser[];
  question_stats?: QuestionStats;
  ai_concurrency_stats?: AIConcurrencyStats;
  worker_health?: WorkerHealth;
  worker_port?: string;
  worker_base_url?: string;
}

export type AIConcurrencyStatsUserActiveCount = {[key: string]: number};

export interface AIConcurrencyStats {
  active_requests?: number;
  max_concurrent?: number;
  queued_requests?: number;
  total_requests?: number;
  user_active_count?: AIConcurrencyStatsUserActiveCount;
  max_per_user?: number;
}

export type WorkerHealthWorkerInstancesItemLastHeartbeat = {
  Time?: string;
  Valid?: boolean;
};

export type WorkerHealthWorkerInstancesItem = {
  healthy?: boolean;
  is_paused?: boolean;
  is_running?: boolean;
  last_heartbeat?: WorkerHealthWorkerInstancesItemLastHeartbeat;
  total_questions_generated?: number;
  total_runs?: number;
  worker_instance?: string;
};

export interface WorkerHealth {
  global_paused?: boolean;
  healthy_count?: number;
  total_count?: number;
  worker_instances?: WorkerHealthWorkerInstancesItem[];
}

export type PriorityAnalyticsDistribution = {
  high?: number;
  medium?: number;
  low?: number;
  average?: number;
};

export interface PriorityAnalytics {
  distribution?: PriorityAnalyticsDistribution;
}

export type UserPerformanceAnalyticsWeakAreasItem = { [key: string]: unknown };

export type UserPerformanceAnalyticsLearningPreferences = { [key: string]: unknown };

export interface UserPerformanceAnalytics {
  weakAreas?: UserPerformanceAnalyticsWeakAreasItem[];
  learningPreferences?: UserPerformanceAnalyticsLearningPreferences;
}

export type GenerationIntelligenceGapAnalysisItem = { [key: string]: unknown };

export type GenerationIntelligenceGenerationSuggestionsItem = { [key: string]: unknown };

export interface GenerationIntelligence {
  gapAnalysis?: GenerationIntelligenceGapAnalysisItem[];
  generationSuggestions?: GenerationIntelligenceGenerationSuggestionsItem[];
}

export type SystemHealthAnalyticsPerformance = { [key: string]: unknown };

export type SystemHealthAnalyticsBackgroundJobs = { [key: string]: unknown };

export interface SystemHealthAnalytics {
  performance?: SystemHealthAnalyticsPerformance;
  backgroundJobs?: SystemHealthAnalyticsBackgroundJobs;
}

export type UserQuestionStatsAnsweredByType = {[key: string]: number};

export type UserQuestionStatsAnsweredByLevel = {[key: string]: number};

export type UserQuestionStatsAccuracyByType = {[key: string]: number};

export type UserQuestionStatsAccuracyByLevel = {[key: string]: number};

export type UserQuestionStatsAvailableByType = {[key: string]: number};

export type UserQuestionStatsAvailableByLevel = {[key: string]: number};

export interface UserQuestionStats {
  user_id?: number;
  /** @minimum 0 */
  total_answered?: number;
  answered_by_type?: UserQuestionStatsAnsweredByType;
  answered_by_level?: UserQuestionStatsAnsweredByLevel;
  accuracy_by_type?: UserQuestionStatsAccuracyByType;
  accuracy_by_level?: UserQuestionStatsAccuracyByLevel;
  available_by_type?: UserQuestionStatsAvailableByType;
  available_by_level?: UserQuestionStatsAvailableByLevel;
}

/**
 * Breakdown of questions by type
 */
export type QuestionStatsQuestionsByType = {[key: string]: number};

/**
 * Breakdown of questions by level
 */
export type QuestionStatsQuestionsByLevel = {[key: string]: number};

/**
 * Breakdown of questions by language
 */
export type QuestionStatsQuestionsByLanguage = {[key: string]: number};

export interface QuestionStats {
  /**
   * Total number of questions
   * @minimum 0
   */
  total_questions?: number;
  /**
   * Total number of responses
   * @minimum 0
   */
  total_responses?: number;
  /** Breakdown of questions by type */
  questions_by_type?: QuestionStatsQuestionsByType;
  /** Breakdown of questions by level */
  questions_by_level?: QuestionStatsQuestionsByLevel;
  /** Breakdown of questions by language */
  questions_by_language?: QuestionStatsQuestionsByLanguage;
}

/**
 * Breakdown of notifications by type
 */
export type NotificationStatsNotificationsByType = {[key: string]: number};

export interface NotificationStats {
  /**
   * Total number of notifications sent
   * @minimum 0
   */
  total_sent?: number;
  /**
   * Total number of notifications that failed
   * @minimum 0
   */
  total_failed?: number;
  /**
   * Success rate as a percentage (0-1)
   * @minimum 0
   * @maximum 1
   */
  success_rate?: number;
  /**
   * Number of notifications sent today
   * @minimum 0
   */
  sent_today?: number;
  /**
   * Number of notifications sent this week
   * @minimum 0
   */
  sent_this_week?: number;
  /** Breakdown of notifications by type */
  notifications_by_type?: NotificationStatsNotificationsByType;
}

/**
 * Breakdown of errors by type
 */
export type NotificationErrorStatsErrorsByType = {[key: string]: number};

/**
 * Breakdown of errors by notification type
 */
export type NotificationErrorStatsErrorsByNotificationType = {[key: string]: number};

export interface NotificationErrorStats {
  /**
   * Total number of errors
   * @minimum 0
   */
  total_errors?: number;
  /**
   * Number of unresolved errors
   * @minimum 0
   */
  unresolved_errors?: number;
  /** Breakdown of errors by type */
  errors_by_type?: NotificationErrorStatsErrorsByType;
  /** Breakdown of errors by notification type */
  errors_by_notification_type?: NotificationErrorStatsErrorsByNotificationType;
}

/**
 * Type of notification that failed
 */
export type NotificationErrorNotificationType = typeof NotificationErrorNotificationType[keyof typeof NotificationErrorNotificationType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const NotificationErrorNotificationType = {
  daily_reminder: 'daily_reminder',
  test_email: 'test_email',
} as const;

/**
 * Type of error that occurred
 */
export type NotificationErrorErrorType = typeof NotificationErrorErrorType[keyof typeof NotificationErrorErrorType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const NotificationErrorErrorType = {
  smtp_error: 'smtp_error',
  template_error: 'template_error',
  user_not_found: 'user_not_found',
  email_disabled: 'email_disabled',
  other: 'other',
} as const;

export interface NotificationError {
  id?: number;
  /** @nullable */
  user_id?: number | null;
  /** Username of the user (if available) */
  username?: string;
  /** Type of notification that failed */
  notification_type?: NotificationErrorNotificationType;
  /** Type of error that occurred */
  error_type?: NotificationErrorErrorType;
  /** Detailed error message */
  error_message?: string;
  /**
   * Email address that was being used
   * @nullable
   */
  email_address?: string | null;
  /** When the error occurred */
  occurred_at?: string;
  /**
   * When the error was resolved
   * @nullable
   */
  resolved_at?: string | null;
  /**
   * Notes about how the error was resolved
   * @nullable
   */
  resolution_notes?: string | null;
}

/**
 * Type of notification
 */
export type UpcomingNotificationNotificationType = typeof UpcomingNotificationNotificationType[keyof typeof UpcomingNotificationNotificationType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UpcomingNotificationNotificationType = {
  daily_reminder: 'daily_reminder',
  test_email: 'test_email',
} as const;

/**
 * Current status of the notification
 */
export type UpcomingNotificationStatus = typeof UpcomingNotificationStatus[keyof typeof UpcomingNotificationStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UpcomingNotificationStatus = {
  pending: 'pending',
  sent: 'sent',
  cancelled: 'cancelled',
} as const;

export interface UpcomingNotification {
  id?: number;
  user_id?: number;
  /** Username of the user */
  username?: string;
  /** Email address for the notification */
  email_address?: string;
  /** Type of notification */
  notification_type?: UpcomingNotificationNotificationType;
  /** When the notification is scheduled to be sent */
  scheduled_for?: string;
  /** Current status of the notification */
  status?: UpcomingNotificationStatus;
  /** When the notification was created */
  created_at?: string;
}

/**
 * Type of notification
 */
export type SentNotificationNotificationType = typeof SentNotificationNotificationType[keyof typeof SentNotificationNotificationType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SentNotificationNotificationType = {
  daily_reminder: 'daily_reminder',
  test_email: 'test_email',
} as const;

/**
 * Status of the notification
 */
export type SentNotificationStatus = typeof SentNotificationStatus[keyof typeof SentNotificationStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SentNotificationStatus = {
  sent: 'sent',
  failed: 'failed',
  bounced: 'bounced',
} as const;

export interface SentNotification {
  id?: number;
  user_id?: number;
  /** Username of the user */
  username?: string;
  /** Email address the notification was sent to */
  email_address?: string;
  /** Type of notification */
  notification_type?: SentNotificationNotificationType;
  /** Subject line of the email */
  subject?: string;
  /** Template used for the notification */
  template_name?: string;
  /** When the notification was sent */
  sent_at?: string;
  /** Status of the notification */
  status?: SentNotificationStatus;
  /**
   * Error message if the notification failed
   * @nullable
   */
  error_message?: string | null;
  /**
   * Number of times the notification was retried
   * @minimum 0
   */
  retry_count?: number;
}

export interface PaginationInfo {
  /**
   * Current page number
   * @minimum 1
   */
  page: number;
  /**
   * Number of items per page
   * @minimum 1
   * @maximum 100
   */
  page_size: number;
  /**
   * Total number of items
   * @minimum 0
   */
  total: number;
  /**
   * Total number of pages
   * @minimum 0
   */
  total_pages: number;
}

/**
 * Current status of the worker
 */
export type WorkerStatusStatus = typeof WorkerStatusStatus[keyof typeof WorkerStatusStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const WorkerStatusStatus = {
  idle: 'idle',
  busy: 'busy',
  error: 'error',
} as const;

export interface WorkerStatus {
  /** Current status of the worker */
  status?: WorkerStatusStatus;
  /** Timestamp of the last heartbeat from the worker */
  last_heartbeat?: string;
  /**
   * Error message if the worker is in an error state
   * @nullable
   */
  error_message?: string | null;
}

export interface WorkerStatusResponse {
  /** Whether the worker has encountered errors */
  has_errors: boolean;
  /** Error message if worker has errors */
  error_message: string;
  /** Whether the worker is globally paused */
  global_paused: boolean;
  /** Whether the user's question generation is paused */
  user_paused: boolean;
  /** Number of healthy worker instances */
  healthy_workers: number;
  /** Total number of worker instances */
  total_workers: number;
  /** Detailed error information if any */
  last_error_details: string;
  /** Whether the worker is currently running */
  worker_running: boolean;
}

/**
 * Mapping from level code to short label (e.g. Beginner, Intermediate)
 */
export type LevelsResponseLevelDescriptions = {[key: string]: string};

export interface LevelsResponse {
  /**
   * Array of available language proficiency levels
   * @maxItems 20
   */
  levels: string[];
  /** Mapping from level code to short label (e.g. Beginner, Intermediate) */
  level_descriptions: LevelsResponseLevelDescriptions;
}

export interface LanguageInfo {
  /** ISO language code */
  code: string;
  /** Human-readable language name */
  name: string;
  /** TTS locale code for this language */
  tts_locale?: string;
  /** Default TTS voice for this language */
  tts_voice?: string;
}

/**
 * Array of available learning languages with codes and names
 * @maxItems 20
 */
export type LanguagesResponse = LanguageInfo[];

export interface APIKeyAvailabilityResponse {
  /** Whether the user has a saved API key for this provider */
  has_api_key: boolean;
}

/**
 * Permission level: 'readonly' for GET requests only, 'full' for all operations
 */
export type CreateAPIKeyRequestPermissionLevel = typeof CreateAPIKeyRequestPermissionLevel[keyof typeof CreateAPIKeyRequestPermissionLevel];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreateAPIKeyRequestPermissionLevel = {
  readonly: 'readonly',
  full: 'full',
} as const;

export interface CreateAPIKeyRequest {
  /** A descriptive name for the API key */
  key_name: string;
  /** Permission level: 'readonly' for GET requests only, 'full' for all operations */
  permission_level: CreateAPIKeyRequestPermissionLevel;
}

/**
 * Permission level
 */
export type CreateAPIKeyResponsePermissionLevel = typeof CreateAPIKeyResponsePermissionLevel[keyof typeof CreateAPIKeyResponsePermissionLevel];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreateAPIKeyResponsePermissionLevel = {
  readonly: 'readonly',
  full: 'full',
} as const;

export interface CreateAPIKeyResponse {
  /** Unique ID of the API key */
  id?: number;
  /** Name of the API key */
  key_name?: string;
  /** Full API key - only shown once! */
  key?: string;
  /** First characters of key for identification */
  key_prefix?: string;
  /** Permission level */
  permission_level?: CreateAPIKeyResponsePermissionLevel;
  /** Creation timestamp */
  created_at?: string;
  /** Warning message */
  message?: string;
}

/**
 * Permission level
 */
export type APIKeySummaryPermissionLevel = typeof APIKeySummaryPermissionLevel[keyof typeof APIKeySummaryPermissionLevel];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const APIKeySummaryPermissionLevel = {
  readonly: 'readonly',
  full: 'full',
} as const;

export interface APIKeySummary {
  /** Unique ID */
  id?: number;
  /** Name of the key */
  key_name?: string;
  /** First characters for identification */
  key_prefix?: string;
  /** Permission level */
  permission_level?: APIKeySummaryPermissionLevel;
  /**
   * Last time this key was used
   * @nullable
   */
  last_used_at?: string | null;
  /** Creation timestamp */
  created_at?: string;
  /** Last update timestamp */
  updated_at?: string;
}

export interface APIKeysListResponse {
  api_keys?: APIKeySummary[];
  /** Total number of keys */
  count?: number;
}

export interface DeleteAPIKeyResponse {
  success?: boolean;
  message?: string;
}

export interface MessageResponse {
  message: string;
}

export type AIFixResponseSuggestionAllOf = {
  /** Explanation of why the AI suggested these changes */
  change_reason?: string;
  /** Additional context provided by the admin when requesting the fix */
  additional_context?: string;
};

export type AIFixResponseSuggestion = Question & AIFixResponseSuggestionAllOf;

export interface AIFixResponse {
  original: Question;
  suggestion: AIFixResponseSuggestion;
}

export interface BulkDeleteResponse {
  /** Number of records deleted */
  deleted_count: number;
}

export interface BookmarkStatusResponse {
  /** The new bookmark status of the message */
  bookmarked: boolean;
}

export interface UserProfileMessageResponse {
  message: string;
  user: UserProfile;
}

export interface QuestionAssignedUsersResponse {
  /** @maxItems 5 */
  users: UserProfile[];
  /** Total number of users assigned to this question */
  total_count: number;
}

export interface AdminQuestionsResponse {
  questions: Question[];
  pagination: PaginationInfo;
  stats: QuestionStats;
}

export type ReportedQuestionsStatsReportedByType = {[key: string]: number};

export type ReportedQuestionsStatsReportedByLevel = {[key: string]: number};

export type ReportedQuestionsStatsReportedByLanguage = {[key: string]: number};

export interface ReportedQuestionsStats {
  total_reported?: number;
  reported_by_type?: ReportedQuestionsStatsReportedByType;
  reported_by_level?: ReportedQuestionsStatsReportedByLevel;
  reported_by_language?: ReportedQuestionsStatsReportedByLanguage;
}

export interface AdminReportedQuestionsResponse {
  questions: Question[];
  pagination: PaginationInfo;
  stats: ReportedQuestionsStats;
}

export interface AdminRolesResponse {
  roles: Role[];
}

export interface AdminStoriesResponse {
  stories: Story[];
  pagination: PaginationInfo;
}

export interface AdminUsersResponse {
  users: UserProfile[];
}

export interface AdminUsersPaginatedResponse {
  users: DashboardUser[];
  pagination: PaginationInfo;
}

export interface WorkerDetailsResponse { [key: string]: unknown }

export type WorkerLogsResponseLogsItem = { [key: string]: unknown };

export interface WorkerLogsResponse {
  logs: WorkerLogsResponseLogsItem[];
}

export interface WorkerUserStatus {
  id: number;
  username: string;
  is_paused: boolean;
}

export interface WorkerUserListResponse {
  users: WorkerUserStatus[];
}

export interface WorkerAIConcurrencyStats {
  active_requests?: number;
  max_concurrent?: number;
  queued_requests?: number;
  total_requests?: number;
}

export interface WorkerNotificationErrorsResponse {
  errors: NotificationError[];
  pagination: PaginationInfo;
  stats: NotificationErrorStats;
}

export interface WorkerNotificationSentResponse {
  notifications: SentNotification[];
  pagination: PaginationInfo;
  stats: NotificationStats;
}

export interface ChatBookmarksResponse {
  messages: ChatMessage[];
  /** The search query that was used (if any) */
  query?: string;
  /** Total number of bookmarked messages */
  total: number;
  /** Number of messages returned */
  limit: number;
  /** Number of messages skipped */
  offset: number;
}

export interface ConversationsListResponse {
  conversations: Conversation[];
  /** Total number of conversations */
  total: number;
  /** Number of conversations returned */
  limit: number;
  /** Number of conversations skipped */
  offset: number;
}

export type ConversationSearchResponseAllOf = {
  /** The search query that was used */
  query?: string;
};

export type ConversationSearchResponse = ConversationsListResponse & ConversationSearchResponseAllOf;

export interface DailyDatesResponse {
  dates: string[];
}

export interface DailyQuestionsResponse {
  date: string;
  questions: DailyQuestionWithDetails[];
}

export interface AdminDailyQuestionsResponse {
  questions: DailyQuestionWithDetails[];
}

export interface DailyQuestionHistoryResponse {
  history: DailyQuestionHistory[];
}

export interface WordOfDayHistoryResponse {
  words: WordOfTheDayDisplay[];
  /** Number of words returned */
  count: number;
}

export type DailyAnswerResponseAllOf = {
  /** Whether the question is now completed */
  is_completed?: boolean;
};

export type DailyAnswerResponse = AnswerResponse & DailyAnswerResponseAllOf;

export interface TTSStreamInitResponse {
  stream_id: string;
  /** @nullable */
  token?: string | null;
}

/**
 * Health status of the service
 */
export type HealthStatusResponseStatus = typeof HealthStatusResponseStatus[keyof typeof HealthStatusResponseStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const HealthStatusResponseStatus = {
  ok: 'ok',
} as const;

export interface HealthStatusResponse {
  /** Health status of the service */
  status: HealthStatusResponseStatus;
  /** Service name */
  service: string;
}

/**
 * Health status of the service
 */
export type HealthErrorResponseStatus = typeof HealthErrorResponseStatus[keyof typeof HealthErrorResponseStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const HealthErrorResponseStatus = {
  unhealthy: 'unhealthy',
} as const;

export interface HealthErrorResponse {
  /** Health status of the service */
  status: HealthErrorResponseStatus;
  timestamp: string;
  error: string;
}

export interface GoogleOAuthLoginResponse {
  /** The Google OAuth authorization URL to redirect the user to */
  auth_url: string;
}

export interface PriorityInsights {
  /**
   * Total number of questions waiting to be processed
   * @minimum 0
   */
  total_questions_in_queue?: number;
  /**
   * Number of high-priority questions
   * @minimum 0
   */
  high_priority_questions?: number;
  /**
   * Number of medium-priority questions
   * @minimum 0
   */
  medium_priority_questions?: number;
  /**
   * Number of low-priority questions
   * @minimum 0
   */
  low_priority_questions?: number;
}

export interface GenerationFocus {
  /** The AI model currently being used for generation */
  current_generation_model?: string;
  /** Timestamp of the last time a question was generated */
  last_generation_time?: string;
  /**
   * Average number of questions generated per minute
   * @minimum 0
   */
  generation_rate?: number;
}

export interface UserNullable {
  id?: number;
  /**
   * Username (1-100 characters, alphanumeric + underscore + email characters, cannot be empty or whitespace-only)
   * @maxLength 100
   * @pattern ^[a-zA-Z0-9_@.+-]+$
   */
  username?: string;
  /** @nullable */
  email?: string | null;
  /** @nullable */
  timezone?: string | null;
  /** @nullable */
  preferred_language?: string | null;
  /** @nullable */
  current_level?: string | null;
  /** @nullable */
  ai_provider?: string | null;
  /** @nullable */
  ai_model?: string | null;
  /**
   * Whether AI features are enabled for this user
   * @nullable
   */
  ai_enabled?: boolean | null;
  /** Whether the user is paused (question generation disabled) */
  is_paused?: boolean;
  /** Whether the user has a valid API key saved for their current AI provider */
  has_api_key?: boolean;
  created_at?: string;
  /** @nullable */
  last_active?: string | null;
  /**
   * List of roles assigned to the user
   * @maxItems 20
   */
  roles?: Role[];
}

export type ForceSendNotificationResponseUser = {
  id?: number;
  username?: string;
  email?: string;
};

export type ForceSendNotificationResponseNotification = {
  type?: string;
  subject?: string;
  status?: string;
};

export interface ForceSendNotificationResponse {
  message?: string;
  user?: ForceSendNotificationResponseUser;
  notification?: ForceSendNotificationResponseNotification;
}

/**
 * The format for streaming audio data
 */
export type TTSRequestStreamFormat = typeof TTSRequestStreamFormat[keyof typeof TTSRequestStreamFormat];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TTSRequestStreamFormat = {
  sse: 'sse',
  audio: 'audio',
  audio_stream: 'audio_stream',
} as const;

export interface TTSRequest {
  /**
   * The text to convert to speech
   * @minLength 1
   * @maxLength 4000
   */
  input: string;
  /** The voice to use for speech generation */
  voice?: string;
  /** The TTS model to use */
  model?: string;
  /** The format for streaming audio data */
  stream_format?: TTSRequestStreamFormat;
}

/**
 * The type of SSE event
 */
export type TTSResponseType = typeof TTSResponseType[keyof typeof TTSResponseType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TTSResponseType = {
  audio: 'audio',
  usage: 'usage',
  error: 'error',
} as const;

/**
 * Usage statistics (for type=usage)
 */
export type TTSResponseUsage = {
  /** Number of input tokens processed */
  input_tokens?: number;
  /** Number of output tokens generated */
  output_tokens?: number;
  /** Total tokens used */
  total_tokens?: number;
};

export interface TTSResponse {
  /** The type of SSE event */
  type?: TTSResponseType;
  /** Base64 encoded audio chunk (for type=audio) */
  audio?: string;
  /** Usage statistics (for type=usage) */
  usage?: TTSResponseUsage;
  /** Error message (for type=error) */
  error?: string;
}

export interface TranslateRequest {
  /**
   * Text to translate
   * @minLength 1
   * @maxLength 5000
   */
  text: string;
  /**
   * Target language code (e.g., 'en', 'es', 'fr')
   * @minLength 2
   * @maxLength 10
   */
  target_language: string;
  /**
   * Source language code (optional - will be auto-detected if not provided)
   * @minLength 2
   * @maxLength 10
   */
  source_language?: string;
}

export interface TranslateResponse {
  /** The translated text */
  translated_text: string;
  /** Detected or provided source language code */
  source_language: string;
  /** Target language code that was requested */
  target_language: string;
  /**
   * Translation confidence score (if available from provider)
   * @minimum 0
   * @maximum 1
   */
  confidence?: number;
}

/**
 * Translation direction
 */
export type TranslationPracticeGenerateRequestDirection = typeof TranslationPracticeGenerateRequestDirection[keyof typeof TranslationPracticeGenerateRequestDirection];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TranslationPracticeGenerateRequestDirection = {
  en_to_learning: 'en_to_learning',
  learning_to_en: 'learning_to_en',
} as const;

export interface TranslationPracticeGenerateRequest {
  /** Learning language code */
  language: string;
  /** Language level (e.g., A1, A2, B1, B2) */
  level: string;
  /** Translation direction */
  direction: TranslationPracticeGenerateRequestDirection;
  /** Optional topic or keywords for sentence generation */
  topic?: string;
}

export interface TranslationPracticeSentenceResponse {
  /** Sentence ID */
  id: number;
  /** The sentence text to translate */
  sentence_text: string;
  /** Source language code */
  source_language: string;
  /** Target language code */
  target_language: string;
  /** Language level */
  language_level: string;
  /** Source type (ai_generated, story_section, vocabulary_question, etc.) */
  source_type: string;
  /** ID of the source (if applicable) */
  source_id?: number;
  /** Topic or keywords (if applicable) */
  topic?: string;
  /** When the sentence was created */
  created_at: string;
}

/**
 * Translation direction
 */
export type TranslationPracticeSubmitRequestTranslationDirection = typeof TranslationPracticeSubmitRequestTranslationDirection[keyof typeof TranslationPracticeSubmitRequestTranslationDirection];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TranslationPracticeSubmitRequestTranslationDirection = {
  en_to_learning: 'en_to_learning',
  learning_to_en: 'learning_to_en',
} as const;

export interface TranslationPracticeSubmitRequest {
  /** ID of the sentence being translated */
  sentence_id: number;
  /** The original sentence to translate */
  original_sentence: string;
  /** The user's translation */
  user_translation: string;
  /** Translation direction */
  translation_direction: TranslationPracticeSubmitRequestTranslationDirection;
}

export interface TranslationPracticeSessionResponse {
  /** Session ID */
  id: number;
  /** Sentence ID */
  sentence_id: number;
  /** The original sentence */
  original_sentence: string;
  /** The user's translation */
  user_translation: string;
  /** Translation direction */
  translation_direction: string;
  /** AI feedback on the translation */
  ai_feedback: string;
  /**
   * AI score from 0 to 5
   * @minimum 0
   * @maximum 5
   */
  ai_score?: number;
  /** When the session was created */
  created_at: string;
}

export interface TranslationPracticeHistoryResponse {
  /** List of practice sessions */
  sessions: TranslationPracticeSessionResponse[];
  /**
   * Total number of sessions matching the query (before pagination)
   * @minimum 0
   */
  total: number;
  /**
   * Number of sessions returned (page size)
   * @minimum 1
   */
  limit: number;
  /**
   * Number of sessions skipped
   * @minimum 0
   */
  offset: number;
}

export interface TranslationPracticeStatsResponse {
  /** Total number of practice sessions */
  total_sessions?: number;
  /** Average AI score */
  average_score?: number;
  /** Minimum AI score */
  min_score?: number;
  /** Maximum AI score */
  max_score?: number;
  /** Number of sessions with score >= 4.0 */
  excellent_count?: number;
  /** Number of sessions with score 3.0-3.9 */
  good_count?: number;
  /** Number of sessions with score < 3.0 */
  needs_improvement_count?: number;
}

export interface DailyQuestionHistory {
  /** RFC3339 timestamp of when the question was assigned in the user's timezone (includes offset) */
  assignment_date: string;
  /** Whether the question was completed on this date */
  is_completed: boolean;
  /**
   * Whether the user's answer was correct (null if not attempted)
   * @nullable
   */
  is_correct?: boolean | null;
  /**
   * When the user submitted their answer
   * @nullable
   */
  submitted_at?: string | null;
}

export type StoryStatus = typeof StoryStatus[keyof typeof StoryStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const StoryStatus = {
  active: 'active',
  archived: 'archived',
  completed: 'completed',
} as const;

export type StorySectionLengthOverride = typeof StorySectionLengthOverride[keyof typeof StorySectionLengthOverride];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const StorySectionLengthOverride = {
  short: 'short',
  medium: 'medium',
  long: 'long',
} as const;

export type StoryStatusProperty = typeof StoryStatusProperty[keyof typeof StoryStatusProperty];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const StoryStatusProperty = {
  active: 'active',
  archived: 'archived',
  completed: 'completed',
} as const;

export interface Story {
  id?: number;
  user_id?: number;
  title?: string;
  language?: string;
  /** @nullable */
  subject?: string | null;
  /** @nullable */
  author_style?: string | null;
  /** @nullable */
  time_period?: string | null;
  /** @nullable */
  genre?: string | null;
  /** @nullable */
  tone?: string | null;
  /** @nullable */
  character_names?: string | null;
  /** @nullable */
  custom_instructions?: string | null;
  section_length_override?: StorySectionLengthOverride;
  status?: StoryStatusProperty;
  /** When true, the worker will skip automatic section generation for this story */
  auto_generation_paused?: boolean;
  /** @nullable */
  last_section_generated_at?: string | null;
  created_at?: string;
  updated_at?: string;
  /** @minimum 0 */
  extra_generations_today?: number;
}

export interface StorySection {
  id?: number;
  story_id?: number;
  section_number?: number;
  content?: string;
  language_level?: string;
  word_count?: number;
  generated_at?: string;
  generation_date?: string;
}

export interface StorySectionQuestion {
  id?: number;
  section_id?: number;
  question_text?: string;
  options?: string[];
  /**
   * @minimum 0
   * @maximum 3
   */
  correct_answer_index?: number;
  /** @nullable */
  explanation?: string | null;
  created_at?: string;
}

export type StoryWithSectionsAllOf = {
  sections?: StorySection[];
};

export type StoryWithSections = Story & StoryWithSectionsAllOf;

export type StorySectionWithQuestionsAllOf = {
  questions?: StorySectionQuestion[];
};

export type StorySectionWithQuestions = StorySection & StorySectionWithQuestionsAllOf;

export interface ToggleAutoGenerationRequest {
  /** Whether to pause (true) or resume (false) auto-generation */
  paused: boolean;
}

export interface ToggleAutoGenerationResponse {
  message?: string;
  auto_generation_paused?: boolean;
}

export type CreateStoryRequestSectionLengthOverride = typeof CreateStoryRequestSectionLengthOverride[keyof typeof CreateStoryRequestSectionLengthOverride];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreateStoryRequestSectionLengthOverride = {
  short: 'short',
  medium: 'medium',
  long: 'long',
} as const;

export interface CreateStoryRequest {
  /**
   * @minLength 1
   * @maxLength 200
   */
  title: string;
  /**
   * @maxLength 500
   * @nullable
   */
  subject?: string | null;
  /**
   * @maxLength 200
   * @nullable
   */
  author_style?: string | null;
  /**
   * @maxLength 200
   * @nullable
   */
  time_period?: string | null;
  /**
   * @maxLength 100
   * @nullable
   */
  genre?: string | null;
  /**
   * @maxLength 100
   * @nullable
   */
  tone?: string | null;
  /**
   * @maxLength 1000
   * @nullable
   */
  character_names?: string | null;
  /**
   * @maxLength 2000
   * @nullable
   */
  custom_instructions?: string | null;
  section_length_override?: CreateStoryRequestSectionLengthOverride;
}

/**
 * Empty request body for endpoints that don't require request data
 */
export interface EmptyRequest { [key: string]: unknown }

export interface UserIdRequest {
  /**
   * ID of the user
   * @minimum 1
   */
  user_id: number;
}

export interface CreateSnippetRequest {
  /**
   * The original text/word to save
   * @minLength 1
   * @maxLength 2000
   */
  original_text: string;
  /**
   * The translated text
   * @minLength 1
   * @maxLength 2000
   */
  translated_text: string;
  /**
   * ISO language code of the source text
   * @minLength 2
   * @maxLength 10
   */
  source_language: string;
  /**
   * ISO language code of the target translation
   * @minLength 2
   * @maxLength 10
   */
  target_language: string;
  /**
   * Optional ID of the question where this text was encountered. If provided, the snippet will inherit the question's difficulty level (A1, A2, B1, B2, C1, C2)
   * @minimum 1
   * @nullable
   */
  question_id?: number | null;
  /**
   * Optional ID of the story section where this text was encountered
   * @minimum 1
   * @nullable
   */
  section_id?: number | null;
  /**
   * Optional ID of the story where this text was encountered
   * @minimum 1
   * @nullable
   */
  story_id?: number | null;
  /**
   * Optional user-provided context or notes about this snippet
   * @maxLength 1000
   * @nullable
   */
  context?: string | null;
}

export interface UpdateSnippetRequest {
  /**
   * The original text/word to save
   * @maxLength 500
   */
  original_text?: string;
  /**
   * The translated text
   * @maxLength 500
   */
  translated_text?: string;
  /**
   * ISO language code of the source text
   * @maxLength 10
   */
  source_language?: string;
  /**
   * ISO language code of the target translation
   * @maxLength 10
   */
  target_language?: string;
  /**
   * User-provided context or notes about this snippet
   * @maxLength 1000
   * @nullable
   */
  context?: string | null;
}

export interface Snippet {
  id?: number;
  user_id?: number;
  original_text?: string;
  translated_text?: string;
  source_language?: string;
  target_language?: string;
  /** @nullable */
  question_id?: number | null;
  /**
   * ID of the story section where this snippet was created
   * @nullable
   */
  section_id?: number | null;
  /**
   * ID of the story where this snippet was created
   * @nullable
   */
  story_id?: number | null;
  /** @nullable */
  context?: string | null;
  /**
   * CEFR level (A1, A2, B1, B2, C1, C2)
   * @nullable
   */
  difficulty_level?: string | null;
  created_at?: string;
  updated_at?: string;
}

export interface SnippetsResponse {
  snippets: Snippet[];
}

export interface SnippetList {
  snippets?: Snippet[];
  /** Total number of snippets matching the query */
  total?: number;
  /** Number of snippets returned */
  limit?: number;
  /** Number of snippets skipped */
  offset?: number;
  /**
   * The search query that was used (if any)
   * @nullable
   */
  query?: string | null;
}

/**
 * Usage statistics organized by service, month (YYYY-MM), and usage type
 */
export type UsageStatsResponseUsageStats = {[key: string]: {[key: string]: {
  /** @minimum 0 */
  characters_used?: number;
  /** @minimum 0 */
  requests_made?: number;
  /** @minimum 0 */
  quota?: number;
}}};

/**
 * Monthly totals organized by month (YYYY-MM) and service
 */
export type UsageStatsResponseMonthlyTotals = {[key: string]: {[key: string]: {
  /** @minimum 0 */
  total_characters?: number;
  /** @minimum 0 */
  total_requests?: number;
}}};

/**
 * Cache performance statistics across all services
 */
export type UsageStatsResponseCacheStats = {
  /**
   * Total number of cache hit requests
   * @minimum 0
   */
  total_cache_hits_requests?: number;
  /**
   * Total characters served from cache
   * @minimum 0
   */
  total_cache_hits_characters?: number;
  /**
   * Total number of cache miss requests
   * @minimum 0
   */
  total_cache_misses_requests?: number;
  /**
   * Cache hit rate as a percentage
   * @minimum 0
   * @maximum 100
   */
  cache_hit_rate?: number;
};

export interface UsageStatsResponse {
  /** Usage statistics organized by service, month (YYYY-MM), and usage type */
  usage_stats: UsageStatsResponseUsageStats;
  /** Monthly totals organized by month (YYYY-MM) and service */
  monthly_totals: UsageStatsResponseMonthlyTotals;
  /** List of service names */
  services: string[];
  /** Cache performance statistics across all services */
  cache_stats?: UsageStatsResponseCacheStats;
}

export type ServiceUsageStatsResponseDataItem = {
  /** First day of the month (YYYY-MM) */
  month?: string;
  /** Type of usage (e.g., "translation") */
  usage_type?: string;
  /**
   * Number of characters processed
   * @minimum 0
   */
  characters_used?: number;
  /**
   * Number of requests made
   * @minimum 0
   */
  requests_made?: number;
  /**
   * Monthly quota for this service
   * @minimum 0
   */
  quota?: number;
};

export interface ServiceUsageStatsResponse {
  /** Name of the service */
  service: string;
  data: ServiceUsageStatsResponseDataItem[];
}

export type APIKeyTestResponsePermissionLevel = typeof APIKeyTestResponsePermissionLevel[keyof typeof APIKeyTestResponsePermissionLevel];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const APIKeyTestResponsePermissionLevel = {
  readonly: 'readonly',
  full: 'full',
} as const;

export interface APIKeyTestResponse {
  ok?: boolean;
  user_id?: number;
  username?: string;
  permission_level?: APIKeyTestResponsePermissionLevel;
  api_key_id?: number;
  method?: string;
}

export type GetV1AuthGoogleCallbackParams = {
/**
 * Authorization code from Google
 */
code: string;
/**
 * State parameter for CSRF protection
 */
state?: string;
};

export type GetV1QuizQuestionParams = {
/**
 * Preferred language for the question
 */
language?: Language;
/**
 * Difficulty level for the question
 */
level?: Level;
/**
 * Specific question type(s) to retrieve (comma-separated list). If multiple types are provided, the first valid type will be used.
 * @pattern ^[a-zA-Z_]+(,[a-zA-Z_]+)*$
 */
type?: string;
/**
 * Question type(s) to exclude from random selection (comma-separated list). Useful for filtering out specific question types from the general quiz.
 * @pattern ^[a-zA-Z_]+(,[a-zA-Z_]+)*$
 */
exclude_type?: string;
};

export type GetV1QuizAiTokenUsageParams = {
/**
 * Start date in YYYY-MM-DD format
 */
startDate: string;
/**
 * End date in YYYY-MM-DD format
 */
endDate: string;
};

export type GetV1QuizAiTokenUsageDailyParams = {
/**
 * Start date in YYYY-MM-DD format
 */
startDate: string;
/**
 * End date in YYYY-MM-DD format
 */
endDate: string;
};

export type GetV1QuizAiTokenUsageHourlyParams = {
/**
 * Date in YYYY-MM-DD format
 */
date: string;
};

export type GetV1SettingsLevelsParams = {
/**
 * Language to get levels for (optional - returns all levels if not specified)
 */
language?: string;
};

export type GetV1AiConversationsParams = {
/**
 * Maximum number of conversations to return
 * @minimum 1
 * @maximum 100
 */
limit?: number;
/**
 * Number of conversations to skip
 * @minimum 0
 */
offset?: number;
};

export type GetV1AiSearchParams = {
/**
 * Search query string
 * @minLength 1
 * @maxLength 255
 */
q: string;
/**
 * Maximum number of results to return
 * @minimum 1
 * @maximum 100
 */
limit?: number;
/**
 * Number of results to skip
 * @minimum 0
 */
offset?: number;
};

export type PutV1AiConversationsBookmarkBody = {
  /** ID of the conversation containing the message */
  conversation_id: string;
  /** ID of the message to bookmark/unbookmark */
  message_id: string;
};

export type GetV1AiBookmarksParams = {
/**
 * Optional search query to filter bookmarked messages
 * @maxLength 255
 */
q?: string;
/**
 * Maximum number of messages to return
 * @minimum 1
 * @maximum 100
 */
limit?: number;
/**
 * Number of messages to skip
 * @minimum 0
 */
offset?: number;
};

export type GetV1SnippetsParams = {
/**
 * Optional search query to filter snippets by text content
 * @maxLength 255
 */
q?: string;
/**
 * Filter by source language
 * @maxLength 10
 */
source_lang?: string;
/**
 * Filter by target language
 * @maxLength 10
 */
target_lang?: string;
/**
 * Filter by story ID
 * @minimum 1
 */
story_id?: number;
/**
 * Filter by difficulty level (CEFR level)
 */
level?: GetV1SnippetsLevel;
/**
 * Maximum number of snippets to return (default 50, max 100)
 * @minimum 1
 * @maximum 100
 */
limit?: number;
/**
 * Number of snippets to skip for pagination
 * @minimum 0
 */
offset?: number;
};

export type GetV1SnippetsLevel = typeof GetV1SnippetsLevel[keyof typeof GetV1SnippetsLevel];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetV1SnippetsLevel = {
  A1: 'A1',
  A2: 'A2',
  B1: 'B1',
  B2: 'B2',
  C1: 'C1',
  C2: 'C2',
} as const;

export type GetV1SnippetsSearchParams = {
/**
 * Search query string
 * @minLength 1
 * @maxLength 255
 */
q: string;
/**
 * Filter results by source language
 * @maxLength 10
 */
source_lang?: string;
/**
 * Maximum number of results to return
 * @minimum 1
 * @maximum 100
 */
limit?: number;
/**
 * Number of results to skip
 * @minimum 0
 */
offset?: number;
};

export type PostV1AdminBackendUserzBody = {
  /**
   * Username (1-100 characters, alphanumeric + underscore + email characters, cannot be empty or whitespace-only)
   * @minLength 3
   * @maxLength 100
   * @pattern ^[a-zA-Z0-9_@.+-]+$
   */
  username: string;
  /** Email address for the new user */
  email: string;
  /**
   * Password for the new user
   * @minLength 8
   */
  password: string;
  /** Preferred language for the user */
  language?: string;
  /** Current level for the user */
  level?: string;
  /** AI provider preference */
  ai_provider?: string;
  /** AI model preference */
  ai_model?: string;
  /** Whether AI is enabled for this user */
  ai_enabled?: boolean;
};

export type GetV1AdminBackendUserzPaginatedParams = {
/**
 * Page number (1-based)
 * @minimum 1
 */
page?: number;
/**
 * Number of users per page
 * @minimum 1
 * @maximum 100
 */
page_size?: number;
/**
 * Search term for username or email
 */
search?: string;
/**
 * Filter by preferred language
 */
language?: Language;
/**
 * Filter by current level
 */
level?: Level;
/**
 * Filter by AI provider
 */
ai_provider?: string;
/**
 * Filter by AI model
 */
ai_model?: string;
/**
 * Filter by AI enabled status
 */
ai_enabled?: GetV1AdminBackendUserzPaginatedAiEnabled;
/**
 * Filter by active status (active within 7 days)
 */
active?: GetV1AdminBackendUserzPaginatedActive;
};

export type GetV1AdminBackendUserzPaginatedAiEnabled = typeof GetV1AdminBackendUserzPaginatedAiEnabled[keyof typeof GetV1AdminBackendUserzPaginatedAiEnabled];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetV1AdminBackendUserzPaginatedAiEnabled = {
  true: 'true',
  false: 'false',
} as const;

export type GetV1AdminBackendUserzPaginatedActive = typeof GetV1AdminBackendUserzPaginatedActive[keyof typeof GetV1AdminBackendUserzPaginatedActive];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetV1AdminBackendUserzPaginatedActive = {
  true: 'true',
  false: 'false',
} as const;

export type PostV1AdminBackendUserzIdRolesBody = {
  /**
   * Role ID to assign
   * @minimum 1
   */
  role_id: number;
};

export type GetV1AdminWorkerNotificationsErrorsParams = {
/**
 * Page number (1-based)
 * @minimum 1
 */
page?: number;
/**
 * Number of errors per page
 * @minimum 1
 * @maximum 100
 */
page_size?: number;
/**
 * Filter by error type
 */
error_type?: GetV1AdminWorkerNotificationsErrorsErrorType;
/**
 * Filter by notification type
 */
notification_type?: GetV1AdminWorkerNotificationsErrorsNotificationType;
/**
 * Filter by resolution status
 */
resolved?: GetV1AdminWorkerNotificationsErrorsResolved;
};

export type GetV1AdminWorkerNotificationsErrorsErrorType = typeof GetV1AdminWorkerNotificationsErrorsErrorType[keyof typeof GetV1AdminWorkerNotificationsErrorsErrorType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetV1AdminWorkerNotificationsErrorsErrorType = {
  smtp_error: 'smtp_error',
  template_error: 'template_error',
  user_not_found: 'user_not_found',
  email_disabled: 'email_disabled',
  other: 'other',
} as const;

export type GetV1AdminWorkerNotificationsErrorsNotificationType = typeof GetV1AdminWorkerNotificationsErrorsNotificationType[keyof typeof GetV1AdminWorkerNotificationsErrorsNotificationType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetV1AdminWorkerNotificationsErrorsNotificationType = {
  daily_reminder: 'daily_reminder',
  test_email: 'test_email',
} as const;

export type GetV1AdminWorkerNotificationsErrorsResolved = typeof GetV1AdminWorkerNotificationsErrorsResolved[keyof typeof GetV1AdminWorkerNotificationsErrorsResolved];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetV1AdminWorkerNotificationsErrorsResolved = {
  true: 'true',
  false: 'false',
} as const;

export type GetV1AdminWorkerNotificationsSentParams = {
/**
 * Page number (1-based)
 * @minimum 1
 */
page?: number;
/**
 * Number of notifications per page
 * @minimum 1
 * @maximum 100
 */
page_size?: number;
/**
 * Filter by notification type
 */
notification_type?: GetV1AdminWorkerNotificationsSentNotificationType;
/**
 * Filter by status
 */
status?: GetV1AdminWorkerNotificationsSentStatus;
/**
 * Filter notifications sent after this timestamp
 */
sent_after?: string;
/**
 * Filter notifications sent before this timestamp
 */
sent_before?: string;
};

export type GetV1AdminWorkerNotificationsSentNotificationType = typeof GetV1AdminWorkerNotificationsSentNotificationType[keyof typeof GetV1AdminWorkerNotificationsSentNotificationType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetV1AdminWorkerNotificationsSentNotificationType = {
  daily_reminder: 'daily_reminder',
  test_email: 'test_email',
} as const;

export type GetV1AdminWorkerNotificationsSentStatus = typeof GetV1AdminWorkerNotificationsSentStatus[keyof typeof GetV1AdminWorkerNotificationsSentStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetV1AdminWorkerNotificationsSentStatus = {
  sent: 'sent',
  failed: 'failed',
  bounced: 'bounced',
} as const;

export type PostV1AdminWorkerNotificationsForceSendBody = {
  /** Username of the user to send notification to */
  username: string;
};

export type GetV1AdminBackendQuestionsParams = {
/**
 * Page number (1-based)
 * @minimum 1
 */
page?: number;
/**
 * Number of questions per page
 * @minimum 1
 * @maximum 100
 */
page_size?: number;
/**
 * Search term for question content
 */
search?: string;
/**
 * Filter by question type
 */
type?: QuestionType;
/**
 * Filter by question status
 */
status?: QuestionStatus;
/**
 * Filter by language
 */
language?: Language;
/**
 * Filter by level
 */
level?: Level;
/**
 * Filter by user ID (optional)
 * @minimum 1
 */
user_id?: number;
};

export type GetV1AdminBackendQuestionsPaginatedParams = {
/**
 * Page number (1-based)
 * @minimum 1
 */
page?: number;
/**
 * Number of questions per page
 * @minimum 1
 * @maximum 100
 */
page_size?: number;
/**
 * Search term for question content
 */
search?: string;
/**
 * Filter by question type
 */
type?: QuestionType;
/**
 * Filter by question status
 */
status?: QuestionStatus;
/**
 * Filter by language
 */
language?: Language;
/**
 * Filter by level
 */
level?: Level;
/**
 * Filter by user ID (optional)
 * @minimum 1
 */
user_id?: number;
};

/**
 * Updated question content
 */
export type PutV1AdminBackendQuestionsIdBodyContent = { [key: string]: unknown };

export type PutV1AdminBackendQuestionsIdBody = {
  /** Updated question content */
  content: PutV1AdminBackendQuestionsIdBodyContent;
  /** Index of the correct answer */
  correct_answer?: number;
  /** Explanation for the correct answer */
  explanation: string;
};

export type PostV1AdminBackendQuestionsIdAssignUsersBody = {
  /**
   * Array of user IDs to assign to the question
   * @minItems 1
   */
  user_ids: number[];
};

export type PostV1AdminBackendQuestionsIdUnassignUsersBody = {
  /**
   * Array of user IDs to unassign from the question
   * @minItems 1
   */
  user_ids: number[];
};

export type PostV1AdminBackendQuestionsIdAiFixBody = {
  additional_context?: string;
};

export type GetV1AdminBackendReportedQuestionsParams = {
/**
 * Page number (1-based)
 * @minimum 1
 */
page?: number;
/**
 * Number of questions per page
 * @minimum 1
 * @maximum 100
 */
page_size?: number;
/**
 * Search term for question content
 */
search?: string;
/**
 * Filter by question type
 */
type?: QuestionType;
/**
 * Filter by language
 */
language?: Language;
/**
 * Filter by level
 */
level?: Level;
};

export type GetV1AdminBackendStoriesParams = {
/**
 * Page number (1-based)
 * @minimum 1
 */
page?: number;
/**
 * Number of stories per page
 * @minimum 1
 * @maximum 100
 */
page_size?: number;
/**
 * Search term for story title
 */
search?: string;
/**
 * Filter by language
 */
language?: Language;
/**
 * Filter by story status
 */
status?: StoryStatus;
/**
 * Filter by user ID (optional)
 * @minimum 1
 */
user_id?: number;
};

export type PostV1DailyQuestionsDateAnswerQuestionIdBody = {
  /**
   * Index of the user's selected answer (0-based)
   * @minimum 0
   * @maximum 3
   */
  user_answer_index: number;
};

export type GetV1WordOfDayEmbedParams = {
/**
 * Optional date in YYYY-MM-DD format. Defaults to today's date in the user's timezone when omitted.
 * @pattern ^\d{4}-\d{2}-\d{2}$
 */
date?: string;
};

export type GetV1WordOfDayHistoryParams = {
/**
 * Start date in YYYY-MM-DD format
 * @pattern ^\d{4}-\d{2}-\d{2}$
 */
start_date: string;
/**
 * End date in YYYY-MM-DD format
 * @pattern ^\d{4}-\d{2}-\d{2}$
 */
end_date: string;
};

export type GetV1StoryParams = {
/**
 * Include archived stories in the response
 */
include_archived?: boolean;
};

export type GetV1AdminBackendFeedbackParams = {
/**
 * Page number
 * @minimum 1
 */
page?: number;
/**
 * Number of items per page
 * @minimum 1
 * @maximum 100
 */
page_size?: number;
/**
 * Filter by status
 */
status?: GetV1AdminBackendFeedbackStatus;
/**
 * Filter by feedback type
 */
feedback_type?: string;
/**
 * Filter by user ID
 */
user_id?: number;
};

export type GetV1AdminBackendFeedbackStatus = typeof GetV1AdminBackendFeedbackStatus[keyof typeof GetV1AdminBackendFeedbackStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetV1AdminBackendFeedbackStatus = {
  new: 'new',
  in_progress: 'in_progress',
  resolved: 'resolved',
  dismissed: 'dismissed',
} as const;

export type DeleteV1AdminBackendFeedbackParams = {
/**
 * Status of feedback reports to delete
 */
status: DeleteV1AdminBackendFeedbackStatus;
};

export type DeleteV1AdminBackendFeedbackStatus = typeof DeleteV1AdminBackendFeedbackStatus[keyof typeof DeleteV1AdminBackendFeedbackStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const DeleteV1AdminBackendFeedbackStatus = {
  new: 'new',
  in_progress: 'in_progress',
  resolved: 'resolved',
  dismissed: 'dismissed',
} as const;

export type GetV1TranslationPracticeSentenceParams = {
/**
 * Learning language code
 */
language: string;
/**
 * Language level (e.g., A1, A2, B1, B2)
 */
level: string;
/**
 * Translation direction
 */
direction: GetV1TranslationPracticeSentenceDirection;
};

export type GetV1TranslationPracticeSentenceDirection = typeof GetV1TranslationPracticeSentenceDirection[keyof typeof GetV1TranslationPracticeSentenceDirection];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetV1TranslationPracticeSentenceDirection = {
  en_to_learning: 'en_to_learning',
  learning_to_en: 'learning_to_en',
} as const;

export type GetV1TranslationPracticeHistoryParams = {
/**
 * Maximum number of sessions to return
 * @minimum 1
 * @maximum 100
 */
limit?: number;
/**
 * Search query to filter sessions by original sentence, user translation, feedback, or direction
 * @maxLength 500
 */
search?: string;
/**
 * Number of sessions to skip for pagination
 * @minimum 0
 */
offset?: number;
};

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * Authenticate a user with username and password. Creates new user if doesn't exist.
 * @summary User login
 */
export const postV1AuthLogin = (
    loginRequest: LoginRequest,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<LoginResponse>(
      {url: `/v1/auth/login`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: loginRequest, signal
    },
      options);
    }
  


export const getPostV1AuthLoginMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AuthLogin>>, TError,{data: LoginRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postV1AuthLogin>>, TError,{data: LoginRequest}, TContext> => {

const mutationKey = ['postV1AuthLogin'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1AuthLogin>>, {data: LoginRequest}> = (props) => {
          const {data} = props ?? {};

          return  postV1AuthLogin(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1AuthLoginMutationResult = NonNullable<Awaited<ReturnType<typeof postV1AuthLogin>>>
    export type PostV1AuthLoginMutationBody = LoginRequest
    export type PostV1AuthLoginMutationError = ErrorResponse

    /**
 * @summary User login
 */
export const usePostV1AuthLogin = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AuthLogin>>, TError,{data: LoginRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postV1AuthLogin>>,
        TError,
        {data: LoginRequest},
        TContext
      > => {

      const mutationOptions = getPostV1AuthLoginMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Log out the current user and clear session.
 * @summary User logout
 */
export const postV1AuthLogout = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<SuccessResponse>(
      {url: `/v1/auth/logout`, method: 'POST', signal
    },
      options);
    }
  


export const getPostV1AuthLogoutMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AuthLogout>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postV1AuthLogout>>, TError,void, TContext> => {

const mutationKey = ['postV1AuthLogout'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1AuthLogout>>, void> = () => {
          

          return  postV1AuthLogout(requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1AuthLogoutMutationResult = NonNullable<Awaited<ReturnType<typeof postV1AuthLogout>>>
    
    export type PostV1AuthLogoutMutationError = unknown

    /**
 * @summary User logout
 */
export const usePostV1AuthLogout = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AuthLogout>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postV1AuthLogout>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getPostV1AuthLogoutMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Check if user is currently authenticated.
 * @summary Get authentication status
 */
export const getV1AuthStatus = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<AuthStatusResponse>(
      {url: `/v1/auth/status`, method: 'GET', signal
    },
      options);
    }
  



export const getGetV1AuthStatusQueryKey = () => {
    return [
    `/v1/auth/status`
    ] as const;
    }

    
export const getGetV1AuthStatusQueryOptions = <TData = Awaited<ReturnType<typeof getV1AuthStatus>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AuthStatus>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AuthStatusQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AuthStatus>>> = ({ signal }) => getV1AuthStatus(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AuthStatus>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AuthStatusQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AuthStatus>>>
export type GetV1AuthStatusQueryError = unknown


export function useGetV1AuthStatus<TData = Awaited<ReturnType<typeof getV1AuthStatus>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AuthStatus>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AuthStatus>>,
          TError,
          Awaited<ReturnType<typeof getV1AuthStatus>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AuthStatus<TData = Awaited<ReturnType<typeof getV1AuthStatus>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AuthStatus>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AuthStatus>>,
          TError,
          Awaited<ReturnType<typeof getV1AuthStatus>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AuthStatus<TData = Awaited<ReturnType<typeof getV1AuthStatus>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AuthStatus>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get authentication status
 */

export function useGetV1AuthStatus<TData = Awaited<ReturnType<typeof getV1AuthStatus>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AuthStatus>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AuthStatusQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Returns 204 when the user is authenticated; returns 401 when unauthenticated. Intended for reverse proxy auth_request.
 * @summary Authentication check
 */
export const getV1AuthCheck = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/v1/auth/check`, method: 'GET', signal
    },
      options);
    }
  



export const getGetV1AuthCheckQueryKey = () => {
    return [
    `/v1/auth/check`
    ] as const;
    }

    
export const getGetV1AuthCheckQueryOptions = <TData = Awaited<ReturnType<typeof getV1AuthCheck>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AuthCheck>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AuthCheckQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AuthCheck>>> = ({ signal }) => getV1AuthCheck(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AuthCheck>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AuthCheckQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AuthCheck>>>
export type GetV1AuthCheckQueryError = ErrorResponse


export function useGetV1AuthCheck<TData = Awaited<ReturnType<typeof getV1AuthCheck>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AuthCheck>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AuthCheck>>,
          TError,
          Awaited<ReturnType<typeof getV1AuthCheck>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AuthCheck<TData = Awaited<ReturnType<typeof getV1AuthCheck>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AuthCheck>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AuthCheck>>,
          TError,
          Awaited<ReturnType<typeof getV1AuthCheck>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AuthCheck<TData = Awaited<ReturnType<typeof getV1AuthCheck>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AuthCheck>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Authentication check
 */

export function useGetV1AuthCheck<TData = Awaited<ReturnType<typeof getV1AuthCheck>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AuthCheck>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AuthCheckQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Create a new user account with username, email, and password
 * @summary User signup
 */
export const postV1AuthSignup = (
    userCreateRequest: UserCreateRequest,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<SuccessResponse>(
      {url: `/v1/auth/signup`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: userCreateRequest, signal
    },
      options);
    }
  


export const getPostV1AuthSignupMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AuthSignup>>, TError,{data: UserCreateRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postV1AuthSignup>>, TError,{data: UserCreateRequest}, TContext> => {

const mutationKey = ['postV1AuthSignup'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1AuthSignup>>, {data: UserCreateRequest}> = (props) => {
          const {data} = props ?? {};

          return  postV1AuthSignup(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1AuthSignupMutationResult = NonNullable<Awaited<ReturnType<typeof postV1AuthSignup>>>
    export type PostV1AuthSignupMutationBody = UserCreateRequest
    export type PostV1AuthSignupMutationError = ErrorResponse

    /**
 * @summary User signup
 */
export const usePostV1AuthSignup = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AuthSignup>>, TError,{data: UserCreateRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postV1AuthSignup>>,
        TError,
        {data: UserCreateRequest},
        TContext
      > => {

      const mutationOptions = getPostV1AuthSignupMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Check whether user signups are enabled or disabled
 * @summary Get signup status
 */
export const getV1AuthSignupStatus = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<SignupStatusResponse>(
      {url: `/v1/auth/signup/status`, method: 'GET', signal
    },
      options);
    }
  



export const getGetV1AuthSignupStatusQueryKey = () => {
    return [
    `/v1/auth/signup/status`
    ] as const;
    }

    
export const getGetV1AuthSignupStatusQueryOptions = <TData = Awaited<ReturnType<typeof getV1AuthSignupStatus>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AuthSignupStatus>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AuthSignupStatusQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AuthSignupStatus>>> = ({ signal }) => getV1AuthSignupStatus(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AuthSignupStatus>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AuthSignupStatusQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AuthSignupStatus>>>
export type GetV1AuthSignupStatusQueryError = unknown


export function useGetV1AuthSignupStatus<TData = Awaited<ReturnType<typeof getV1AuthSignupStatus>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AuthSignupStatus>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AuthSignupStatus>>,
          TError,
          Awaited<ReturnType<typeof getV1AuthSignupStatus>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AuthSignupStatus<TData = Awaited<ReturnType<typeof getV1AuthSignupStatus>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AuthSignupStatus>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AuthSignupStatus>>,
          TError,
          Awaited<ReturnType<typeof getV1AuthSignupStatus>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AuthSignupStatus<TData = Awaited<ReturnType<typeof getV1AuthSignupStatus>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AuthSignupStatus>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get signup status
 */

export function useGetV1AuthSignupStatus<TData = Awaited<ReturnType<typeof getV1AuthSignupStatus>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AuthSignupStatus>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AuthSignupStatusQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Redirects user to Google OAuth for authentication
 * @summary Initiate Google OAuth login
 */
export const getV1AuthGoogleLogin = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GoogleOAuthLoginResponse>(
      {url: `/v1/auth/google/login`, method: 'GET', signal
    },
      options);
    }
  



export const getGetV1AuthGoogleLoginQueryKey = () => {
    return [
    `/v1/auth/google/login`
    ] as const;
    }

    
export const getGetV1AuthGoogleLoginQueryOptions = <TData = Awaited<ReturnType<typeof getV1AuthGoogleLogin>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AuthGoogleLogin>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AuthGoogleLoginQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AuthGoogleLogin>>> = ({ signal }) => getV1AuthGoogleLogin(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AuthGoogleLogin>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AuthGoogleLoginQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AuthGoogleLogin>>>
export type GetV1AuthGoogleLoginQueryError = unknown


export function useGetV1AuthGoogleLogin<TData = Awaited<ReturnType<typeof getV1AuthGoogleLogin>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AuthGoogleLogin>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AuthGoogleLogin>>,
          TError,
          Awaited<ReturnType<typeof getV1AuthGoogleLogin>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AuthGoogleLogin<TData = Awaited<ReturnType<typeof getV1AuthGoogleLogin>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AuthGoogleLogin>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AuthGoogleLogin>>,
          TError,
          Awaited<ReturnType<typeof getV1AuthGoogleLogin>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AuthGoogleLogin<TData = Awaited<ReturnType<typeof getV1AuthGoogleLogin>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AuthGoogleLogin>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Initiate Google OAuth login
 */

export function useGetV1AuthGoogleLogin<TData = Awaited<ReturnType<typeof getV1AuthGoogleLogin>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AuthGoogleLogin>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AuthGoogleLoginQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Handle the callback from Google OAuth after successful authentication
 * @summary Google OAuth callback
 */
export const getV1AuthGoogleCallback = (
    params: GetV1AuthGoogleCallbackParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<LoginResponse>(
      {url: `/v1/auth/google/callback`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getGetV1AuthGoogleCallbackQueryKey = (params?: GetV1AuthGoogleCallbackParams,) => {
    return [
    `/v1/auth/google/callback`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetV1AuthGoogleCallbackQueryOptions = <TData = Awaited<ReturnType<typeof getV1AuthGoogleCallback>>, TError = ErrorResponse>(params: GetV1AuthGoogleCallbackParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AuthGoogleCallback>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AuthGoogleCallbackQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AuthGoogleCallback>>> = ({ signal }) => getV1AuthGoogleCallback(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AuthGoogleCallback>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AuthGoogleCallbackQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AuthGoogleCallback>>>
export type GetV1AuthGoogleCallbackQueryError = ErrorResponse


export function useGetV1AuthGoogleCallback<TData = Awaited<ReturnType<typeof getV1AuthGoogleCallback>>, TError = ErrorResponse>(
 params: GetV1AuthGoogleCallbackParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AuthGoogleCallback>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AuthGoogleCallback>>,
          TError,
          Awaited<ReturnType<typeof getV1AuthGoogleCallback>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AuthGoogleCallback<TData = Awaited<ReturnType<typeof getV1AuthGoogleCallback>>, TError = ErrorResponse>(
 params: GetV1AuthGoogleCallbackParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AuthGoogleCallback>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AuthGoogleCallback>>,
          TError,
          Awaited<ReturnType<typeof getV1AuthGoogleCallback>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AuthGoogleCallback<TData = Awaited<ReturnType<typeof getV1AuthGoogleCallback>>, TError = ErrorResponse>(
 params: GetV1AuthGoogleCallbackParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AuthGoogleCallback>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Google OAuth callback
 */

export function useGetV1AuthGoogleCallback<TData = Awaited<ReturnType<typeof getV1AuthGoogleCallback>>, TError = ErrorResponse>(
 params: GetV1AuthGoogleCallbackParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AuthGoogleCallback>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AuthGoogleCallbackQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Get the next question for the authenticated user. If a specific `type` is requested and no eligible questions are currently available, the server returns 202 with a generating status and prioritizes generation of that type for the user.
 * @summary Get next question
 */
export const getV1QuizQuestion = (
    params?: GetV1QuizQuestionParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<Question | GeneratingResponse>(
      {url: `/v1/quiz/question`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getGetV1QuizQuestionQueryKey = (params?: GetV1QuizQuestionParams,) => {
    return [
    `/v1/quiz/question`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetV1QuizQuestionQueryOptions = <TData = Awaited<ReturnType<typeof getV1QuizQuestion>>, TError = ErrorResponse>(params?: GetV1QuizQuestionParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1QuizQuestion>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1QuizQuestionQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1QuizQuestion>>> = ({ signal }) => getV1QuizQuestion(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1QuizQuestion>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1QuizQuestionQueryResult = NonNullable<Awaited<ReturnType<typeof getV1QuizQuestion>>>
export type GetV1QuizQuestionQueryError = ErrorResponse


export function useGetV1QuizQuestion<TData = Awaited<ReturnType<typeof getV1QuizQuestion>>, TError = ErrorResponse>(
 params: undefined |  GetV1QuizQuestionParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1QuizQuestion>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1QuizQuestion>>,
          TError,
          Awaited<ReturnType<typeof getV1QuizQuestion>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1QuizQuestion<TData = Awaited<ReturnType<typeof getV1QuizQuestion>>, TError = ErrorResponse>(
 params?: GetV1QuizQuestionParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1QuizQuestion>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1QuizQuestion>>,
          TError,
          Awaited<ReturnType<typeof getV1QuizQuestion>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1QuizQuestion<TData = Awaited<ReturnType<typeof getV1QuizQuestion>>, TError = ErrorResponse>(
 params?: GetV1QuizQuestionParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1QuizQuestion>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get next question
 */

export function useGetV1QuizQuestion<TData = Awaited<ReturnType<typeof getV1QuizQuestion>>, TError = ErrorResponse>(
 params?: GetV1QuizQuestionParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1QuizQuestion>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1QuizQuestionQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Retrieve a specific question by its ID
 * @summary Get specific question by ID
 */
export const getV1QuizQuestionId = (
    id: number,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<Question>(
      {url: `/v1/quiz/question/${id}`, method: 'GET', signal
    },
      options);
    }
  



export const getGetV1QuizQuestionIdQueryKey = (id?: number,) => {
    return [
    `/v1/quiz/question/${id}`
    ] as const;
    }

    
export const getGetV1QuizQuestionIdQueryOptions = <TData = Awaited<ReturnType<typeof getV1QuizQuestionId>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1QuizQuestionId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1QuizQuestionIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1QuizQuestionId>>> = ({ signal }) => getV1QuizQuestionId(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1QuizQuestionId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1QuizQuestionIdQueryResult = NonNullable<Awaited<ReturnType<typeof getV1QuizQuestionId>>>
export type GetV1QuizQuestionIdQueryError = ErrorResponse


export function useGetV1QuizQuestionId<TData = Awaited<ReturnType<typeof getV1QuizQuestionId>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1QuizQuestionId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1QuizQuestionId>>,
          TError,
          Awaited<ReturnType<typeof getV1QuizQuestionId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1QuizQuestionId<TData = Awaited<ReturnType<typeof getV1QuizQuestionId>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1QuizQuestionId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1QuizQuestionId>>,
          TError,
          Awaited<ReturnType<typeof getV1QuizQuestionId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1QuizQuestionId<TData = Awaited<ReturnType<typeof getV1QuizQuestionId>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1QuizQuestionId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get specific question by ID
 */

export function useGetV1QuizQuestionId<TData = Awaited<ReturnType<typeof getV1QuizQuestionId>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1QuizQuestionId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1QuizQuestionIdQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Submit an answer for a question and get feedback
 * @summary Submit answer
 */
export const postV1QuizAnswer = (
    answerRequest: AnswerRequest,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<AnswerResponse>(
      {url: `/v1/quiz/answer`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: answerRequest, signal
    },
      options);
    }
  


export const getPostV1QuizAnswerMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1QuizAnswer>>, TError,{data: AnswerRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postV1QuizAnswer>>, TError,{data: AnswerRequest}, TContext> => {

const mutationKey = ['postV1QuizAnswer'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1QuizAnswer>>, {data: AnswerRequest}> = (props) => {
          const {data} = props ?? {};

          return  postV1QuizAnswer(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1QuizAnswerMutationResult = NonNullable<Awaited<ReturnType<typeof postV1QuizAnswer>>>
    export type PostV1QuizAnswerMutationBody = AnswerRequest
    export type PostV1QuizAnswerMutationError = ErrorResponse

    /**
 * @summary Submit answer
 */
export const usePostV1QuizAnswer = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1QuizAnswer>>, TError,{data: AnswerRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postV1QuizAnswer>>,
        TError,
        {data: AnswerRequest},
        TContext
      > => {

      const mutationOptions = getPostV1QuizAnswerMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Get detailed progress information for the authenticated user
 * @summary Get user progress
 */
export const getV1QuizProgress = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<UserProgress>(
      {url: `/v1/quiz/progress`, method: 'GET', signal
    },
      options);
    }
  



export const getGetV1QuizProgressQueryKey = () => {
    return [
    `/v1/quiz/progress`
    ] as const;
    }

    
export const getGetV1QuizProgressQueryOptions = <TData = Awaited<ReturnType<typeof getV1QuizProgress>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1QuizProgress>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1QuizProgressQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1QuizProgress>>> = ({ signal }) => getV1QuizProgress(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1QuizProgress>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1QuizProgressQueryResult = NonNullable<Awaited<ReturnType<typeof getV1QuizProgress>>>
export type GetV1QuizProgressQueryError = ErrorResponse


export function useGetV1QuizProgress<TData = Awaited<ReturnType<typeof getV1QuizProgress>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1QuizProgress>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1QuizProgress>>,
          TError,
          Awaited<ReturnType<typeof getV1QuizProgress>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1QuizProgress<TData = Awaited<ReturnType<typeof getV1QuizProgress>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1QuizProgress>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1QuizProgress>>,
          TError,
          Awaited<ReturnType<typeof getV1QuizProgress>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1QuizProgress<TData = Awaited<ReturnType<typeof getV1QuizProgress>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1QuizProgress>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get user progress
 */

export function useGetV1QuizProgress<TData = Awaited<ReturnType<typeof getV1QuizProgress>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1QuizProgress>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1QuizProgressQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Get AI token usage statistics for the authenticated user
 * @summary Get user AI token usage
 */
export const getV1QuizAiTokenUsage = (
    params: GetV1QuizAiTokenUsageParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<UserUsageStats[]>(
      {url: `/v1/quiz/ai-token-usage`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getGetV1QuizAiTokenUsageQueryKey = (params?: GetV1QuizAiTokenUsageParams,) => {
    return [
    `/v1/quiz/ai-token-usage`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetV1QuizAiTokenUsageQueryOptions = <TData = Awaited<ReturnType<typeof getV1QuizAiTokenUsage>>, TError = ErrorResponse>(params: GetV1QuizAiTokenUsageParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1QuizAiTokenUsage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1QuizAiTokenUsageQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1QuizAiTokenUsage>>> = ({ signal }) => getV1QuizAiTokenUsage(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1QuizAiTokenUsage>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1QuizAiTokenUsageQueryResult = NonNullable<Awaited<ReturnType<typeof getV1QuizAiTokenUsage>>>
export type GetV1QuizAiTokenUsageQueryError = ErrorResponse


export function useGetV1QuizAiTokenUsage<TData = Awaited<ReturnType<typeof getV1QuizAiTokenUsage>>, TError = ErrorResponse>(
 params: GetV1QuizAiTokenUsageParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1QuizAiTokenUsage>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1QuizAiTokenUsage>>,
          TError,
          Awaited<ReturnType<typeof getV1QuizAiTokenUsage>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1QuizAiTokenUsage<TData = Awaited<ReturnType<typeof getV1QuizAiTokenUsage>>, TError = ErrorResponse>(
 params: GetV1QuizAiTokenUsageParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1QuizAiTokenUsage>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1QuizAiTokenUsage>>,
          TError,
          Awaited<ReturnType<typeof getV1QuizAiTokenUsage>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1QuizAiTokenUsage<TData = Awaited<ReturnType<typeof getV1QuizAiTokenUsage>>, TError = ErrorResponse>(
 params: GetV1QuizAiTokenUsageParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1QuizAiTokenUsage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get user AI token usage
 */

export function useGetV1QuizAiTokenUsage<TData = Awaited<ReturnType<typeof getV1QuizAiTokenUsage>>, TError = ErrorResponse>(
 params: GetV1QuizAiTokenUsageParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1QuizAiTokenUsage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1QuizAiTokenUsageQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Get daily aggregated AI token usage statistics for the authenticated user
 * @summary Get user daily AI token usage
 */
export const getV1QuizAiTokenUsageDaily = (
    params: GetV1QuizAiTokenUsageDailyParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<UserUsageStatsDaily[]>(
      {url: `/v1/quiz/ai-token-usage/daily`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getGetV1QuizAiTokenUsageDailyQueryKey = (params?: GetV1QuizAiTokenUsageDailyParams,) => {
    return [
    `/v1/quiz/ai-token-usage/daily`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetV1QuizAiTokenUsageDailyQueryOptions = <TData = Awaited<ReturnType<typeof getV1QuizAiTokenUsageDaily>>, TError = ErrorResponse>(params: GetV1QuizAiTokenUsageDailyParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1QuizAiTokenUsageDaily>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1QuizAiTokenUsageDailyQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1QuizAiTokenUsageDaily>>> = ({ signal }) => getV1QuizAiTokenUsageDaily(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1QuizAiTokenUsageDaily>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1QuizAiTokenUsageDailyQueryResult = NonNullable<Awaited<ReturnType<typeof getV1QuizAiTokenUsageDaily>>>
export type GetV1QuizAiTokenUsageDailyQueryError = ErrorResponse


export function useGetV1QuizAiTokenUsageDaily<TData = Awaited<ReturnType<typeof getV1QuizAiTokenUsageDaily>>, TError = ErrorResponse>(
 params: GetV1QuizAiTokenUsageDailyParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1QuizAiTokenUsageDaily>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1QuizAiTokenUsageDaily>>,
          TError,
          Awaited<ReturnType<typeof getV1QuizAiTokenUsageDaily>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1QuizAiTokenUsageDaily<TData = Awaited<ReturnType<typeof getV1QuizAiTokenUsageDaily>>, TError = ErrorResponse>(
 params: GetV1QuizAiTokenUsageDailyParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1QuizAiTokenUsageDaily>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1QuizAiTokenUsageDaily>>,
          TError,
          Awaited<ReturnType<typeof getV1QuizAiTokenUsageDaily>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1QuizAiTokenUsageDaily<TData = Awaited<ReturnType<typeof getV1QuizAiTokenUsageDaily>>, TError = ErrorResponse>(
 params: GetV1QuizAiTokenUsageDailyParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1QuizAiTokenUsageDaily>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get user daily AI token usage
 */

export function useGetV1QuizAiTokenUsageDaily<TData = Awaited<ReturnType<typeof getV1QuizAiTokenUsageDaily>>, TError = ErrorResponse>(
 params: GetV1QuizAiTokenUsageDailyParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1QuizAiTokenUsageDaily>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1QuizAiTokenUsageDailyQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Get hourly aggregated AI token usage statistics for the authenticated user on a specific day
 * @summary Get user hourly AI token usage
 */
export const getV1QuizAiTokenUsageHourly = (
    params: GetV1QuizAiTokenUsageHourlyParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<UserUsageStatsHourly[]>(
      {url: `/v1/quiz/ai-token-usage/hourly`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getGetV1QuizAiTokenUsageHourlyQueryKey = (params?: GetV1QuizAiTokenUsageHourlyParams,) => {
    return [
    `/v1/quiz/ai-token-usage/hourly`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetV1QuizAiTokenUsageHourlyQueryOptions = <TData = Awaited<ReturnType<typeof getV1QuizAiTokenUsageHourly>>, TError = ErrorResponse>(params: GetV1QuizAiTokenUsageHourlyParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1QuizAiTokenUsageHourly>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1QuizAiTokenUsageHourlyQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1QuizAiTokenUsageHourly>>> = ({ signal }) => getV1QuizAiTokenUsageHourly(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1QuizAiTokenUsageHourly>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1QuizAiTokenUsageHourlyQueryResult = NonNullable<Awaited<ReturnType<typeof getV1QuizAiTokenUsageHourly>>>
export type GetV1QuizAiTokenUsageHourlyQueryError = ErrorResponse


export function useGetV1QuizAiTokenUsageHourly<TData = Awaited<ReturnType<typeof getV1QuizAiTokenUsageHourly>>, TError = ErrorResponse>(
 params: GetV1QuizAiTokenUsageHourlyParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1QuizAiTokenUsageHourly>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1QuizAiTokenUsageHourly>>,
          TError,
          Awaited<ReturnType<typeof getV1QuizAiTokenUsageHourly>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1QuizAiTokenUsageHourly<TData = Awaited<ReturnType<typeof getV1QuizAiTokenUsageHourly>>, TError = ErrorResponse>(
 params: GetV1QuizAiTokenUsageHourlyParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1QuizAiTokenUsageHourly>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1QuizAiTokenUsageHourly>>,
          TError,
          Awaited<ReturnType<typeof getV1QuizAiTokenUsageHourly>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1QuizAiTokenUsageHourly<TData = Awaited<ReturnType<typeof getV1QuizAiTokenUsageHourly>>, TError = ErrorResponse>(
 params: GetV1QuizAiTokenUsageHourlyParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1QuizAiTokenUsageHourly>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get user hourly AI token usage
 */

export function useGetV1QuizAiTokenUsageHourly<TData = Awaited<ReturnType<typeof getV1QuizAiTokenUsageHourly>>, TError = ErrorResponse>(
 params: GetV1QuizAiTokenUsageHourlyParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1QuizAiTokenUsageHourly>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1QuizAiTokenUsageHourlyQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Report a question as incorrect or problematic with optional explanation
 * @summary Report question
 */
export const postV1QuizQuestionIdReport = (
    id: number,
    reportQuestionRequest?: ReportQuestionRequest,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<SuccessResponse>(
      {url: `/v1/quiz/question/${id}/report`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: reportQuestionRequest, signal
    },
      options);
    }
  


export const getPostV1QuizQuestionIdReportMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1QuizQuestionIdReport>>, TError,{id: number;data: ReportQuestionRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postV1QuizQuestionIdReport>>, TError,{id: number;data: ReportQuestionRequest}, TContext> => {

const mutationKey = ['postV1QuizQuestionIdReport'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1QuizQuestionIdReport>>, {id: number;data: ReportQuestionRequest}> = (props) => {
          const {id,data} = props ?? {};

          return  postV1QuizQuestionIdReport(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1QuizQuestionIdReportMutationResult = NonNullable<Awaited<ReturnType<typeof postV1QuizQuestionIdReport>>>
    export type PostV1QuizQuestionIdReportMutationBody = ReportQuestionRequest
    export type PostV1QuizQuestionIdReportMutationError = ErrorResponse

    /**
 * @summary Report question
 */
export const usePostV1QuizQuestionIdReport = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1QuizQuestionIdReport>>, TError,{id: number;data: ReportQuestionRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postV1QuizQuestionIdReport>>,
        TError,
        {id: number;data: ReportQuestionRequest},
        TContext
      > => {

      const mutationOptions = getPostV1QuizQuestionIdReportMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Mark a question as known by the user, which affects priority scoring
 * @summary Mark question as known
 */
export const postV1QuizQuestionIdMarkKnown = (
    id: number,
    markQuestionKnownRequest?: MarkQuestionKnownRequest,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<SuccessResponse>(
      {url: `/v1/quiz/question/${id}/mark-known`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: markQuestionKnownRequest, signal
    },
      options);
    }
  


export const getPostV1QuizQuestionIdMarkKnownMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1QuizQuestionIdMarkKnown>>, TError,{id: number;data: MarkQuestionKnownRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postV1QuizQuestionIdMarkKnown>>, TError,{id: number;data: MarkQuestionKnownRequest}, TContext> => {

const mutationKey = ['postV1QuizQuestionIdMarkKnown'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1QuizQuestionIdMarkKnown>>, {id: number;data: MarkQuestionKnownRequest}> = (props) => {
          const {id,data} = props ?? {};

          return  postV1QuizQuestionIdMarkKnown(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1QuizQuestionIdMarkKnownMutationResult = NonNullable<Awaited<ReturnType<typeof postV1QuizQuestionIdMarkKnown>>>
    export type PostV1QuizQuestionIdMarkKnownMutationBody = MarkQuestionKnownRequest
    export type PostV1QuizQuestionIdMarkKnownMutationError = ErrorResponse

    /**
 * @summary Mark question as known
 */
export const usePostV1QuizQuestionIdMarkKnown = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1QuizQuestionIdMarkKnown>>, TError,{id: number;data: MarkQuestionKnownRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postV1QuizQuestionIdMarkKnown>>,
        TError,
        {id: number;data: MarkQuestionKnownRequest},
        TContext
      > => {

      const mutationOptions = getPostV1QuizQuestionIdMarkKnownMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Get the current status of the question generation worker
 * @summary Get worker status
 */
export const getV1QuizWorkerStatus = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<WorkerStatusResponse>(
      {url: `/v1/quiz/worker-status`, method: 'GET', signal
    },
      options);
    }
  



export const getGetV1QuizWorkerStatusQueryKey = () => {
    return [
    `/v1/quiz/worker-status`
    ] as const;
    }

    
export const getGetV1QuizWorkerStatusQueryOptions = <TData = Awaited<ReturnType<typeof getV1QuizWorkerStatus>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1QuizWorkerStatus>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1QuizWorkerStatusQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1QuizWorkerStatus>>> = ({ signal }) => getV1QuizWorkerStatus(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1QuizWorkerStatus>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1QuizWorkerStatusQueryResult = NonNullable<Awaited<ReturnType<typeof getV1QuizWorkerStatus>>>
export type GetV1QuizWorkerStatusQueryError = ErrorResponse


export function useGetV1QuizWorkerStatus<TData = Awaited<ReturnType<typeof getV1QuizWorkerStatus>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1QuizWorkerStatus>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1QuizWorkerStatus>>,
          TError,
          Awaited<ReturnType<typeof getV1QuizWorkerStatus>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1QuizWorkerStatus<TData = Awaited<ReturnType<typeof getV1QuizWorkerStatus>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1QuizWorkerStatus>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1QuizWorkerStatus>>,
          TError,
          Awaited<ReturnType<typeof getV1QuizWorkerStatus>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1QuizWorkerStatus<TData = Awaited<ReturnType<typeof getV1QuizWorkerStatus>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1QuizWorkerStatus>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get worker status
 */

export function useGetV1QuizWorkerStatus<TData = Awaited<ReturnType<typeof getV1QuizWorkerStatus>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1QuizWorkerStatus>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1QuizWorkerStatusQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Update various settings for the authenticated user
 * @summary Update user settings
 */
export const putV1Settings = (
    userSettings: UserSettings,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<SuccessResponse>(
      {url: `/v1/settings`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: userSettings
    },
      options);
    }
  


export const getPutV1SettingsMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putV1Settings>>, TError,{data: UserSettings}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof putV1Settings>>, TError,{data: UserSettings}, TContext> => {

const mutationKey = ['putV1Settings'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putV1Settings>>, {data: UserSettings}> = (props) => {
          const {data} = props ?? {};

          return  putV1Settings(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PutV1SettingsMutationResult = NonNullable<Awaited<ReturnType<typeof putV1Settings>>>
    export type PutV1SettingsMutationBody = UserSettings
    export type PutV1SettingsMutationError = ErrorResponse

    /**
 * @summary Update user settings
 */
export const usePutV1Settings = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putV1Settings>>, TError,{data: UserSettings}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof putV1Settings>>,
        TError,
        {data: UserSettings},
        TContext
      > => {

      const mutationOptions = getPutV1SettingsMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Retrieve the list of configured AI providers and their models
 * @summary Get available AI providers
 */
export const getV1SettingsAiProviders = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<AIProviders>(
      {url: `/v1/settings/ai-providers`, method: 'GET', signal
    },
      options);
    }
  



export const getGetV1SettingsAiProvidersQueryKey = () => {
    return [
    `/v1/settings/ai-providers`
    ] as const;
    }

    
export const getGetV1SettingsAiProvidersQueryOptions = <TData = Awaited<ReturnType<typeof getV1SettingsAiProviders>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1SettingsAiProviders>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1SettingsAiProvidersQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1SettingsAiProviders>>> = ({ signal }) => getV1SettingsAiProviders(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1SettingsAiProviders>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1SettingsAiProvidersQueryResult = NonNullable<Awaited<ReturnType<typeof getV1SettingsAiProviders>>>
export type GetV1SettingsAiProvidersQueryError = unknown


export function useGetV1SettingsAiProviders<TData = Awaited<ReturnType<typeof getV1SettingsAiProviders>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1SettingsAiProviders>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1SettingsAiProviders>>,
          TError,
          Awaited<ReturnType<typeof getV1SettingsAiProviders>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1SettingsAiProviders<TData = Awaited<ReturnType<typeof getV1SettingsAiProviders>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1SettingsAiProviders>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1SettingsAiProviders>>,
          TError,
          Awaited<ReturnType<typeof getV1SettingsAiProviders>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1SettingsAiProviders<TData = Awaited<ReturnType<typeof getV1SettingsAiProviders>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1SettingsAiProviders>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get available AI providers
 */

export function useGetV1SettingsAiProviders<TData = Awaited<ReturnType<typeof getV1SettingsAiProviders>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1SettingsAiProviders>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1SettingsAiProvidersQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Test the connection to the selected AI provider with given credentials
 * @summary Test AI connection
 */
export const postV1SettingsTestAi = (
    testAIRequest: TestAIRequest,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<SuccessResponse>(
      {url: `/v1/settings/test-ai`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: testAIRequest, signal
    },
      options);
    }
  


export const getPostV1SettingsTestAiMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1SettingsTestAi>>, TError,{data: TestAIRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postV1SettingsTestAi>>, TError,{data: TestAIRequest}, TContext> => {

const mutationKey = ['postV1SettingsTestAi'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1SettingsTestAi>>, {data: TestAIRequest}> = (props) => {
          const {data} = props ?? {};

          return  postV1SettingsTestAi(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1SettingsTestAiMutationResult = NonNullable<Awaited<ReturnType<typeof postV1SettingsTestAi>>>
    export type PostV1SettingsTestAiMutationBody = TestAIRequest
    export type PostV1SettingsTestAiMutationError = ErrorResponse

    /**
 * @summary Test AI connection
 */
export const usePostV1SettingsTestAi = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1SettingsTestAi>>, TError,{data: TestAIRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postV1SettingsTestAi>>,
        TError,
        {data: TestAIRequest},
        TContext
      > => {

      const mutationOptions = getPostV1SettingsTestAiMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Send a test email to the current user to verify email configuration
 * @summary Send test email
 */
export const postV1SettingsTestEmail = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<SuccessResponse>(
      {url: `/v1/settings/test-email`, method: 'POST', signal
    },
      options);
    }
  


export const getPostV1SettingsTestEmailMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1SettingsTestEmail>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postV1SettingsTestEmail>>, TError,void, TContext> => {

const mutationKey = ['postV1SettingsTestEmail'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1SettingsTestEmail>>, void> = () => {
          

          return  postV1SettingsTestEmail(requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1SettingsTestEmailMutationResult = NonNullable<Awaited<ReturnType<typeof postV1SettingsTestEmail>>>
    
    export type PostV1SettingsTestEmailMutationError = ErrorResponse

    /**
 * @summary Send test email
 */
export const usePostV1SettingsTestEmail = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1SettingsTestEmail>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postV1SettingsTestEmail>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getPostV1SettingsTestEmailMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Enable or disable Word of the Day emails for the authenticated user
 * @summary Update Word of the Day email preference
 */
export const putV1SettingsWordOfDayEmail = (
    wordOfDayEmailPreferenceRequest: WordOfDayEmailPreferenceRequest,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<SuccessResponse>(
      {url: `/v1/settings/word-of-day-email`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: wordOfDayEmailPreferenceRequest
    },
      options);
    }
  


export const getPutV1SettingsWordOfDayEmailMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putV1SettingsWordOfDayEmail>>, TError,{data: WordOfDayEmailPreferenceRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof putV1SettingsWordOfDayEmail>>, TError,{data: WordOfDayEmailPreferenceRequest}, TContext> => {

const mutationKey = ['putV1SettingsWordOfDayEmail'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putV1SettingsWordOfDayEmail>>, {data: WordOfDayEmailPreferenceRequest}> = (props) => {
          const {data} = props ?? {};

          return  putV1SettingsWordOfDayEmail(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PutV1SettingsWordOfDayEmailMutationResult = NonNullable<Awaited<ReturnType<typeof putV1SettingsWordOfDayEmail>>>
    export type PutV1SettingsWordOfDayEmailMutationBody = WordOfDayEmailPreferenceRequest
    export type PutV1SettingsWordOfDayEmailMutationError = ErrorResponse

    /**
 * @summary Update Word of the Day email preference
 */
export const usePutV1SettingsWordOfDayEmail = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putV1SettingsWordOfDayEmail>>, TError,{data: WordOfDayEmailPreferenceRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof putV1SettingsWordOfDayEmail>>,
        TError,
        {data: WordOfDayEmailPreferenceRequest},
        TContext
      > => {

      const mutationOptions = getPutV1SettingsWordOfDayEmailMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Retrieve the list of available language proficiency levels and their short descriptions
 * @summary Get available levels
 */
export const getV1SettingsLevels = (
    params?: GetV1SettingsLevelsParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<LevelsResponse>(
      {url: `/v1/settings/levels`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getGetV1SettingsLevelsQueryKey = (params?: GetV1SettingsLevelsParams,) => {
    return [
    `/v1/settings/levels`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetV1SettingsLevelsQueryOptions = <TData = Awaited<ReturnType<typeof getV1SettingsLevels>>, TError = unknown>(params?: GetV1SettingsLevelsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1SettingsLevels>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1SettingsLevelsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1SettingsLevels>>> = ({ signal }) => getV1SettingsLevels(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1SettingsLevels>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1SettingsLevelsQueryResult = NonNullable<Awaited<ReturnType<typeof getV1SettingsLevels>>>
export type GetV1SettingsLevelsQueryError = unknown


export function useGetV1SettingsLevels<TData = Awaited<ReturnType<typeof getV1SettingsLevels>>, TError = unknown>(
 params: undefined |  GetV1SettingsLevelsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1SettingsLevels>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1SettingsLevels>>,
          TError,
          Awaited<ReturnType<typeof getV1SettingsLevels>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1SettingsLevels<TData = Awaited<ReturnType<typeof getV1SettingsLevels>>, TError = unknown>(
 params?: GetV1SettingsLevelsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1SettingsLevels>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1SettingsLevels>>,
          TError,
          Awaited<ReturnType<typeof getV1SettingsLevels>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1SettingsLevels<TData = Awaited<ReturnType<typeof getV1SettingsLevels>>, TError = unknown>(
 params?: GetV1SettingsLevelsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1SettingsLevels>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get available levels
 */

export function useGetV1SettingsLevels<TData = Awaited<ReturnType<typeof getV1SettingsLevels>>, TError = unknown>(
 params?: GetV1SettingsLevelsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1SettingsLevels>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1SettingsLevelsQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Retrieve the list of available learning languages
 * @summary Get available languages
 */
export const getV1SettingsLanguages = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<LanguagesResponse>(
      {url: `/v1/settings/languages`, method: 'GET', signal
    },
      options);
    }
  



export const getGetV1SettingsLanguagesQueryKey = () => {
    return [
    `/v1/settings/languages`
    ] as const;
    }

    
export const getGetV1SettingsLanguagesQueryOptions = <TData = Awaited<ReturnType<typeof getV1SettingsLanguages>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1SettingsLanguages>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1SettingsLanguagesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1SettingsLanguages>>> = ({ signal }) => getV1SettingsLanguages(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1SettingsLanguages>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1SettingsLanguagesQueryResult = NonNullable<Awaited<ReturnType<typeof getV1SettingsLanguages>>>
export type GetV1SettingsLanguagesQueryError = unknown


export function useGetV1SettingsLanguages<TData = Awaited<ReturnType<typeof getV1SettingsLanguages>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1SettingsLanguages>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1SettingsLanguages>>,
          TError,
          Awaited<ReturnType<typeof getV1SettingsLanguages>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1SettingsLanguages<TData = Awaited<ReturnType<typeof getV1SettingsLanguages>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1SettingsLanguages>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1SettingsLanguages>>,
          TError,
          Awaited<ReturnType<typeof getV1SettingsLanguages>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1SettingsLanguages<TData = Awaited<ReturnType<typeof getV1SettingsLanguages>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1SettingsLanguages>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get available languages
 */

export function useGetV1SettingsLanguages<TData = Awaited<ReturnType<typeof getV1SettingsLanguages>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1SettingsLanguages>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1SettingsLanguagesQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Check if the authenticated user has a saved API key for the specified provider
 * @summary Check if user has API key for provider
 */
export const getV1SettingsApiKeyProvider = (
    provider: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<APIKeyAvailabilityResponse>(
      {url: `/v1/settings/api-key/${provider}`, method: 'GET', signal
    },
      options);
    }
  



export const getGetV1SettingsApiKeyProviderQueryKey = (provider?: string,) => {
    return [
    `/v1/settings/api-key/${provider}`
    ] as const;
    }

    
export const getGetV1SettingsApiKeyProviderQueryOptions = <TData = Awaited<ReturnType<typeof getV1SettingsApiKeyProvider>>, TError = ErrorResponse>(provider: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1SettingsApiKeyProvider>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1SettingsApiKeyProviderQueryKey(provider);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1SettingsApiKeyProvider>>> = ({ signal }) => getV1SettingsApiKeyProvider(provider, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(provider), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1SettingsApiKeyProvider>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1SettingsApiKeyProviderQueryResult = NonNullable<Awaited<ReturnType<typeof getV1SettingsApiKeyProvider>>>
export type GetV1SettingsApiKeyProviderQueryError = ErrorResponse


export function useGetV1SettingsApiKeyProvider<TData = Awaited<ReturnType<typeof getV1SettingsApiKeyProvider>>, TError = ErrorResponse>(
 provider: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1SettingsApiKeyProvider>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1SettingsApiKeyProvider>>,
          TError,
          Awaited<ReturnType<typeof getV1SettingsApiKeyProvider>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1SettingsApiKeyProvider<TData = Awaited<ReturnType<typeof getV1SettingsApiKeyProvider>>, TError = ErrorResponse>(
 provider: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1SettingsApiKeyProvider>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1SettingsApiKeyProvider>>,
          TError,
          Awaited<ReturnType<typeof getV1SettingsApiKeyProvider>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1SettingsApiKeyProvider<TData = Awaited<ReturnType<typeof getV1SettingsApiKeyProvider>>, TError = ErrorResponse>(
 provider: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1SettingsApiKeyProvider>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Check if user has API key for provider
 */

export function useGetV1SettingsApiKeyProvider<TData = Awaited<ReturnType<typeof getV1SettingsApiKeyProvider>>, TError = ErrorResponse>(
 provider: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1SettingsApiKeyProvider>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1SettingsApiKeyProviderQueryOptions(provider,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Create a new AI conversation for the authenticated user
 * @summary Create a new AI conversation
 */
export const postV1AiConversations = (
    createConversationRequest: CreateConversationRequest,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<Conversation>(
      {url: `/v1/ai/conversations`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createConversationRequest, signal
    },
      options);
    }
  


export const getPostV1AiConversationsMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AiConversations>>, TError,{data: CreateConversationRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postV1AiConversations>>, TError,{data: CreateConversationRequest}, TContext> => {

const mutationKey = ['postV1AiConversations'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1AiConversations>>, {data: CreateConversationRequest}> = (props) => {
          const {data} = props ?? {};

          return  postV1AiConversations(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1AiConversationsMutationResult = NonNullable<Awaited<ReturnType<typeof postV1AiConversations>>>
    export type PostV1AiConversationsMutationBody = CreateConversationRequest
    export type PostV1AiConversationsMutationError = ErrorResponse

    /**
 * @summary Create a new AI conversation
 */
export const usePostV1AiConversations = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AiConversations>>, TError,{data: CreateConversationRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postV1AiConversations>>,
        TError,
        {data: CreateConversationRequest},
        TContext
      > => {

      const mutationOptions = getPostV1AiConversationsMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Retrieve a list of all AI conversations for the authenticated user
 * @summary List user's AI conversations
 */
export const getV1AiConversations = (
    params?: GetV1AiConversationsParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<ConversationsListResponse>(
      {url: `/v1/ai/conversations`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getGetV1AiConversationsQueryKey = (params?: GetV1AiConversationsParams,) => {
    return [
    `/v1/ai/conversations`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetV1AiConversationsQueryOptions = <TData = Awaited<ReturnType<typeof getV1AiConversations>>, TError = ErrorResponse>(params?: GetV1AiConversationsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AiConversations>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AiConversationsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AiConversations>>> = ({ signal }) => getV1AiConversations(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AiConversations>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AiConversationsQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AiConversations>>>
export type GetV1AiConversationsQueryError = ErrorResponse


export function useGetV1AiConversations<TData = Awaited<ReturnType<typeof getV1AiConversations>>, TError = ErrorResponse>(
 params: undefined |  GetV1AiConversationsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AiConversations>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AiConversations>>,
          TError,
          Awaited<ReturnType<typeof getV1AiConversations>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AiConversations<TData = Awaited<ReturnType<typeof getV1AiConversations>>, TError = ErrorResponse>(
 params?: GetV1AiConversationsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AiConversations>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AiConversations>>,
          TError,
          Awaited<ReturnType<typeof getV1AiConversations>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AiConversations<TData = Awaited<ReturnType<typeof getV1AiConversations>>, TError = ErrorResponse>(
 params?: GetV1AiConversationsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AiConversations>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List user's AI conversations
 */

export function useGetV1AiConversations<TData = Awaited<ReturnType<typeof getV1AiConversations>>, TError = ErrorResponse>(
 params?: GetV1AiConversationsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AiConversations>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AiConversationsQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Retrieve a specific AI conversation and all its associated messages
 * @summary Get AI conversation with messages
 */
export const getV1AiConversationsId = (
    id: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<Conversation>(
      {url: `/v1/ai/conversations/${id}`, method: 'GET', signal
    },
      options);
    }
  



export const getGetV1AiConversationsIdQueryKey = (id?: string,) => {
    return [
    `/v1/ai/conversations/${id}`
    ] as const;
    }

    
export const getGetV1AiConversationsIdQueryOptions = <TData = Awaited<ReturnType<typeof getV1AiConversationsId>>, TError = ErrorResponse>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AiConversationsId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AiConversationsIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AiConversationsId>>> = ({ signal }) => getV1AiConversationsId(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AiConversationsId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AiConversationsIdQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AiConversationsId>>>
export type GetV1AiConversationsIdQueryError = ErrorResponse


export function useGetV1AiConversationsId<TData = Awaited<ReturnType<typeof getV1AiConversationsId>>, TError = ErrorResponse>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AiConversationsId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AiConversationsId>>,
          TError,
          Awaited<ReturnType<typeof getV1AiConversationsId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AiConversationsId<TData = Awaited<ReturnType<typeof getV1AiConversationsId>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AiConversationsId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AiConversationsId>>,
          TError,
          Awaited<ReturnType<typeof getV1AiConversationsId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AiConversationsId<TData = Awaited<ReturnType<typeof getV1AiConversationsId>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AiConversationsId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get AI conversation with messages
 */

export function useGetV1AiConversationsId<TData = Awaited<ReturnType<typeof getV1AiConversationsId>>, TError = ErrorResponse>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AiConversationsId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AiConversationsIdQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Update an AI conversation (e.g., change its title)
 * @summary Update AI conversation
 */
export const putV1AiConversationsId = (
    id: string,
    updateConversationRequest: UpdateConversationRequest,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<Conversation>(
      {url: `/v1/ai/conversations/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: updateConversationRequest
    },
      options);
    }
  


export const getPutV1AiConversationsIdMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putV1AiConversationsId>>, TError,{id: string;data: UpdateConversationRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof putV1AiConversationsId>>, TError,{id: string;data: UpdateConversationRequest}, TContext> => {

const mutationKey = ['putV1AiConversationsId'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putV1AiConversationsId>>, {id: string;data: UpdateConversationRequest}> = (props) => {
          const {id,data} = props ?? {};

          return  putV1AiConversationsId(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PutV1AiConversationsIdMutationResult = NonNullable<Awaited<ReturnType<typeof putV1AiConversationsId>>>
    export type PutV1AiConversationsIdMutationBody = UpdateConversationRequest
    export type PutV1AiConversationsIdMutationError = ErrorResponse

    /**
 * @summary Update AI conversation
 */
export const usePutV1AiConversationsId = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putV1AiConversationsId>>, TError,{id: string;data: UpdateConversationRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof putV1AiConversationsId>>,
        TError,
        {id: string;data: UpdateConversationRequest},
        TContext
      > => {

      const mutationOptions = getPutV1AiConversationsIdMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Delete an AI conversation and all its associated messages
 * @summary Delete AI conversation
 */
export const deleteV1AiConversationsId = (
    id: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/v1/ai/conversations/${id}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteV1AiConversationsIdMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteV1AiConversationsId>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteV1AiConversationsId>>, TError,{id: string}, TContext> => {

const mutationKey = ['deleteV1AiConversationsId'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteV1AiConversationsId>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  deleteV1AiConversationsId(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteV1AiConversationsIdMutationResult = NonNullable<Awaited<ReturnType<typeof deleteV1AiConversationsId>>>
    
    export type DeleteV1AiConversationsIdMutationError = ErrorResponse

    /**
 * @summary Delete AI conversation
 */
export const useDeleteV1AiConversationsId = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteV1AiConversationsId>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteV1AiConversationsId>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getDeleteV1AiConversationsIdMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Add a new AI chat message to an existing conversation
 * @summary Add message to conversation
 */
export const postV1AiConversationsConversationIdMessages = (
    conversationId: string,
    createMessageRequest: CreateMessageRequest,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<ChatMessage>(
      {url: `/v1/ai/conversations/${conversationId}/messages`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createMessageRequest, signal
    },
      options);
    }
  


export const getPostV1AiConversationsConversationIdMessagesMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AiConversationsConversationIdMessages>>, TError,{conversationId: string;data: CreateMessageRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postV1AiConversationsConversationIdMessages>>, TError,{conversationId: string;data: CreateMessageRequest}, TContext> => {

const mutationKey = ['postV1AiConversationsConversationIdMessages'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1AiConversationsConversationIdMessages>>, {conversationId: string;data: CreateMessageRequest}> = (props) => {
          const {conversationId,data} = props ?? {};

          return  postV1AiConversationsConversationIdMessages(conversationId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1AiConversationsConversationIdMessagesMutationResult = NonNullable<Awaited<ReturnType<typeof postV1AiConversationsConversationIdMessages>>>
    export type PostV1AiConversationsConversationIdMessagesMutationBody = CreateMessageRequest
    export type PostV1AiConversationsConversationIdMessagesMutationError = ErrorResponse

    /**
 * @summary Add message to conversation
 */
export const usePostV1AiConversationsConversationIdMessages = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AiConversationsConversationIdMessages>>, TError,{conversationId: string;data: CreateMessageRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postV1AiConversationsConversationIdMessages>>,
        TError,
        {conversationId: string;data: CreateMessageRequest},
        TContext
      > => {

      const mutationOptions = getPostV1AiConversationsConversationIdMessagesMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Search across all AI conversations belonging to the authenticated user
 * @summary Search AI conversations
 */
export const getV1AiSearch = (
    params: GetV1AiSearchParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<ConversationSearchResponse>(
      {url: `/v1/ai/search`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getGetV1AiSearchQueryKey = (params?: GetV1AiSearchParams,) => {
    return [
    `/v1/ai/search`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetV1AiSearchQueryOptions = <TData = Awaited<ReturnType<typeof getV1AiSearch>>, TError = ErrorResponse>(params: GetV1AiSearchParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AiSearch>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AiSearchQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AiSearch>>> = ({ signal }) => getV1AiSearch(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AiSearch>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AiSearchQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AiSearch>>>
export type GetV1AiSearchQueryError = ErrorResponse


export function useGetV1AiSearch<TData = Awaited<ReturnType<typeof getV1AiSearch>>, TError = ErrorResponse>(
 params: GetV1AiSearchParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AiSearch>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AiSearch>>,
          TError,
          Awaited<ReturnType<typeof getV1AiSearch>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AiSearch<TData = Awaited<ReturnType<typeof getV1AiSearch>>, TError = ErrorResponse>(
 params: GetV1AiSearchParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AiSearch>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AiSearch>>,
          TError,
          Awaited<ReturnType<typeof getV1AiSearch>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AiSearch<TData = Awaited<ReturnType<typeof getV1AiSearch>>, TError = ErrorResponse>(
 params: GetV1AiSearchParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AiSearch>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Search AI conversations
 */

export function useGetV1AiSearch<TData = Awaited<ReturnType<typeof getV1AiSearch>>, TError = ErrorResponse>(
 params: GetV1AiSearchParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AiSearch>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AiSearchQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Toggle the bookmark status of a specific message in a conversation
 * @summary Toggle message bookmark
 */
export const putV1AiConversationsBookmark = (
    putV1AiConversationsBookmarkBody: PutV1AiConversationsBookmarkBody,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<BookmarkStatusResponse>(
      {url: `/v1/ai/conversations/bookmark`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: putV1AiConversationsBookmarkBody
    },
      options);
    }
  


export const getPutV1AiConversationsBookmarkMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putV1AiConversationsBookmark>>, TError,{data: PutV1AiConversationsBookmarkBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof putV1AiConversationsBookmark>>, TError,{data: PutV1AiConversationsBookmarkBody}, TContext> => {

const mutationKey = ['putV1AiConversationsBookmark'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putV1AiConversationsBookmark>>, {data: PutV1AiConversationsBookmarkBody}> = (props) => {
          const {data} = props ?? {};

          return  putV1AiConversationsBookmark(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PutV1AiConversationsBookmarkMutationResult = NonNullable<Awaited<ReturnType<typeof putV1AiConversationsBookmark>>>
    export type PutV1AiConversationsBookmarkMutationBody = PutV1AiConversationsBookmarkBody
    export type PutV1AiConversationsBookmarkMutationError = ErrorResponse

    /**
 * @summary Toggle message bookmark
 */
export const usePutV1AiConversationsBookmark = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putV1AiConversationsBookmark>>, TError,{data: PutV1AiConversationsBookmarkBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof putV1AiConversationsBookmark>>,
        TError,
        {data: PutV1AiConversationsBookmarkBody},
        TContext
      > => {

      const mutationOptions = getPutV1AiConversationsBookmarkMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Retrieve all bookmarked AI chat messages for the authenticated user with optional search
 * @summary Get bookmarked messages
 */
export const getV1AiBookmarks = (
    params?: GetV1AiBookmarksParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<ChatBookmarksResponse>(
      {url: `/v1/ai/bookmarks`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getGetV1AiBookmarksQueryKey = (params?: GetV1AiBookmarksParams,) => {
    return [
    `/v1/ai/bookmarks`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetV1AiBookmarksQueryOptions = <TData = Awaited<ReturnType<typeof getV1AiBookmarks>>, TError = ErrorResponse>(params?: GetV1AiBookmarksParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AiBookmarks>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AiBookmarksQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AiBookmarks>>> = ({ signal }) => getV1AiBookmarks(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AiBookmarks>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AiBookmarksQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AiBookmarks>>>
export type GetV1AiBookmarksQueryError = ErrorResponse


export function useGetV1AiBookmarks<TData = Awaited<ReturnType<typeof getV1AiBookmarks>>, TError = ErrorResponse>(
 params: undefined |  GetV1AiBookmarksParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AiBookmarks>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AiBookmarks>>,
          TError,
          Awaited<ReturnType<typeof getV1AiBookmarks>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AiBookmarks<TData = Awaited<ReturnType<typeof getV1AiBookmarks>>, TError = ErrorResponse>(
 params?: GetV1AiBookmarksParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AiBookmarks>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AiBookmarks>>,
          TError,
          Awaited<ReturnType<typeof getV1AiBookmarks>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AiBookmarks<TData = Awaited<ReturnType<typeof getV1AiBookmarks>>, TError = ErrorResponse>(
 params?: GetV1AiBookmarksParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AiBookmarks>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get bookmarked messages
 */

export function useGetV1AiBookmarks<TData = Awaited<ReturnType<typeof getV1AiBookmarks>>, TError = ErrorResponse>(
 params?: GetV1AiBookmarksParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AiBookmarks>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AiBookmarksQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Save a word or phrase with its translation for later review
 * @summary Save a new vocabulary snippet
 */
export const postV1Snippets = (
    createSnippetRequest: CreateSnippetRequest,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<Snippet>(
      {url: `/v1/snippets`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createSnippetRequest, signal
    },
      options);
    }
  


export const getPostV1SnippetsMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1Snippets>>, TError,{data: CreateSnippetRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postV1Snippets>>, TError,{data: CreateSnippetRequest}, TContext> => {

const mutationKey = ['postV1Snippets'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1Snippets>>, {data: CreateSnippetRequest}> = (props) => {
          const {data} = props ?? {};

          return  postV1Snippets(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1SnippetsMutationResult = NonNullable<Awaited<ReturnType<typeof postV1Snippets>>>
    export type PostV1SnippetsMutationBody = CreateSnippetRequest
    export type PostV1SnippetsMutationError = ErrorResponse

    /**
 * @summary Save a new vocabulary snippet
 */
export const usePostV1Snippets = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1Snippets>>, TError,{data: CreateSnippetRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postV1Snippets>>,
        TError,
        {data: CreateSnippetRequest},
        TContext
      > => {

      const mutationOptions = getPostV1SnippetsMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Retrieve all vocabulary snippets saved by the authenticated user
 * @summary List user's saved snippets
 */
export const getV1Snippets = (
    params?: GetV1SnippetsParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<SnippetList>(
      {url: `/v1/snippets`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getGetV1SnippetsQueryKey = (params?: GetV1SnippetsParams,) => {
    return [
    `/v1/snippets`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetV1SnippetsQueryOptions = <TData = Awaited<ReturnType<typeof getV1Snippets>>, TError = ErrorResponse>(params?: GetV1SnippetsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1Snippets>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1SnippetsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1Snippets>>> = ({ signal }) => getV1Snippets(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1Snippets>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1SnippetsQueryResult = NonNullable<Awaited<ReturnType<typeof getV1Snippets>>>
export type GetV1SnippetsQueryError = ErrorResponse


export function useGetV1Snippets<TData = Awaited<ReturnType<typeof getV1Snippets>>, TError = ErrorResponse>(
 params: undefined |  GetV1SnippetsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1Snippets>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1Snippets>>,
          TError,
          Awaited<ReturnType<typeof getV1Snippets>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1Snippets<TData = Awaited<ReturnType<typeof getV1Snippets>>, TError = ErrorResponse>(
 params?: GetV1SnippetsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1Snippets>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1Snippets>>,
          TError,
          Awaited<ReturnType<typeof getV1Snippets>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1Snippets<TData = Awaited<ReturnType<typeof getV1Snippets>>, TError = ErrorResponse>(
 params?: GetV1SnippetsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1Snippets>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List user's saved snippets
 */

export function useGetV1Snippets<TData = Awaited<ReturnType<typeof getV1Snippets>>, TError = ErrorResponse>(
 params?: GetV1SnippetsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1Snippets>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1SnippetsQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Search across all snippets for the authenticated user
 * @summary Search snippets
 */
export const getV1SnippetsSearch = (
    params: GetV1SnippetsSearchParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<SnippetList>(
      {url: `/v1/snippets/search`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getGetV1SnippetsSearchQueryKey = (params?: GetV1SnippetsSearchParams,) => {
    return [
    `/v1/snippets/search`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetV1SnippetsSearchQueryOptions = <TData = Awaited<ReturnType<typeof getV1SnippetsSearch>>, TError = ErrorResponse>(params: GetV1SnippetsSearchParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1SnippetsSearch>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1SnippetsSearchQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1SnippetsSearch>>> = ({ signal }) => getV1SnippetsSearch(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1SnippetsSearch>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1SnippetsSearchQueryResult = NonNullable<Awaited<ReturnType<typeof getV1SnippetsSearch>>>
export type GetV1SnippetsSearchQueryError = ErrorResponse


export function useGetV1SnippetsSearch<TData = Awaited<ReturnType<typeof getV1SnippetsSearch>>, TError = ErrorResponse>(
 params: GetV1SnippetsSearchParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1SnippetsSearch>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1SnippetsSearch>>,
          TError,
          Awaited<ReturnType<typeof getV1SnippetsSearch>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1SnippetsSearch<TData = Awaited<ReturnType<typeof getV1SnippetsSearch>>, TError = ErrorResponse>(
 params: GetV1SnippetsSearchParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1SnippetsSearch>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1SnippetsSearch>>,
          TError,
          Awaited<ReturnType<typeof getV1SnippetsSearch>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1SnippetsSearch<TData = Awaited<ReturnType<typeof getV1SnippetsSearch>>, TError = ErrorResponse>(
 params: GetV1SnippetsSearchParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1SnippetsSearch>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Search snippets
 */

export function useGetV1SnippetsSearch<TData = Awaited<ReturnType<typeof getV1SnippetsSearch>>, TError = ErrorResponse>(
 params: GetV1SnippetsSearchParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1SnippetsSearch>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1SnippetsSearchQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Retrieve all vocabulary snippets saved by the authenticated user for a specific question. This endpoint is optimized for performance to avoid slowing down question loading.
 * @summary Get snippets for a specific question
 */
export const getV1SnippetsByQuestionQuestionId = (
    questionId: number,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<SnippetsResponse>(
      {url: `/v1/snippets/by-question/${questionId}`, method: 'GET', signal
    },
      options);
    }
  



export const getGetV1SnippetsByQuestionQuestionIdQueryKey = (questionId?: number,) => {
    return [
    `/v1/snippets/by-question/${questionId}`
    ] as const;
    }

    
export const getGetV1SnippetsByQuestionQuestionIdQueryOptions = <TData = Awaited<ReturnType<typeof getV1SnippetsByQuestionQuestionId>>, TError = ErrorResponse>(questionId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1SnippetsByQuestionQuestionId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1SnippetsByQuestionQuestionIdQueryKey(questionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1SnippetsByQuestionQuestionId>>> = ({ signal }) => getV1SnippetsByQuestionQuestionId(questionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(questionId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1SnippetsByQuestionQuestionId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1SnippetsByQuestionQuestionIdQueryResult = NonNullable<Awaited<ReturnType<typeof getV1SnippetsByQuestionQuestionId>>>
export type GetV1SnippetsByQuestionQuestionIdQueryError = ErrorResponse


export function useGetV1SnippetsByQuestionQuestionId<TData = Awaited<ReturnType<typeof getV1SnippetsByQuestionQuestionId>>, TError = ErrorResponse>(
 questionId: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1SnippetsByQuestionQuestionId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1SnippetsByQuestionQuestionId>>,
          TError,
          Awaited<ReturnType<typeof getV1SnippetsByQuestionQuestionId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1SnippetsByQuestionQuestionId<TData = Awaited<ReturnType<typeof getV1SnippetsByQuestionQuestionId>>, TError = ErrorResponse>(
 questionId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1SnippetsByQuestionQuestionId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1SnippetsByQuestionQuestionId>>,
          TError,
          Awaited<ReturnType<typeof getV1SnippetsByQuestionQuestionId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1SnippetsByQuestionQuestionId<TData = Awaited<ReturnType<typeof getV1SnippetsByQuestionQuestionId>>, TError = ErrorResponse>(
 questionId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1SnippetsByQuestionQuestionId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get snippets for a specific question
 */

export function useGetV1SnippetsByQuestionQuestionId<TData = Awaited<ReturnType<typeof getV1SnippetsByQuestionQuestionId>>, TError = ErrorResponse>(
 questionId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1SnippetsByQuestionQuestionId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1SnippetsByQuestionQuestionIdQueryOptions(questionId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Retrieve all vocabulary snippets saved by the authenticated user for a specific story section. This endpoint is optimized for performance to avoid slowing down story section loading.
 * @summary Get snippets for a specific story section
 */
export const getV1SnippetsBySectionSectionId = (
    sectionId: number,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<SnippetsResponse>(
      {url: `/v1/snippets/by-section/${sectionId}`, method: 'GET', signal
    },
      options);
    }
  



export const getGetV1SnippetsBySectionSectionIdQueryKey = (sectionId?: number,) => {
    return [
    `/v1/snippets/by-section/${sectionId}`
    ] as const;
    }

    
export const getGetV1SnippetsBySectionSectionIdQueryOptions = <TData = Awaited<ReturnType<typeof getV1SnippetsBySectionSectionId>>, TError = ErrorResponse>(sectionId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1SnippetsBySectionSectionId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1SnippetsBySectionSectionIdQueryKey(sectionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1SnippetsBySectionSectionId>>> = ({ signal }) => getV1SnippetsBySectionSectionId(sectionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sectionId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1SnippetsBySectionSectionId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1SnippetsBySectionSectionIdQueryResult = NonNullable<Awaited<ReturnType<typeof getV1SnippetsBySectionSectionId>>>
export type GetV1SnippetsBySectionSectionIdQueryError = ErrorResponse


export function useGetV1SnippetsBySectionSectionId<TData = Awaited<ReturnType<typeof getV1SnippetsBySectionSectionId>>, TError = ErrorResponse>(
 sectionId: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1SnippetsBySectionSectionId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1SnippetsBySectionSectionId>>,
          TError,
          Awaited<ReturnType<typeof getV1SnippetsBySectionSectionId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1SnippetsBySectionSectionId<TData = Awaited<ReturnType<typeof getV1SnippetsBySectionSectionId>>, TError = ErrorResponse>(
 sectionId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1SnippetsBySectionSectionId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1SnippetsBySectionSectionId>>,
          TError,
          Awaited<ReturnType<typeof getV1SnippetsBySectionSectionId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1SnippetsBySectionSectionId<TData = Awaited<ReturnType<typeof getV1SnippetsBySectionSectionId>>, TError = ErrorResponse>(
 sectionId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1SnippetsBySectionSectionId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get snippets for a specific story section
 */

export function useGetV1SnippetsBySectionSectionId<TData = Awaited<ReturnType<typeof getV1SnippetsBySectionSectionId>>, TError = ErrorResponse>(
 sectionId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1SnippetsBySectionSectionId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1SnippetsBySectionSectionIdQueryOptions(sectionId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Retrieve all vocabulary snippets saved by the authenticated user for a specific story. This endpoint is optimized for performance to avoid slowing down story loading.
 * @summary Get snippets for a specific story
 */
export const getV1SnippetsByStoryStoryId = (
    storyId: number,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<SnippetsResponse>(
      {url: `/v1/snippets/by-story/${storyId}`, method: 'GET', signal
    },
      options);
    }
  



export const getGetV1SnippetsByStoryStoryIdQueryKey = (storyId?: number,) => {
    return [
    `/v1/snippets/by-story/${storyId}`
    ] as const;
    }

    
export const getGetV1SnippetsByStoryStoryIdQueryOptions = <TData = Awaited<ReturnType<typeof getV1SnippetsByStoryStoryId>>, TError = ErrorResponse>(storyId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1SnippetsByStoryStoryId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1SnippetsByStoryStoryIdQueryKey(storyId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1SnippetsByStoryStoryId>>> = ({ signal }) => getV1SnippetsByStoryStoryId(storyId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(storyId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1SnippetsByStoryStoryId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1SnippetsByStoryStoryIdQueryResult = NonNullable<Awaited<ReturnType<typeof getV1SnippetsByStoryStoryId>>>
export type GetV1SnippetsByStoryStoryIdQueryError = ErrorResponse


export function useGetV1SnippetsByStoryStoryId<TData = Awaited<ReturnType<typeof getV1SnippetsByStoryStoryId>>, TError = ErrorResponse>(
 storyId: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1SnippetsByStoryStoryId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1SnippetsByStoryStoryId>>,
          TError,
          Awaited<ReturnType<typeof getV1SnippetsByStoryStoryId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1SnippetsByStoryStoryId<TData = Awaited<ReturnType<typeof getV1SnippetsByStoryStoryId>>, TError = ErrorResponse>(
 storyId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1SnippetsByStoryStoryId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1SnippetsByStoryStoryId>>,
          TError,
          Awaited<ReturnType<typeof getV1SnippetsByStoryStoryId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1SnippetsByStoryStoryId<TData = Awaited<ReturnType<typeof getV1SnippetsByStoryStoryId>>, TError = ErrorResponse>(
 storyId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1SnippetsByStoryStoryId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get snippets for a specific story
 */

export function useGetV1SnippetsByStoryStoryId<TData = Awaited<ReturnType<typeof getV1SnippetsByStoryStoryId>>, TError = ErrorResponse>(
 storyId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1SnippetsByStoryStoryId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1SnippetsByStoryStoryIdQueryOptions(storyId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Retrieve a single vocabulary snippet by its ID
 * @summary Get a specific snippet by ID
 */
export const getV1SnippetsId = (
    id: number,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<Snippet>(
      {url: `/v1/snippets/${id}`, method: 'GET', signal
    },
      options);
    }
  



export const getGetV1SnippetsIdQueryKey = (id?: number,) => {
    return [
    `/v1/snippets/${id}`
    ] as const;
    }

    
export const getGetV1SnippetsIdQueryOptions = <TData = Awaited<ReturnType<typeof getV1SnippetsId>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1SnippetsId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1SnippetsIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1SnippetsId>>> = ({ signal }) => getV1SnippetsId(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1SnippetsId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1SnippetsIdQueryResult = NonNullable<Awaited<ReturnType<typeof getV1SnippetsId>>>
export type GetV1SnippetsIdQueryError = ErrorResponse


export function useGetV1SnippetsId<TData = Awaited<ReturnType<typeof getV1SnippetsId>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1SnippetsId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1SnippetsId>>,
          TError,
          Awaited<ReturnType<typeof getV1SnippetsId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1SnippetsId<TData = Awaited<ReturnType<typeof getV1SnippetsId>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1SnippetsId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1SnippetsId>>,
          TError,
          Awaited<ReturnType<typeof getV1SnippetsId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1SnippetsId<TData = Awaited<ReturnType<typeof getV1SnippetsId>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1SnippetsId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get a specific snippet by ID
 */

export function useGetV1SnippetsId<TData = Awaited<ReturnType<typeof getV1SnippetsId>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1SnippetsId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1SnippetsIdQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Update any field of a vocabulary snippet
 * @summary Update a snippet
 */
export const putV1SnippetsId = (
    id: number,
    updateSnippetRequest: UpdateSnippetRequest,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<Snippet>(
      {url: `/v1/snippets/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: updateSnippetRequest
    },
      options);
    }
  


export const getPutV1SnippetsIdMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putV1SnippetsId>>, TError,{id: number;data: UpdateSnippetRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof putV1SnippetsId>>, TError,{id: number;data: UpdateSnippetRequest}, TContext> => {

const mutationKey = ['putV1SnippetsId'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putV1SnippetsId>>, {id: number;data: UpdateSnippetRequest}> = (props) => {
          const {id,data} = props ?? {};

          return  putV1SnippetsId(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PutV1SnippetsIdMutationResult = NonNullable<Awaited<ReturnType<typeof putV1SnippetsId>>>
    export type PutV1SnippetsIdMutationBody = UpdateSnippetRequest
    export type PutV1SnippetsIdMutationError = ErrorResponse

    /**
 * @summary Update a snippet
 */
export const usePutV1SnippetsId = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putV1SnippetsId>>, TError,{id: number;data: UpdateSnippetRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof putV1SnippetsId>>,
        TError,
        {id: number;data: UpdateSnippetRequest},
        TContext
      > => {

      const mutationOptions = getPutV1SnippetsIdMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Delete a vocabulary snippet
 * @summary Delete a snippet
 */
export const deleteV1SnippetsId = (
    id: number,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/v1/snippets/${id}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteV1SnippetsIdMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteV1SnippetsId>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteV1SnippetsId>>, TError,{id: number}, TContext> => {

const mutationKey = ['deleteV1SnippetsId'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteV1SnippetsId>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteV1SnippetsId(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteV1SnippetsIdMutationResult = NonNullable<Awaited<ReturnType<typeof deleteV1SnippetsId>>>
    
    export type DeleteV1SnippetsIdMutationError = ErrorResponse

    /**
 * @summary Delete a snippet
 */
export const useDeleteV1SnippetsId = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteV1SnippetsId>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteV1SnippetsId>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteV1SnippetsIdMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Update the profile of the currently authenticated user
 * @summary Update current user profile
 */
export const putV1UserzProfile = (
    userUpdateRequest: UserUpdateRequest,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<UserProfileMessageResponse>(
      {url: `/v1/userz/profile`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: userUpdateRequest
    },
      options);
    }
  


export const getPutV1UserzProfileMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putV1UserzProfile>>, TError,{data: UserUpdateRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof putV1UserzProfile>>, TError,{data: UserUpdateRequest}, TContext> => {

const mutationKey = ['putV1UserzProfile'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putV1UserzProfile>>, {data: UserUpdateRequest}> = (props) => {
          const {data} = props ?? {};

          return  putV1UserzProfile(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PutV1UserzProfileMutationResult = NonNullable<Awaited<ReturnType<typeof putV1UserzProfile>>>
    export type PutV1UserzProfileMutationBody = UserUpdateRequest
    export type PutV1UserzProfileMutationError = ErrorResponse

    /**
 * @summary Update current user profile
 */
export const usePutV1UserzProfile = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putV1UserzProfile>>, TError,{data: UserUpdateRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof putV1UserzProfile>>,
        TError,
        {data: UserUpdateRequest},
        TContext
      > => {

      const mutationOptions = getPutV1UserzProfileMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Submit feedback or bug report with optional screenshot and context data
 * @summary Submit feedback or report an issue
 */
export const postV1Feedback = (
    feedbackSubmissionRequest: FeedbackSubmissionRequest,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<FeedbackReport>(
      {url: `/v1/feedback`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: feedbackSubmissionRequest, signal
    },
      options);
    }
  


export const getPostV1FeedbackMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1Feedback>>, TError,{data: FeedbackSubmissionRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postV1Feedback>>, TError,{data: FeedbackSubmissionRequest}, TContext> => {

const mutationKey = ['postV1Feedback'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1Feedback>>, {data: FeedbackSubmissionRequest}> = (props) => {
          const {data} = props ?? {};

          return  postV1Feedback(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1FeedbackMutationResult = NonNullable<Awaited<ReturnType<typeof postV1Feedback>>>
    export type PostV1FeedbackMutationBody = FeedbackSubmissionRequest
    export type PostV1FeedbackMutationError = ErrorResponse

    /**
 * @summary Submit feedback or report an issue
 */
export const usePostV1Feedback = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1Feedback>>, TError,{data: FeedbackSubmissionRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postV1Feedback>>,
        TError,
        {data: FeedbackSubmissionRequest},
        TContext
      > => {

      const mutationOptions = getPostV1FeedbackMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Get the backend admin interface HTML page (admin only)
 * @summary Get backend admin page
 */
export const getV1AdminBackend = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<string>(
      {url: `/v1/admin/backend`, method: 'GET', signal
    },
      options);
    }
  



export const getGetV1AdminBackendQueryKey = () => {
    return [
    `/v1/admin/backend`
    ] as const;
    }

    
export const getGetV1AdminBackendQueryOptions = <TData = Awaited<ReturnType<typeof getV1AdminBackend>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackend>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AdminBackendQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AdminBackend>>> = ({ signal }) => getV1AdminBackend(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackend>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AdminBackendQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AdminBackend>>>
export type GetV1AdminBackendQueryError = ErrorResponse


export function useGetV1AdminBackend<TData = Awaited<ReturnType<typeof getV1AdminBackend>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackend>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminBackend>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminBackend>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminBackend<TData = Awaited<ReturnType<typeof getV1AdminBackend>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackend>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminBackend>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminBackend>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminBackend<TData = Awaited<ReturnType<typeof getV1AdminBackend>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackend>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get backend admin page
 */

export function useGetV1AdminBackend<TData = Awaited<ReturnType<typeof getV1AdminBackend>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackend>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AdminBackendQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Get a list of all users (admin only)
 * @summary List all users
 */
export const getV1AdminBackendUserz = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<AdminUsersResponse>(
      {url: `/v1/admin/backend/userz`, method: 'GET', signal
    },
      options);
    }
  



export const getGetV1AdminBackendUserzQueryKey = () => {
    return [
    `/v1/admin/backend/userz`
    ] as const;
    }

    
export const getGetV1AdminBackendUserzQueryOptions = <TData = Awaited<ReturnType<typeof getV1AdminBackendUserz>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendUserz>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AdminBackendUserzQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AdminBackendUserz>>> = ({ signal }) => getV1AdminBackendUserz(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendUserz>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AdminBackendUserzQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AdminBackendUserz>>>
export type GetV1AdminBackendUserzQueryError = ErrorResponse


export function useGetV1AdminBackendUserz<TData = Awaited<ReturnType<typeof getV1AdminBackendUserz>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendUserz>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminBackendUserz>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminBackendUserz>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminBackendUserz<TData = Awaited<ReturnType<typeof getV1AdminBackendUserz>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendUserz>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminBackendUserz>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminBackendUserz>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminBackendUserz<TData = Awaited<ReturnType<typeof getV1AdminBackendUserz>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendUserz>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List all users
 */

export function useGetV1AdminBackendUserz<TData = Awaited<ReturnType<typeof getV1AdminBackendUserz>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendUserz>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AdminBackendUserzQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Create a new user account (admin only)
 * @summary Create a new user
 */
export const postV1AdminBackendUserz = (
    postV1AdminBackendUserzBody: PostV1AdminBackendUserzBody,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<UserProfileMessageResponse>(
      {url: `/v1/admin/backend/userz`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: postV1AdminBackendUserzBody, signal
    },
      options);
    }
  


export const getPostV1AdminBackendUserzMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AdminBackendUserz>>, TError,{data: PostV1AdminBackendUserzBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postV1AdminBackendUserz>>, TError,{data: PostV1AdminBackendUserzBody}, TContext> => {

const mutationKey = ['postV1AdminBackendUserz'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1AdminBackendUserz>>, {data: PostV1AdminBackendUserzBody}> = (props) => {
          const {data} = props ?? {};

          return  postV1AdminBackendUserz(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1AdminBackendUserzMutationResult = NonNullable<Awaited<ReturnType<typeof postV1AdminBackendUserz>>>
    export type PostV1AdminBackendUserzMutationBody = PostV1AdminBackendUserzBody
    export type PostV1AdminBackendUserzMutationError = ErrorResponse

    /**
 * @summary Create a new user
 */
export const usePostV1AdminBackendUserz = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AdminBackendUserz>>, TError,{data: PostV1AdminBackendUserzBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postV1AdminBackendUserz>>,
        TError,
        {data: PostV1AdminBackendUserzBody},
        TContext
      > => {

      const mutationOptions = getPostV1AdminBackendUserzMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Permanently deletes all stories, sections, and story-generated questions belonging to the authenticated user. This action is irreversible.
 * @summary Delete all stories for the authenticated user
 */
export const postV1SettingsClearStories = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<SuccessResponse>(
      {url: `/v1/settings/clear-stories`, method: 'POST', signal
    },
      options);
    }
  


export const getPostV1SettingsClearStoriesMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1SettingsClearStories>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postV1SettingsClearStories>>, TError,void, TContext> => {

const mutationKey = ['postV1SettingsClearStories'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1SettingsClearStories>>, void> = () => {
          

          return  postV1SettingsClearStories(requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1SettingsClearStoriesMutationResult = NonNullable<Awaited<ReturnType<typeof postV1SettingsClearStories>>>
    
    export type PostV1SettingsClearStoriesMutationError = ErrorResponse

    /**
 * @summary Delete all stories for the authenticated user
 */
export const usePostV1SettingsClearStories = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1SettingsClearStories>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postV1SettingsClearStories>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getPostV1SettingsClearStoriesMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Clears the authenticated user's activity (questions, responses, performance metrics) and deletes all stories. This is irreversible.
 * @summary Reset the authenticated user's account
 */
export const postV1SettingsResetAccount = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<SuccessResponse>(
      {url: `/v1/settings/reset-account`, method: 'POST', signal
    },
      options);
    }
  


export const getPostV1SettingsResetAccountMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1SettingsResetAccount>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postV1SettingsResetAccount>>, TError,void, TContext> => {

const mutationKey = ['postV1SettingsResetAccount'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1SettingsResetAccount>>, void> = () => {
          

          return  postV1SettingsResetAccount(requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1SettingsResetAccountMutationResult = NonNullable<Awaited<ReturnType<typeof postV1SettingsResetAccount>>>
    
    export type PostV1SettingsResetAccountMutationError = ErrorResponse

    /**
 * @summary Reset the authenticated user's account
 */
export const usePostV1SettingsResetAccount = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1SettingsResetAccount>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postV1SettingsResetAccount>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getPostV1SettingsResetAccountMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Permanently deletes all AI conversations and their associated messages belonging to the authenticated user. This action is irreversible.
 * @summary Delete all AI chats for the authenticated user
 */
export const postV1SettingsClearAiChats = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<SuccessResponse>(
      {url: `/v1/settings/clear-ai-chats`, method: 'POST', signal
    },
      options);
    }
  


export const getPostV1SettingsClearAiChatsMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1SettingsClearAiChats>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postV1SettingsClearAiChats>>, TError,void, TContext> => {

const mutationKey = ['postV1SettingsClearAiChats'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1SettingsClearAiChats>>, void> = () => {
          

          return  postV1SettingsClearAiChats(requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1SettingsClearAiChatsMutationResult = NonNullable<Awaited<ReturnType<typeof postV1SettingsClearAiChats>>>
    
    export type PostV1SettingsClearAiChatsMutationError = ErrorResponse

    /**
 * @summary Delete all AI chats for the authenticated user
 */
export const usePostV1SettingsClearAiChats = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1SettingsClearAiChats>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postV1SettingsClearAiChats>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getPostV1SettingsClearAiChatsMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Permanently deletes all translation practice sessions belonging to the authenticated user. This action is irreversible.
 * @summary Delete all translation practice history for the authenticated user
 */
export const postV1SettingsClearTranslationPracticeHistory = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<SuccessResponse>(
      {url: `/v1/settings/clear-translation-practice-history`, method: 'POST', signal
    },
      options);
    }
  


export const getPostV1SettingsClearTranslationPracticeHistoryMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1SettingsClearTranslationPracticeHistory>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postV1SettingsClearTranslationPracticeHistory>>, TError,void, TContext> => {

const mutationKey = ['postV1SettingsClearTranslationPracticeHistory'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1SettingsClearTranslationPracticeHistory>>, void> = () => {
          

          return  postV1SettingsClearTranslationPracticeHistory(requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1SettingsClearTranslationPracticeHistoryMutationResult = NonNullable<Awaited<ReturnType<typeof postV1SettingsClearTranslationPracticeHistory>>>
    
    export type PostV1SettingsClearTranslationPracticeHistoryMutationError = ErrorResponse

    /**
 * @summary Delete all translation practice history for the authenticated user
 */
export const usePostV1SettingsClearTranslationPracticeHistory = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1SettingsClearTranslationPracticeHistory>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postV1SettingsClearTranslationPracticeHistory>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getPostV1SettingsClearTranslationPracticeHistoryMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Get paginated users with search and filtering options (admin only)
 * @summary Get paginated users with filtering
 */
export const getV1AdminBackendUserzPaginated = (
    params?: GetV1AdminBackendUserzPaginatedParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<AdminUsersPaginatedResponse>(
      {url: `/v1/admin/backend/userz/paginated`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getGetV1AdminBackendUserzPaginatedQueryKey = (params?: GetV1AdminBackendUserzPaginatedParams,) => {
    return [
    `/v1/admin/backend/userz/paginated`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetV1AdminBackendUserzPaginatedQueryOptions = <TData = Awaited<ReturnType<typeof getV1AdminBackendUserzPaginated>>, TError = ErrorResponse>(params?: GetV1AdminBackendUserzPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendUserzPaginated>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AdminBackendUserzPaginatedQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AdminBackendUserzPaginated>>> = ({ signal }) => getV1AdminBackendUserzPaginated(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendUserzPaginated>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AdminBackendUserzPaginatedQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AdminBackendUserzPaginated>>>
export type GetV1AdminBackendUserzPaginatedQueryError = ErrorResponse


export function useGetV1AdminBackendUserzPaginated<TData = Awaited<ReturnType<typeof getV1AdminBackendUserzPaginated>>, TError = ErrorResponse>(
 params: undefined |  GetV1AdminBackendUserzPaginatedParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendUserzPaginated>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminBackendUserzPaginated>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminBackendUserzPaginated>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminBackendUserzPaginated<TData = Awaited<ReturnType<typeof getV1AdminBackendUserzPaginated>>, TError = ErrorResponse>(
 params?: GetV1AdminBackendUserzPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendUserzPaginated>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminBackendUserzPaginated>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminBackendUserzPaginated>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminBackendUserzPaginated<TData = Awaited<ReturnType<typeof getV1AdminBackendUserzPaginated>>, TError = ErrorResponse>(
 params?: GetV1AdminBackendUserzPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendUserzPaginated>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get paginated users with filtering
 */

export function useGetV1AdminBackendUserzPaginated<TData = Awaited<ReturnType<typeof getV1AdminBackendUserzPaginated>>, TError = ErrorResponse>(
 params?: GetV1AdminBackendUserzPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendUserzPaginated>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AdminBackendUserzPaginatedQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Update user details (admin only)
 * @summary Update user details
 */
export const putV1AdminBackendUserzId = (
    id: number,
    userUpdateRequest: UserUpdateRequest,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<UserProfileMessageResponse>(
      {url: `/v1/admin/backend/userz/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: userUpdateRequest
    },
      options);
    }
  


export const getPutV1AdminBackendUserzIdMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putV1AdminBackendUserzId>>, TError,{id: number;data: UserUpdateRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof putV1AdminBackendUserzId>>, TError,{id: number;data: UserUpdateRequest}, TContext> => {

const mutationKey = ['putV1AdminBackendUserzId'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putV1AdminBackendUserzId>>, {id: number;data: UserUpdateRequest}> = (props) => {
          const {id,data} = props ?? {};

          return  putV1AdminBackendUserzId(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PutV1AdminBackendUserzIdMutationResult = NonNullable<Awaited<ReturnType<typeof putV1AdminBackendUserzId>>>
    export type PutV1AdminBackendUserzIdMutationBody = UserUpdateRequest
    export type PutV1AdminBackendUserzIdMutationError = ErrorResponse

    /**
 * @summary Update user details
 */
export const usePutV1AdminBackendUserzId = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putV1AdminBackendUserzId>>, TError,{id: number;data: UserUpdateRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof putV1AdminBackendUserzId>>,
        TError,
        {id: number;data: UserUpdateRequest},
        TContext
      > => {

      const mutationOptions = getPutV1AdminBackendUserzIdMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Delete a user (admin only)
 * @summary Delete user
 */
export const deleteV1AdminBackendUserzId = (
    id: number,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<MessageResponse>(
      {url: `/v1/admin/backend/userz/${id}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteV1AdminBackendUserzIdMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteV1AdminBackendUserzId>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteV1AdminBackendUserzId>>, TError,{id: number}, TContext> => {

const mutationKey = ['deleteV1AdminBackendUserzId'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteV1AdminBackendUserzId>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteV1AdminBackendUserzId(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteV1AdminBackendUserzIdMutationResult = NonNullable<Awaited<ReturnType<typeof deleteV1AdminBackendUserzId>>>
    
    export type DeleteV1AdminBackendUserzIdMutationError = ErrorResponse

    /**
 * @summary Delete user
 */
export const useDeleteV1AdminBackendUserzId = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteV1AdminBackendUserzId>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteV1AdminBackendUserzId>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteV1AdminBackendUserzIdMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Reset a user's password (admin only)
 * @summary Reset user password
 */
export const postV1AdminBackendUserzIdResetPassword = (
    id: number,
    passwordResetRequest: PasswordResetRequest,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<MessageResponse>(
      {url: `/v1/admin/backend/userz/${id}/reset-password`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: passwordResetRequest, signal
    },
      options);
    }
  


export const getPostV1AdminBackendUserzIdResetPasswordMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AdminBackendUserzIdResetPassword>>, TError,{id: number;data: PasswordResetRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postV1AdminBackendUserzIdResetPassword>>, TError,{id: number;data: PasswordResetRequest}, TContext> => {

const mutationKey = ['postV1AdminBackendUserzIdResetPassword'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1AdminBackendUserzIdResetPassword>>, {id: number;data: PasswordResetRequest}> = (props) => {
          const {id,data} = props ?? {};

          return  postV1AdminBackendUserzIdResetPassword(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1AdminBackendUserzIdResetPasswordMutationResult = NonNullable<Awaited<ReturnType<typeof postV1AdminBackendUserzIdResetPassword>>>
    export type PostV1AdminBackendUserzIdResetPasswordMutationBody = PasswordResetRequest
    export type PostV1AdminBackendUserzIdResetPasswordMutationError = ErrorResponse

    /**
 * @summary Reset user password
 */
export const usePostV1AdminBackendUserzIdResetPassword = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AdminBackendUserzIdResetPassword>>, TError,{id: number;data: PasswordResetRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postV1AdminBackendUserzIdResetPassword>>,
        TError,
        {id: number;data: PasswordResetRequest},
        TContext
      > => {

      const mutationOptions = getPostV1AdminBackendUserzIdResetPasswordMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Get all available roles in the system (admin only)
 * @summary Get all roles
 */
export const getV1AdminBackendRoles = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<AdminRolesResponse>(
      {url: `/v1/admin/backend/roles`, method: 'GET', signal
    },
      options);
    }
  



export const getGetV1AdminBackendRolesQueryKey = () => {
    return [
    `/v1/admin/backend/roles`
    ] as const;
    }

    
export const getGetV1AdminBackendRolesQueryOptions = <TData = Awaited<ReturnType<typeof getV1AdminBackendRoles>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendRoles>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AdminBackendRolesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AdminBackendRoles>>> = ({ signal }) => getV1AdminBackendRoles(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendRoles>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AdminBackendRolesQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AdminBackendRoles>>>
export type GetV1AdminBackendRolesQueryError = ErrorResponse


export function useGetV1AdminBackendRoles<TData = Awaited<ReturnType<typeof getV1AdminBackendRoles>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendRoles>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminBackendRoles>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminBackendRoles>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminBackendRoles<TData = Awaited<ReturnType<typeof getV1AdminBackendRoles>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendRoles>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminBackendRoles>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminBackendRoles>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminBackendRoles<TData = Awaited<ReturnType<typeof getV1AdminBackendRoles>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendRoles>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get all roles
 */

export function useGetV1AdminBackendRoles<TData = Awaited<ReturnType<typeof getV1AdminBackendRoles>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendRoles>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AdminBackendRolesQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Get all roles for a specific user (admin only)
 * @summary Get user roles
 */
export const getV1AdminBackendUserzIdRoles = (
    id: number,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<AdminRolesResponse>(
      {url: `/v1/admin/backend/userz/${id}/roles`, method: 'GET', signal
    },
      options);
    }
  



export const getGetV1AdminBackendUserzIdRolesQueryKey = (id?: number,) => {
    return [
    `/v1/admin/backend/userz/${id}/roles`
    ] as const;
    }

    
export const getGetV1AdminBackendUserzIdRolesQueryOptions = <TData = Awaited<ReturnType<typeof getV1AdminBackendUserzIdRoles>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendUserzIdRoles>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AdminBackendUserzIdRolesQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AdminBackendUserzIdRoles>>> = ({ signal }) => getV1AdminBackendUserzIdRoles(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendUserzIdRoles>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AdminBackendUserzIdRolesQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AdminBackendUserzIdRoles>>>
export type GetV1AdminBackendUserzIdRolesQueryError = ErrorResponse


export function useGetV1AdminBackendUserzIdRoles<TData = Awaited<ReturnType<typeof getV1AdminBackendUserzIdRoles>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendUserzIdRoles>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminBackendUserzIdRoles>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminBackendUserzIdRoles>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminBackendUserzIdRoles<TData = Awaited<ReturnType<typeof getV1AdminBackendUserzIdRoles>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendUserzIdRoles>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminBackendUserzIdRoles>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminBackendUserzIdRoles>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminBackendUserzIdRoles<TData = Awaited<ReturnType<typeof getV1AdminBackendUserzIdRoles>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendUserzIdRoles>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get user roles
 */

export function useGetV1AdminBackendUserzIdRoles<TData = Awaited<ReturnType<typeof getV1AdminBackendUserzIdRoles>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendUserzIdRoles>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AdminBackendUserzIdRolesQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Assign a role to a specific user (admin only)
 * @summary Assign role to user
 */
export const postV1AdminBackendUserzIdRoles = (
    id: number,
    postV1AdminBackendUserzIdRolesBody: PostV1AdminBackendUserzIdRolesBody,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<MessageResponse>(
      {url: `/v1/admin/backend/userz/${id}/roles`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: postV1AdminBackendUserzIdRolesBody, signal
    },
      options);
    }
  


export const getPostV1AdminBackendUserzIdRolesMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AdminBackendUserzIdRoles>>, TError,{id: number;data: PostV1AdminBackendUserzIdRolesBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postV1AdminBackendUserzIdRoles>>, TError,{id: number;data: PostV1AdminBackendUserzIdRolesBody}, TContext> => {

const mutationKey = ['postV1AdminBackendUserzIdRoles'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1AdminBackendUserzIdRoles>>, {id: number;data: PostV1AdminBackendUserzIdRolesBody}> = (props) => {
          const {id,data} = props ?? {};

          return  postV1AdminBackendUserzIdRoles(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1AdminBackendUserzIdRolesMutationResult = NonNullable<Awaited<ReturnType<typeof postV1AdminBackendUserzIdRoles>>>
    export type PostV1AdminBackendUserzIdRolesMutationBody = PostV1AdminBackendUserzIdRolesBody
    export type PostV1AdminBackendUserzIdRolesMutationError = ErrorResponse

    /**
 * @summary Assign role to user
 */
export const usePostV1AdminBackendUserzIdRoles = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AdminBackendUserzIdRoles>>, TError,{id: number;data: PostV1AdminBackendUserzIdRolesBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postV1AdminBackendUserzIdRoles>>,
        TError,
        {id: number;data: PostV1AdminBackendUserzIdRolesBody},
        TContext
      > => {

      const mutationOptions = getPostV1AdminBackendUserzIdRolesMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Remove a role from a specific user (admin only)
 * @summary Remove role from user
 */
export const deleteV1AdminBackendUserzIdRolesRoleId = (
    id: number,
    roleId: number,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<MessageResponse>(
      {url: `/v1/admin/backend/userz/${id}/roles/${roleId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteV1AdminBackendUserzIdRolesRoleIdMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteV1AdminBackendUserzIdRolesRoleId>>, TError,{id: number;roleId: number}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteV1AdminBackendUserzIdRolesRoleId>>, TError,{id: number;roleId: number}, TContext> => {

const mutationKey = ['deleteV1AdminBackendUserzIdRolesRoleId'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteV1AdminBackendUserzIdRolesRoleId>>, {id: number;roleId: number}> = (props) => {
          const {id,roleId} = props ?? {};

          return  deleteV1AdminBackendUserzIdRolesRoleId(id,roleId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteV1AdminBackendUserzIdRolesRoleIdMutationResult = NonNullable<Awaited<ReturnType<typeof deleteV1AdminBackendUserzIdRolesRoleId>>>
    
    export type DeleteV1AdminBackendUserzIdRolesRoleIdMutationError = ErrorResponse

    /**
 * @summary Remove role from user
 */
export const useDeleteV1AdminBackendUserzIdRolesRoleId = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteV1AdminBackendUserzIdRolesRoleId>>, TError,{id: number;roleId: number}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteV1AdminBackendUserzIdRolesRoleId>>,
        TError,
        {id: number;roleId: number},
        TContext
      > => {

      const mutationOptions = getDeleteV1AdminBackendUserzIdRolesRoleIdMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Get comprehensive admin dashboard data including user stats, worker health, and AI concurrency (admin only)
 * @summary Get backend admin dashboard data
 */
export const getV1AdminBackendDashboard = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<DashboardResponse>(
      {url: `/v1/admin/backend/dashboard`, method: 'GET', signal
    },
      options);
    }
  



export const getGetV1AdminBackendDashboardQueryKey = () => {
    return [
    `/v1/admin/backend/dashboard`
    ] as const;
    }

    
export const getGetV1AdminBackendDashboardQueryOptions = <TData = Awaited<ReturnType<typeof getV1AdminBackendDashboard>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendDashboard>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AdminBackendDashboardQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AdminBackendDashboard>>> = ({ signal }) => getV1AdminBackendDashboard(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendDashboard>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AdminBackendDashboardQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AdminBackendDashboard>>>
export type GetV1AdminBackendDashboardQueryError = ErrorResponse


export function useGetV1AdminBackendDashboard<TData = Awaited<ReturnType<typeof getV1AdminBackendDashboard>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendDashboard>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminBackendDashboard>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminBackendDashboard>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminBackendDashboard<TData = Awaited<ReturnType<typeof getV1AdminBackendDashboard>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendDashboard>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminBackendDashboard>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminBackendDashboard>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminBackendDashboard<TData = Awaited<ReturnType<typeof getV1AdminBackendDashboard>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendDashboard>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get backend admin dashboard data
 */

export function useGetV1AdminBackendDashboard<TData = Awaited<ReturnType<typeof getV1AdminBackendDashboard>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendDashboard>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AdminBackendDashboardQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Get real-time AI concurrency statistics (admin only)
 * @summary Get AI concurrency statistics
 */
export const getV1AdminBackendAiConcurrency = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<AIConcurrencyStats>(
      {url: `/v1/admin/backend/ai-concurrency`, method: 'GET', signal
    },
      options);
    }
  



export const getGetV1AdminBackendAiConcurrencyQueryKey = () => {
    return [
    `/v1/admin/backend/ai-concurrency`
    ] as const;
    }

    
export const getGetV1AdminBackendAiConcurrencyQueryOptions = <TData = Awaited<ReturnType<typeof getV1AdminBackendAiConcurrency>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendAiConcurrency>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AdminBackendAiConcurrencyQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AdminBackendAiConcurrency>>> = ({ signal }) => getV1AdminBackendAiConcurrency(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendAiConcurrency>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AdminBackendAiConcurrencyQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AdminBackendAiConcurrency>>>
export type GetV1AdminBackendAiConcurrencyQueryError = ErrorResponse


export function useGetV1AdminBackendAiConcurrency<TData = Awaited<ReturnType<typeof getV1AdminBackendAiConcurrency>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendAiConcurrency>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminBackendAiConcurrency>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminBackendAiConcurrency>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminBackendAiConcurrency<TData = Awaited<ReturnType<typeof getV1AdminBackendAiConcurrency>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendAiConcurrency>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminBackendAiConcurrency>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminBackendAiConcurrency>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminBackendAiConcurrency<TData = Awaited<ReturnType<typeof getV1AdminBackendAiConcurrency>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendAiConcurrency>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get AI concurrency statistics
 */

export function useGetV1AdminBackendAiConcurrency<TData = Awaited<ReturnType<typeof getV1AdminBackendAiConcurrency>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendAiConcurrency>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AdminBackendAiConcurrencyQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Get the current status of the worker (admin only)
 * @summary Get worker status
 */
export const getV1AdminWorkerStatus = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<WorkerStatus>(
      {url: `/v1/admin/worker/status`, method: 'GET', signal
    },
      options);
    }
  



export const getGetV1AdminWorkerStatusQueryKey = () => {
    return [
    `/v1/admin/worker/status`
    ] as const;
    }

    
export const getGetV1AdminWorkerStatusQueryOptions = <TData = Awaited<ReturnType<typeof getV1AdminWorkerStatus>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerStatus>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AdminWorkerStatusQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AdminWorkerStatus>>> = ({ signal }) => getV1AdminWorkerStatus(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerStatus>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AdminWorkerStatusQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AdminWorkerStatus>>>
export type GetV1AdminWorkerStatusQueryError = ErrorResponse


export function useGetV1AdminWorkerStatus<TData = Awaited<ReturnType<typeof getV1AdminWorkerStatus>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerStatus>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminWorkerStatus>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminWorkerStatus>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminWorkerStatus<TData = Awaited<ReturnType<typeof getV1AdminWorkerStatus>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerStatus>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminWorkerStatus>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminWorkerStatus>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminWorkerStatus<TData = Awaited<ReturnType<typeof getV1AdminWorkerStatus>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerStatus>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get worker status
 */

export function useGetV1AdminWorkerStatus<TData = Awaited<ReturnType<typeof getV1AdminWorkerStatus>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerStatus>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AdminWorkerStatusQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Get detailed information about the worker (admin only)
 * @summary Get worker details
 */
export const getV1AdminWorkerDetails = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<WorkerDetailsResponse>(
      {url: `/v1/admin/worker/details`, method: 'GET', signal
    },
      options);
    }
  



export const getGetV1AdminWorkerDetailsQueryKey = () => {
    return [
    `/v1/admin/worker/details`
    ] as const;
    }

    
export const getGetV1AdminWorkerDetailsQueryOptions = <TData = Awaited<ReturnType<typeof getV1AdminWorkerDetails>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerDetails>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AdminWorkerDetailsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AdminWorkerDetails>>> = ({ signal }) => getV1AdminWorkerDetails(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerDetails>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AdminWorkerDetailsQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AdminWorkerDetails>>>
export type GetV1AdminWorkerDetailsQueryError = ErrorResponse


export function useGetV1AdminWorkerDetails<TData = Awaited<ReturnType<typeof getV1AdminWorkerDetails>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerDetails>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminWorkerDetails>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminWorkerDetails>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminWorkerDetails<TData = Awaited<ReturnType<typeof getV1AdminWorkerDetails>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerDetails>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminWorkerDetails>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminWorkerDetails>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminWorkerDetails<TData = Awaited<ReturnType<typeof getV1AdminWorkerDetails>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerDetails>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get worker details
 */

export function useGetV1AdminWorkerDetails<TData = Awaited<ReturnType<typeof getV1AdminWorkerDetails>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerDetails>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AdminWorkerDetailsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Pause the worker (admin only)
 * @summary Pause worker
 */
export const postV1AdminWorkerPause = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<MessageResponse>(
      {url: `/v1/admin/worker/pause`, method: 'POST', signal
    },
      options);
    }
  


export const getPostV1AdminWorkerPauseMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AdminWorkerPause>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postV1AdminWorkerPause>>, TError,void, TContext> => {

const mutationKey = ['postV1AdminWorkerPause'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1AdminWorkerPause>>, void> = () => {
          

          return  postV1AdminWorkerPause(requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1AdminWorkerPauseMutationResult = NonNullable<Awaited<ReturnType<typeof postV1AdminWorkerPause>>>
    
    export type PostV1AdminWorkerPauseMutationError = ErrorResponse

    /**
 * @summary Pause worker
 */
export const usePostV1AdminWorkerPause = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AdminWorkerPause>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postV1AdminWorkerPause>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getPostV1AdminWorkerPauseMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Resume the worker (admin only)
 * @summary Resume worker
 */
export const postV1AdminWorkerResume = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<MessageResponse>(
      {url: `/v1/admin/worker/resume`, method: 'POST', signal
    },
      options);
    }
  


export const getPostV1AdminWorkerResumeMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AdminWorkerResume>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postV1AdminWorkerResume>>, TError,void, TContext> => {

const mutationKey = ['postV1AdminWorkerResume'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1AdminWorkerResume>>, void> = () => {
          

          return  postV1AdminWorkerResume(requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1AdminWorkerResumeMutationResult = NonNullable<Awaited<ReturnType<typeof postV1AdminWorkerResume>>>
    
    export type PostV1AdminWorkerResumeMutationError = ErrorResponse

    /**
 * @summary Resume worker
 */
export const usePostV1AdminWorkerResume = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AdminWorkerResume>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postV1AdminWorkerResume>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getPostV1AdminWorkerResumeMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Trigger a manual worker run (admin only)
 * @summary Trigger worker run
 */
export const postV1AdminWorkerTrigger = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<MessageResponse>(
      {url: `/v1/admin/worker/trigger`, method: 'POST', signal
    },
      options);
    }
  


export const getPostV1AdminWorkerTriggerMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AdminWorkerTrigger>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postV1AdminWorkerTrigger>>, TError,void, TContext> => {

const mutationKey = ['postV1AdminWorkerTrigger'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1AdminWorkerTrigger>>, void> = () => {
          

          return  postV1AdminWorkerTrigger(requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1AdminWorkerTriggerMutationResult = NonNullable<Awaited<ReturnType<typeof postV1AdminWorkerTrigger>>>
    
    export type PostV1AdminWorkerTriggerMutationError = ErrorResponse

    /**
 * @summary Trigger worker run
 */
export const usePostV1AdminWorkerTrigger = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AdminWorkerTrigger>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postV1AdminWorkerTrigger>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getPostV1AdminWorkerTriggerMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Get worker activity logs (admin only)
 * @summary Get worker logs
 */
export const getV1AdminWorkerLogs = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<WorkerLogsResponse>(
      {url: `/v1/admin/worker/logs`, method: 'GET', signal
    },
      options);
    }
  



export const getGetV1AdminWorkerLogsQueryKey = () => {
    return [
    `/v1/admin/worker/logs`
    ] as const;
    }

    
export const getGetV1AdminWorkerLogsQueryOptions = <TData = Awaited<ReturnType<typeof getV1AdminWorkerLogs>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerLogs>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AdminWorkerLogsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AdminWorkerLogs>>> = ({ signal }) => getV1AdminWorkerLogs(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerLogs>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AdminWorkerLogsQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AdminWorkerLogs>>>
export type GetV1AdminWorkerLogsQueryError = ErrorResponse


export function useGetV1AdminWorkerLogs<TData = Awaited<ReturnType<typeof getV1AdminWorkerLogs>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerLogs>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminWorkerLogs>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminWorkerLogs>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminWorkerLogs<TData = Awaited<ReturnType<typeof getV1AdminWorkerLogs>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerLogs>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminWorkerLogs>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminWorkerLogs>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminWorkerLogs<TData = Awaited<ReturnType<typeof getV1AdminWorkerLogs>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerLogs>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get worker logs
 */

export function useGetV1AdminWorkerLogs<TData = Awaited<ReturnType<typeof getV1AdminWorkerLogs>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerLogs>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AdminWorkerLogsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Get AI concurrency statistics from the worker (admin only)
 * @summary Get worker AI concurrency statistics
 */
export const getV1AdminWorkerAiConcurrency = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<WorkerAIConcurrencyStats>(
      {url: `/v1/admin/worker/ai-concurrency`, method: 'GET', signal
    },
      options);
    }
  



export const getGetV1AdminWorkerAiConcurrencyQueryKey = () => {
    return [
    `/v1/admin/worker/ai-concurrency`
    ] as const;
    }

    
export const getGetV1AdminWorkerAiConcurrencyQueryOptions = <TData = Awaited<ReturnType<typeof getV1AdminWorkerAiConcurrency>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerAiConcurrency>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AdminWorkerAiConcurrencyQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AdminWorkerAiConcurrency>>> = ({ signal }) => getV1AdminWorkerAiConcurrency(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerAiConcurrency>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AdminWorkerAiConcurrencyQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AdminWorkerAiConcurrency>>>
export type GetV1AdminWorkerAiConcurrencyQueryError = ErrorResponse


export function useGetV1AdminWorkerAiConcurrency<TData = Awaited<ReturnType<typeof getV1AdminWorkerAiConcurrency>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerAiConcurrency>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminWorkerAiConcurrency>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminWorkerAiConcurrency>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminWorkerAiConcurrency<TData = Awaited<ReturnType<typeof getV1AdminWorkerAiConcurrency>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerAiConcurrency>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminWorkerAiConcurrency>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminWorkerAiConcurrency>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminWorkerAiConcurrency<TData = Awaited<ReturnType<typeof getV1AdminWorkerAiConcurrency>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerAiConcurrency>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get worker AI concurrency statistics
 */

export function useGetV1AdminWorkerAiConcurrency<TData = Awaited<ReturnType<typeof getV1AdminWorkerAiConcurrency>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerAiConcurrency>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AdminWorkerAiConcurrencyQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Get list of users with their worker pause status (admin only)
 * @summary Get worker user list with pause status
 */
export const getV1AdminWorkerUsers = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<WorkerUserListResponse>(
      {url: `/v1/admin/worker/users`, method: 'GET', signal
    },
      options);
    }
  



export const getGetV1AdminWorkerUsersQueryKey = () => {
    return [
    `/v1/admin/worker/users`
    ] as const;
    }

    
export const getGetV1AdminWorkerUsersQueryOptions = <TData = Awaited<ReturnType<typeof getV1AdminWorkerUsers>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerUsers>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AdminWorkerUsersQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AdminWorkerUsers>>> = ({ signal }) => getV1AdminWorkerUsers(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerUsers>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AdminWorkerUsersQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AdminWorkerUsers>>>
export type GetV1AdminWorkerUsersQueryError = ErrorResponse


export function useGetV1AdminWorkerUsers<TData = Awaited<ReturnType<typeof getV1AdminWorkerUsers>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerUsers>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminWorkerUsers>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminWorkerUsers>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminWorkerUsers<TData = Awaited<ReturnType<typeof getV1AdminWorkerUsers>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerUsers>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminWorkerUsers>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminWorkerUsers>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminWorkerUsers<TData = Awaited<ReturnType<typeof getV1AdminWorkerUsers>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerUsers>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get worker user list with pause status
 */

export function useGetV1AdminWorkerUsers<TData = Awaited<ReturnType<typeof getV1AdminWorkerUsers>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerUsers>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AdminWorkerUsersQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Pause question generation for a specific user (admin only)
 * @summary Pause worker for a specific user
 */
export const postV1AdminWorkerUsersPause = (
    userIdRequest: UserIdRequest,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<MessageResponse>(
      {url: `/v1/admin/worker/users/pause`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: userIdRequest, signal
    },
      options);
    }
  


export const getPostV1AdminWorkerUsersPauseMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AdminWorkerUsersPause>>, TError,{data: UserIdRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postV1AdminWorkerUsersPause>>, TError,{data: UserIdRequest}, TContext> => {

const mutationKey = ['postV1AdminWorkerUsersPause'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1AdminWorkerUsersPause>>, {data: UserIdRequest}> = (props) => {
          const {data} = props ?? {};

          return  postV1AdminWorkerUsersPause(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1AdminWorkerUsersPauseMutationResult = NonNullable<Awaited<ReturnType<typeof postV1AdminWorkerUsersPause>>>
    export type PostV1AdminWorkerUsersPauseMutationBody = UserIdRequest
    export type PostV1AdminWorkerUsersPauseMutationError = ErrorResponse

    /**
 * @summary Pause worker for a specific user
 */
export const usePostV1AdminWorkerUsersPause = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AdminWorkerUsersPause>>, TError,{data: UserIdRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postV1AdminWorkerUsersPause>>,
        TError,
        {data: UserIdRequest},
        TContext
      > => {

      const mutationOptions = getPostV1AdminWorkerUsersPauseMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Resume question generation for a specific user (admin only)
 * @summary Resume worker for a specific user
 */
export const postV1AdminWorkerUsersResume = (
    userIdRequest: UserIdRequest,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<MessageResponse>(
      {url: `/v1/admin/worker/users/resume`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: userIdRequest, signal
    },
      options);
    }
  


export const getPostV1AdminWorkerUsersResumeMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AdminWorkerUsersResume>>, TError,{data: UserIdRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postV1AdminWorkerUsersResume>>, TError,{data: UserIdRequest}, TContext> => {

const mutationKey = ['postV1AdminWorkerUsersResume'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1AdminWorkerUsersResume>>, {data: UserIdRequest}> = (props) => {
          const {data} = props ?? {};

          return  postV1AdminWorkerUsersResume(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1AdminWorkerUsersResumeMutationResult = NonNullable<Awaited<ReturnType<typeof postV1AdminWorkerUsersResume>>>
    export type PostV1AdminWorkerUsersResumeMutationBody = UserIdRequest
    export type PostV1AdminWorkerUsersResumeMutationError = ErrorResponse

    /**
 * @summary Resume worker for a specific user
 */
export const usePostV1AdminWorkerUsersResume = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AdminWorkerUsersResume>>, TError,{data: UserIdRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postV1AdminWorkerUsersResume>>,
        TError,
        {data: UserIdRequest},
        TContext
      > => {

      const mutationOptions = getPostV1AdminWorkerUsersResumeMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Get priority analytics from the worker (admin only)
 * @summary Get worker priority analytics
 */
export const getV1AdminWorkerAnalyticsPriorityScores = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<PriorityAnalytics>(
      {url: `/v1/admin/worker/analytics/priority-scores`, method: 'GET', signal
    },
      options);
    }
  



export const getGetV1AdminWorkerAnalyticsPriorityScoresQueryKey = () => {
    return [
    `/v1/admin/worker/analytics/priority-scores`
    ] as const;
    }

    
export const getGetV1AdminWorkerAnalyticsPriorityScoresQueryOptions = <TData = Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsPriorityScores>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsPriorityScores>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AdminWorkerAnalyticsPriorityScoresQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsPriorityScores>>> = ({ signal }) => getV1AdminWorkerAnalyticsPriorityScores(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsPriorityScores>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AdminWorkerAnalyticsPriorityScoresQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsPriorityScores>>>
export type GetV1AdminWorkerAnalyticsPriorityScoresQueryError = ErrorResponse


export function useGetV1AdminWorkerAnalyticsPriorityScores<TData = Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsPriorityScores>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsPriorityScores>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsPriorityScores>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsPriorityScores>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminWorkerAnalyticsPriorityScores<TData = Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsPriorityScores>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsPriorityScores>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsPriorityScores>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsPriorityScores>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminWorkerAnalyticsPriorityScores<TData = Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsPriorityScores>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsPriorityScores>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get worker priority analytics
 */

export function useGetV1AdminWorkerAnalyticsPriorityScores<TData = Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsPriorityScores>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsPriorityScores>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AdminWorkerAnalyticsPriorityScoresQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Get user performance analytics from the worker (admin only)
 * @summary Get worker user performance analytics
 */
export const getV1AdminWorkerAnalyticsUserPerformance = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<UserPerformanceAnalytics>(
      {url: `/v1/admin/worker/analytics/user-performance`, method: 'GET', signal
    },
      options);
    }
  



export const getGetV1AdminWorkerAnalyticsUserPerformanceQueryKey = () => {
    return [
    `/v1/admin/worker/analytics/user-performance`
    ] as const;
    }

    
export const getGetV1AdminWorkerAnalyticsUserPerformanceQueryOptions = <TData = Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsUserPerformance>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsUserPerformance>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AdminWorkerAnalyticsUserPerformanceQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsUserPerformance>>> = ({ signal }) => getV1AdminWorkerAnalyticsUserPerformance(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsUserPerformance>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AdminWorkerAnalyticsUserPerformanceQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsUserPerformance>>>
export type GetV1AdminWorkerAnalyticsUserPerformanceQueryError = ErrorResponse


export function useGetV1AdminWorkerAnalyticsUserPerformance<TData = Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsUserPerformance>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsUserPerformance>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsUserPerformance>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsUserPerformance>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminWorkerAnalyticsUserPerformance<TData = Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsUserPerformance>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsUserPerformance>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsUserPerformance>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsUserPerformance>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminWorkerAnalyticsUserPerformance<TData = Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsUserPerformance>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsUserPerformance>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get worker user performance analytics
 */

export function useGetV1AdminWorkerAnalyticsUserPerformance<TData = Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsUserPerformance>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsUserPerformance>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AdminWorkerAnalyticsUserPerformanceQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Get generation intelligence from the worker (admin only)
 * @summary Get worker generation intelligence
 */
export const getV1AdminWorkerAnalyticsGenerationIntelligence = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GenerationIntelligence>(
      {url: `/v1/admin/worker/analytics/generation-intelligence`, method: 'GET', signal
    },
      options);
    }
  



export const getGetV1AdminWorkerAnalyticsGenerationIntelligenceQueryKey = () => {
    return [
    `/v1/admin/worker/analytics/generation-intelligence`
    ] as const;
    }

    
export const getGetV1AdminWorkerAnalyticsGenerationIntelligenceQueryOptions = <TData = Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsGenerationIntelligence>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsGenerationIntelligence>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AdminWorkerAnalyticsGenerationIntelligenceQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsGenerationIntelligence>>> = ({ signal }) => getV1AdminWorkerAnalyticsGenerationIntelligence(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsGenerationIntelligence>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AdminWorkerAnalyticsGenerationIntelligenceQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsGenerationIntelligence>>>
export type GetV1AdminWorkerAnalyticsGenerationIntelligenceQueryError = ErrorResponse


export function useGetV1AdminWorkerAnalyticsGenerationIntelligence<TData = Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsGenerationIntelligence>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsGenerationIntelligence>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsGenerationIntelligence>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsGenerationIntelligence>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminWorkerAnalyticsGenerationIntelligence<TData = Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsGenerationIntelligence>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsGenerationIntelligence>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsGenerationIntelligence>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsGenerationIntelligence>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminWorkerAnalyticsGenerationIntelligence<TData = Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsGenerationIntelligence>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsGenerationIntelligence>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get worker generation intelligence
 */

export function useGetV1AdminWorkerAnalyticsGenerationIntelligence<TData = Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsGenerationIntelligence>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsGenerationIntelligence>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AdminWorkerAnalyticsGenerationIntelligenceQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Get system health analytics from the worker (admin only)
 * @summary Get worker system health analytics
 */
export const getV1AdminWorkerAnalyticsSystemHealth = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<SystemHealthAnalytics>(
      {url: `/v1/admin/worker/analytics/system-health`, method: 'GET', signal
    },
      options);
    }
  



export const getGetV1AdminWorkerAnalyticsSystemHealthQueryKey = () => {
    return [
    `/v1/admin/worker/analytics/system-health`
    ] as const;
    }

    
export const getGetV1AdminWorkerAnalyticsSystemHealthQueryOptions = <TData = Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsSystemHealth>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsSystemHealth>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AdminWorkerAnalyticsSystemHealthQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsSystemHealth>>> = ({ signal }) => getV1AdminWorkerAnalyticsSystemHealth(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsSystemHealth>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AdminWorkerAnalyticsSystemHealthQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsSystemHealth>>>
export type GetV1AdminWorkerAnalyticsSystemHealthQueryError = ErrorResponse


export function useGetV1AdminWorkerAnalyticsSystemHealth<TData = Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsSystemHealth>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsSystemHealth>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsSystemHealth>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsSystemHealth>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminWorkerAnalyticsSystemHealth<TData = Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsSystemHealth>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsSystemHealth>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsSystemHealth>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsSystemHealth>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminWorkerAnalyticsSystemHealth<TData = Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsSystemHealth>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsSystemHealth>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get worker system health analytics
 */

export function useGetV1AdminWorkerAnalyticsSystemHealth<TData = Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsSystemHealth>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerAnalyticsSystemHealth>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AdminWorkerAnalyticsSystemHealthQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Get comprehensive notification statistics including sent count, error count, and user statistics (admin only)
 * @summary Get notification statistics
 */
export const getV1AdminWorkerNotificationsStats = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<NotificationStats>(
      {url: `/v1/admin/worker/notifications/stats`, method: 'GET', signal
    },
      options);
    }
  



export const getGetV1AdminWorkerNotificationsStatsQueryKey = () => {
    return [
    `/v1/admin/worker/notifications/stats`
    ] as const;
    }

    
export const getGetV1AdminWorkerNotificationsStatsQueryOptions = <TData = Awaited<ReturnType<typeof getV1AdminWorkerNotificationsStats>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerNotificationsStats>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AdminWorkerNotificationsStatsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AdminWorkerNotificationsStats>>> = ({ signal }) => getV1AdminWorkerNotificationsStats(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerNotificationsStats>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AdminWorkerNotificationsStatsQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AdminWorkerNotificationsStats>>>
export type GetV1AdminWorkerNotificationsStatsQueryError = ErrorResponse


export function useGetV1AdminWorkerNotificationsStats<TData = Awaited<ReturnType<typeof getV1AdminWorkerNotificationsStats>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerNotificationsStats>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminWorkerNotificationsStats>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminWorkerNotificationsStats>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminWorkerNotificationsStats<TData = Awaited<ReturnType<typeof getV1AdminWorkerNotificationsStats>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerNotificationsStats>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminWorkerNotificationsStats>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminWorkerNotificationsStats>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminWorkerNotificationsStats<TData = Awaited<ReturnType<typeof getV1AdminWorkerNotificationsStats>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerNotificationsStats>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get notification statistics
 */

export function useGetV1AdminWorkerNotificationsStats<TData = Awaited<ReturnType<typeof getV1AdminWorkerNotificationsStats>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerNotificationsStats>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AdminWorkerNotificationsStatsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Get paginated list of notification errors with filtering options (admin only)
 * @summary Get notification errors
 */
export const getV1AdminWorkerNotificationsErrors = (
    params?: GetV1AdminWorkerNotificationsErrorsParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<WorkerNotificationErrorsResponse>(
      {url: `/v1/admin/worker/notifications/errors`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getGetV1AdminWorkerNotificationsErrorsQueryKey = (params?: GetV1AdminWorkerNotificationsErrorsParams,) => {
    return [
    `/v1/admin/worker/notifications/errors`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetV1AdminWorkerNotificationsErrorsQueryOptions = <TData = Awaited<ReturnType<typeof getV1AdminWorkerNotificationsErrors>>, TError = ErrorResponse>(params?: GetV1AdminWorkerNotificationsErrorsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerNotificationsErrors>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AdminWorkerNotificationsErrorsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AdminWorkerNotificationsErrors>>> = ({ signal }) => getV1AdminWorkerNotificationsErrors(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerNotificationsErrors>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AdminWorkerNotificationsErrorsQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AdminWorkerNotificationsErrors>>>
export type GetV1AdminWorkerNotificationsErrorsQueryError = ErrorResponse


export function useGetV1AdminWorkerNotificationsErrors<TData = Awaited<ReturnType<typeof getV1AdminWorkerNotificationsErrors>>, TError = ErrorResponse>(
 params: undefined |  GetV1AdminWorkerNotificationsErrorsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerNotificationsErrors>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminWorkerNotificationsErrors>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminWorkerNotificationsErrors>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminWorkerNotificationsErrors<TData = Awaited<ReturnType<typeof getV1AdminWorkerNotificationsErrors>>, TError = ErrorResponse>(
 params?: GetV1AdminWorkerNotificationsErrorsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerNotificationsErrors>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminWorkerNotificationsErrors>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminWorkerNotificationsErrors>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminWorkerNotificationsErrors<TData = Awaited<ReturnType<typeof getV1AdminWorkerNotificationsErrors>>, TError = ErrorResponse>(
 params?: GetV1AdminWorkerNotificationsErrorsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerNotificationsErrors>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get notification errors
 */

export function useGetV1AdminWorkerNotificationsErrors<TData = Awaited<ReturnType<typeof getV1AdminWorkerNotificationsErrors>>, TError = ErrorResponse>(
 params?: GetV1AdminWorkerNotificationsErrorsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerNotificationsErrors>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AdminWorkerNotificationsErrorsQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Get paginated list of sent notifications with filtering options (admin only)
 * @summary Get sent notifications
 */
export const getV1AdminWorkerNotificationsSent = (
    params?: GetV1AdminWorkerNotificationsSentParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<WorkerNotificationSentResponse>(
      {url: `/v1/admin/worker/notifications/sent`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getGetV1AdminWorkerNotificationsSentQueryKey = (params?: GetV1AdminWorkerNotificationsSentParams,) => {
    return [
    `/v1/admin/worker/notifications/sent`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetV1AdminWorkerNotificationsSentQueryOptions = <TData = Awaited<ReturnType<typeof getV1AdminWorkerNotificationsSent>>, TError = ErrorResponse>(params?: GetV1AdminWorkerNotificationsSentParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerNotificationsSent>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AdminWorkerNotificationsSentQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AdminWorkerNotificationsSent>>> = ({ signal }) => getV1AdminWorkerNotificationsSent(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerNotificationsSent>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AdminWorkerNotificationsSentQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AdminWorkerNotificationsSent>>>
export type GetV1AdminWorkerNotificationsSentQueryError = ErrorResponse


export function useGetV1AdminWorkerNotificationsSent<TData = Awaited<ReturnType<typeof getV1AdminWorkerNotificationsSent>>, TError = ErrorResponse>(
 params: undefined |  GetV1AdminWorkerNotificationsSentParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerNotificationsSent>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminWorkerNotificationsSent>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminWorkerNotificationsSent>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminWorkerNotificationsSent<TData = Awaited<ReturnType<typeof getV1AdminWorkerNotificationsSent>>, TError = ErrorResponse>(
 params?: GetV1AdminWorkerNotificationsSentParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerNotificationsSent>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminWorkerNotificationsSent>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminWorkerNotificationsSent>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminWorkerNotificationsSent<TData = Awaited<ReturnType<typeof getV1AdminWorkerNotificationsSent>>, TError = ErrorResponse>(
 params?: GetV1AdminWorkerNotificationsSentParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerNotificationsSent>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get sent notifications
 */

export function useGetV1AdminWorkerNotificationsSent<TData = Awaited<ReturnType<typeof getV1AdminWorkerNotificationsSent>>, TError = ErrorResponse>(
 params?: GetV1AdminWorkerNotificationsSentParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerNotificationsSent>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AdminWorkerNotificationsSentQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Force send a daily reminder notification to a specific user, bypassing normal time and date checks (admin only)
 * @summary Force send notification to user
 */
export const postV1AdminWorkerNotificationsForceSend = (
    postV1AdminWorkerNotificationsForceSendBody: PostV1AdminWorkerNotificationsForceSendBody,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<ForceSendNotificationResponse>(
      {url: `/v1/admin/worker/notifications/force-send`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: postV1AdminWorkerNotificationsForceSendBody, signal
    },
      options);
    }
  


export const getPostV1AdminWorkerNotificationsForceSendMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AdminWorkerNotificationsForceSend>>, TError,{data: PostV1AdminWorkerNotificationsForceSendBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postV1AdminWorkerNotificationsForceSend>>, TError,{data: PostV1AdminWorkerNotificationsForceSendBody}, TContext> => {

const mutationKey = ['postV1AdminWorkerNotificationsForceSend'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1AdminWorkerNotificationsForceSend>>, {data: PostV1AdminWorkerNotificationsForceSendBody}> = (props) => {
          const {data} = props ?? {};

          return  postV1AdminWorkerNotificationsForceSend(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1AdminWorkerNotificationsForceSendMutationResult = NonNullable<Awaited<ReturnType<typeof postV1AdminWorkerNotificationsForceSend>>>
    export type PostV1AdminWorkerNotificationsForceSendMutationBody = PostV1AdminWorkerNotificationsForceSendBody
    export type PostV1AdminWorkerNotificationsForceSendMutationError = ErrorResponse

    /**
 * @summary Force send notification to user
 */
export const usePostV1AdminWorkerNotificationsForceSend = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AdminWorkerNotificationsForceSend>>, TError,{data: PostV1AdminWorkerNotificationsForceSendBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postV1AdminWorkerNotificationsForceSend>>,
        TError,
        {data: PostV1AdminWorkerNotificationsForceSendBody},
        TContext
      > => {

      const mutationOptions = getPostV1AdminWorkerNotificationsForceSendMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Get all questions in the system with pagination, search, and filtering options (admin only)
 * @summary Get all questions with pagination and filtering
 */
export const getV1AdminBackendQuestions = (
    params?: GetV1AdminBackendQuestionsParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<AdminQuestionsResponse>(
      {url: `/v1/admin/backend/questions`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getGetV1AdminBackendQuestionsQueryKey = (params?: GetV1AdminBackendQuestionsParams,) => {
    return [
    `/v1/admin/backend/questions`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetV1AdminBackendQuestionsQueryOptions = <TData = Awaited<ReturnType<typeof getV1AdminBackendQuestions>>, TError = ErrorResponse>(params?: GetV1AdminBackendQuestionsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendQuestions>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AdminBackendQuestionsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AdminBackendQuestions>>> = ({ signal }) => getV1AdminBackendQuestions(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendQuestions>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AdminBackendQuestionsQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AdminBackendQuestions>>>
export type GetV1AdminBackendQuestionsQueryError = ErrorResponse


export function useGetV1AdminBackendQuestions<TData = Awaited<ReturnType<typeof getV1AdminBackendQuestions>>, TError = ErrorResponse>(
 params: undefined |  GetV1AdminBackendQuestionsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendQuestions>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminBackendQuestions>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminBackendQuestions>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminBackendQuestions<TData = Awaited<ReturnType<typeof getV1AdminBackendQuestions>>, TError = ErrorResponse>(
 params?: GetV1AdminBackendQuestionsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendQuestions>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminBackendQuestions>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminBackendQuestions>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminBackendQuestions<TData = Awaited<ReturnType<typeof getV1AdminBackendQuestions>>, TError = ErrorResponse>(
 params?: GetV1AdminBackendQuestionsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendQuestions>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get all questions with pagination and filtering
 */

export function useGetV1AdminBackendQuestions<TData = Awaited<ReturnType<typeof getV1AdminBackendQuestions>>, TError = ErrorResponse>(
 params?: GetV1AdminBackendQuestionsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendQuestions>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AdminBackendQuestionsQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Get questions with pagination support (admin only)
 * @summary Get paginated questions
 */
export const getV1AdminBackendQuestionsPaginated = (
    params?: GetV1AdminBackendQuestionsPaginatedParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<AdminQuestionsResponse>(
      {url: `/v1/admin/backend/questions/paginated`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getGetV1AdminBackendQuestionsPaginatedQueryKey = (params?: GetV1AdminBackendQuestionsPaginatedParams,) => {
    return [
    `/v1/admin/backend/questions/paginated`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetV1AdminBackendQuestionsPaginatedQueryOptions = <TData = Awaited<ReturnType<typeof getV1AdminBackendQuestionsPaginated>>, TError = ErrorResponse>(params?: GetV1AdminBackendQuestionsPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendQuestionsPaginated>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AdminBackendQuestionsPaginatedQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AdminBackendQuestionsPaginated>>> = ({ signal }) => getV1AdminBackendQuestionsPaginated(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendQuestionsPaginated>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AdminBackendQuestionsPaginatedQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AdminBackendQuestionsPaginated>>>
export type GetV1AdminBackendQuestionsPaginatedQueryError = ErrorResponse


export function useGetV1AdminBackendQuestionsPaginated<TData = Awaited<ReturnType<typeof getV1AdminBackendQuestionsPaginated>>, TError = ErrorResponse>(
 params: undefined |  GetV1AdminBackendQuestionsPaginatedParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendQuestionsPaginated>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminBackendQuestionsPaginated>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminBackendQuestionsPaginated>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminBackendQuestionsPaginated<TData = Awaited<ReturnType<typeof getV1AdminBackendQuestionsPaginated>>, TError = ErrorResponse>(
 params?: GetV1AdminBackendQuestionsPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendQuestionsPaginated>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminBackendQuestionsPaginated>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminBackendQuestionsPaginated>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminBackendQuestionsPaginated<TData = Awaited<ReturnType<typeof getV1AdminBackendQuestionsPaginated>>, TError = ErrorResponse>(
 params?: GetV1AdminBackendQuestionsPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendQuestionsPaginated>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get paginated questions
 */

export function useGetV1AdminBackendQuestionsPaginated<TData = Awaited<ReturnType<typeof getV1AdminBackendQuestionsPaginated>>, TError = ErrorResponse>(
 params?: GetV1AdminBackendQuestionsPaginatedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendQuestionsPaginated>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AdminBackendQuestionsPaginatedQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Get a specific question by its ID for editing (admin only)
 * @summary Get a single question by ID
 */
export const getV1AdminBackendQuestionsId = (
    id: number,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<Question>(
      {url: `/v1/admin/backend/questions/${id}`, method: 'GET', signal
    },
      options);
    }
  



export const getGetV1AdminBackendQuestionsIdQueryKey = (id?: number,) => {
    return [
    `/v1/admin/backend/questions/${id}`
    ] as const;
    }

    
export const getGetV1AdminBackendQuestionsIdQueryOptions = <TData = Awaited<ReturnType<typeof getV1AdminBackendQuestionsId>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendQuestionsId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AdminBackendQuestionsIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AdminBackendQuestionsId>>> = ({ signal }) => getV1AdminBackendQuestionsId(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendQuestionsId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AdminBackendQuestionsIdQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AdminBackendQuestionsId>>>
export type GetV1AdminBackendQuestionsIdQueryError = ErrorResponse


export function useGetV1AdminBackendQuestionsId<TData = Awaited<ReturnType<typeof getV1AdminBackendQuestionsId>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendQuestionsId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminBackendQuestionsId>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminBackendQuestionsId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminBackendQuestionsId<TData = Awaited<ReturnType<typeof getV1AdminBackendQuestionsId>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendQuestionsId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminBackendQuestionsId>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminBackendQuestionsId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminBackendQuestionsId<TData = Awaited<ReturnType<typeof getV1AdminBackendQuestionsId>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendQuestionsId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get a single question by ID
 */

export function useGetV1AdminBackendQuestionsId<TData = Awaited<ReturnType<typeof getV1AdminBackendQuestionsId>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendQuestionsId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AdminBackendQuestionsIdQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Update a specific question by its ID (admin only)
 * @summary Update a question
 */
export const putV1AdminBackendQuestionsId = (
    id: number,
    putV1AdminBackendQuestionsIdBody: PutV1AdminBackendQuestionsIdBody,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<MessageResponse>(
      {url: `/v1/admin/backend/questions/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: putV1AdminBackendQuestionsIdBody
    },
      options);
    }
  


export const getPutV1AdminBackendQuestionsIdMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putV1AdminBackendQuestionsId>>, TError,{id: number;data: PutV1AdminBackendQuestionsIdBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof putV1AdminBackendQuestionsId>>, TError,{id: number;data: PutV1AdminBackendQuestionsIdBody}, TContext> => {

const mutationKey = ['putV1AdminBackendQuestionsId'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putV1AdminBackendQuestionsId>>, {id: number;data: PutV1AdminBackendQuestionsIdBody}> = (props) => {
          const {id,data} = props ?? {};

          return  putV1AdminBackendQuestionsId(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PutV1AdminBackendQuestionsIdMutationResult = NonNullable<Awaited<ReturnType<typeof putV1AdminBackendQuestionsId>>>
    export type PutV1AdminBackendQuestionsIdMutationBody = PutV1AdminBackendQuestionsIdBody
    export type PutV1AdminBackendQuestionsIdMutationError = ErrorResponse

    /**
 * @summary Update a question
 */
export const usePutV1AdminBackendQuestionsId = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putV1AdminBackendQuestionsId>>, TError,{id: number;data: PutV1AdminBackendQuestionsIdBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof putV1AdminBackendQuestionsId>>,
        TError,
        {id: number;data: PutV1AdminBackendQuestionsIdBody},
        TContext
      > => {

      const mutationOptions = getPutV1AdminBackendQuestionsIdMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Delete a specific question by its ID (admin only)
 * @summary Delete a question
 */
export const deleteV1AdminBackendQuestionsId = (
    id: number,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<MessageResponse>(
      {url: `/v1/admin/backend/questions/${id}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteV1AdminBackendQuestionsIdMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteV1AdminBackendQuestionsId>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteV1AdminBackendQuestionsId>>, TError,{id: number}, TContext> => {

const mutationKey = ['deleteV1AdminBackendQuestionsId'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteV1AdminBackendQuestionsId>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteV1AdminBackendQuestionsId(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteV1AdminBackendQuestionsIdMutationResult = NonNullable<Awaited<ReturnType<typeof deleteV1AdminBackendQuestionsId>>>
    
    export type DeleteV1AdminBackendQuestionsIdMutationError = ErrorResponse

    /**
 * @summary Delete a question
 */
export const useDeleteV1AdminBackendQuestionsId = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteV1AdminBackendQuestionsId>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteV1AdminBackendQuestionsId>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteV1AdminBackendQuestionsIdMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Get the users assigned to a specific question, showing up to 5 users and the total count (admin only)
 * @summary Get users assigned to a question
 */
export const getV1AdminBackendQuestionsIdUsers = (
    id: number,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<QuestionAssignedUsersResponse>(
      {url: `/v1/admin/backend/questions/${id}/users`, method: 'GET', signal
    },
      options);
    }
  



export const getGetV1AdminBackendQuestionsIdUsersQueryKey = (id?: number,) => {
    return [
    `/v1/admin/backend/questions/${id}/users`
    ] as const;
    }

    
export const getGetV1AdminBackendQuestionsIdUsersQueryOptions = <TData = Awaited<ReturnType<typeof getV1AdminBackendQuestionsIdUsers>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendQuestionsIdUsers>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AdminBackendQuestionsIdUsersQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AdminBackendQuestionsIdUsers>>> = ({ signal }) => getV1AdminBackendQuestionsIdUsers(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendQuestionsIdUsers>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AdminBackendQuestionsIdUsersQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AdminBackendQuestionsIdUsers>>>
export type GetV1AdminBackendQuestionsIdUsersQueryError = ErrorResponse


export function useGetV1AdminBackendQuestionsIdUsers<TData = Awaited<ReturnType<typeof getV1AdminBackendQuestionsIdUsers>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendQuestionsIdUsers>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminBackendQuestionsIdUsers>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminBackendQuestionsIdUsers>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminBackendQuestionsIdUsers<TData = Awaited<ReturnType<typeof getV1AdminBackendQuestionsIdUsers>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendQuestionsIdUsers>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminBackendQuestionsIdUsers>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminBackendQuestionsIdUsers>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminBackendQuestionsIdUsers<TData = Awaited<ReturnType<typeof getV1AdminBackendQuestionsIdUsers>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendQuestionsIdUsers>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get users assigned to a question
 */

export function useGetV1AdminBackendQuestionsIdUsers<TData = Awaited<ReturnType<typeof getV1AdminBackendQuestionsIdUsers>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendQuestionsIdUsers>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AdminBackendQuestionsIdUsersQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Assign multiple users to a specific question (admin only)
 * @summary Assign users to a question
 */
export const postV1AdminBackendQuestionsIdAssignUsers = (
    id: number,
    postV1AdminBackendQuestionsIdAssignUsersBody: PostV1AdminBackendQuestionsIdAssignUsersBody,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<MessageResponse>(
      {url: `/v1/admin/backend/questions/${id}/assign-users`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: postV1AdminBackendQuestionsIdAssignUsersBody, signal
    },
      options);
    }
  


export const getPostV1AdminBackendQuestionsIdAssignUsersMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AdminBackendQuestionsIdAssignUsers>>, TError,{id: number;data: PostV1AdminBackendQuestionsIdAssignUsersBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postV1AdminBackendQuestionsIdAssignUsers>>, TError,{id: number;data: PostV1AdminBackendQuestionsIdAssignUsersBody}, TContext> => {

const mutationKey = ['postV1AdminBackendQuestionsIdAssignUsers'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1AdminBackendQuestionsIdAssignUsers>>, {id: number;data: PostV1AdminBackendQuestionsIdAssignUsersBody}> = (props) => {
          const {id,data} = props ?? {};

          return  postV1AdminBackendQuestionsIdAssignUsers(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1AdminBackendQuestionsIdAssignUsersMutationResult = NonNullable<Awaited<ReturnType<typeof postV1AdminBackendQuestionsIdAssignUsers>>>
    export type PostV1AdminBackendQuestionsIdAssignUsersMutationBody = PostV1AdminBackendQuestionsIdAssignUsersBody
    export type PostV1AdminBackendQuestionsIdAssignUsersMutationError = ErrorResponse

    /**
 * @summary Assign users to a question
 */
export const usePostV1AdminBackendQuestionsIdAssignUsers = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AdminBackendQuestionsIdAssignUsers>>, TError,{id: number;data: PostV1AdminBackendQuestionsIdAssignUsersBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postV1AdminBackendQuestionsIdAssignUsers>>,
        TError,
        {id: number;data: PostV1AdminBackendQuestionsIdAssignUsersBody},
        TContext
      > => {

      const mutationOptions = getPostV1AdminBackendQuestionsIdAssignUsersMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Remove multiple users from a specific question (admin only)
 * @summary Unassign users from a question
 */
export const postV1AdminBackendQuestionsIdUnassignUsers = (
    id: number,
    postV1AdminBackendQuestionsIdUnassignUsersBody: PostV1AdminBackendQuestionsIdUnassignUsersBody,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<MessageResponse>(
      {url: `/v1/admin/backend/questions/${id}/unassign-users`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: postV1AdminBackendQuestionsIdUnassignUsersBody, signal
    },
      options);
    }
  


export const getPostV1AdminBackendQuestionsIdUnassignUsersMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AdminBackendQuestionsIdUnassignUsers>>, TError,{id: number;data: PostV1AdminBackendQuestionsIdUnassignUsersBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postV1AdminBackendQuestionsIdUnassignUsers>>, TError,{id: number;data: PostV1AdminBackendQuestionsIdUnassignUsersBody}, TContext> => {

const mutationKey = ['postV1AdminBackendQuestionsIdUnassignUsers'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1AdminBackendQuestionsIdUnassignUsers>>, {id: number;data: PostV1AdminBackendQuestionsIdUnassignUsersBody}> = (props) => {
          const {id,data} = props ?? {};

          return  postV1AdminBackendQuestionsIdUnassignUsers(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1AdminBackendQuestionsIdUnassignUsersMutationResult = NonNullable<Awaited<ReturnType<typeof postV1AdminBackendQuestionsIdUnassignUsers>>>
    export type PostV1AdminBackendQuestionsIdUnassignUsersMutationBody = PostV1AdminBackendQuestionsIdUnassignUsersBody
    export type PostV1AdminBackendQuestionsIdUnassignUsersMutationError = ErrorResponse

    /**
 * @summary Unassign users from a question
 */
export const usePostV1AdminBackendQuestionsIdUnassignUsers = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AdminBackendQuestionsIdUnassignUsers>>, TError,{id: number;data: PostV1AdminBackendQuestionsIdUnassignUsersBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postV1AdminBackendQuestionsIdUnassignUsers>>,
        TError,
        {id: number;data: PostV1AdminBackendQuestionsIdUnassignUsersBody},
        TContext
      > => {

      const mutationOptions = getPostV1AdminBackendQuestionsIdUnassignUsersMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Mark a reported question as fixed (admin only)
 * @summary Mark question as fixed
 */
export const postV1AdminBackendQuestionsIdFix = (
    id: number,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<MessageResponse>(
      {url: `/v1/admin/backend/questions/${id}/fix`, method: 'POST', signal
    },
      options);
    }
  


export const getPostV1AdminBackendQuestionsIdFixMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AdminBackendQuestionsIdFix>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postV1AdminBackendQuestionsIdFix>>, TError,{id: number}, TContext> => {

const mutationKey = ['postV1AdminBackendQuestionsIdFix'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1AdminBackendQuestionsIdFix>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  postV1AdminBackendQuestionsIdFix(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1AdminBackendQuestionsIdFixMutationResult = NonNullable<Awaited<ReturnType<typeof postV1AdminBackendQuestionsIdFix>>>
    
    export type PostV1AdminBackendQuestionsIdFixMutationError = ErrorResponse

    /**
 * @summary Mark question as fixed
 */
export const usePostV1AdminBackendQuestionsIdFix = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AdminBackendQuestionsIdFix>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postV1AdminBackendQuestionsIdFix>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getPostV1AdminBackendQuestionsIdFixMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Use AI to automatically fix a reported question (admin only)
 * @summary Fix question with AI
 */
export const postV1AdminBackendQuestionsIdAiFix = (
    id: number,
    postV1AdminBackendQuestionsIdAiFixBody?: PostV1AdminBackendQuestionsIdAiFixBody,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<AIFixResponse>(
      {url: `/v1/admin/backend/questions/${id}/ai-fix`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: postV1AdminBackendQuestionsIdAiFixBody, signal
    },
      options);
    }
  


export const getPostV1AdminBackendQuestionsIdAiFixMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AdminBackendQuestionsIdAiFix>>, TError,{id: number;data: PostV1AdminBackendQuestionsIdAiFixBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postV1AdminBackendQuestionsIdAiFix>>, TError,{id: number;data: PostV1AdminBackendQuestionsIdAiFixBody}, TContext> => {

const mutationKey = ['postV1AdminBackendQuestionsIdAiFix'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1AdminBackendQuestionsIdAiFix>>, {id: number;data: PostV1AdminBackendQuestionsIdAiFixBody}> = (props) => {
          const {id,data} = props ?? {};

          return  postV1AdminBackendQuestionsIdAiFix(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1AdminBackendQuestionsIdAiFixMutationResult = NonNullable<Awaited<ReturnType<typeof postV1AdminBackendQuestionsIdAiFix>>>
    export type PostV1AdminBackendQuestionsIdAiFixMutationBody = PostV1AdminBackendQuestionsIdAiFixBody
    export type PostV1AdminBackendQuestionsIdAiFixMutationError = ErrorResponse

    /**
 * @summary Fix question with AI
 */
export const usePostV1AdminBackendQuestionsIdAiFix = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AdminBackendQuestionsIdAiFix>>, TError,{id: number;data: PostV1AdminBackendQuestionsIdAiFixBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postV1AdminBackendQuestionsIdAiFix>>,
        TError,
        {id: number;data: PostV1AdminBackendQuestionsIdAiFixBody},
        TContext
      > => {

      const mutationOptions = getPostV1AdminBackendQuestionsIdAiFixMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Clear all user data including questions, responses, and stats (admin only)
 * @summary Clear all user data
 */
export const postV1AdminBackendClearUserData = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<MessageResponse>(
      {url: `/v1/admin/backend/clear-user-data`, method: 'POST', signal
    },
      options);
    }
  


export const getPostV1AdminBackendClearUserDataMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AdminBackendClearUserData>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postV1AdminBackendClearUserData>>, TError,void, TContext> => {

const mutationKey = ['postV1AdminBackendClearUserData'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1AdminBackendClearUserData>>, void> = () => {
          

          return  postV1AdminBackendClearUserData(requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1AdminBackendClearUserDataMutationResult = NonNullable<Awaited<ReturnType<typeof postV1AdminBackendClearUserData>>>
    
    export type PostV1AdminBackendClearUserDataMutationError = ErrorResponse

    /**
 * @summary Clear all user data
 */
export const usePostV1AdminBackendClearUserData = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AdminBackendClearUserData>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postV1AdminBackendClearUserData>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getPostV1AdminBackendClearUserDataMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Clear all data from the database (admin only)
 * @summary Clear entire database
 */
export const postV1AdminBackendClearDatabase = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<MessageResponse>(
      {url: `/v1/admin/backend/clear-database`, method: 'POST', signal
    },
      options);
    }
  


export const getPostV1AdminBackendClearDatabaseMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AdminBackendClearDatabase>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postV1AdminBackendClearDatabase>>, TError,void, TContext> => {

const mutationKey = ['postV1AdminBackendClearDatabase'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1AdminBackendClearDatabase>>, void> = () => {
          

          return  postV1AdminBackendClearDatabase(requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1AdminBackendClearDatabaseMutationResult = NonNullable<Awaited<ReturnType<typeof postV1AdminBackendClearDatabase>>>
    
    export type PostV1AdminBackendClearDatabaseMutationError = ErrorResponse

    /**
 * @summary Clear entire database
 */
export const usePostV1AdminBackendClearDatabase = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AdminBackendClearDatabase>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postV1AdminBackendClearDatabase>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getPostV1AdminBackendClearDatabaseMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Clear all data for a specific user including questions, responses, and stats (admin only)
 * @summary Clear user data for specific user
 */
export const postV1AdminBackendUserzIdClear = (
    id: number,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<MessageResponse>(
      {url: `/v1/admin/backend/userz/${id}/clear`, method: 'POST', signal
    },
      options);
    }
  


export const getPostV1AdminBackendUserzIdClearMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AdminBackendUserzIdClear>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postV1AdminBackendUserzIdClear>>, TError,{id: number}, TContext> => {

const mutationKey = ['postV1AdminBackendUserzIdClear'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1AdminBackendUserzIdClear>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  postV1AdminBackendUserzIdClear(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1AdminBackendUserzIdClearMutationResult = NonNullable<Awaited<ReturnType<typeof postV1AdminBackendUserzIdClear>>>
    
    export type PostV1AdminBackendUserzIdClearMutationError = ErrorResponse

    /**
 * @summary Clear user data for specific user
 */
export const usePostV1AdminBackendUserzIdClear = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AdminBackendUserzIdClear>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postV1AdminBackendUserzIdClear>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getPostV1AdminBackendUserzIdClearMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Get comprehensive usage statistics for all services (admin only)
 * @summary Get usage statistics
 */
export const getV1AdminBackendUsageStats = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<UsageStatsResponse>(
      {url: `/v1/admin/backend/usage-stats`, method: 'GET', signal
    },
      options);
    }
  



export const getGetV1AdminBackendUsageStatsQueryKey = () => {
    return [
    `/v1/admin/backend/usage-stats`
    ] as const;
    }

    
export const getGetV1AdminBackendUsageStatsQueryOptions = <TData = Awaited<ReturnType<typeof getV1AdminBackendUsageStats>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendUsageStats>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AdminBackendUsageStatsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AdminBackendUsageStats>>> = ({ signal }) => getV1AdminBackendUsageStats(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendUsageStats>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AdminBackendUsageStatsQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AdminBackendUsageStats>>>
export type GetV1AdminBackendUsageStatsQueryError = ErrorResponse


export function useGetV1AdminBackendUsageStats<TData = Awaited<ReturnType<typeof getV1AdminBackendUsageStats>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendUsageStats>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminBackendUsageStats>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminBackendUsageStats>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminBackendUsageStats<TData = Awaited<ReturnType<typeof getV1AdminBackendUsageStats>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendUsageStats>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminBackendUsageStats>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminBackendUsageStats>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminBackendUsageStats<TData = Awaited<ReturnType<typeof getV1AdminBackendUsageStats>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendUsageStats>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get usage statistics
 */

export function useGetV1AdminBackendUsageStats<TData = Awaited<ReturnType<typeof getV1AdminBackendUsageStats>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendUsageStats>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AdminBackendUsageStatsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Get usage statistics for a specific translation service (admin only)
 * @summary Get usage statistics for specific service
 */
export const getV1AdminBackendUsageStatsService = (
    service: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<ServiceUsageStatsResponse>(
      {url: `/v1/admin/backend/usage-stats/${service}`, method: 'GET', signal
    },
      options);
    }
  



export const getGetV1AdminBackendUsageStatsServiceQueryKey = (service?: string,) => {
    return [
    `/v1/admin/backend/usage-stats/${service}`
    ] as const;
    }

    
export const getGetV1AdminBackendUsageStatsServiceQueryOptions = <TData = Awaited<ReturnType<typeof getV1AdminBackendUsageStatsService>>, TError = ErrorResponse>(service: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendUsageStatsService>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AdminBackendUsageStatsServiceQueryKey(service);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AdminBackendUsageStatsService>>> = ({ signal }) => getV1AdminBackendUsageStatsService(service, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(service), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendUsageStatsService>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AdminBackendUsageStatsServiceQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AdminBackendUsageStatsService>>>
export type GetV1AdminBackendUsageStatsServiceQueryError = ErrorResponse


export function useGetV1AdminBackendUsageStatsService<TData = Awaited<ReturnType<typeof getV1AdminBackendUsageStatsService>>, TError = ErrorResponse>(
 service: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendUsageStatsService>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminBackendUsageStatsService>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminBackendUsageStatsService>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminBackendUsageStatsService<TData = Awaited<ReturnType<typeof getV1AdminBackendUsageStatsService>>, TError = ErrorResponse>(
 service: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendUsageStatsService>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminBackendUsageStatsService>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminBackendUsageStatsService>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminBackendUsageStatsService<TData = Awaited<ReturnType<typeof getV1AdminBackendUsageStatsService>>, TError = ErrorResponse>(
 service: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendUsageStatsService>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get usage statistics for specific service
 */

export function useGetV1AdminBackendUsageStatsService<TData = Awaited<ReturnType<typeof getV1AdminBackendUsageStatsService>>, TError = ErrorResponse>(
 service: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendUsageStatsService>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AdminBackendUsageStatsServiceQueryOptions(service,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Get all reported questions with pagination, search, and filtering options (admin only)
 * @summary Get reported questions with pagination and filtering
 */
export const getV1AdminBackendReportedQuestions = (
    params?: GetV1AdminBackendReportedQuestionsParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<AdminReportedQuestionsResponse>(
      {url: `/v1/admin/backend/reported-questions`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getGetV1AdminBackendReportedQuestionsQueryKey = (params?: GetV1AdminBackendReportedQuestionsParams,) => {
    return [
    `/v1/admin/backend/reported-questions`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetV1AdminBackendReportedQuestionsQueryOptions = <TData = Awaited<ReturnType<typeof getV1AdminBackendReportedQuestions>>, TError = ErrorResponse>(params?: GetV1AdminBackendReportedQuestionsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendReportedQuestions>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AdminBackendReportedQuestionsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AdminBackendReportedQuestions>>> = ({ signal }) => getV1AdminBackendReportedQuestions(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendReportedQuestions>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AdminBackendReportedQuestionsQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AdminBackendReportedQuestions>>>
export type GetV1AdminBackendReportedQuestionsQueryError = ErrorResponse


export function useGetV1AdminBackendReportedQuestions<TData = Awaited<ReturnType<typeof getV1AdminBackendReportedQuestions>>, TError = ErrorResponse>(
 params: undefined |  GetV1AdminBackendReportedQuestionsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendReportedQuestions>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminBackendReportedQuestions>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminBackendReportedQuestions>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminBackendReportedQuestions<TData = Awaited<ReturnType<typeof getV1AdminBackendReportedQuestions>>, TError = ErrorResponse>(
 params?: GetV1AdminBackendReportedQuestionsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendReportedQuestions>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminBackendReportedQuestions>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminBackendReportedQuestions>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminBackendReportedQuestions<TData = Awaited<ReturnType<typeof getV1AdminBackendReportedQuestions>>, TError = ErrorResponse>(
 params?: GetV1AdminBackendReportedQuestionsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendReportedQuestions>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get reported questions with pagination and filtering
 */

export function useGetV1AdminBackendReportedQuestions<TData = Awaited<ReturnType<typeof getV1AdminBackendReportedQuestions>>, TError = ErrorResponse>(
 params?: GetV1AdminBackendReportedQuestionsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendReportedQuestions>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AdminBackendReportedQuestionsQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Get all user stories with pagination, search, and filtering options (admin only)
 * @summary Get all stories with pagination and filtering
 */
export const getV1AdminBackendStories = (
    params?: GetV1AdminBackendStoriesParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<AdminStoriesResponse>(
      {url: `/v1/admin/backend/stories`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getGetV1AdminBackendStoriesQueryKey = (params?: GetV1AdminBackendStoriesParams,) => {
    return [
    `/v1/admin/backend/stories`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetV1AdminBackendStoriesQueryOptions = <TData = Awaited<ReturnType<typeof getV1AdminBackendStories>>, TError = ErrorResponse>(params?: GetV1AdminBackendStoriesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendStories>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AdminBackendStoriesQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AdminBackendStories>>> = ({ signal }) => getV1AdminBackendStories(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendStories>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AdminBackendStoriesQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AdminBackendStories>>>
export type GetV1AdminBackendStoriesQueryError = ErrorResponse


export function useGetV1AdminBackendStories<TData = Awaited<ReturnType<typeof getV1AdminBackendStories>>, TError = ErrorResponse>(
 params: undefined |  GetV1AdminBackendStoriesParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendStories>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminBackendStories>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminBackendStories>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminBackendStories<TData = Awaited<ReturnType<typeof getV1AdminBackendStories>>, TError = ErrorResponse>(
 params?: GetV1AdminBackendStoriesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendStories>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminBackendStories>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminBackendStories>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminBackendStories<TData = Awaited<ReturnType<typeof getV1AdminBackendStories>>, TError = ErrorResponse>(
 params?: GetV1AdminBackendStoriesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendStories>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get all stories with pagination and filtering
 */

export function useGetV1AdminBackendStories<TData = Awaited<ReturnType<typeof getV1AdminBackendStories>>, TError = ErrorResponse>(
 params?: GetV1AdminBackendStoriesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendStories>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AdminBackendStoriesQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Get a specific story with its sections (admin only)
 * @summary Get a single story by ID (with sections)
 */
export const getV1AdminBackendStoriesId = (
    id: number,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<StoryWithSections>(
      {url: `/v1/admin/backend/stories/${id}`, method: 'GET', signal
    },
      options);
    }
  



export const getGetV1AdminBackendStoriesIdQueryKey = (id?: number,) => {
    return [
    `/v1/admin/backend/stories/${id}`
    ] as const;
    }

    
export const getGetV1AdminBackendStoriesIdQueryOptions = <TData = Awaited<ReturnType<typeof getV1AdminBackendStoriesId>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendStoriesId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AdminBackendStoriesIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AdminBackendStoriesId>>> = ({ signal }) => getV1AdminBackendStoriesId(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendStoriesId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AdminBackendStoriesIdQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AdminBackendStoriesId>>>
export type GetV1AdminBackendStoriesIdQueryError = ErrorResponse


export function useGetV1AdminBackendStoriesId<TData = Awaited<ReturnType<typeof getV1AdminBackendStoriesId>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendStoriesId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminBackendStoriesId>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminBackendStoriesId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminBackendStoriesId<TData = Awaited<ReturnType<typeof getV1AdminBackendStoriesId>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendStoriesId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminBackendStoriesId>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminBackendStoriesId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminBackendStoriesId<TData = Awaited<ReturnType<typeof getV1AdminBackendStoriesId>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendStoriesId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get a single story by ID (with sections)
 */

export function useGetV1AdminBackendStoriesId<TData = Awaited<ReturnType<typeof getV1AdminBackendStoriesId>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendStoriesId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AdminBackendStoriesIdQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Delete a user story by ID. Admins can delete stories regardless of status. Admin only.
 * @summary Delete a story (admin)
 */
export const deleteV1AdminBackendStoriesId = (
    id: number,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/v1/admin/backend/stories/${id}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteV1AdminBackendStoriesIdMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteV1AdminBackendStoriesId>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteV1AdminBackendStoriesId>>, TError,{id: number}, TContext> => {

const mutationKey = ['deleteV1AdminBackendStoriesId'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteV1AdminBackendStoriesId>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteV1AdminBackendStoriesId(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteV1AdminBackendStoriesIdMutationResult = NonNullable<Awaited<ReturnType<typeof deleteV1AdminBackendStoriesId>>>
    
    export type DeleteV1AdminBackendStoriesIdMutationError = ErrorResponse

    /**
 * @summary Delete a story (admin)
 */
export const useDeleteV1AdminBackendStoriesId = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteV1AdminBackendStoriesId>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteV1AdminBackendStoriesId>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteV1AdminBackendStoriesIdMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Get a specific story section and its questions (admin only)
 * @summary Get a story section with questions by ID
 */
export const getV1AdminBackendStorySectionsId = (
    id: number,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<StorySectionWithQuestions>(
      {url: `/v1/admin/backend/story-sections/${id}`, method: 'GET', signal
    },
      options);
    }
  



export const getGetV1AdminBackendStorySectionsIdQueryKey = (id?: number,) => {
    return [
    `/v1/admin/backend/story-sections/${id}`
    ] as const;
    }

    
export const getGetV1AdminBackendStorySectionsIdQueryOptions = <TData = Awaited<ReturnType<typeof getV1AdminBackendStorySectionsId>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendStorySectionsId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AdminBackendStorySectionsIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AdminBackendStorySectionsId>>> = ({ signal }) => getV1AdminBackendStorySectionsId(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendStorySectionsId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AdminBackendStorySectionsIdQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AdminBackendStorySectionsId>>>
export type GetV1AdminBackendStorySectionsIdQueryError = ErrorResponse


export function useGetV1AdminBackendStorySectionsId<TData = Awaited<ReturnType<typeof getV1AdminBackendStorySectionsId>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendStorySectionsId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminBackendStorySectionsId>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminBackendStorySectionsId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminBackendStorySectionsId<TData = Awaited<ReturnType<typeof getV1AdminBackendStorySectionsId>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendStorySectionsId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminBackendStorySectionsId>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminBackendStorySectionsId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminBackendStorySectionsId<TData = Awaited<ReturnType<typeof getV1AdminBackendStorySectionsId>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendStorySectionsId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get a story section with questions by ID
 */

export function useGetV1AdminBackendStorySectionsId<TData = Awaited<ReturnType<typeof getV1AdminBackendStorySectionsId>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendStorySectionsId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AdminBackendStorySectionsIdQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Get a streaming AI-powered explanation or chat about a question.
 */
export const postV1QuizChatStream = (
    quizChatRequest: QuizChatRequest,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<string>(
      {url: `/v1/quiz/chat/stream`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: quizChatRequest, signal
    },
      options);
    }
  


export const getPostV1QuizChatStreamMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1QuizChatStream>>, TError,{data: QuizChatRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postV1QuizChatStream>>, TError,{data: QuizChatRequest}, TContext> => {

const mutationKey = ['postV1QuizChatStream'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1QuizChatStream>>, {data: QuizChatRequest}> = (props) => {
          const {data} = props ?? {};

          return  postV1QuizChatStream(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1QuizChatStreamMutationResult = NonNullable<Awaited<ReturnType<typeof postV1QuizChatStream>>>
    export type PostV1QuizChatStreamMutationBody = QuizChatRequest
    export type PostV1QuizChatStreamMutationError = ErrorResponse

    /**
 * @summary Get a streaming AI-powered explanation or chat about a question.
 */
export const usePostV1QuizChatStream = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1QuizChatStream>>, TError,{data: QuizChatRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postV1QuizChatStream>>,
        TError,
        {data: QuizChatRequest},
        TContext
      > => {

      const mutationOptions = getPostV1QuizChatStreamMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Retrieve all daily questions assigned to the user for a specific date
 * @summary Get daily questions for a specific date
 */
export const getV1DailyQuestionsDate = (
    date: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<DailyQuestionsResponse>(
      {url: `/v1/daily/questions/${date}`, method: 'GET', signal
    },
      options);
    }
  



export const getGetV1DailyQuestionsDateQueryKey = (date?: string,) => {
    return [
    `/v1/daily/questions/${date}`
    ] as const;
    }

    
export const getGetV1DailyQuestionsDateQueryOptions = <TData = Awaited<ReturnType<typeof getV1DailyQuestionsDate>>, TError = ErrorResponse>(date: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1DailyQuestionsDate>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1DailyQuestionsDateQueryKey(date);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1DailyQuestionsDate>>> = ({ signal }) => getV1DailyQuestionsDate(date, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(date), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1DailyQuestionsDate>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1DailyQuestionsDateQueryResult = NonNullable<Awaited<ReturnType<typeof getV1DailyQuestionsDate>>>
export type GetV1DailyQuestionsDateQueryError = ErrorResponse


export function useGetV1DailyQuestionsDate<TData = Awaited<ReturnType<typeof getV1DailyQuestionsDate>>, TError = ErrorResponse>(
 date: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1DailyQuestionsDate>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1DailyQuestionsDate>>,
          TError,
          Awaited<ReturnType<typeof getV1DailyQuestionsDate>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1DailyQuestionsDate<TData = Awaited<ReturnType<typeof getV1DailyQuestionsDate>>, TError = ErrorResponse>(
 date: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1DailyQuestionsDate>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1DailyQuestionsDate>>,
          TError,
          Awaited<ReturnType<typeof getV1DailyQuestionsDate>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1DailyQuestionsDate<TData = Awaited<ReturnType<typeof getV1DailyQuestionsDate>>, TError = ErrorResponse>(
 date: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1DailyQuestionsDate>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get daily questions for a specific date
 */

export function useGetV1DailyQuestionsDate<TData = Awaited<ReturnType<typeof getV1DailyQuestionsDate>>, TError = ErrorResponse>(
 date: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1DailyQuestionsDate>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1DailyQuestionsDateQueryOptions(date,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Mark a specific daily question as completed for the given date
 * @summary Mark daily question as completed
 */
export const postV1DailyQuestionsDateCompleteQuestionId = (
    date: string,
    questionId: number,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<SuccessResponse>(
      {url: `/v1/daily/questions/${date}/complete/${questionId}`, method: 'POST', signal
    },
      options);
    }
  


export const getPostV1DailyQuestionsDateCompleteQuestionIdMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1DailyQuestionsDateCompleteQuestionId>>, TError,{date: string;questionId: number}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postV1DailyQuestionsDateCompleteQuestionId>>, TError,{date: string;questionId: number}, TContext> => {

const mutationKey = ['postV1DailyQuestionsDateCompleteQuestionId'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1DailyQuestionsDateCompleteQuestionId>>, {date: string;questionId: number}> = (props) => {
          const {date,questionId} = props ?? {};

          return  postV1DailyQuestionsDateCompleteQuestionId(date,questionId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1DailyQuestionsDateCompleteQuestionIdMutationResult = NonNullable<Awaited<ReturnType<typeof postV1DailyQuestionsDateCompleteQuestionId>>>
    
    export type PostV1DailyQuestionsDateCompleteQuestionIdMutationError = ErrorResponse

    /**
 * @summary Mark daily question as completed
 */
export const usePostV1DailyQuestionsDateCompleteQuestionId = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1DailyQuestionsDateCompleteQuestionId>>, TError,{date: string;questionId: number}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postV1DailyQuestionsDateCompleteQuestionId>>,
        TError,
        {date: string;questionId: number},
        TContext
      > => {

      const mutationOptions = getPostV1DailyQuestionsDateCompleteQuestionIdMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Reset a specific daily question completion status for the given date
 * @summary Reset daily question completion
 */
export const deleteV1DailyQuestionsDateCompleteQuestionId = (
    date: string,
    questionId: number,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<SuccessResponse>(
      {url: `/v1/daily/questions/${date}/complete/${questionId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteV1DailyQuestionsDateCompleteQuestionIdMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteV1DailyQuestionsDateCompleteQuestionId>>, TError,{date: string;questionId: number}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteV1DailyQuestionsDateCompleteQuestionId>>, TError,{date: string;questionId: number}, TContext> => {

const mutationKey = ['deleteV1DailyQuestionsDateCompleteQuestionId'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteV1DailyQuestionsDateCompleteQuestionId>>, {date: string;questionId: number}> = (props) => {
          const {date,questionId} = props ?? {};

          return  deleteV1DailyQuestionsDateCompleteQuestionId(date,questionId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteV1DailyQuestionsDateCompleteQuestionIdMutationResult = NonNullable<Awaited<ReturnType<typeof deleteV1DailyQuestionsDateCompleteQuestionId>>>
    
    export type DeleteV1DailyQuestionsDateCompleteQuestionIdMutationError = ErrorResponse

    /**
 * @summary Reset daily question completion
 */
export const useDeleteV1DailyQuestionsDateCompleteQuestionId = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteV1DailyQuestionsDateCompleteQuestionId>>, TError,{date: string;questionId: number}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteV1DailyQuestionsDateCompleteQuestionId>>,
        TError,
        {date: string;questionId: number},
        TContext
      > => {

      const mutationOptions = getDeleteV1DailyQuestionsDateCompleteQuestionIdMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Retrieve all dates for which the user has daily question assignments
 * @summary Get available dates with daily question assignments
 */
export const getV1DailyDates = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<DailyDatesResponse>(
      {url: `/v1/daily/dates`, method: 'GET', signal
    },
      options);
    }
  



export const getGetV1DailyDatesQueryKey = () => {
    return [
    `/v1/daily/dates`
    ] as const;
    }

    
export const getGetV1DailyDatesQueryOptions = <TData = Awaited<ReturnType<typeof getV1DailyDates>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1DailyDates>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1DailyDatesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1DailyDates>>> = ({ signal }) => getV1DailyDates(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1DailyDates>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1DailyDatesQueryResult = NonNullable<Awaited<ReturnType<typeof getV1DailyDates>>>
export type GetV1DailyDatesQueryError = ErrorResponse


export function useGetV1DailyDates<TData = Awaited<ReturnType<typeof getV1DailyDates>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1DailyDates>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1DailyDates>>,
          TError,
          Awaited<ReturnType<typeof getV1DailyDates>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1DailyDates<TData = Awaited<ReturnType<typeof getV1DailyDates>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1DailyDates>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1DailyDates>>,
          TError,
          Awaited<ReturnType<typeof getV1DailyDates>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1DailyDates<TData = Awaited<ReturnType<typeof getV1DailyDates>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1DailyDates>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get available dates with daily question assignments
 */

export function useGetV1DailyDates<TData = Awaited<ReturnType<typeof getV1DailyDates>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1DailyDates>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1DailyDatesQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Submit an answer for a specific daily question and mark it as completed
 * @summary Submit answer for daily question
 */
export const postV1DailyQuestionsDateAnswerQuestionId = (
    date: string,
    questionId: number,
    postV1DailyQuestionsDateAnswerQuestionIdBody: PostV1DailyQuestionsDateAnswerQuestionIdBody,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<DailyAnswerResponse>(
      {url: `/v1/daily/questions/${date}/answer/${questionId}`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: postV1DailyQuestionsDateAnswerQuestionIdBody, signal
    },
      options);
    }
  


export const getPostV1DailyQuestionsDateAnswerQuestionIdMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1DailyQuestionsDateAnswerQuestionId>>, TError,{date: string;questionId: number;data: PostV1DailyQuestionsDateAnswerQuestionIdBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postV1DailyQuestionsDateAnswerQuestionId>>, TError,{date: string;questionId: number;data: PostV1DailyQuestionsDateAnswerQuestionIdBody}, TContext> => {

const mutationKey = ['postV1DailyQuestionsDateAnswerQuestionId'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1DailyQuestionsDateAnswerQuestionId>>, {date: string;questionId: number;data: PostV1DailyQuestionsDateAnswerQuestionIdBody}> = (props) => {
          const {date,questionId,data} = props ?? {};

          return  postV1DailyQuestionsDateAnswerQuestionId(date,questionId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1DailyQuestionsDateAnswerQuestionIdMutationResult = NonNullable<Awaited<ReturnType<typeof postV1DailyQuestionsDateAnswerQuestionId>>>
    export type PostV1DailyQuestionsDateAnswerQuestionIdMutationBody = PostV1DailyQuestionsDateAnswerQuestionIdBody
    export type PostV1DailyQuestionsDateAnswerQuestionIdMutationError = ErrorResponse

    /**
 * @summary Submit answer for daily question
 */
export const usePostV1DailyQuestionsDateAnswerQuestionId = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1DailyQuestionsDateAnswerQuestionId>>, TError,{date: string;questionId: number;data: PostV1DailyQuestionsDateAnswerQuestionIdBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postV1DailyQuestionsDateAnswerQuestionId>>,
        TError,
        {date: string;questionId: number;data: PostV1DailyQuestionsDateAnswerQuestionIdBody},
        TContext
      > => {

      const mutationOptions = getPostV1DailyQuestionsDateAnswerQuestionIdMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Get progress information (completed vs total questions) for a specific date
 * @summary Get daily progress for a specific date
 */
export const getV1DailyProgressDate = (
    date: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<DailyProgress>(
      {url: `/v1/daily/progress/${date}`, method: 'GET', signal
    },
      options);
    }
  



export const getGetV1DailyProgressDateQueryKey = (date?: string,) => {
    return [
    `/v1/daily/progress/${date}`
    ] as const;
    }

    
export const getGetV1DailyProgressDateQueryOptions = <TData = Awaited<ReturnType<typeof getV1DailyProgressDate>>, TError = ErrorResponse>(date: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1DailyProgressDate>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1DailyProgressDateQueryKey(date);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1DailyProgressDate>>> = ({ signal }) => getV1DailyProgressDate(date, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(date), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1DailyProgressDate>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1DailyProgressDateQueryResult = NonNullable<Awaited<ReturnType<typeof getV1DailyProgressDate>>>
export type GetV1DailyProgressDateQueryError = ErrorResponse


export function useGetV1DailyProgressDate<TData = Awaited<ReturnType<typeof getV1DailyProgressDate>>, TError = ErrorResponse>(
 date: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1DailyProgressDate>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1DailyProgressDate>>,
          TError,
          Awaited<ReturnType<typeof getV1DailyProgressDate>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1DailyProgressDate<TData = Awaited<ReturnType<typeof getV1DailyProgressDate>>, TError = ErrorResponse>(
 date: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1DailyProgressDate>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1DailyProgressDate>>,
          TError,
          Awaited<ReturnType<typeof getV1DailyProgressDate>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1DailyProgressDate<TData = Awaited<ReturnType<typeof getV1DailyProgressDate>>, TError = ErrorResponse>(
 date: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1DailyProgressDate>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get daily progress for a specific date
 */

export function useGetV1DailyProgressDate<TData = Awaited<ReturnType<typeof getV1DailyProgressDate>>, TError = ErrorResponse>(
 date: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1DailyProgressDate>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1DailyProgressDateQueryOptions(date,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Retrieve the history of a specific question for the user over the last 14 days
 * @summary Get question history
 */
export const getV1DailyHistoryQuestionId = (
    questionId: number,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<DailyQuestionHistoryResponse>(
      {url: `/v1/daily/history/${questionId}`, method: 'GET', signal
    },
      options);
    }
  



export const getGetV1DailyHistoryQuestionIdQueryKey = (questionId?: number,) => {
    return [
    `/v1/daily/history/${questionId}`
    ] as const;
    }

    
export const getGetV1DailyHistoryQuestionIdQueryOptions = <TData = Awaited<ReturnType<typeof getV1DailyHistoryQuestionId>>, TError = ErrorResponse>(questionId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1DailyHistoryQuestionId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1DailyHistoryQuestionIdQueryKey(questionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1DailyHistoryQuestionId>>> = ({ signal }) => getV1DailyHistoryQuestionId(questionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(questionId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1DailyHistoryQuestionId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1DailyHistoryQuestionIdQueryResult = NonNullable<Awaited<ReturnType<typeof getV1DailyHistoryQuestionId>>>
export type GetV1DailyHistoryQuestionIdQueryError = ErrorResponse


export function useGetV1DailyHistoryQuestionId<TData = Awaited<ReturnType<typeof getV1DailyHistoryQuestionId>>, TError = ErrorResponse>(
 questionId: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1DailyHistoryQuestionId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1DailyHistoryQuestionId>>,
          TError,
          Awaited<ReturnType<typeof getV1DailyHistoryQuestionId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1DailyHistoryQuestionId<TData = Awaited<ReturnType<typeof getV1DailyHistoryQuestionId>>, TError = ErrorResponse>(
 questionId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1DailyHistoryQuestionId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1DailyHistoryQuestionId>>,
          TError,
          Awaited<ReturnType<typeof getV1DailyHistoryQuestionId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1DailyHistoryQuestionId<TData = Awaited<ReturnType<typeof getV1DailyHistoryQuestionId>>, TError = ErrorResponse>(
 questionId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1DailyHistoryQuestionId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get question history
 */

export function useGetV1DailyHistoryQuestionId<TData = Awaited<ReturnType<typeof getV1DailyHistoryQuestionId>>, TError = ErrorResponse>(
 questionId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1DailyHistoryQuestionId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1DailyHistoryQuestionIdQueryOptions(questionId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Retrieve the word of the day for a specific date. If not yet assigned, a new word will be automatically selected.
 * @summary Get word of the day
 */
export const getV1WordOfDayDate = (
    date: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<WordOfTheDayDisplay>(
      {url: `/v1/word-of-day/${date}`, method: 'GET', signal
    },
      options);
    }
  



export const getGetV1WordOfDayDateQueryKey = (date?: string,) => {
    return [
    `/v1/word-of-day/${date}`
    ] as const;
    }

    
export const getGetV1WordOfDayDateQueryOptions = <TData = Awaited<ReturnType<typeof getV1WordOfDayDate>>, TError = ErrorResponse>(date: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1WordOfDayDate>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1WordOfDayDateQueryKey(date);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1WordOfDayDate>>> = ({ signal }) => getV1WordOfDayDate(date, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(date), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1WordOfDayDate>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1WordOfDayDateQueryResult = NonNullable<Awaited<ReturnType<typeof getV1WordOfDayDate>>>
export type GetV1WordOfDayDateQueryError = ErrorResponse


export function useGetV1WordOfDayDate<TData = Awaited<ReturnType<typeof getV1WordOfDayDate>>, TError = ErrorResponse>(
 date: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1WordOfDayDate>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1WordOfDayDate>>,
          TError,
          Awaited<ReturnType<typeof getV1WordOfDayDate>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1WordOfDayDate<TData = Awaited<ReturnType<typeof getV1WordOfDayDate>>, TError = ErrorResponse>(
 date: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1WordOfDayDate>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1WordOfDayDate>>,
          TError,
          Awaited<ReturnType<typeof getV1WordOfDayDate>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1WordOfDayDate<TData = Awaited<ReturnType<typeof getV1WordOfDayDate>>, TError = ErrorResponse>(
 date: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1WordOfDayDate>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get word of the day
 */

export function useGetV1WordOfDayDate<TData = Awaited<ReturnType<typeof getV1WordOfDayDate>>, TError = ErrorResponse>(
 date: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1WordOfDayDate>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1WordOfDayDateQueryOptions(date,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Returns the word of the day for today when the date is omitted.
 * @summary Get today's word of the day
 */
export const getV1WordOfDay = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<WordOfTheDayDisplay>(
      {url: `/v1/word-of-day`, method: 'GET', signal
    },
      options);
    }
  



export const getGetV1WordOfDayQueryKey = () => {
    return [
    `/v1/word-of-day`
    ] as const;
    }

    
export const getGetV1WordOfDayQueryOptions = <TData = Awaited<ReturnType<typeof getV1WordOfDay>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1WordOfDay>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1WordOfDayQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1WordOfDay>>> = ({ signal }) => getV1WordOfDay(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1WordOfDay>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1WordOfDayQueryResult = NonNullable<Awaited<ReturnType<typeof getV1WordOfDay>>>
export type GetV1WordOfDayQueryError = ErrorResponse


export function useGetV1WordOfDay<TData = Awaited<ReturnType<typeof getV1WordOfDay>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1WordOfDay>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1WordOfDay>>,
          TError,
          Awaited<ReturnType<typeof getV1WordOfDay>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1WordOfDay<TData = Awaited<ReturnType<typeof getV1WordOfDay>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1WordOfDay>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1WordOfDay>>,
          TError,
          Awaited<ReturnType<typeof getV1WordOfDay>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1WordOfDay<TData = Awaited<ReturnType<typeof getV1WordOfDay>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1WordOfDay>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get today's word of the day
 */

export function useGetV1WordOfDay<TData = Awaited<ReturnType<typeof getV1WordOfDay>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1WordOfDay>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1WordOfDayQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Retrieve word of the day as HTML for embedding in an iframe. When no date query parameter is provided, the authenticated user's timezone is used to resolve today's date.
 * @summary Get embeddable word of the day HTML (default date)
 */
export const getV1WordOfDayEmbed = (
    params?: GetV1WordOfDayEmbedParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<string>(
      {url: `/v1/word-of-day/embed`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getGetV1WordOfDayEmbedQueryKey = (params?: GetV1WordOfDayEmbedParams,) => {
    return [
    `/v1/word-of-day/embed`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetV1WordOfDayEmbedQueryOptions = <TData = Awaited<ReturnType<typeof getV1WordOfDayEmbed>>, TError = string>(params?: GetV1WordOfDayEmbedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1WordOfDayEmbed>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1WordOfDayEmbedQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1WordOfDayEmbed>>> = ({ signal }) => getV1WordOfDayEmbed(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1WordOfDayEmbed>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1WordOfDayEmbedQueryResult = NonNullable<Awaited<ReturnType<typeof getV1WordOfDayEmbed>>>
export type GetV1WordOfDayEmbedQueryError = string


export function useGetV1WordOfDayEmbed<TData = Awaited<ReturnType<typeof getV1WordOfDayEmbed>>, TError = string>(
 params: undefined |  GetV1WordOfDayEmbedParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1WordOfDayEmbed>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1WordOfDayEmbed>>,
          TError,
          Awaited<ReturnType<typeof getV1WordOfDayEmbed>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1WordOfDayEmbed<TData = Awaited<ReturnType<typeof getV1WordOfDayEmbed>>, TError = string>(
 params?: GetV1WordOfDayEmbedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1WordOfDayEmbed>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1WordOfDayEmbed>>,
          TError,
          Awaited<ReturnType<typeof getV1WordOfDayEmbed>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1WordOfDayEmbed<TData = Awaited<ReturnType<typeof getV1WordOfDayEmbed>>, TError = string>(
 params?: GetV1WordOfDayEmbedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1WordOfDayEmbed>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get embeddable word of the day HTML (default date)
 */

export function useGetV1WordOfDayEmbed<TData = Awaited<ReturnType<typeof getV1WordOfDayEmbed>>, TError = string>(
 params?: GetV1WordOfDayEmbedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1WordOfDayEmbed>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1WordOfDayEmbedQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Retrieve word of the day as HTML for embedding in an iframe. Supports session authentication or API keys.
 * @summary Get embeddable word of the day HTML
 */
export const getV1WordOfDayDateEmbed = (
    date: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<string>(
      {url: `/v1/word-of-day/${date}/embed`, method: 'GET', signal
    },
      options);
    }
  



export const getGetV1WordOfDayDateEmbedQueryKey = (date?: string,) => {
    return [
    `/v1/word-of-day/${date}/embed`
    ] as const;
    }

    
export const getGetV1WordOfDayDateEmbedQueryOptions = <TData = Awaited<ReturnType<typeof getV1WordOfDayDateEmbed>>, TError = string>(date: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1WordOfDayDateEmbed>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1WordOfDayDateEmbedQueryKey(date);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1WordOfDayDateEmbed>>> = ({ signal }) => getV1WordOfDayDateEmbed(date, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(date), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1WordOfDayDateEmbed>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1WordOfDayDateEmbedQueryResult = NonNullable<Awaited<ReturnType<typeof getV1WordOfDayDateEmbed>>>
export type GetV1WordOfDayDateEmbedQueryError = string


export function useGetV1WordOfDayDateEmbed<TData = Awaited<ReturnType<typeof getV1WordOfDayDateEmbed>>, TError = string>(
 date: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1WordOfDayDateEmbed>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1WordOfDayDateEmbed>>,
          TError,
          Awaited<ReturnType<typeof getV1WordOfDayDateEmbed>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1WordOfDayDateEmbed<TData = Awaited<ReturnType<typeof getV1WordOfDayDateEmbed>>, TError = string>(
 date: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1WordOfDayDateEmbed>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1WordOfDayDateEmbed>>,
          TError,
          Awaited<ReturnType<typeof getV1WordOfDayDateEmbed>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1WordOfDayDateEmbed<TData = Awaited<ReturnType<typeof getV1WordOfDayDateEmbed>>, TError = string>(
 date: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1WordOfDayDateEmbed>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get embeddable word of the day HTML
 */

export function useGetV1WordOfDayDateEmbed<TData = Awaited<ReturnType<typeof getV1WordOfDayDateEmbed>>, TError = string>(
 date: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1WordOfDayDateEmbed>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1WordOfDayDateEmbedQueryOptions(date,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Retrieve historical words of the day for a date range
 * @summary Get word of the day history
 */
export const getV1WordOfDayHistory = (
    params: GetV1WordOfDayHistoryParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<WordOfDayHistoryResponse>(
      {url: `/v1/word-of-day/history`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getGetV1WordOfDayHistoryQueryKey = (params?: GetV1WordOfDayHistoryParams,) => {
    return [
    `/v1/word-of-day/history`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetV1WordOfDayHistoryQueryOptions = <TData = Awaited<ReturnType<typeof getV1WordOfDayHistory>>, TError = ErrorResponse>(params: GetV1WordOfDayHistoryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1WordOfDayHistory>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1WordOfDayHistoryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1WordOfDayHistory>>> = ({ signal }) => getV1WordOfDayHistory(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1WordOfDayHistory>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1WordOfDayHistoryQueryResult = NonNullable<Awaited<ReturnType<typeof getV1WordOfDayHistory>>>
export type GetV1WordOfDayHistoryQueryError = ErrorResponse


export function useGetV1WordOfDayHistory<TData = Awaited<ReturnType<typeof getV1WordOfDayHistory>>, TError = ErrorResponse>(
 params: GetV1WordOfDayHistoryParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1WordOfDayHistory>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1WordOfDayHistory>>,
          TError,
          Awaited<ReturnType<typeof getV1WordOfDayHistory>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1WordOfDayHistory<TData = Awaited<ReturnType<typeof getV1WordOfDayHistory>>, TError = ErrorResponse>(
 params: GetV1WordOfDayHistoryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1WordOfDayHistory>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1WordOfDayHistory>>,
          TError,
          Awaited<ReturnType<typeof getV1WordOfDayHistory>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1WordOfDayHistory<TData = Awaited<ReturnType<typeof getV1WordOfDayHistory>>, TError = ErrorResponse>(
 params: GetV1WordOfDayHistoryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1WordOfDayHistory>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get word of the day history
 */

export function useGetV1WordOfDayHistory<TData = Awaited<ReturnType<typeof getV1WordOfDayHistory>>, TError = ErrorResponse>(
 params: GetV1WordOfDayHistoryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1WordOfDayHistory>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1WordOfDayHistoryQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Create a new story for the authenticated user. The story will automatically become their current active story.
 * @summary Create a new story
 */
export const postV1Story = (
    createStoryRequest: CreateStoryRequest,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<Story>(
      {url: `/v1/story`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createStoryRequest, signal
    },
      options);
    }
  


export const getPostV1StoryMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1Story>>, TError,{data: CreateStoryRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postV1Story>>, TError,{data: CreateStoryRequest}, TContext> => {

const mutationKey = ['postV1Story'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1Story>>, {data: CreateStoryRequest}> = (props) => {
          const {data} = props ?? {};

          return  postV1Story(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1StoryMutationResult = NonNullable<Awaited<ReturnType<typeof postV1Story>>>
    export type PostV1StoryMutationBody = CreateStoryRequest
    export type PostV1StoryMutationError = ErrorResponse

    /**
 * @summary Create a new story
 */
export const usePostV1Story = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1Story>>, TError,{data: CreateStoryRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postV1Story>>,
        TError,
        {data: CreateStoryRequest},
        TContext
      > => {

      const mutationOptions = getPostV1StoryMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Retrieve all stories for the authenticated user, optionally including archived stories.
 * @summary Get user stories
 */
export const getV1Story = (
    params?: GetV1StoryParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<Story[]>(
      {url: `/v1/story`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getGetV1StoryQueryKey = (params?: GetV1StoryParams,) => {
    return [
    `/v1/story`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetV1StoryQueryOptions = <TData = Awaited<ReturnType<typeof getV1Story>>, TError = ErrorResponse>(params?: GetV1StoryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1Story>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1StoryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1Story>>> = ({ signal }) => getV1Story(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1Story>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1StoryQueryResult = NonNullable<Awaited<ReturnType<typeof getV1Story>>>
export type GetV1StoryQueryError = ErrorResponse


export function useGetV1Story<TData = Awaited<ReturnType<typeof getV1Story>>, TError = ErrorResponse>(
 params: undefined |  GetV1StoryParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1Story>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1Story>>,
          TError,
          Awaited<ReturnType<typeof getV1Story>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1Story<TData = Awaited<ReturnType<typeof getV1Story>>, TError = ErrorResponse>(
 params?: GetV1StoryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1Story>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1Story>>,
          TError,
          Awaited<ReturnType<typeof getV1Story>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1Story<TData = Awaited<ReturnType<typeof getV1Story>>, TError = ErrorResponse>(
 params?: GetV1StoryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1Story>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get user stories
 */

export function useGetV1Story<TData = Awaited<ReturnType<typeof getV1Story>>, TError = ErrorResponse>(
 params?: GetV1StoryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1Story>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1StoryQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Retrieve the user's current active story with all sections. If a story exists but has no sections yet, returns 202 with generating status as the first section is being created.
 * @summary Get current story
 */
export const getV1StoryCurrent = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<StoryWithSections | GeneratingResponse>(
      {url: `/v1/story/current`, method: 'GET', signal
    },
      options);
    }
  



export const getGetV1StoryCurrentQueryKey = () => {
    return [
    `/v1/story/current`
    ] as const;
    }

    
export const getGetV1StoryCurrentQueryOptions = <TData = Awaited<ReturnType<typeof getV1StoryCurrent>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1StoryCurrent>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1StoryCurrentQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1StoryCurrent>>> = ({ signal }) => getV1StoryCurrent(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1StoryCurrent>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1StoryCurrentQueryResult = NonNullable<Awaited<ReturnType<typeof getV1StoryCurrent>>>
export type GetV1StoryCurrentQueryError = ErrorResponse


export function useGetV1StoryCurrent<TData = Awaited<ReturnType<typeof getV1StoryCurrent>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1StoryCurrent>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1StoryCurrent>>,
          TError,
          Awaited<ReturnType<typeof getV1StoryCurrent>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1StoryCurrent<TData = Awaited<ReturnType<typeof getV1StoryCurrent>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1StoryCurrent>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1StoryCurrent>>,
          TError,
          Awaited<ReturnType<typeof getV1StoryCurrent>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1StoryCurrent<TData = Awaited<ReturnType<typeof getV1StoryCurrent>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1StoryCurrent>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get current story
 */

export function useGetV1StoryCurrent<TData = Awaited<ReturnType<typeof getV1StoryCurrent>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1StoryCurrent>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1StoryCurrentQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Retrieve a specific story by ID with all sections.
 * @summary Get a specific story
 */
export const getV1StoryId = (
    id: number,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<StoryWithSections>(
      {url: `/v1/story/${id}`, method: 'GET', signal
    },
      options);
    }
  



export const getGetV1StoryIdQueryKey = (id?: number,) => {
    return [
    `/v1/story/${id}`
    ] as const;
    }

    
export const getGetV1StoryIdQueryOptions = <TData = Awaited<ReturnType<typeof getV1StoryId>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1StoryId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1StoryIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1StoryId>>> = ({ signal }) => getV1StoryId(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1StoryId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1StoryIdQueryResult = NonNullable<Awaited<ReturnType<typeof getV1StoryId>>>
export type GetV1StoryIdQueryError = ErrorResponse


export function useGetV1StoryId<TData = Awaited<ReturnType<typeof getV1StoryId>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1StoryId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1StoryId>>,
          TError,
          Awaited<ReturnType<typeof getV1StoryId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1StoryId<TData = Awaited<ReturnType<typeof getV1StoryId>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1StoryId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1StoryId>>,
          TError,
          Awaited<ReturnType<typeof getV1StoryId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1StoryId<TData = Awaited<ReturnType<typeof getV1StoryId>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1StoryId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get a specific story
 */

export function useGetV1StoryId<TData = Awaited<ReturnType<typeof getV1StoryId>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1StoryId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1StoryIdQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Delete a story. Only archived or completed stories can be deleted.
 * @summary Delete a story
 */
export const deleteV1StoryId = (
    id: number,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/v1/story/${id}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteV1StoryIdMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteV1StoryId>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteV1StoryId>>, TError,{id: number}, TContext> => {

const mutationKey = ['deleteV1StoryId'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteV1StoryId>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteV1StoryId(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteV1StoryIdMutationResult = NonNullable<Awaited<ReturnType<typeof deleteV1StoryId>>>
    
    export type DeleteV1StoryIdMutationError = ErrorResponse

    /**
 * @summary Delete a story
 */
export const useDeleteV1StoryId = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteV1StoryId>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteV1StoryId>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteV1StoryIdMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Manually generate the next section for a story. Only allowed once per day.
 * @summary Generate next section
 */
export const postV1StoryIdGenerate = (
    id: number,
    emptyRequest?: EmptyRequest,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<StorySection>(
      {url: `/v1/story/${id}/generate`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: emptyRequest, signal
    },
      options);
    }
  


export const getPostV1StoryIdGenerateMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1StoryIdGenerate>>, TError,{id: number;data: EmptyRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postV1StoryIdGenerate>>, TError,{id: number;data: EmptyRequest}, TContext> => {

const mutationKey = ['postV1StoryIdGenerate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1StoryIdGenerate>>, {id: number;data: EmptyRequest}> = (props) => {
          const {id,data} = props ?? {};

          return  postV1StoryIdGenerate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1StoryIdGenerateMutationResult = NonNullable<Awaited<ReturnType<typeof postV1StoryIdGenerate>>>
    export type PostV1StoryIdGenerateMutationBody = EmptyRequest
    export type PostV1StoryIdGenerateMutationError = ErrorResponse

    /**
 * @summary Generate next section
 */
export const usePostV1StoryIdGenerate = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1StoryIdGenerate>>, TError,{id: number;data: EmptyRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postV1StoryIdGenerate>>,
        TError,
        {id: number;data: EmptyRequest},
        TContext
      > => {

      const mutationOptions = getPostV1StoryIdGenerateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Archive a story, removing it from the current active story.
 * @summary Archive a story
 */
export const postV1StoryIdArchive = (
    id: number,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/v1/story/${id}/archive`, method: 'POST', signal
    },
      options);
    }
  


export const getPostV1StoryIdArchiveMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1StoryIdArchive>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postV1StoryIdArchive>>, TError,{id: number}, TContext> => {

const mutationKey = ['postV1StoryIdArchive'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1StoryIdArchive>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  postV1StoryIdArchive(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1StoryIdArchiveMutationResult = NonNullable<Awaited<ReturnType<typeof postV1StoryIdArchive>>>
    
    export type PostV1StoryIdArchiveMutationError = ErrorResponse

    /**
 * @summary Archive a story
 */
export const usePostV1StoryIdArchive = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1StoryIdArchive>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postV1StoryIdArchive>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getPostV1StoryIdArchiveMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Mark a story as completed.
 * @summary Complete a story
 */
export const postV1StoryIdComplete = (
    id: number,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/v1/story/${id}/complete`, method: 'POST', signal
    },
      options);
    }
  


export const getPostV1StoryIdCompleteMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1StoryIdComplete>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postV1StoryIdComplete>>, TError,{id: number}, TContext> => {

const mutationKey = ['postV1StoryIdComplete'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1StoryIdComplete>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  postV1StoryIdComplete(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1StoryIdCompleteMutationResult = NonNullable<Awaited<ReturnType<typeof postV1StoryIdComplete>>>
    
    export type PostV1StoryIdCompleteMutationError = ErrorResponse

    /**
 * @summary Complete a story
 */
export const usePostV1StoryIdComplete = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1StoryIdComplete>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postV1StoryIdComplete>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getPostV1StoryIdCompleteMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Set a story as the user's current active story.
 * @summary Set story as current
 */
export const postV1StoryIdSetCurrent = (
    id: number,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/v1/story/${id}/set-current`, method: 'POST', signal
    },
      options);
    }
  


export const getPostV1StoryIdSetCurrentMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1StoryIdSetCurrent>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postV1StoryIdSetCurrent>>, TError,{id: number}, TContext> => {

const mutationKey = ['postV1StoryIdSetCurrent'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1StoryIdSetCurrent>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  postV1StoryIdSetCurrent(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1StoryIdSetCurrentMutationResult = NonNullable<Awaited<ReturnType<typeof postV1StoryIdSetCurrent>>>
    
    export type PostV1StoryIdSetCurrentMutationError = ErrorResponse

    /**
 * @summary Set story as current
 */
export const usePostV1StoryIdSetCurrent = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1StoryIdSetCurrent>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postV1StoryIdSetCurrent>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getPostV1StoryIdSetCurrentMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Pause or resume automatic section generation for a story. Manual generation still works when paused.
 * @summary Toggle auto-generation for a story
 */
export const postV1StoryIdToggleAutoGeneration = (
    id: number,
    toggleAutoGenerationRequest: ToggleAutoGenerationRequest,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<ToggleAutoGenerationResponse>(
      {url: `/v1/story/${id}/toggle-auto-generation`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: toggleAutoGenerationRequest, signal
    },
      options);
    }
  


export const getPostV1StoryIdToggleAutoGenerationMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1StoryIdToggleAutoGeneration>>, TError,{id: number;data: ToggleAutoGenerationRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postV1StoryIdToggleAutoGeneration>>, TError,{id: number;data: ToggleAutoGenerationRequest}, TContext> => {

const mutationKey = ['postV1StoryIdToggleAutoGeneration'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1StoryIdToggleAutoGeneration>>, {id: number;data: ToggleAutoGenerationRequest}> = (props) => {
          const {id,data} = props ?? {};

          return  postV1StoryIdToggleAutoGeneration(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1StoryIdToggleAutoGenerationMutationResult = NonNullable<Awaited<ReturnType<typeof postV1StoryIdToggleAutoGeneration>>>
    export type PostV1StoryIdToggleAutoGenerationMutationBody = ToggleAutoGenerationRequest
    export type PostV1StoryIdToggleAutoGenerationMutationError = ErrorResponse

    /**
 * @summary Toggle auto-generation for a story
 */
export const usePostV1StoryIdToggleAutoGeneration = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1StoryIdToggleAutoGeneration>>, TError,{id: number;data: ToggleAutoGenerationRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postV1StoryIdToggleAutoGeneration>>,
        TError,
        {id: number;data: ToggleAutoGenerationRequest},
        TContext
      > => {

      const mutationOptions = getPostV1StoryIdToggleAutoGenerationMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Retrieve a specific story section with its questions.
 * @summary Get a story section
 */
export const getV1StorySectionId = (
    id: number,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<StorySectionWithQuestions>(
      {url: `/v1/story/section/${id}`, method: 'GET', signal
    },
      options);
    }
  



export const getGetV1StorySectionIdQueryKey = (id?: number,) => {
    return [
    `/v1/story/section/${id}`
    ] as const;
    }

    
export const getGetV1StorySectionIdQueryOptions = <TData = Awaited<ReturnType<typeof getV1StorySectionId>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1StorySectionId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1StorySectionIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1StorySectionId>>> = ({ signal }) => getV1StorySectionId(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1StorySectionId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1StorySectionIdQueryResult = NonNullable<Awaited<ReturnType<typeof getV1StorySectionId>>>
export type GetV1StorySectionIdQueryError = ErrorResponse


export function useGetV1StorySectionId<TData = Awaited<ReturnType<typeof getV1StorySectionId>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1StorySectionId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1StorySectionId>>,
          TError,
          Awaited<ReturnType<typeof getV1StorySectionId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1StorySectionId<TData = Awaited<ReturnType<typeof getV1StorySectionId>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1StorySectionId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1StorySectionId>>,
          TError,
          Awaited<ReturnType<typeof getV1StorySectionId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1StorySectionId<TData = Awaited<ReturnType<typeof getV1StorySectionId>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1StorySectionId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get a story section
 */

export function useGetV1StorySectionId<TData = Awaited<ReturnType<typeof getV1StorySectionId>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1StorySectionId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1StorySectionIdQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Generate and download a PDF file containing the complete story.
 * @summary Export story as PDF
 */
export const getV1StoryIdExport = (
    id: number,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<Blob>(
      {url: `/v1/story/${id}/export`, method: 'GET',
        responseType: 'blob', signal
    },
      options);
    }
  



export const getGetV1StoryIdExportQueryKey = (id?: number,) => {
    return [
    `/v1/story/${id}/export`
    ] as const;
    }

    
export const getGetV1StoryIdExportQueryOptions = <TData = Awaited<ReturnType<typeof getV1StoryIdExport>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1StoryIdExport>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1StoryIdExportQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1StoryIdExport>>> = ({ signal }) => getV1StoryIdExport(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1StoryIdExport>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1StoryIdExportQueryResult = NonNullable<Awaited<ReturnType<typeof getV1StoryIdExport>>>
export type GetV1StoryIdExportQueryError = ErrorResponse


export function useGetV1StoryIdExport<TData = Awaited<ReturnType<typeof getV1StoryIdExport>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1StoryIdExport>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1StoryIdExport>>,
          TError,
          Awaited<ReturnType<typeof getV1StoryIdExport>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1StoryIdExport<TData = Awaited<ReturnType<typeof getV1StoryIdExport>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1StoryIdExport>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1StoryIdExport>>,
          TError,
          Awaited<ReturnType<typeof getV1StoryIdExport>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1StoryIdExport<TData = Awaited<ReturnType<typeof getV1StoryIdExport>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1StoryIdExport>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Export story as PDF
 */

export function useGetV1StoryIdExport<TData = Awaited<ReturnType<typeof getV1StoryIdExport>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1StoryIdExport>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1StoryIdExportQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Retrieve the current user's learning preferences
 * @summary Get user learning preferences
 */
export const getV1PreferencesLearning = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<UserLearningPreferences>(
      {url: `/v1/preferences/learning`, method: 'GET', signal
    },
      options);
    }
  



export const getGetV1PreferencesLearningQueryKey = () => {
    return [
    `/v1/preferences/learning`
    ] as const;
    }

    
export const getGetV1PreferencesLearningQueryOptions = <TData = Awaited<ReturnType<typeof getV1PreferencesLearning>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1PreferencesLearning>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1PreferencesLearningQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1PreferencesLearning>>> = ({ signal }) => getV1PreferencesLearning(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1PreferencesLearning>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1PreferencesLearningQueryResult = NonNullable<Awaited<ReturnType<typeof getV1PreferencesLearning>>>
export type GetV1PreferencesLearningQueryError = ErrorResponse


export function useGetV1PreferencesLearning<TData = Awaited<ReturnType<typeof getV1PreferencesLearning>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1PreferencesLearning>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1PreferencesLearning>>,
          TError,
          Awaited<ReturnType<typeof getV1PreferencesLearning>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1PreferencesLearning<TData = Awaited<ReturnType<typeof getV1PreferencesLearning>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1PreferencesLearning>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1PreferencesLearning>>,
          TError,
          Awaited<ReturnType<typeof getV1PreferencesLearning>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1PreferencesLearning<TData = Awaited<ReturnType<typeof getV1PreferencesLearning>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1PreferencesLearning>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get user learning preferences
 */

export function useGetV1PreferencesLearning<TData = Awaited<ReturnType<typeof getV1PreferencesLearning>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1PreferencesLearning>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1PreferencesLearningQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Update the current user's learning preferences
 * @summary Update user learning preferences
 */
export const putV1PreferencesLearning = (
    userLearningPreferences: UserLearningPreferences,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<UserLearningPreferences>(
      {url: `/v1/preferences/learning`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: userLearningPreferences
    },
      options);
    }
  


export const getPutV1PreferencesLearningMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putV1PreferencesLearning>>, TError,{data: UserLearningPreferences}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof putV1PreferencesLearning>>, TError,{data: UserLearningPreferences}, TContext> => {

const mutationKey = ['putV1PreferencesLearning'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putV1PreferencesLearning>>, {data: UserLearningPreferences}> = (props) => {
          const {data} = props ?? {};

          return  putV1PreferencesLearning(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PutV1PreferencesLearningMutationResult = NonNullable<Awaited<ReturnType<typeof putV1PreferencesLearning>>>
    export type PutV1PreferencesLearningMutationBody = UserLearningPreferences
    export type PutV1PreferencesLearningMutationError = ErrorResponse

    /**
 * @summary Update user learning preferences
 */
export const usePutV1PreferencesLearning = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putV1PreferencesLearning>>, TError,{data: UserLearningPreferences}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof putV1PreferencesLearning>>,
        TError,
        {data: UserLearningPreferences},
        TContext
      > => {

      const mutationOptions = getPutV1PreferencesLearningMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Returns aggregated version information for backend and worker services
 * @summary Get service version info
 */
export const getV1Version = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<AggregatedVersion>(
      {url: `/v1/version`, method: 'GET', signal
    },
      options);
    }
  



export const getGetV1VersionQueryKey = () => {
    return [
    `/v1/version`
    ] as const;
    }

    
export const getGetV1VersionQueryOptions = <TData = Awaited<ReturnType<typeof getV1Version>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1Version>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1VersionQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1Version>>> = ({ signal }) => getV1Version(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1Version>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1VersionQueryResult = NonNullable<Awaited<ReturnType<typeof getV1Version>>>
export type GetV1VersionQueryError = unknown


export function useGetV1Version<TData = Awaited<ReturnType<typeof getV1Version>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1Version>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1Version>>,
          TError,
          Awaited<ReturnType<typeof getV1Version>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1Version<TData = Awaited<ReturnType<typeof getV1Version>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1Version>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1Version>>,
          TError,
          Awaited<ReturnType<typeof getV1Version>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1Version<TData = Awaited<ReturnType<typeof getV1Version>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1Version>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get service version info
 */

export function useGetV1Version<TData = Awaited<ReturnType<typeof getV1Version>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1Version>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1VersionQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Returns the health status of the service
 * @summary Health check
 */
export const getHealth = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<HealthStatusResponse>(
      {url: `/health`, method: 'GET', signal
    },
      options);
    }
  



export const getGetHealthQueryKey = () => {
    return [
    `/health`
    ] as const;
    }

    
export const getGetHealthQueryOptions = <TData = Awaited<ReturnType<typeof getHealth>>, TError = HealthErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getHealth>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetHealthQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getHealth>>> = ({ signal }) => getHealth(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getHealth>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetHealthQueryResult = NonNullable<Awaited<ReturnType<typeof getHealth>>>
export type GetHealthQueryError = HealthErrorResponse


export function useGetHealth<TData = Awaited<ReturnType<typeof getHealth>>, TError = HealthErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getHealth>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getHealth>>,
          TError,
          Awaited<ReturnType<typeof getHealth>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetHealth<TData = Awaited<ReturnType<typeof getHealth>>, TError = HealthErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getHealth>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getHealth>>,
          TError,
          Awaited<ReturnType<typeof getHealth>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetHealth<TData = Awaited<ReturnType<typeof getHealth>>, TError = HealthErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getHealth>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Health check
 */

export function useGetHealth<TData = Awaited<ReturnType<typeof getHealth>>, TError = HealthErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getHealth>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetHealthQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Retrieve all daily questions assigned to a specific user for a given date (admin only)
 * @summary Get daily questions for a specific user and date
 */
export const getV1AdminWorkerDailyUsersUserIdQuestionsDate = (
    userId: number,
    date: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<AdminDailyQuestionsResponse>(
      {url: `/v1/admin/worker/daily/users/${userId}/questions/${date}`, method: 'GET', signal
    },
      options);
    }
  



export const getGetV1AdminWorkerDailyUsersUserIdQuestionsDateQueryKey = (userId?: number,
    date?: string,) => {
    return [
    `/v1/admin/worker/daily/users/${userId}/questions/${date}`
    ] as const;
    }

    
export const getGetV1AdminWorkerDailyUsersUserIdQuestionsDateQueryOptions = <TData = Awaited<ReturnType<typeof getV1AdminWorkerDailyUsersUserIdQuestionsDate>>, TError = ErrorResponse>(userId: number,
    date: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerDailyUsersUserIdQuestionsDate>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AdminWorkerDailyUsersUserIdQuestionsDateQueryKey(userId,date);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AdminWorkerDailyUsersUserIdQuestionsDate>>> = ({ signal }) => getV1AdminWorkerDailyUsersUserIdQuestionsDate(userId,date, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(userId && date), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerDailyUsersUserIdQuestionsDate>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AdminWorkerDailyUsersUserIdQuestionsDateQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AdminWorkerDailyUsersUserIdQuestionsDate>>>
export type GetV1AdminWorkerDailyUsersUserIdQuestionsDateQueryError = ErrorResponse


export function useGetV1AdminWorkerDailyUsersUserIdQuestionsDate<TData = Awaited<ReturnType<typeof getV1AdminWorkerDailyUsersUserIdQuestionsDate>>, TError = ErrorResponse>(
 userId: number,
    date: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerDailyUsersUserIdQuestionsDate>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminWorkerDailyUsersUserIdQuestionsDate>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminWorkerDailyUsersUserIdQuestionsDate>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminWorkerDailyUsersUserIdQuestionsDate<TData = Awaited<ReturnType<typeof getV1AdminWorkerDailyUsersUserIdQuestionsDate>>, TError = ErrorResponse>(
 userId: number,
    date: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerDailyUsersUserIdQuestionsDate>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminWorkerDailyUsersUserIdQuestionsDate>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminWorkerDailyUsersUserIdQuestionsDate>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminWorkerDailyUsersUserIdQuestionsDate<TData = Awaited<ReturnType<typeof getV1AdminWorkerDailyUsersUserIdQuestionsDate>>, TError = ErrorResponse>(
 userId: number,
    date: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerDailyUsersUserIdQuestionsDate>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get daily questions for a specific user and date
 */

export function useGetV1AdminWorkerDailyUsersUserIdQuestionsDate<TData = Awaited<ReturnType<typeof getV1AdminWorkerDailyUsersUserIdQuestionsDate>>, TError = ErrorResponse>(
 userId: number,
    date: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminWorkerDailyUsersUserIdQuestionsDate>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AdminWorkerDailyUsersUserIdQuestionsDateQueryOptions(userId,date,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Clear and regenerate daily questions for a specific user and date (admin only)
 * @summary Regenerate daily questions for a specific user and date
 */
export const postV1AdminWorkerDailyUsersUserIdQuestionsDateRegenerate = (
    userId: number,
    date: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<SuccessResponse>(
      {url: `/v1/admin/worker/daily/users/${userId}/questions/${date}/regenerate`, method: 'POST', signal
    },
      options);
    }
  


export const getPostV1AdminWorkerDailyUsersUserIdQuestionsDateRegenerateMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AdminWorkerDailyUsersUserIdQuestionsDateRegenerate>>, TError,{userId: number;date: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postV1AdminWorkerDailyUsersUserIdQuestionsDateRegenerate>>, TError,{userId: number;date: string}, TContext> => {

const mutationKey = ['postV1AdminWorkerDailyUsersUserIdQuestionsDateRegenerate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1AdminWorkerDailyUsersUserIdQuestionsDateRegenerate>>, {userId: number;date: string}> = (props) => {
          const {userId,date} = props ?? {};

          return  postV1AdminWorkerDailyUsersUserIdQuestionsDateRegenerate(userId,date,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1AdminWorkerDailyUsersUserIdQuestionsDateRegenerateMutationResult = NonNullable<Awaited<ReturnType<typeof postV1AdminWorkerDailyUsersUserIdQuestionsDateRegenerate>>>
    
    export type PostV1AdminWorkerDailyUsersUserIdQuestionsDateRegenerateMutationError = ErrorResponse

    /**
 * @summary Regenerate daily questions for a specific user and date
 */
export const usePostV1AdminWorkerDailyUsersUserIdQuestionsDateRegenerate = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AdminWorkerDailyUsersUserIdQuestionsDateRegenerate>>, TError,{userId: number;date: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postV1AdminWorkerDailyUsersUserIdQuestionsDateRegenerate>>,
        TError,
        {userId: number;date: string},
        TContext
      > => {

      const mutationOptions = getPostV1AdminWorkerDailyUsersUserIdQuestionsDateRegenerateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Retrieve feedback reports with filtering and pagination (admin only)
 * @summary Get all feedback reports (paginated)
 */
export const getV1AdminBackendFeedback = (
    params?: GetV1AdminBackendFeedbackParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<FeedbackListResponse>(
      {url: `/v1/admin/backend/feedback`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getGetV1AdminBackendFeedbackQueryKey = (params?: GetV1AdminBackendFeedbackParams,) => {
    return [
    `/v1/admin/backend/feedback`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetV1AdminBackendFeedbackQueryOptions = <TData = Awaited<ReturnType<typeof getV1AdminBackendFeedback>>, TError = ErrorResponse>(params?: GetV1AdminBackendFeedbackParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendFeedback>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AdminBackendFeedbackQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AdminBackendFeedback>>> = ({ signal }) => getV1AdminBackendFeedback(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendFeedback>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AdminBackendFeedbackQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AdminBackendFeedback>>>
export type GetV1AdminBackendFeedbackQueryError = ErrorResponse


export function useGetV1AdminBackendFeedback<TData = Awaited<ReturnType<typeof getV1AdminBackendFeedback>>, TError = ErrorResponse>(
 params: undefined |  GetV1AdminBackendFeedbackParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendFeedback>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminBackendFeedback>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminBackendFeedback>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminBackendFeedback<TData = Awaited<ReturnType<typeof getV1AdminBackendFeedback>>, TError = ErrorResponse>(
 params?: GetV1AdminBackendFeedbackParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendFeedback>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminBackendFeedback>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminBackendFeedback>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminBackendFeedback<TData = Awaited<ReturnType<typeof getV1AdminBackendFeedback>>, TError = ErrorResponse>(
 params?: GetV1AdminBackendFeedbackParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendFeedback>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get all feedback reports (paginated)
 */

export function useGetV1AdminBackendFeedback<TData = Awaited<ReturnType<typeof getV1AdminBackendFeedback>>, TError = ErrorResponse>(
 params?: GetV1AdminBackendFeedbackParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendFeedback>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AdminBackendFeedbackQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Delete all feedback reports with a specific status (bulk delete)
 * @summary Delete feedback reports by status
 */
export const deleteV1AdminBackendFeedback = (
    params: DeleteV1AdminBackendFeedbackParams,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<BulkDeleteResponse>(
      {url: `/v1/admin/backend/feedback`, method: 'DELETE',
        params
    },
      options);
    }
  


export const getDeleteV1AdminBackendFeedbackMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteV1AdminBackendFeedback>>, TError,{params: DeleteV1AdminBackendFeedbackParams}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteV1AdminBackendFeedback>>, TError,{params: DeleteV1AdminBackendFeedbackParams}, TContext> => {

const mutationKey = ['deleteV1AdminBackendFeedback'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteV1AdminBackendFeedback>>, {params: DeleteV1AdminBackendFeedbackParams}> = (props) => {
          const {params} = props ?? {};

          return  deleteV1AdminBackendFeedback(params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteV1AdminBackendFeedbackMutationResult = NonNullable<Awaited<ReturnType<typeof deleteV1AdminBackendFeedback>>>
    
    export type DeleteV1AdminBackendFeedbackMutationError = ErrorResponse

    /**
 * @summary Delete feedback reports by status
 */
export const useDeleteV1AdminBackendFeedback = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteV1AdminBackendFeedback>>, TError,{params: DeleteV1AdminBackendFeedbackParams}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteV1AdminBackendFeedback>>,
        TError,
        {params: DeleteV1AdminBackendFeedbackParams},
        TContext
      > => {

      const mutationOptions = getDeleteV1AdminBackendFeedbackMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Get feedback report details
 */
export const getV1AdminBackendFeedbackId = (
    id: number,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<FeedbackReport>(
      {url: `/v1/admin/backend/feedback/${id}`, method: 'GET', signal
    },
      options);
    }
  



export const getGetV1AdminBackendFeedbackIdQueryKey = (id?: number,) => {
    return [
    `/v1/admin/backend/feedback/${id}`
    ] as const;
    }

    
export const getGetV1AdminBackendFeedbackIdQueryOptions = <TData = Awaited<ReturnType<typeof getV1AdminBackendFeedbackId>>, TError = ErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendFeedbackId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AdminBackendFeedbackIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AdminBackendFeedbackId>>> = ({ signal }) => getV1AdminBackendFeedbackId(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendFeedbackId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AdminBackendFeedbackIdQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AdminBackendFeedbackId>>>
export type GetV1AdminBackendFeedbackIdQueryError = ErrorResponse


export function useGetV1AdminBackendFeedbackId<TData = Awaited<ReturnType<typeof getV1AdminBackendFeedbackId>>, TError = ErrorResponse>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendFeedbackId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminBackendFeedbackId>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminBackendFeedbackId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminBackendFeedbackId<TData = Awaited<ReturnType<typeof getV1AdminBackendFeedbackId>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendFeedbackId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AdminBackendFeedbackId>>,
          TError,
          Awaited<ReturnType<typeof getV1AdminBackendFeedbackId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AdminBackendFeedbackId<TData = Awaited<ReturnType<typeof getV1AdminBackendFeedbackId>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendFeedbackId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get feedback report details
 */

export function useGetV1AdminBackendFeedbackId<TData = Awaited<ReturnType<typeof getV1AdminBackendFeedbackId>>, TError = ErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AdminBackendFeedbackId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AdminBackendFeedbackIdQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary Update feedback report status
 */
export const patchV1AdminBackendFeedbackId = (
    id: number,
    feedbackUpdateRequest: FeedbackUpdateRequest,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<FeedbackReport>(
      {url: `/v1/admin/backend/feedback/${id}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: feedbackUpdateRequest
    },
      options);
    }
  


export const getPatchV1AdminBackendFeedbackIdMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchV1AdminBackendFeedbackId>>, TError,{id: number;data: FeedbackUpdateRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof patchV1AdminBackendFeedbackId>>, TError,{id: number;data: FeedbackUpdateRequest}, TContext> => {

const mutationKey = ['patchV1AdminBackendFeedbackId'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patchV1AdminBackendFeedbackId>>, {id: number;data: FeedbackUpdateRequest}> = (props) => {
          const {id,data} = props ?? {};

          return  patchV1AdminBackendFeedbackId(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatchV1AdminBackendFeedbackIdMutationResult = NonNullable<Awaited<ReturnType<typeof patchV1AdminBackendFeedbackId>>>
    export type PatchV1AdminBackendFeedbackIdMutationBody = FeedbackUpdateRequest
    export type PatchV1AdminBackendFeedbackIdMutationError = ErrorResponse

    /**
 * @summary Update feedback report status
 */
export const usePatchV1AdminBackendFeedbackId = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchV1AdminBackendFeedbackId>>, TError,{id: number;data: FeedbackUpdateRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof patchV1AdminBackendFeedbackId>>,
        TError,
        {id: number;data: FeedbackUpdateRequest},
        TContext
      > => {

      const mutationOptions = getPatchV1AdminBackendFeedbackIdMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Delete a feedback report
 */
export const deleteV1AdminBackendFeedbackId = (
    id: number,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/v1/admin/backend/feedback/${id}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteV1AdminBackendFeedbackIdMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteV1AdminBackendFeedbackId>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteV1AdminBackendFeedbackId>>, TError,{id: number}, TContext> => {

const mutationKey = ['deleteV1AdminBackendFeedbackId'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteV1AdminBackendFeedbackId>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteV1AdminBackendFeedbackId(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteV1AdminBackendFeedbackIdMutationResult = NonNullable<Awaited<ReturnType<typeof deleteV1AdminBackendFeedbackId>>>
    
    export type DeleteV1AdminBackendFeedbackIdMutationError = ErrorResponse

    /**
 * @summary Delete a feedback report
 */
export const useDeleteV1AdminBackendFeedbackId = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteV1AdminBackendFeedbackId>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteV1AdminBackendFeedbackId>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteV1AdminBackendFeedbackIdMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Create a Linear issue from a feedback report (admin only). Requires Linear integration to be enabled.
 * @summary Create Linear issue from feedback
 */
export const postV1AdminBackendFeedbackIdLinearIssue = (
    id: number,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<CreateLinearIssueResponse>(
      {url: `/v1/admin/backend/feedback/${id}/linear-issue`, method: 'POST', signal
    },
      options);
    }
  


export const getPostV1AdminBackendFeedbackIdLinearIssueMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AdminBackendFeedbackIdLinearIssue>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postV1AdminBackendFeedbackIdLinearIssue>>, TError,{id: number}, TContext> => {

const mutationKey = ['postV1AdminBackendFeedbackIdLinearIssue'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1AdminBackendFeedbackIdLinearIssue>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  postV1AdminBackendFeedbackIdLinearIssue(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1AdminBackendFeedbackIdLinearIssueMutationResult = NonNullable<Awaited<ReturnType<typeof postV1AdminBackendFeedbackIdLinearIssue>>>
    
    export type PostV1AdminBackendFeedbackIdLinearIssueMutationError = ErrorResponse

    /**
 * @summary Create Linear issue from feedback
 */
export const usePostV1AdminBackendFeedbackIdLinearIssue = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AdminBackendFeedbackIdLinearIssue>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postV1AdminBackendFeedbackIdLinearIssue>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getPostV1AdminBackendFeedbackIdLinearIssueMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Generate a new API key for programmatic access. The full key is only returned once during creation.
 * @summary Create API key
 */
export const postV1ApiKeys = (
    createAPIKeyRequest: CreateAPIKeyRequest,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<CreateAPIKeyResponse>(
      {url: `/v1/api-keys`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createAPIKeyRequest, signal
    },
      options);
    }
  


export const getPostV1ApiKeysMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1ApiKeys>>, TError,{data: CreateAPIKeyRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postV1ApiKeys>>, TError,{data: CreateAPIKeyRequest}, TContext> => {

const mutationKey = ['postV1ApiKeys'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1ApiKeys>>, {data: CreateAPIKeyRequest}> = (props) => {
          const {data} = props ?? {};

          return  postV1ApiKeys(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1ApiKeysMutationResult = NonNullable<Awaited<ReturnType<typeof postV1ApiKeys>>>
    export type PostV1ApiKeysMutationBody = CreateAPIKeyRequest
    export type PostV1ApiKeysMutationError = ErrorResponse

    /**
 * @summary Create API key
 */
export const usePostV1ApiKeys = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1ApiKeys>>, TError,{data: CreateAPIKeyRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postV1ApiKeys>>,
        TError,
        {data: CreateAPIKeyRequest},
        TContext
      > => {

      const mutationOptions = getPostV1ApiKeysMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Get all API keys for the current user (without exposing the actual keys)
 * @summary List API keys
 */
export const getV1ApiKeys = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<APIKeysListResponse>(
      {url: `/v1/api-keys`, method: 'GET', signal
    },
      options);
    }
  



export const getGetV1ApiKeysQueryKey = () => {
    return [
    `/v1/api-keys`
    ] as const;
    }

    
export const getGetV1ApiKeysQueryOptions = <TData = Awaited<ReturnType<typeof getV1ApiKeys>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ApiKeys>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1ApiKeysQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1ApiKeys>>> = ({ signal }) => getV1ApiKeys(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1ApiKeys>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1ApiKeysQueryResult = NonNullable<Awaited<ReturnType<typeof getV1ApiKeys>>>
export type GetV1ApiKeysQueryError = ErrorResponse


export function useGetV1ApiKeys<TData = Awaited<ReturnType<typeof getV1ApiKeys>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ApiKeys>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1ApiKeys>>,
          TError,
          Awaited<ReturnType<typeof getV1ApiKeys>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1ApiKeys<TData = Awaited<ReturnType<typeof getV1ApiKeys>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ApiKeys>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1ApiKeys>>,
          TError,
          Awaited<ReturnType<typeof getV1ApiKeys>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1ApiKeys<TData = Awaited<ReturnType<typeof getV1ApiKeys>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ApiKeys>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List API keys
 */

export function useGetV1ApiKeys<TData = Awaited<ReturnType<typeof getV1ApiKeys>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ApiKeys>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1ApiKeysQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Permanently delete an API key. This action cannot be undone.
 * @summary Delete API key
 */
export const deleteV1ApiKeysId = (
    id: number,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<DeleteAPIKeyResponse>(
      {url: `/v1/api-keys/${id}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteV1ApiKeysIdMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteV1ApiKeysId>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteV1ApiKeysId>>, TError,{id: number}, TContext> => {

const mutationKey = ['deleteV1ApiKeysId'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteV1ApiKeysId>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteV1ApiKeysId(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteV1ApiKeysIdMutationResult = NonNullable<Awaited<ReturnType<typeof deleteV1ApiKeysId>>>
    
    export type DeleteV1ApiKeysIdMutationError = ErrorResponse

    /**
 * @summary Delete API key
 */
export const useDeleteV1ApiKeysId = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteV1ApiKeysId>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteV1ApiKeysId>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteV1ApiKeysIdMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Verifies an API key can authenticate for read-only operations. Requires Authorization header and ignores cookies.
 * @summary Test API key (readonly)
 */
export const getV1ApiKeysTestRead = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<APIKeyTestResponse>(
      {url: `/v1/api-keys/test-read`, method: 'GET', signal
    },
      options);
    }
  



export const getGetV1ApiKeysTestReadQueryKey = () => {
    return [
    `/v1/api-keys/test-read`
    ] as const;
    }

    
export const getGetV1ApiKeysTestReadQueryOptions = <TData = Awaited<ReturnType<typeof getV1ApiKeysTestRead>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ApiKeysTestRead>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1ApiKeysTestReadQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1ApiKeysTestRead>>> = ({ signal }) => getV1ApiKeysTestRead(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1ApiKeysTestRead>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1ApiKeysTestReadQueryResult = NonNullable<Awaited<ReturnType<typeof getV1ApiKeysTestRead>>>
export type GetV1ApiKeysTestReadQueryError = ErrorResponse


export function useGetV1ApiKeysTestRead<TData = Awaited<ReturnType<typeof getV1ApiKeysTestRead>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ApiKeysTestRead>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1ApiKeysTestRead>>,
          TError,
          Awaited<ReturnType<typeof getV1ApiKeysTestRead>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1ApiKeysTestRead<TData = Awaited<ReturnType<typeof getV1ApiKeysTestRead>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ApiKeysTestRead>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1ApiKeysTestRead>>,
          TError,
          Awaited<ReturnType<typeof getV1ApiKeysTestRead>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1ApiKeysTestRead<TData = Awaited<ReturnType<typeof getV1ApiKeysTestRead>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ApiKeysTestRead>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Test API key (readonly)
 */

export function useGetV1ApiKeysTestRead<TData = Awaited<ReturnType<typeof getV1ApiKeysTestRead>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ApiKeysTestRead>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1ApiKeysTestReadQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Verifies an API key can authenticate for write operations. Readonly keys will receive 403. Requires Authorization header and ignores cookies.
 * @summary Test API key (write)
 */
export const postV1ApiKeysTestWrite = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<APIKeyTestResponse>(
      {url: `/v1/api-keys/test-write`, method: 'POST', signal
    },
      options);
    }
  


export const getPostV1ApiKeysTestWriteMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1ApiKeysTestWrite>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postV1ApiKeysTestWrite>>, TError,void, TContext> => {

const mutationKey = ['postV1ApiKeysTestWrite'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1ApiKeysTestWrite>>, void> = () => {
          

          return  postV1ApiKeysTestWrite(requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1ApiKeysTestWriteMutationResult = NonNullable<Awaited<ReturnType<typeof postV1ApiKeysTestWrite>>>
    
    export type PostV1ApiKeysTestWriteMutationError = ErrorResponse

    /**
 * @summary Test API key (write)
 */
export const usePostV1ApiKeysTestWrite = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1ApiKeysTestWrite>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postV1ApiKeysTestWrite>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getPostV1ApiKeysTestWriteMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Translate text to a target language using configured translation provider
 * @summary Translate text
 */
export const postV1Translate = (
    translateRequest: TranslateRequest,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<TranslateResponse>(
      {url: `/v1/translate`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: translateRequest, signal
    },
      options);
    }
  


export const getPostV1TranslateMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1Translate>>, TError,{data: TranslateRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postV1Translate>>, TError,{data: TranslateRequest}, TContext> => {

const mutationKey = ['postV1Translate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1Translate>>, {data: TranslateRequest}> = (props) => {
          const {data} = props ?? {};

          return  postV1Translate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1TranslateMutationResult = NonNullable<Awaited<ReturnType<typeof postV1Translate>>>
    export type PostV1TranslateMutationBody = TranslateRequest
    export type PostV1TranslateMutationError = ErrorResponse

    /**
 * @summary Translate text
 */
export const usePostV1Translate = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1Translate>>, TError,{data: TranslateRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postV1Translate>>,
        TError,
        {data: TranslateRequest},
        TContext
      > => {

      const mutationOptions = getPostV1TranslateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Generate a new sentence using AI for translation practice
 * @summary Generate a new sentence for translation practice
 */
export const postV1TranslationPracticeGenerate = (
    translationPracticeGenerateRequest: TranslationPracticeGenerateRequest,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<TranslationPracticeSentenceResponse>(
      {url: `/v1/translation-practice/generate`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: translationPracticeGenerateRequest, signal
    },
      options);
    }
  


export const getPostV1TranslationPracticeGenerateMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1TranslationPracticeGenerate>>, TError,{data: TranslationPracticeGenerateRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postV1TranslationPracticeGenerate>>, TError,{data: TranslationPracticeGenerateRequest}, TContext> => {

const mutationKey = ['postV1TranslationPracticeGenerate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1TranslationPracticeGenerate>>, {data: TranslationPracticeGenerateRequest}> = (props) => {
          const {data} = props ?? {};

          return  postV1TranslationPracticeGenerate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1TranslationPracticeGenerateMutationResult = NonNullable<Awaited<ReturnType<typeof postV1TranslationPracticeGenerate>>>
    export type PostV1TranslationPracticeGenerateMutationBody = TranslationPracticeGenerateRequest
    export type PostV1TranslationPracticeGenerateMutationError = ErrorResponse

    /**
 * @summary Generate a new sentence for translation practice
 */
export const usePostV1TranslationPracticeGenerate = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1TranslationPracticeGenerate>>, TError,{data: TranslationPracticeGenerateRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postV1TranslationPracticeGenerate>>,
        TError,
        {data: TranslationPracticeGenerateRequest},
        TContext
      > => {

      const mutationOptions = getPostV1TranslationPracticeGenerateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Retrieve a sentence from existing content (stories, vocabulary, reading comprehension) for translation practice
 * @summary Get a sentence from existing content
 */
export const getV1TranslationPracticeSentence = (
    params: GetV1TranslationPracticeSentenceParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<TranslationPracticeSentenceResponse>(
      {url: `/v1/translation-practice/sentence`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getGetV1TranslationPracticeSentenceQueryKey = (params?: GetV1TranslationPracticeSentenceParams,) => {
    return [
    `/v1/translation-practice/sentence`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetV1TranslationPracticeSentenceQueryOptions = <TData = Awaited<ReturnType<typeof getV1TranslationPracticeSentence>>, TError = ErrorResponse>(params: GetV1TranslationPracticeSentenceParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1TranslationPracticeSentence>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1TranslationPracticeSentenceQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1TranslationPracticeSentence>>> = ({ signal }) => getV1TranslationPracticeSentence(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1TranslationPracticeSentence>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1TranslationPracticeSentenceQueryResult = NonNullable<Awaited<ReturnType<typeof getV1TranslationPracticeSentence>>>
export type GetV1TranslationPracticeSentenceQueryError = ErrorResponse


export function useGetV1TranslationPracticeSentence<TData = Awaited<ReturnType<typeof getV1TranslationPracticeSentence>>, TError = ErrorResponse>(
 params: GetV1TranslationPracticeSentenceParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1TranslationPracticeSentence>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1TranslationPracticeSentence>>,
          TError,
          Awaited<ReturnType<typeof getV1TranslationPracticeSentence>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1TranslationPracticeSentence<TData = Awaited<ReturnType<typeof getV1TranslationPracticeSentence>>, TError = ErrorResponse>(
 params: GetV1TranslationPracticeSentenceParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1TranslationPracticeSentence>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1TranslationPracticeSentence>>,
          TError,
          Awaited<ReturnType<typeof getV1TranslationPracticeSentence>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1TranslationPracticeSentence<TData = Awaited<ReturnType<typeof getV1TranslationPracticeSentence>>, TError = ErrorResponse>(
 params: GetV1TranslationPracticeSentenceParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1TranslationPracticeSentence>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get a sentence from existing content
 */

export function useGetV1TranslationPracticeSentence<TData = Awaited<ReturnType<typeof getV1TranslationPracticeSentence>>, TError = ErrorResponse>(
 params: GetV1TranslationPracticeSentenceParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1TranslationPracticeSentence>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1TranslationPracticeSentenceQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Submit a user's translation for AI evaluation and feedback
 * @summary Submit a translation for evaluation
 */
export const postV1TranslationPracticeSubmit = (
    translationPracticeSubmitRequest: TranslationPracticeSubmitRequest,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<TranslationPracticeSessionResponse>(
      {url: `/v1/translation-practice/submit`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: translationPracticeSubmitRequest, signal
    },
      options);
    }
  


export const getPostV1TranslationPracticeSubmitMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1TranslationPracticeSubmit>>, TError,{data: TranslationPracticeSubmitRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postV1TranslationPracticeSubmit>>, TError,{data: TranslationPracticeSubmitRequest}, TContext> => {

const mutationKey = ['postV1TranslationPracticeSubmit'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1TranslationPracticeSubmit>>, {data: TranslationPracticeSubmitRequest}> = (props) => {
          const {data} = props ?? {};

          return  postV1TranslationPracticeSubmit(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1TranslationPracticeSubmitMutationResult = NonNullable<Awaited<ReturnType<typeof postV1TranslationPracticeSubmit>>>
    export type PostV1TranslationPracticeSubmitMutationBody = TranslationPracticeSubmitRequest
    export type PostV1TranslationPracticeSubmitMutationError = ErrorResponse

    /**
 * @summary Submit a translation for evaluation
 */
export const usePostV1TranslationPracticeSubmit = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1TranslationPracticeSubmit>>, TError,{data: TranslationPracticeSubmitRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postV1TranslationPracticeSubmit>>,
        TError,
        {data: TranslationPracticeSubmitRequest},
        TContext
      > => {

      const mutationOptions = getPostV1TranslationPracticeSubmitMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Retrieve the user's translation practice history
 * @summary Get translation practice history
 */
export const getV1TranslationPracticeHistory = (
    params?: GetV1TranslationPracticeHistoryParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<TranslationPracticeHistoryResponse>(
      {url: `/v1/translation-practice/history`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getGetV1TranslationPracticeHistoryQueryKey = (params?: GetV1TranslationPracticeHistoryParams,) => {
    return [
    `/v1/translation-practice/history`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetV1TranslationPracticeHistoryQueryOptions = <TData = Awaited<ReturnType<typeof getV1TranslationPracticeHistory>>, TError = ErrorResponse>(params?: GetV1TranslationPracticeHistoryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1TranslationPracticeHistory>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1TranslationPracticeHistoryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1TranslationPracticeHistory>>> = ({ signal }) => getV1TranslationPracticeHistory(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1TranslationPracticeHistory>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1TranslationPracticeHistoryQueryResult = NonNullable<Awaited<ReturnType<typeof getV1TranslationPracticeHistory>>>
export type GetV1TranslationPracticeHistoryQueryError = ErrorResponse


export function useGetV1TranslationPracticeHistory<TData = Awaited<ReturnType<typeof getV1TranslationPracticeHistory>>, TError = ErrorResponse>(
 params: undefined |  GetV1TranslationPracticeHistoryParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1TranslationPracticeHistory>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1TranslationPracticeHistory>>,
          TError,
          Awaited<ReturnType<typeof getV1TranslationPracticeHistory>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1TranslationPracticeHistory<TData = Awaited<ReturnType<typeof getV1TranslationPracticeHistory>>, TError = ErrorResponse>(
 params?: GetV1TranslationPracticeHistoryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1TranslationPracticeHistory>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1TranslationPracticeHistory>>,
          TError,
          Awaited<ReturnType<typeof getV1TranslationPracticeHistory>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1TranslationPracticeHistory<TData = Awaited<ReturnType<typeof getV1TranslationPracticeHistory>>, TError = ErrorResponse>(
 params?: GetV1TranslationPracticeHistoryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1TranslationPracticeHistory>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get translation practice history
 */

export function useGetV1TranslationPracticeHistory<TData = Awaited<ReturnType<typeof getV1TranslationPracticeHistory>>, TError = ErrorResponse>(
 params?: GetV1TranslationPracticeHistoryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1TranslationPracticeHistory>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1TranslationPracticeHistoryQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Retrieve statistics about the user's translation practice performance
 * @summary Get translation practice statistics
 */
export const getV1TranslationPracticeStats = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<TranslationPracticeStatsResponse>(
      {url: `/v1/translation-practice/stats`, method: 'GET', signal
    },
      options);
    }
  



export const getGetV1TranslationPracticeStatsQueryKey = () => {
    return [
    `/v1/translation-practice/stats`
    ] as const;
    }

    
export const getGetV1TranslationPracticeStatsQueryOptions = <TData = Awaited<ReturnType<typeof getV1TranslationPracticeStats>>, TError = ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1TranslationPracticeStats>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1TranslationPracticeStatsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1TranslationPracticeStats>>> = ({ signal }) => getV1TranslationPracticeStats(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1TranslationPracticeStats>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1TranslationPracticeStatsQueryResult = NonNullable<Awaited<ReturnType<typeof getV1TranslationPracticeStats>>>
export type GetV1TranslationPracticeStatsQueryError = ErrorResponse


export function useGetV1TranslationPracticeStats<TData = Awaited<ReturnType<typeof getV1TranslationPracticeStats>>, TError = ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1TranslationPracticeStats>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1TranslationPracticeStats>>,
          TError,
          Awaited<ReturnType<typeof getV1TranslationPracticeStats>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1TranslationPracticeStats<TData = Awaited<ReturnType<typeof getV1TranslationPracticeStats>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1TranslationPracticeStats>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1TranslationPracticeStats>>,
          TError,
          Awaited<ReturnType<typeof getV1TranslationPracticeStats>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1TranslationPracticeStats<TData = Awaited<ReturnType<typeof getV1TranslationPracticeStats>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1TranslationPracticeStats>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get translation practice statistics
 */

export function useGetV1TranslationPracticeStats<TData = Awaited<ReturnType<typeof getV1TranslationPracticeStats>>, TError = ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1TranslationPracticeStats>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1TranslationPracticeStatsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Convert text to speech using the TTS service with SSE streaming support
 * @summary Generate speech from text
 */
export const postV1AudioSpeech = (
    tTSRequest: TTSRequest,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<TTSResponse>(
      {url: `/v1/audio/speech`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: tTSRequest, signal
    },
      options);
    }
  


export const getPostV1AudioSpeechMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AudioSpeech>>, TError,{data: TTSRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postV1AudioSpeech>>, TError,{data: TTSRequest}, TContext> => {

const mutationKey = ['postV1AudioSpeech'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1AudioSpeech>>, {data: TTSRequest}> = (props) => {
          const {data} = props ?? {};

          return  postV1AudioSpeech(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1AudioSpeechMutationResult = NonNullable<Awaited<ReturnType<typeof postV1AudioSpeech>>>
    export type PostV1AudioSpeechMutationBody = TTSRequest
    export type PostV1AudioSpeechMutationError = ErrorResponse

    /**
 * @summary Generate speech from text
 */
export const usePostV1AudioSpeech = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AudioSpeech>>, TError,{data: TTSRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postV1AudioSpeech>>,
        TError,
        {data: TTSRequest},
        TContext
      > => {

      const mutationOptions = getPostV1AudioSpeechMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Create and initialize a TTS stream. Returns a stream identifier and optional token to access the streaming audio endpoint.
 * @summary Initialize a TTS stream (for iOS playback)
 */
export const postV1AudioSpeechInit = (
    tTSRequest: TTSRequest,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<TTSStreamInitResponse>(
      {url: `/v1/audio/speech/init`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: tTSRequest, signal
    },
      options);
    }
  


export const getPostV1AudioSpeechInitMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AudioSpeechInit>>, TError,{data: TTSRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postV1AudioSpeechInit>>, TError,{data: TTSRequest}, TContext> => {

const mutationKey = ['postV1AudioSpeechInit'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1AudioSpeechInit>>, {data: TTSRequest}> = (props) => {
          const {data} = props ?? {};

          return  postV1AudioSpeechInit(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1AudioSpeechInitMutationResult = NonNullable<Awaited<ReturnType<typeof postV1AudioSpeechInit>>>
    export type PostV1AudioSpeechInitMutationBody = TTSRequest
    export type PostV1AudioSpeechInitMutationError = ErrorResponse

    /**
 * @summary Initialize a TTS stream (for iOS playback)
 */
export const usePostV1AudioSpeechInit = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AudioSpeechInit>>, TError,{data: TTSRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postV1AudioSpeechInit>>,
        TError,
        {data: TTSRequest},
        TContext
      > => {

      const mutationOptions = getPostV1AudioSpeechInitMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Stream the generated audio for the previously initialized stream_id. Typically used by iOS Safari to play audio directly.
 * @summary Stream audio for initialized TTS stream
 */
export const getV1AudioSpeechStreamStreamId = (
    streamId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<Blob>(
      {url: `/v1/audio/speech/stream/${streamId}`, method: 'GET',
        responseType: 'blob', signal
    },
      options);
    }
  



export const getGetV1AudioSpeechStreamStreamIdQueryKey = (streamId?: string,) => {
    return [
    `/v1/audio/speech/stream/${streamId}`
    ] as const;
    }

    
export const getGetV1AudioSpeechStreamStreamIdQueryOptions = <TData = Awaited<ReturnType<typeof getV1AudioSpeechStreamStreamId>>, TError = ErrorResponse>(streamId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AudioSpeechStreamStreamId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AudioSpeechStreamStreamIdQueryKey(streamId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AudioSpeechStreamStreamId>>> = ({ signal }) => getV1AudioSpeechStreamStreamId(streamId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(streamId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AudioSpeechStreamStreamId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AudioSpeechStreamStreamIdQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AudioSpeechStreamStreamId>>>
export type GetV1AudioSpeechStreamStreamIdQueryError = ErrorResponse


export function useGetV1AudioSpeechStreamStreamId<TData = Awaited<ReturnType<typeof getV1AudioSpeechStreamStreamId>>, TError = ErrorResponse>(
 streamId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AudioSpeechStreamStreamId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AudioSpeechStreamStreamId>>,
          TError,
          Awaited<ReturnType<typeof getV1AudioSpeechStreamStreamId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AudioSpeechStreamStreamId<TData = Awaited<ReturnType<typeof getV1AudioSpeechStreamStreamId>>, TError = ErrorResponse>(
 streamId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AudioSpeechStreamStreamId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AudioSpeechStreamStreamId>>,
          TError,
          Awaited<ReturnType<typeof getV1AudioSpeechStreamStreamId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AudioSpeechStreamStreamId<TData = Awaited<ReturnType<typeof getV1AudioSpeechStreamStreamId>>, TError = ErrorResponse>(
 streamId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AudioSpeechStreamStreamId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Stream audio for initialized TTS stream
 */

export function useGetV1AudioSpeechStreamStreamId<TData = Awaited<ReturnType<typeof getV1AudioSpeechStreamStreamId>>, TError = ErrorResponse>(
 streamId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AudioSpeechStreamStreamId>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AudioSpeechStreamStreamIdQueryOptions(streamId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


export const getPostV1AuthLoginResponseMock = (overrideResponse: Partial< LoginResponse > = {}): LoginResponse => ({success: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), message: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), user: faker.helpers.arrayElement([{id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), username: faker.helpers.arrayElement([faker.helpers.fromRegExp('^[a-zA-Z0-9_@.+-]+$'), undefined]), email: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), timezone: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), preferred_language: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), current_level: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), ai_provider: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), ai_model: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), ai_enabled: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), is_paused: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), has_api_key: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), word_of_day_email_enabled: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), created_at: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), last_active: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), roles: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 20 }) }, (_, i) => i + 1).map(() => ({id: faker.number.int({min: undefined, max: undefined}), name: faker.string.alpha({length: {min: 10, max: 50}}), description: faker.string.alpha({length: {min: 10, max: 500}}), created_at: faker.string.alpha({length: {min: 10, max: 20}}), updated_at: faker.string.alpha({length: {min: 10, max: 20}})})), undefined])}, undefined]), redirect_uri: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), ...overrideResponse})

export const getPostV1AuthLogoutResponseMock = (overrideResponse: Partial< SuccessResponse > = {}): SuccessResponse => ({success: faker.datatype.boolean(), message: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 500}}), undefined]), ...overrideResponse})

export const getGetV1AuthStatusResponseMock = (overrideResponse: Partial< AuthStatusResponse > = {}): AuthStatusResponse => ({authenticated: faker.datatype.boolean(), user: {id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), username: faker.helpers.arrayElement([faker.helpers.fromRegExp('^[a-zA-Z0-9_@.+-]+$'), undefined]), email: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), timezone: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), preferred_language: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), current_level: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), ai_provider: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), ai_model: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), ai_enabled: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), is_paused: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), has_api_key: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), word_of_day_email_enabled: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), created_at: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), last_active: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), roles: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 20 }) }, (_, i) => i + 1).map(() => ({id: faker.number.int({min: undefined, max: undefined}), name: faker.string.alpha({length: {min: 10, max: 50}}), description: faker.string.alpha({length: {min: 10, max: 500}}), created_at: faker.string.alpha({length: {min: 10, max: 20}}), updated_at: faker.string.alpha({length: {min: 10, max: 20}})})), undefined])}, ...overrideResponse})

export const getPostV1AuthSignupResponseMock = (overrideResponse: Partial< SuccessResponse > = {}): SuccessResponse => ({success: faker.datatype.boolean(), message: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 500}}), undefined]), ...overrideResponse})

export const getGetV1AuthSignupStatusResponseMock = (overrideResponse: Partial< SignupStatusResponse > = {}): SignupStatusResponse => ({signups_disabled: faker.datatype.boolean(), ...overrideResponse})

export const getGetV1AuthGoogleLoginResponseMock = (overrideResponse: Partial< GoogleOAuthLoginResponse > = {}): GoogleOAuthLoginResponse => ({auth_url: faker.string.alpha({length: {min: 10, max: 20}}), ...overrideResponse})

export const getGetV1AuthGoogleCallbackResponseMock = (overrideResponse: Partial< LoginResponse > = {}): LoginResponse => ({success: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), message: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), user: faker.helpers.arrayElement([{id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), username: faker.helpers.arrayElement([faker.helpers.fromRegExp('^[a-zA-Z0-9_@.+-]+$'), undefined]), email: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), timezone: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), preferred_language: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), current_level: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), ai_provider: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), ai_model: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), ai_enabled: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), is_paused: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), has_api_key: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), word_of_day_email_enabled: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), created_at: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), last_active: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), roles: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 20 }) }, (_, i) => i + 1).map(() => ({id: faker.number.int({min: undefined, max: undefined}), name: faker.string.alpha({length: {min: 10, max: 50}}), description: faker.string.alpha({length: {min: 10, max: 500}}), created_at: faker.string.alpha({length: {min: 10, max: 20}}), updated_at: faker.string.alpha({length: {min: 10, max: 20}})})), undefined])}, undefined]), redirect_uri: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), ...overrideResponse})

export const getGetV1QuizQuestionResponseMock = (overrideResponse: Partial< Question | GeneratingResponse > = {}): Question | GeneratingResponse => (faker.helpers.arrayElement([{id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), language: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), level: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), type: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(QuestionType)), undefined]), status: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(QuestionStatus)), undefined]), difficulty_score: faker.helpers.arrayElement([faker.number.float({min: undefined, max: undefined, fractionDigits: 2}), undefined]), explanation: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), content: faker.helpers.arrayElement([{question: faker.string.alpha({length: {min: 1, max: 1000}}), options: Array.from({ length: faker.number.int({ min: 4, max: 10 }) }, (_, i) => i + 1).map(() => (faker.string.alpha({length: {min: 1, max: 500}}))), sentence: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 2000}}), undefined]), passage: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 5000}}), undefined]), hint: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 500}}), undefined]), topic: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 200}}), undefined])}, undefined]), created_at: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), correct_count: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), incorrect_count: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), total_responses: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), user_count: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), correct_answer: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), reporters: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), topic_category: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), grammar_focus: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), vocabulary_domain: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), scenario: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), style_modifier: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), difficulty_modifier: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), time_context: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), confidence_level: faker.helpers.arrayElement([faker.number.int({min: 1, max: 5}), undefined]), ...overrideResponse}, {status: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 100}}), undefined]), message: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 500}}), undefined]), ai_model: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), api_key: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), ...overrideResponse}]))

export const getGetV1QuizQuestionIdResponseMock = (overrideResponse: Partial< Question > = {}): Question => ({id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), language: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), level: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), type: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(QuestionType)), undefined]), status: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(QuestionStatus)), undefined]), difficulty_score: faker.helpers.arrayElement([faker.number.float({min: undefined, max: undefined, fractionDigits: 2}), undefined]), explanation: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), content: faker.helpers.arrayElement([{question: faker.string.alpha({length: {min: 1, max: 1000}}), options: Array.from({ length: faker.number.int({ min: 4, max: 10 }) }, (_, i) => i + 1).map(() => (faker.string.alpha({length: {min: 1, max: 500}}))), sentence: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 2000}}), undefined]), passage: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 5000}}), undefined]), hint: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 500}}), undefined]), topic: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 200}}), undefined])}, undefined]), created_at: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), correct_count: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), incorrect_count: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), total_responses: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), user_count: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), correct_answer: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), reporters: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), topic_category: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), grammar_focus: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), vocabulary_domain: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), scenario: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), style_modifier: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), difficulty_modifier: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), time_context: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), confidence_level: faker.helpers.arrayElement([faker.number.int({min: 1, max: 5}), undefined]), ...overrideResponse})

export const getPostV1QuizAnswerResponseMock = (overrideResponse: Partial< AnswerResponse > = {}): AnswerResponse => ({is_correct: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), user_answer: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), user_answer_index: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), explanation: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), next_difficulty: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), correct_answer_index: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), ...overrideResponse})

export const getGetV1QuizProgressResponseMock = (overrideResponse: Partial< UserProgress > = {}): UserProgress => ({current_level: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), suggested_level: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), accuracy_rate: faker.helpers.arrayElement([faker.number.float({min: 0, max: 1, fractionDigits: 2}), undefined]), total_questions: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined}), undefined]), correct_answers: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined}), undefined]), performance_by_topic: faker.helpers.arrayElement([{
        [faker.string.alphanumeric(5)]: {correct_attempts: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined}), undefined]), total_attempts: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined}), undefined]), average_response_time_ms: faker.helpers.arrayElement([faker.number.float({min: 0, max: undefined, fractionDigits: 2}), undefined]), last_updated: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined])}
      }, undefined]), weak_areas: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 50 }) }, (_, i) => i + 1).map(() => (faker.string.alpha({length: {min: 10, max: 20}}))), undefined]), recent_activity: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 100 }) }, (_, i) => i + 1).map(() => ({question_id: faker.helpers.arrayElement([faker.number.int({min: 1, max: undefined}), undefined]), is_correct: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), created_at: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined])})), undefined]), worker_status: faker.helpers.arrayElement([{status: faker.helpers.arrayElement([faker.helpers.arrayElement(['idle','busy','error'] as const), undefined]), last_heartbeat: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), error_message: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined])}, undefined]), learning_preferences: faker.helpers.arrayElement([{focus_on_weak_areas: faker.datatype.boolean(), fresh_question_ratio: faker.number.float({min: 0, max: 1, fractionDigits: 2}), known_question_penalty: faker.number.float({min: 0, max: 1, fractionDigits: 2}), review_interval_days: faker.number.int({min: 1, max: 60}), weak_area_boost: faker.number.float({min: 1, max: 5, fractionDigits: 2}), daily_reminder_enabled: faker.datatype.boolean(), tts_voice: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), daily_goal: faker.helpers.arrayElement([faker.number.int({min: 1, max: undefined}), undefined])}, undefined]), priority_insights: faker.helpers.arrayElement([{total_questions_in_queue: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined}), undefined]), high_priority_questions: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined}), undefined]), medium_priority_questions: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined}), undefined]), low_priority_questions: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined}), undefined])}, undefined]), generation_focus: faker.helpers.arrayElement([{current_generation_model: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), last_generation_time: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), generation_rate: faker.helpers.arrayElement([faker.number.float({min: 0, max: undefined, fractionDigits: 2}), undefined])}, undefined]), high_priority_topics: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 20 }) }, (_, i) => i + 1).map(() => (faker.string.alpha({length: {min: 10, max: 20}}))), undefined]), gap_analysis: faker.helpers.arrayElement([{}, undefined]), priority_distribution: faker.helpers.arrayElement([{
        [faker.string.alphanumeric(5)]: faker.number.int({min: 0, max: undefined})
      }, undefined]), ...overrideResponse})

export const getGetV1QuizAiTokenUsageResponseMock = (): UserUsageStats[] => (Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.helpers.arrayElement([faker.number.int({min: 1, max: undefined}), undefined]), user_id: faker.helpers.arrayElement([faker.number.int({min: 1, max: undefined}), undefined]), api_key_id: faker.helpers.arrayElement([faker.number.int({min: 1, max: undefined}), undefined]), usage_date: faker.helpers.arrayElement([faker.date.past().toISOString().split('T')[0], undefined]), usage_hour: faker.helpers.arrayElement([faker.number.int({min: 0, max: 23}), undefined]), service_name: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), provider: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), model: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), usage_type: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), prompt_tokens: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined}), undefined]), completion_tokens: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined}), undefined]), total_tokens: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined}), undefined]), requests_made: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined}), undefined]), created_at: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), updated_at: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined])})))

export const getGetV1QuizAiTokenUsageDailyResponseMock = (): UserUsageStatsDaily[] => (Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({usage_date: faker.helpers.arrayElement([faker.date.past().toISOString().split('T')[0], undefined]), service_name: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), provider: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), model: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), usage_type: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), total_prompt_tokens: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined}), undefined]), total_completion_tokens: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined}), undefined]), total_tokens: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined}), undefined]), total_requests: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined}), undefined])})))

export const getGetV1QuizAiTokenUsageHourlyResponseMock = (): UserUsageStatsHourly[] => (Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({usage_hour: faker.helpers.arrayElement([faker.number.int({min: 0, max: 23}), undefined]), service_name: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), provider: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), model: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), usage_type: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), total_prompt_tokens: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined}), undefined]), total_completion_tokens: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined}), undefined]), total_tokens: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined}), undefined]), total_requests: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined}), undefined])})))

export const getPostV1QuizQuestionIdReportResponseMock = (overrideResponse: Partial< SuccessResponse > = {}): SuccessResponse => ({success: faker.datatype.boolean(), message: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 500}}), undefined]), ...overrideResponse})

export const getPostV1QuizQuestionIdMarkKnownResponseMock = (overrideResponse: Partial< SuccessResponse > = {}): SuccessResponse => ({success: faker.datatype.boolean(), message: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 500}}), undefined]), ...overrideResponse})

export const getGetV1QuizWorkerStatusResponseMock = (overrideResponse: Partial< WorkerStatusResponse > = {}): WorkerStatusResponse => ({has_errors: faker.datatype.boolean(), error_message: faker.string.alpha({length: {min: 10, max: 20}}), global_paused: faker.datatype.boolean(), user_paused: faker.datatype.boolean(), healthy_workers: faker.number.int({min: undefined, max: undefined}), total_workers: faker.number.int({min: undefined, max: undefined}), last_error_details: faker.string.alpha({length: {min: 10, max: 20}}), worker_running: faker.datatype.boolean(), ...overrideResponse})

export const getPutV1SettingsResponseMock = (overrideResponse: Partial< SuccessResponse > = {}): SuccessResponse => ({success: faker.datatype.boolean(), message: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 500}}), undefined]), ...overrideResponse})

export const getGetV1SettingsAiProvidersResponseMock = (overrideResponse: Partial< AIProviders > = {}): AIProviders => ({providers: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 50 }) }, (_, i) => i + 1).map(() => ({name: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 100}}), undefined]), code: faker.helpers.arrayElement([faker.helpers.fromRegExp('^[a-zA-Z0-9_.-]+$'), undefined]), url: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 500}}), undefined]), usage_supported: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), models: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 100 }) }, (_, i) => i + 1).map(() => ({name: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 100}}), undefined]), code: faker.helpers.arrayElement([faker.helpers.fromRegExp('^[a-zA-Z0-9_.:-]+$'), undefined])})), undefined])})), undefined]), levels: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 20 }) }, (_, i) => i + 1).map(() => (faker.string.alpha({length: {min: 10, max: 20}}))), undefined]), ...overrideResponse})

export const getPostV1SettingsTestAiResponseMock = (overrideResponse: Partial< SuccessResponse > = {}): SuccessResponse => ({success: faker.datatype.boolean(), message: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 500}}), undefined]), ...overrideResponse})

export const getPostV1SettingsTestEmailResponseMock = (overrideResponse: Partial< SuccessResponse > = {}): SuccessResponse => ({success: faker.datatype.boolean(), message: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 500}}), undefined]), ...overrideResponse})

export const getPutV1SettingsWordOfDayEmailResponseMock = (overrideResponse: Partial< SuccessResponse > = {}): SuccessResponse => ({success: faker.datatype.boolean(), message: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 500}}), undefined]), ...overrideResponse})

export const getGetV1SettingsLevelsResponseMock = (overrideResponse: Partial< LevelsResponse > = {}): LevelsResponse => ({levels: Array.from({ length: faker.number.int({ min: 1, max: 20 }) }, (_, i) => i + 1).map(() => (faker.string.alpha({length: {min: 10, max: 20}}))), level_descriptions: {
        [faker.string.alphanumeric(5)]: faker.string.alpha({length: {min: 10, max: 20}})
      }, ...overrideResponse})

export const getGetV1SettingsLanguagesResponseMock = (): LanguagesResponse => (Array.from({ length: faker.number.int({ min: 1, max: 20 }) }, (_, i) => i + 1).map(() => ({code: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 20}}), tts_locale: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), tts_voice: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined])})))

export const getGetV1SettingsApiKeyProviderResponseMock = (overrideResponse: Partial< APIKeyAvailabilityResponse > = {}): APIKeyAvailabilityResponse => ({has_api_key: faker.datatype.boolean(), ...overrideResponse})

export const getPostV1AiConversationsResponseMock = (overrideResponse: Partial< Conversation > = {}): Conversation => ({id: faker.string.uuid(), user_id: faker.number.int({min: undefined, max: undefined}), title: faker.string.alpha({length: {min: 10, max: 20}}), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, message_count: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), messages: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.uuid(), conversation_id: faker.string.uuid(), question_id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), role: faker.helpers.arrayElement(['user','assistant'] as const), content: {text: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined])}, bookmarked: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, conversation_title: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined])})), undefined]), ...overrideResponse})

export const getGetV1AiConversationsResponseMock = (overrideResponse: Partial< ConversationsListResponse > = {}): ConversationsListResponse => ({conversations: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.uuid(), user_id: faker.number.int({min: undefined, max: undefined}), title: faker.string.alpha({length: {min: 10, max: 20}}), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, message_count: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), messages: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.uuid(), conversation_id: faker.string.uuid(), question_id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), role: faker.helpers.arrayElement(['user','assistant'] as const), content: {text: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined])}, bookmarked: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, conversation_title: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined])})), undefined])})), total: faker.number.int({min: undefined, max: undefined}), limit: faker.number.int({min: undefined, max: undefined}), offset: faker.number.int({min: undefined, max: undefined}), ...overrideResponse})

export const getGetV1AiConversationsIdResponseMock = (overrideResponse: Partial< Conversation > = {}): Conversation => ({id: faker.string.uuid(), user_id: faker.number.int({min: undefined, max: undefined}), title: faker.string.alpha({length: {min: 10, max: 20}}), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, message_count: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), messages: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.uuid(), conversation_id: faker.string.uuid(), question_id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), role: faker.helpers.arrayElement(['user','assistant'] as const), content: {text: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined])}, bookmarked: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, conversation_title: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined])})), undefined]), ...overrideResponse})

export const getPutV1AiConversationsIdResponseMock = (overrideResponse: Partial< Conversation > = {}): Conversation => ({id: faker.string.uuid(), user_id: faker.number.int({min: undefined, max: undefined}), title: faker.string.alpha({length: {min: 10, max: 20}}), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, message_count: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), messages: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.uuid(), conversation_id: faker.string.uuid(), question_id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), role: faker.helpers.arrayElement(['user','assistant'] as const), content: {text: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined])}, bookmarked: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, conversation_title: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined])})), undefined]), ...overrideResponse})

export const getPostV1AiConversationsConversationIdMessagesResponseMock = (overrideResponse: Partial< ChatMessage > = {}): ChatMessage => ({id: faker.string.uuid(), conversation_id: faker.string.uuid(), question_id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), role: faker.helpers.arrayElement(['user','assistant'] as const), content: {text: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined])}, bookmarked: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, conversation_title: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), ...overrideResponse})

export const getGetV1AiSearchResponseMock = (): ConversationSearchResponse => ({...{conversations: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.uuid(), user_id: faker.number.int({min: undefined, max: undefined}), title: faker.string.alpha({length: {min: 10, max: 20}}), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, message_count: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), messages: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.uuid(), conversation_id: faker.string.uuid(), question_id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), role: faker.helpers.arrayElement(['user','assistant'] as const), content: {text: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined])}, bookmarked: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, conversation_title: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined])})), undefined])})), total: faker.number.int({min: undefined, max: undefined}), limit: faker.number.int({min: undefined, max: undefined}), offset: faker.number.int({min: undefined, max: undefined})},...{query: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined])},})

export const getPutV1AiConversationsBookmarkResponseMock = (overrideResponse: Partial< BookmarkStatusResponse > = {}): BookmarkStatusResponse => ({bookmarked: faker.datatype.boolean(), ...overrideResponse})

export const getGetV1AiBookmarksResponseMock = (overrideResponse: Partial< ChatBookmarksResponse > = {}): ChatBookmarksResponse => ({messages: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.uuid(), conversation_id: faker.string.uuid(), question_id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), role: faker.helpers.arrayElement(['user','assistant'] as const), content: {text: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined])}, bookmarked: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, conversation_title: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined])})), query: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), total: faker.number.int({min: undefined, max: undefined}), limit: faker.number.int({min: undefined, max: undefined}), offset: faker.number.int({min: undefined, max: undefined}), ...overrideResponse})

export const getPostV1SnippetsResponseMock = (overrideResponse: Partial< Snippet > = {}): Snippet => ({id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), user_id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), original_text: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), translated_text: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), source_language: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), target_language: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), question_id: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), null]), undefined]), section_id: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), null]), undefined]), story_id: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), null]), undefined]), context: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), difficulty_level: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), created_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), updated_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), ...overrideResponse})

export const getGetV1SnippetsResponseMock = (overrideResponse: Partial< SnippetList > = {}): SnippetList => ({snippets: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), user_id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), original_text: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), translated_text: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), source_language: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), target_language: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), question_id: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), null]), undefined]), section_id: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), null]), undefined]), story_id: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), null]), undefined]), context: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), difficulty_level: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), created_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), updated_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined])})), undefined]), total: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), limit: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), offset: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), query: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), ...overrideResponse})

export const getGetV1SnippetsSearchResponseMock = (overrideResponse: Partial< SnippetList > = {}): SnippetList => ({snippets: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), user_id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), original_text: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), translated_text: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), source_language: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), target_language: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), question_id: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), null]), undefined]), section_id: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), null]), undefined]), story_id: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), null]), undefined]), context: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), difficulty_level: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), created_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), updated_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined])})), undefined]), total: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), limit: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), offset: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), query: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), ...overrideResponse})

export const getGetV1SnippetsByQuestionQuestionIdResponseMock = (overrideResponse: Partial< SnippetsResponse > = {}): SnippetsResponse => ({snippets: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), user_id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), original_text: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), translated_text: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), source_language: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), target_language: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), question_id: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), null]), undefined]), section_id: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), null]), undefined]), story_id: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), null]), undefined]), context: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), difficulty_level: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), created_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), updated_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined])})), ...overrideResponse})

export const getGetV1SnippetsBySectionSectionIdResponseMock = (overrideResponse: Partial< SnippetsResponse > = {}): SnippetsResponse => ({snippets: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), user_id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), original_text: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), translated_text: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), source_language: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), target_language: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), question_id: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), null]), undefined]), section_id: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), null]), undefined]), story_id: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), null]), undefined]), context: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), difficulty_level: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), created_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), updated_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined])})), ...overrideResponse})

export const getGetV1SnippetsByStoryStoryIdResponseMock = (overrideResponse: Partial< SnippetsResponse > = {}): SnippetsResponse => ({snippets: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), user_id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), original_text: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), translated_text: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), source_language: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), target_language: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), question_id: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), null]), undefined]), section_id: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), null]), undefined]), story_id: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), null]), undefined]), context: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), difficulty_level: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), created_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), updated_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined])})), ...overrideResponse})

export const getGetV1SnippetsIdResponseMock = (overrideResponse: Partial< Snippet > = {}): Snippet => ({id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), user_id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), original_text: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), translated_text: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), source_language: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), target_language: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), question_id: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), null]), undefined]), section_id: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), null]), undefined]), story_id: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), null]), undefined]), context: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), difficulty_level: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), created_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), updated_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), ...overrideResponse})

export const getPutV1SnippetsIdResponseMock = (overrideResponse: Partial< Snippet > = {}): Snippet => ({id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), user_id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), original_text: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), translated_text: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), source_language: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), target_language: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), question_id: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), null]), undefined]), section_id: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), null]), undefined]), story_id: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), null]), undefined]), context: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), difficulty_level: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), created_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), updated_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), ...overrideResponse})

export const getPutV1UserzProfileResponseMock = (overrideResponse: Partial< UserProfileMessageResponse > = {}): UserProfileMessageResponse => ({message: faker.string.alpha({length: {min: 10, max: 20}}), user: {id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), username: faker.helpers.arrayElement([faker.helpers.fromRegExp('^[a-zA-Z0-9_@.+-]+$'), undefined]), email: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), timezone: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), last_active: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), preferred_language: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), current_level: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), ai_enabled: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), is_paused: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), word_of_day_email_enabled: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), created_at: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), updated_at: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined])}, ...overrideResponse})

export const getPostV1FeedbackResponseMock = (overrideResponse: Partial< FeedbackReport > = {}): FeedbackReport => ({id: faker.number.int({min: undefined, max: undefined}), user_id: faker.number.int({min: undefined, max: undefined}), feedback_text: faker.string.alpha({length: {min: 10, max: 5000}}), feedback_type: faker.helpers.arrayElement(['bug','feature_request','general','improvement'] as const), context_data: faker.helpers.arrayElement([{}, undefined]), screenshot_data: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), screenshot_url: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), status: faker.helpers.arrayElement(['new','in_progress','resolved','dismissed'] as const), admin_notes: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), assigned_to_user_id: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), null]), undefined]), resolved_at: faker.helpers.arrayElement([faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), undefined]), resolved_by_user_id: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), null]), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, ...overrideResponse})

export const getGetV1AdminBackendResponseMock = (): string => (faker.word.sample())

export const getGetV1AdminBackendUserzResponseMock = (overrideResponse: Partial< AdminUsersResponse > = {}): AdminUsersResponse => ({users: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), username: faker.helpers.arrayElement([faker.helpers.fromRegExp('^[a-zA-Z0-9_@.+-]+$'), undefined]), email: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), timezone: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), last_active: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), preferred_language: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), current_level: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), ai_enabled: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), is_paused: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), word_of_day_email_enabled: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), created_at: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), updated_at: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined])})), ...overrideResponse})

export const getPostV1AdminBackendUserzResponseMock = (overrideResponse: Partial< UserProfileMessageResponse > = {}): UserProfileMessageResponse => ({message: faker.string.alpha({length: {min: 10, max: 20}}), user: {id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), username: faker.helpers.arrayElement([faker.helpers.fromRegExp('^[a-zA-Z0-9_@.+-]+$'), undefined]), email: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), timezone: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), last_active: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), preferred_language: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), current_level: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), ai_enabled: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), is_paused: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), word_of_day_email_enabled: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), created_at: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), updated_at: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined])}, ...overrideResponse})

export const getPostV1SettingsClearStoriesResponseMock = (overrideResponse: Partial< SuccessResponse > = {}): SuccessResponse => ({success: faker.datatype.boolean(), message: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 500}}), undefined]), ...overrideResponse})

export const getPostV1SettingsResetAccountResponseMock = (overrideResponse: Partial< SuccessResponse > = {}): SuccessResponse => ({success: faker.datatype.boolean(), message: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 500}}), undefined]), ...overrideResponse})

export const getPostV1SettingsClearAiChatsResponseMock = (overrideResponse: Partial< SuccessResponse > = {}): SuccessResponse => ({success: faker.datatype.boolean(), message: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 500}}), undefined]), ...overrideResponse})

export const getPostV1SettingsClearTranslationPracticeHistoryResponseMock = (overrideResponse: Partial< SuccessResponse > = {}): SuccessResponse => ({success: faker.datatype.boolean(), message: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 500}}), undefined]), ...overrideResponse})

export const getGetV1AdminBackendUserzPaginatedResponseMock = (overrideResponse: Partial< AdminUsersPaginatedResponse > = {}): AdminUsersPaginatedResponse => ({users: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({user: faker.helpers.arrayElement([{id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), username: faker.helpers.arrayElement([faker.helpers.fromRegExp('^[a-zA-Z0-9_@.+-]+$'), undefined]), email: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), timezone: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), last_active: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), preferred_language: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), current_level: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), ai_enabled: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), is_paused: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), word_of_day_email_enabled: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), created_at: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), updated_at: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined])}, undefined]), progress: faker.helpers.arrayElement([{current_level: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), suggested_level: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), accuracy_rate: faker.helpers.arrayElement([faker.number.float({min: 0, max: 1, fractionDigits: 2}), undefined]), total_questions: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined}), undefined]), correct_answers: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined}), undefined]), performance_by_topic: faker.helpers.arrayElement([{
        [faker.string.alphanumeric(5)]: {correct_attempts: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined}), undefined]), total_attempts: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined}), undefined]), average_response_time_ms: faker.helpers.arrayElement([faker.number.float({min: 0, max: undefined, fractionDigits: 2}), undefined]), last_updated: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined])}
      }, undefined]), weak_areas: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 50 }) }, (_, i) => i + 1).map(() => (faker.string.alpha({length: {min: 10, max: 20}}))), undefined]), recent_activity: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 100 }) }, (_, i) => i + 1).map(() => ({question_id: faker.helpers.arrayElement([faker.number.int({min: 1, max: undefined}), undefined]), is_correct: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), created_at: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined])})), undefined]), worker_status: faker.helpers.arrayElement([{status: faker.helpers.arrayElement([faker.helpers.arrayElement(['idle','busy','error'] as const), undefined]), last_heartbeat: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), error_message: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined])}, undefined]), learning_preferences: faker.helpers.arrayElement([{focus_on_weak_areas: faker.datatype.boolean(), fresh_question_ratio: faker.number.float({min: 0, max: 1, fractionDigits: 2}), known_question_penalty: faker.number.float({min: 0, max: 1, fractionDigits: 2}), review_interval_days: faker.number.int({min: 1, max: 60}), weak_area_boost: faker.number.float({min: 1, max: 5, fractionDigits: 2}), daily_reminder_enabled: faker.datatype.boolean(), tts_voice: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), daily_goal: faker.helpers.arrayElement([faker.number.int({min: 1, max: undefined}), undefined])}, undefined]), priority_insights: faker.helpers.arrayElement([{total_questions_in_queue: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined}), undefined]), high_priority_questions: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined}), undefined]), medium_priority_questions: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined}), undefined]), low_priority_questions: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined}), undefined])}, undefined]), generation_focus: faker.helpers.arrayElement([{current_generation_model: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), last_generation_time: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), generation_rate: faker.helpers.arrayElement([faker.number.float({min: 0, max: undefined, fractionDigits: 2}), undefined])}, undefined]), high_priority_topics: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 20 }) }, (_, i) => i + 1).map(() => (faker.string.alpha({length: {min: 10, max: 20}}))), undefined]), gap_analysis: faker.helpers.arrayElement([{}, undefined]), priority_distribution: faker.helpers.arrayElement([{
        [faker.string.alphanumeric(5)]: faker.number.int({min: 0, max: undefined})
      }, undefined])}, undefined]), question_stats: faker.helpers.arrayElement([{user_id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), total_answered: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined}), undefined]), answered_by_type: faker.helpers.arrayElement([{
        [faker.string.alphanumeric(5)]: faker.number.int({min: undefined, max: undefined})
      }, undefined]), answered_by_level: faker.helpers.arrayElement([{
        [faker.string.alphanumeric(5)]: faker.number.int({min: undefined, max: undefined})
      }, undefined]), accuracy_by_type: faker.helpers.arrayElement([{
        [faker.string.alphanumeric(5)]: faker.number.float({min: undefined, max: undefined, fractionDigits: 2})
      }, undefined]), accuracy_by_level: faker.helpers.arrayElement([{
        [faker.string.alphanumeric(5)]: faker.number.float({min: undefined, max: undefined, fractionDigits: 2})
      }, undefined]), available_by_type: faker.helpers.arrayElement([{
        [faker.string.alphanumeric(5)]: faker.number.int({min: undefined, max: undefined})
      }, undefined]), available_by_level: faker.helpers.arrayElement([{
        [faker.string.alphanumeric(5)]: faker.number.int({min: undefined, max: undefined})
      }, undefined])}, undefined])})), pagination: {page: faker.number.int({min: 1, max: undefined}), page_size: faker.number.int({min: 1, max: 100}), total: faker.number.int({min: 0, max: undefined}), total_pages: faker.number.int({min: 0, max: undefined})}, ...overrideResponse})

export const getPutV1AdminBackendUserzIdResponseMock = (overrideResponse: Partial< UserProfileMessageResponse > = {}): UserProfileMessageResponse => ({message: faker.string.alpha({length: {min: 10, max: 20}}), user: {id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), username: faker.helpers.arrayElement([faker.helpers.fromRegExp('^[a-zA-Z0-9_@.+-]+$'), undefined]), email: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), timezone: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), last_active: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), preferred_language: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), current_level: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), ai_enabled: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), is_paused: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), word_of_day_email_enabled: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), created_at: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), updated_at: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined])}, ...overrideResponse})

export const getDeleteV1AdminBackendUserzIdResponseMock = (overrideResponse: Partial< MessageResponse > = {}): MessageResponse => ({message: faker.string.alpha({length: {min: 10, max: 20}}), ...overrideResponse})

export const getPostV1AdminBackendUserzIdResetPasswordResponseMock = (overrideResponse: Partial< MessageResponse > = {}): MessageResponse => ({message: faker.string.alpha({length: {min: 10, max: 20}}), ...overrideResponse})

export const getGetV1AdminBackendRolesResponseMock = (overrideResponse: Partial< AdminRolesResponse > = {}): AdminRolesResponse => ({roles: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.number.int({min: undefined, max: undefined}), name: faker.string.alpha({length: {min: 10, max: 50}}), description: faker.string.alpha({length: {min: 10, max: 500}}), created_at: faker.string.alpha({length: {min: 10, max: 20}}), updated_at: faker.string.alpha({length: {min: 10, max: 20}})})), ...overrideResponse})

export const getGetV1AdminBackendUserzIdRolesResponseMock = (overrideResponse: Partial< AdminRolesResponse > = {}): AdminRolesResponse => ({roles: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.number.int({min: undefined, max: undefined}), name: faker.string.alpha({length: {min: 10, max: 50}}), description: faker.string.alpha({length: {min: 10, max: 500}}), created_at: faker.string.alpha({length: {min: 10, max: 20}}), updated_at: faker.string.alpha({length: {min: 10, max: 20}})})), ...overrideResponse})

export const getPostV1AdminBackendUserzIdRolesResponseMock = (overrideResponse: Partial< MessageResponse > = {}): MessageResponse => ({message: faker.string.alpha({length: {min: 10, max: 20}}), ...overrideResponse})

export const getDeleteV1AdminBackendUserzIdRolesRoleIdResponseMock = (overrideResponse: Partial< MessageResponse > = {}): MessageResponse => ({message: faker.string.alpha({length: {min: 10, max: 20}}), ...overrideResponse})

export const getGetV1AdminBackendDashboardResponseMock = (overrideResponse: Partial< DashboardResponse > = {}): DashboardResponse => ({users: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({user: faker.helpers.arrayElement([{id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), username: faker.helpers.arrayElement([faker.helpers.fromRegExp('^[a-zA-Z0-9_@.+-]+$'), undefined]), email: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), timezone: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), last_active: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), preferred_language: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), current_level: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), ai_enabled: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), is_paused: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), word_of_day_email_enabled: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), created_at: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), updated_at: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined])}, undefined]), progress: faker.helpers.arrayElement([{current_level: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), suggested_level: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), accuracy_rate: faker.helpers.arrayElement([faker.number.float({min: 0, max: 1, fractionDigits: 2}), undefined]), total_questions: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined}), undefined]), correct_answers: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined}), undefined]), performance_by_topic: faker.helpers.arrayElement([{
        [faker.string.alphanumeric(5)]: {correct_attempts: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined}), undefined]), total_attempts: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined}), undefined]), average_response_time_ms: faker.helpers.arrayElement([faker.number.float({min: 0, max: undefined, fractionDigits: 2}), undefined]), last_updated: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined])}
      }, undefined]), weak_areas: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 50 }) }, (_, i) => i + 1).map(() => (faker.string.alpha({length: {min: 10, max: 20}}))), undefined]), recent_activity: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 100 }) }, (_, i) => i + 1).map(() => ({question_id: faker.helpers.arrayElement([faker.number.int({min: 1, max: undefined}), undefined]), is_correct: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), created_at: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined])})), undefined]), worker_status: faker.helpers.arrayElement([{status: faker.helpers.arrayElement([faker.helpers.arrayElement(['idle','busy','error'] as const), undefined]), last_heartbeat: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), error_message: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined])}, undefined]), learning_preferences: faker.helpers.arrayElement([{focus_on_weak_areas: faker.datatype.boolean(), fresh_question_ratio: faker.number.float({min: 0, max: 1, fractionDigits: 2}), known_question_penalty: faker.number.float({min: 0, max: 1, fractionDigits: 2}), review_interval_days: faker.number.int({min: 1, max: 60}), weak_area_boost: faker.number.float({min: 1, max: 5, fractionDigits: 2}), daily_reminder_enabled: faker.datatype.boolean(), tts_voice: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), daily_goal: faker.helpers.arrayElement([faker.number.int({min: 1, max: undefined}), undefined])}, undefined]), priority_insights: faker.helpers.arrayElement([{total_questions_in_queue: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined}), undefined]), high_priority_questions: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined}), undefined]), medium_priority_questions: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined}), undefined]), low_priority_questions: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined}), undefined])}, undefined]), generation_focus: faker.helpers.arrayElement([{current_generation_model: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), last_generation_time: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), generation_rate: faker.helpers.arrayElement([faker.number.float({min: 0, max: undefined, fractionDigits: 2}), undefined])}, undefined]), high_priority_topics: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 20 }) }, (_, i) => i + 1).map(() => (faker.string.alpha({length: {min: 10, max: 20}}))), undefined]), gap_analysis: faker.helpers.arrayElement([{}, undefined]), priority_distribution: faker.helpers.arrayElement([{
        [faker.string.alphanumeric(5)]: faker.number.int({min: 0, max: undefined})
      }, undefined])}, undefined]), question_stats: faker.helpers.arrayElement([{user_id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), total_answered: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined}), undefined]), answered_by_type: faker.helpers.arrayElement([{
        [faker.string.alphanumeric(5)]: faker.number.int({min: undefined, max: undefined})
      }, undefined]), answered_by_level: faker.helpers.arrayElement([{
        [faker.string.alphanumeric(5)]: faker.number.int({min: undefined, max: undefined})
      }, undefined]), accuracy_by_type: faker.helpers.arrayElement([{
        [faker.string.alphanumeric(5)]: faker.number.float({min: undefined, max: undefined, fractionDigits: 2})
      }, undefined]), accuracy_by_level: faker.helpers.arrayElement([{
        [faker.string.alphanumeric(5)]: faker.number.float({min: undefined, max: undefined, fractionDigits: 2})
      }, undefined]), available_by_type: faker.helpers.arrayElement([{
        [faker.string.alphanumeric(5)]: faker.number.int({min: undefined, max: undefined})
      }, undefined]), available_by_level: faker.helpers.arrayElement([{
        [faker.string.alphanumeric(5)]: faker.number.int({min: undefined, max: undefined})
      }, undefined])}, undefined])})), undefined]), question_stats: faker.helpers.arrayElement([{total_questions: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined}), undefined]), total_responses: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined}), undefined]), questions_by_type: faker.helpers.arrayElement([{
        [faker.string.alphanumeric(5)]: faker.number.int({min: undefined, max: undefined})
      }, undefined]), questions_by_level: faker.helpers.arrayElement([{
        [faker.string.alphanumeric(5)]: faker.number.int({min: undefined, max: undefined})
      }, undefined]), questions_by_language: faker.helpers.arrayElement([{
        [faker.string.alphanumeric(5)]: faker.number.int({min: undefined, max: undefined})
      }, undefined])}, undefined]), ai_concurrency_stats: faker.helpers.arrayElement([{active_requests: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), max_concurrent: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), queued_requests: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), total_requests: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), user_active_count: faker.helpers.arrayElement([{
        [faker.string.alphanumeric(5)]: faker.number.int({min: undefined, max: undefined})
      }, undefined]), max_per_user: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined])}, undefined]), worker_health: faker.helpers.arrayElement([{global_paused: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), healthy_count: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), total_count: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), worker_instances: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({healthy: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), is_paused: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), is_running: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), last_heartbeat: faker.helpers.arrayElement([{Time: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), Valid: faker.helpers.arrayElement([faker.datatype.boolean(), undefined])}, undefined]), total_questions_generated: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), total_runs: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), worker_instance: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined])})), undefined])}, undefined]), worker_port: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), worker_base_url: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), ...overrideResponse})

export const getGetV1AdminBackendAiConcurrencyResponseMock = (overrideResponse: Partial< AIConcurrencyStats > = {}): AIConcurrencyStats => ({active_requests: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), max_concurrent: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), queued_requests: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), total_requests: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), user_active_count: faker.helpers.arrayElement([{
        [faker.string.alphanumeric(5)]: faker.number.int({min: undefined, max: undefined})
      }, undefined]), max_per_user: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), ...overrideResponse})

export const getGetV1AdminWorkerStatusResponseMock = (overrideResponse: Partial< WorkerStatus > = {}): WorkerStatus => ({status: faker.helpers.arrayElement([faker.helpers.arrayElement(['idle','busy','error'] as const), undefined]), last_heartbeat: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), error_message: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), ...overrideResponse})

export const getGetV1AdminWorkerDetailsResponseMock = (): WorkerDetailsResponse => ({})

export const getPostV1AdminWorkerPauseResponseMock = (overrideResponse: Partial< MessageResponse > = {}): MessageResponse => ({message: faker.string.alpha({length: {min: 10, max: 20}}), ...overrideResponse})

export const getPostV1AdminWorkerResumeResponseMock = (overrideResponse: Partial< MessageResponse > = {}): MessageResponse => ({message: faker.string.alpha({length: {min: 10, max: 20}}), ...overrideResponse})

export const getPostV1AdminWorkerTriggerResponseMock = (overrideResponse: Partial< MessageResponse > = {}): MessageResponse => ({message: faker.string.alpha({length: {min: 10, max: 20}}), ...overrideResponse})

export const getGetV1AdminWorkerLogsResponseMock = (overrideResponse: Partial< WorkerLogsResponse > = {}): WorkerLogsResponse => ({logs: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({})), ...overrideResponse})

export const getGetV1AdminWorkerAiConcurrencyResponseMock = (overrideResponse: Partial< WorkerAIConcurrencyStats > = {}): WorkerAIConcurrencyStats => ({active_requests: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), max_concurrent: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), queued_requests: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), total_requests: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), ...overrideResponse})

export const getGetV1AdminWorkerUsersResponseMock = (overrideResponse: Partial< WorkerUserListResponse > = {}): WorkerUserListResponse => ({users: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.number.int({min: undefined, max: undefined}), username: faker.string.alpha({length: {min: 10, max: 20}}), is_paused: faker.datatype.boolean()})), ...overrideResponse})

export const getPostV1AdminWorkerUsersPauseResponseMock = (overrideResponse: Partial< MessageResponse > = {}): MessageResponse => ({message: faker.string.alpha({length: {min: 10, max: 20}}), ...overrideResponse})

export const getPostV1AdminWorkerUsersResumeResponseMock = (overrideResponse: Partial< MessageResponse > = {}): MessageResponse => ({message: faker.string.alpha({length: {min: 10, max: 20}}), ...overrideResponse})

export const getGetV1AdminWorkerAnalyticsPriorityScoresResponseMock = (overrideResponse: Partial< PriorityAnalytics > = {}): PriorityAnalytics => ({distribution: faker.helpers.arrayElement([{high: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), medium: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), low: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), average: faker.helpers.arrayElement([faker.number.float({min: undefined, max: undefined, fractionDigits: 2}), undefined])}, undefined]), ...overrideResponse})

export const getGetV1AdminWorkerAnalyticsUserPerformanceResponseMock = (overrideResponse: Partial< UserPerformanceAnalytics > = {}): UserPerformanceAnalytics => ({weakAreas: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({})), undefined]), learningPreferences: faker.helpers.arrayElement([{}, undefined]), ...overrideResponse})

export const getGetV1AdminWorkerAnalyticsGenerationIntelligenceResponseMock = (overrideResponse: Partial< GenerationIntelligence > = {}): GenerationIntelligence => ({gapAnalysis: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({})), undefined]), generationSuggestions: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({})), undefined]), ...overrideResponse})

export const getGetV1AdminWorkerAnalyticsSystemHealthResponseMock = (overrideResponse: Partial< SystemHealthAnalytics > = {}): SystemHealthAnalytics => ({performance: faker.helpers.arrayElement([{}, undefined]), backgroundJobs: faker.helpers.arrayElement([{}, undefined]), ...overrideResponse})

export const getGetV1AdminWorkerNotificationsStatsResponseMock = (overrideResponse: Partial< NotificationStats > = {}): NotificationStats => ({total_sent: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined}), undefined]), total_failed: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined}), undefined]), success_rate: faker.helpers.arrayElement([faker.number.float({min: 0, max: 1, fractionDigits: 2}), undefined]), sent_today: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined}), undefined]), sent_this_week: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined}), undefined]), notifications_by_type: faker.helpers.arrayElement([{
        [faker.string.alphanumeric(5)]: faker.number.int({min: undefined, max: undefined})
      }, undefined]), ...overrideResponse})

export const getGetV1AdminWorkerNotificationsErrorsResponseMock = (overrideResponse: Partial< WorkerNotificationErrorsResponse > = {}): WorkerNotificationErrorsResponse => ({errors: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), user_id: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), null]), undefined]), username: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), notification_type: faker.helpers.arrayElement([faker.helpers.arrayElement(['daily_reminder','test_email'] as const), undefined]), error_type: faker.helpers.arrayElement([faker.helpers.arrayElement(['smtp_error','template_error','user_not_found','email_disabled','other'] as const), undefined]), error_message: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), email_address: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), occurred_at: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), resolved_at: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), resolution_notes: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined])})), pagination: {page: faker.number.int({min: 1, max: undefined}), page_size: faker.number.int({min: 1, max: 100}), total: faker.number.int({min: 0, max: undefined}), total_pages: faker.number.int({min: 0, max: undefined})}, stats: {total_errors: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined}), undefined]), unresolved_errors: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined}), undefined]), errors_by_type: faker.helpers.arrayElement([{
        [faker.string.alphanumeric(5)]: faker.number.int({min: undefined, max: undefined})
      }, undefined]), errors_by_notification_type: faker.helpers.arrayElement([{
        [faker.string.alphanumeric(5)]: faker.number.int({min: undefined, max: undefined})
      }, undefined])}, ...overrideResponse})

export const getGetV1AdminWorkerNotificationsSentResponseMock = (overrideResponse: Partial< WorkerNotificationSentResponse > = {}): WorkerNotificationSentResponse => ({notifications: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), user_id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), username: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), email_address: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), notification_type: faker.helpers.arrayElement([faker.helpers.arrayElement(['daily_reminder','test_email'] as const), undefined]), subject: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), template_name: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), sent_at: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), status: faker.helpers.arrayElement([faker.helpers.arrayElement(['sent','failed','bounced'] as const), undefined]), error_message: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), retry_count: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined}), undefined])})), pagination: {page: faker.number.int({min: 1, max: undefined}), page_size: faker.number.int({min: 1, max: 100}), total: faker.number.int({min: 0, max: undefined}), total_pages: faker.number.int({min: 0, max: undefined})}, stats: {total_sent: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined}), undefined]), total_failed: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined}), undefined]), success_rate: faker.helpers.arrayElement([faker.number.float({min: 0, max: 1, fractionDigits: 2}), undefined]), sent_today: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined}), undefined]), sent_this_week: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined}), undefined]), notifications_by_type: faker.helpers.arrayElement([{
        [faker.string.alphanumeric(5)]: faker.number.int({min: undefined, max: undefined})
      }, undefined])}, ...overrideResponse})

export const getPostV1AdminWorkerNotificationsForceSendResponseMock = (overrideResponse: Partial< ForceSendNotificationResponse > = {}): ForceSendNotificationResponse => ({message: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), user: faker.helpers.arrayElement([{id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), username: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), email: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined])}, undefined]), notification: faker.helpers.arrayElement([{type: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), subject: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), status: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined])}, undefined]), ...overrideResponse})

export const getGetV1AdminBackendQuestionsResponseMock = (overrideResponse: Partial< AdminQuestionsResponse > = {}): AdminQuestionsResponse => ({questions: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), language: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), level: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), type: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(QuestionType)), undefined]), status: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(QuestionStatus)), undefined]), difficulty_score: faker.helpers.arrayElement([faker.number.float({min: undefined, max: undefined, fractionDigits: 2}), undefined]), explanation: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), content: faker.helpers.arrayElement([{question: faker.string.alpha({length: {min: 1, max: 1000}}), options: Array.from({ length: faker.number.int({ min: 4, max: 10 }) }, (_, i) => i + 1).map(() => (faker.string.alpha({length: {min: 1, max: 500}}))), sentence: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 2000}}), undefined]), passage: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 5000}}), undefined]), hint: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 500}}), undefined]), topic: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 200}}), undefined])}, undefined]), created_at: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), correct_count: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), incorrect_count: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), total_responses: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), user_count: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), correct_answer: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), reporters: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), topic_category: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), grammar_focus: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), vocabulary_domain: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), scenario: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), style_modifier: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), difficulty_modifier: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), time_context: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), confidence_level: faker.helpers.arrayElement([faker.number.int({min: 1, max: 5}), undefined])})), pagination: {page: faker.number.int({min: 1, max: undefined}), page_size: faker.number.int({min: 1, max: 100}), total: faker.number.int({min: 0, max: undefined}), total_pages: faker.number.int({min: 0, max: undefined})}, stats: {total_questions: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined}), undefined]), total_responses: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined}), undefined]), questions_by_type: faker.helpers.arrayElement([{
        [faker.string.alphanumeric(5)]: faker.number.int({min: undefined, max: undefined})
      }, undefined]), questions_by_level: faker.helpers.arrayElement([{
        [faker.string.alphanumeric(5)]: faker.number.int({min: undefined, max: undefined})
      }, undefined]), questions_by_language: faker.helpers.arrayElement([{
        [faker.string.alphanumeric(5)]: faker.number.int({min: undefined, max: undefined})
      }, undefined])}, ...overrideResponse})

export const getGetV1AdminBackendQuestionsPaginatedResponseMock = (overrideResponse: Partial< AdminQuestionsResponse > = {}): AdminQuestionsResponse => ({questions: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), language: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), level: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), type: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(QuestionType)), undefined]), status: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(QuestionStatus)), undefined]), difficulty_score: faker.helpers.arrayElement([faker.number.float({min: undefined, max: undefined, fractionDigits: 2}), undefined]), explanation: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), content: faker.helpers.arrayElement([{question: faker.string.alpha({length: {min: 1, max: 1000}}), options: Array.from({ length: faker.number.int({ min: 4, max: 10 }) }, (_, i) => i + 1).map(() => (faker.string.alpha({length: {min: 1, max: 500}}))), sentence: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 2000}}), undefined]), passage: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 5000}}), undefined]), hint: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 500}}), undefined]), topic: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 200}}), undefined])}, undefined]), created_at: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), correct_count: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), incorrect_count: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), total_responses: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), user_count: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), correct_answer: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), reporters: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), topic_category: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), grammar_focus: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), vocabulary_domain: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), scenario: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), style_modifier: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), difficulty_modifier: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), time_context: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), confidence_level: faker.helpers.arrayElement([faker.number.int({min: 1, max: 5}), undefined])})), pagination: {page: faker.number.int({min: 1, max: undefined}), page_size: faker.number.int({min: 1, max: 100}), total: faker.number.int({min: 0, max: undefined}), total_pages: faker.number.int({min: 0, max: undefined})}, stats: {total_questions: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined}), undefined]), total_responses: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined}), undefined]), questions_by_type: faker.helpers.arrayElement([{
        [faker.string.alphanumeric(5)]: faker.number.int({min: undefined, max: undefined})
      }, undefined]), questions_by_level: faker.helpers.arrayElement([{
        [faker.string.alphanumeric(5)]: faker.number.int({min: undefined, max: undefined})
      }, undefined]), questions_by_language: faker.helpers.arrayElement([{
        [faker.string.alphanumeric(5)]: faker.number.int({min: undefined, max: undefined})
      }, undefined])}, ...overrideResponse})

export const getGetV1AdminBackendQuestionsIdResponseMock = (overrideResponse: Partial< Question > = {}): Question => ({id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), language: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), level: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), type: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(QuestionType)), undefined]), status: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(QuestionStatus)), undefined]), difficulty_score: faker.helpers.arrayElement([faker.number.float({min: undefined, max: undefined, fractionDigits: 2}), undefined]), explanation: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), content: faker.helpers.arrayElement([{question: faker.string.alpha({length: {min: 1, max: 1000}}), options: Array.from({ length: faker.number.int({ min: 4, max: 10 }) }, (_, i) => i + 1).map(() => (faker.string.alpha({length: {min: 1, max: 500}}))), sentence: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 2000}}), undefined]), passage: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 5000}}), undefined]), hint: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 500}}), undefined]), topic: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 200}}), undefined])}, undefined]), created_at: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), correct_count: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), incorrect_count: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), total_responses: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), user_count: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), correct_answer: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), reporters: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), topic_category: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), grammar_focus: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), vocabulary_domain: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), scenario: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), style_modifier: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), difficulty_modifier: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), time_context: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), confidence_level: faker.helpers.arrayElement([faker.number.int({min: 1, max: 5}), undefined]), ...overrideResponse})

export const getPutV1AdminBackendQuestionsIdResponseMock = (overrideResponse: Partial< MessageResponse > = {}): MessageResponse => ({message: faker.string.alpha({length: {min: 10, max: 20}}), ...overrideResponse})

export const getDeleteV1AdminBackendQuestionsIdResponseMock = (overrideResponse: Partial< MessageResponse > = {}): MessageResponse => ({message: faker.string.alpha({length: {min: 10, max: 20}}), ...overrideResponse})

export const getGetV1AdminBackendQuestionsIdUsersResponseMock = (overrideResponse: Partial< QuestionAssignedUsersResponse > = {}): QuestionAssignedUsersResponse => ({users: Array.from({ length: faker.number.int({ min: 1, max: 5 }) }, (_, i) => i + 1).map(() => ({id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), username: faker.helpers.arrayElement([faker.helpers.fromRegExp('^[a-zA-Z0-9_@.+-]+$'), undefined]), email: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), timezone: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), last_active: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), preferred_language: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), current_level: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), ai_enabled: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), is_paused: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), word_of_day_email_enabled: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), created_at: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), updated_at: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined])})), total_count: faker.number.int({min: undefined, max: undefined}), ...overrideResponse})

export const getPostV1AdminBackendQuestionsIdAssignUsersResponseMock = (overrideResponse: Partial< MessageResponse > = {}): MessageResponse => ({message: faker.string.alpha({length: {min: 10, max: 20}}), ...overrideResponse})

export const getPostV1AdminBackendQuestionsIdUnassignUsersResponseMock = (overrideResponse: Partial< MessageResponse > = {}): MessageResponse => ({message: faker.string.alpha({length: {min: 10, max: 20}}), ...overrideResponse})

export const getPostV1AdminBackendQuestionsIdFixResponseMock = (overrideResponse: Partial< MessageResponse > = {}): MessageResponse => ({message: faker.string.alpha({length: {min: 10, max: 20}}), ...overrideResponse})

export const getPostV1AdminBackendQuestionsIdAiFixResponseMock = (overrideResponse: Partial< AIFixResponse > = {}): AIFixResponse => ({original: {id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), language: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), level: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), type: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(QuestionType)), undefined]), status: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(QuestionStatus)), undefined]), difficulty_score: faker.helpers.arrayElement([faker.number.float({min: undefined, max: undefined, fractionDigits: 2}), undefined]), explanation: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), content: faker.helpers.arrayElement([{question: faker.string.alpha({length: {min: 1, max: 1000}}), options: Array.from({ length: faker.number.int({ min: 4, max: 10 }) }, (_, i) => i + 1).map(() => (faker.string.alpha({length: {min: 1, max: 500}}))), sentence: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 2000}}), undefined]), passage: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 5000}}), undefined]), hint: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 500}}), undefined]), topic: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 200}}), undefined])}, undefined]), created_at: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), correct_count: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), incorrect_count: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), total_responses: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), user_count: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), correct_answer: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), reporters: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), topic_category: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), grammar_focus: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), vocabulary_domain: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), scenario: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), style_modifier: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), difficulty_modifier: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), time_context: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), confidence_level: faker.helpers.arrayElement([faker.number.int({min: 1, max: 5}), undefined])}, suggestion: {...{id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), language: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), level: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), type: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(QuestionType)), undefined]), status: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(QuestionStatus)), undefined]), difficulty_score: faker.helpers.arrayElement([faker.number.float({min: undefined, max: undefined, fractionDigits: 2}), undefined]), explanation: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), content: faker.helpers.arrayElement([{question: faker.string.alpha({length: {min: 1, max: 1000}}), options: Array.from({ length: faker.number.int({ min: 4, max: 10 }) }, (_, i) => i + 1).map(() => (faker.string.alpha({length: {min: 1, max: 500}}))), sentence: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 2000}}), undefined]), passage: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 5000}}), undefined]), hint: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 500}}), undefined]), topic: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 200}}), undefined])}, undefined]), created_at: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), correct_count: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), incorrect_count: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), total_responses: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), user_count: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), correct_answer: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), reporters: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), topic_category: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), grammar_focus: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), vocabulary_domain: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), scenario: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), style_modifier: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), difficulty_modifier: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), time_context: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), confidence_level: faker.helpers.arrayElement([faker.number.int({min: 1, max: 5}), undefined])},...{change_reason: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), additional_context: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined])},}, ...overrideResponse})

export const getPostV1AdminBackendClearUserDataResponseMock = (overrideResponse: Partial< MessageResponse > = {}): MessageResponse => ({message: faker.string.alpha({length: {min: 10, max: 20}}), ...overrideResponse})

export const getPostV1AdminBackendClearDatabaseResponseMock = (overrideResponse: Partial< MessageResponse > = {}): MessageResponse => ({message: faker.string.alpha({length: {min: 10, max: 20}}), ...overrideResponse})

export const getPostV1AdminBackendUserzIdClearResponseMock = (overrideResponse: Partial< MessageResponse > = {}): MessageResponse => ({message: faker.string.alpha({length: {min: 10, max: 20}}), ...overrideResponse})

export const getGetV1AdminBackendUsageStatsResponseMock = (overrideResponse: Partial< UsageStatsResponse > = {}): UsageStatsResponse => ({usage_stats: {
        [faker.string.alphanumeric(5)]: {
        [faker.string.alphanumeric(5)]: {characters_used: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined}), undefined]), requests_made: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined}), undefined]), quota: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined}), undefined])}
      }
      }, monthly_totals: {
        [faker.string.alphanumeric(5)]: {
        [faker.string.alphanumeric(5)]: {total_characters: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined}), undefined]), total_requests: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined}), undefined])}
      }
      }, services: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => (faker.string.alpha({length: {min: 10, max: 20}}))), cache_stats: faker.helpers.arrayElement([{total_cache_hits_requests: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined}), undefined]), total_cache_hits_characters: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined}), undefined]), total_cache_misses_requests: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined}), undefined]), cache_hit_rate: faker.helpers.arrayElement([faker.number.float({min: 0, max: 100, fractionDigits: 2}), undefined])}, undefined]), ...overrideResponse})

export const getGetV1AdminBackendUsageStatsServiceResponseMock = (overrideResponse: Partial< ServiceUsageStatsResponse > = {}): ServiceUsageStatsResponse => ({service: faker.string.alpha({length: {min: 10, max: 20}}), data: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({month: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), usage_type: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), characters_used: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined}), undefined]), requests_made: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined}), undefined]), quota: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined}), undefined])})), ...overrideResponse})

export const getGetV1AdminBackendReportedQuestionsResponseMock = (overrideResponse: Partial< AdminReportedQuestionsResponse > = {}): AdminReportedQuestionsResponse => ({questions: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), language: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), level: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), type: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(QuestionType)), undefined]), status: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(QuestionStatus)), undefined]), difficulty_score: faker.helpers.arrayElement([faker.number.float({min: undefined, max: undefined, fractionDigits: 2}), undefined]), explanation: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), content: faker.helpers.arrayElement([{question: faker.string.alpha({length: {min: 1, max: 1000}}), options: Array.from({ length: faker.number.int({ min: 4, max: 10 }) }, (_, i) => i + 1).map(() => (faker.string.alpha({length: {min: 1, max: 500}}))), sentence: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 2000}}), undefined]), passage: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 5000}}), undefined]), hint: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 500}}), undefined]), topic: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 200}}), undefined])}, undefined]), created_at: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), correct_count: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), incorrect_count: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), total_responses: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), user_count: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), correct_answer: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), reporters: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), topic_category: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), grammar_focus: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), vocabulary_domain: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), scenario: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), style_modifier: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), difficulty_modifier: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), time_context: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), confidence_level: faker.helpers.arrayElement([faker.number.int({min: 1, max: 5}), undefined])})), pagination: {page: faker.number.int({min: 1, max: undefined}), page_size: faker.number.int({min: 1, max: 100}), total: faker.number.int({min: 0, max: undefined}), total_pages: faker.number.int({min: 0, max: undefined})}, stats: {total_reported: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), reported_by_type: faker.helpers.arrayElement([{
        [faker.string.alphanumeric(5)]: faker.number.int({min: undefined, max: undefined})
      }, undefined]), reported_by_level: faker.helpers.arrayElement([{
        [faker.string.alphanumeric(5)]: faker.number.int({min: undefined, max: undefined})
      }, undefined]), reported_by_language: faker.helpers.arrayElement([{
        [faker.string.alphanumeric(5)]: faker.number.int({min: undefined, max: undefined})
      }, undefined])}, ...overrideResponse})

export const getGetV1AdminBackendStoriesResponseMock = (overrideResponse: Partial< AdminStoriesResponse > = {}): AdminStoriesResponse => ({stories: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), user_id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), title: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), language: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), subject: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), author_style: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), time_period: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), genre: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), tone: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), character_names: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), custom_instructions: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), section_length_override: faker.helpers.arrayElement([faker.helpers.arrayElement(['short','medium','long'] as const), undefined]), status: faker.helpers.arrayElement([faker.helpers.arrayElement(['active','archived','completed'] as const), undefined]), auto_generation_paused: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), last_section_generated_at: faker.helpers.arrayElement([faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), undefined]), created_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), updated_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), extra_generations_today: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined}), undefined])})), pagination: {page: faker.number.int({min: 1, max: undefined}), page_size: faker.number.int({min: 1, max: 100}), total: faker.number.int({min: 0, max: undefined}), total_pages: faker.number.int({min: 0, max: undefined})}, ...overrideResponse})

export const getGetV1AdminBackendStoriesIdResponseMock = (): StoryWithSections => ({...{id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), user_id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), title: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), language: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), subject: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), author_style: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), time_period: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), genre: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), tone: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), character_names: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), custom_instructions: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), section_length_override: faker.helpers.arrayElement([faker.helpers.arrayElement(['short','medium','long'] as const), undefined]), status: faker.helpers.arrayElement([faker.helpers.arrayElement(['active','archived','completed'] as const), undefined]), auto_generation_paused: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), last_section_generated_at: faker.helpers.arrayElement([faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), undefined]), created_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), updated_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), extra_generations_today: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined}), undefined])},...{sections: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), story_id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), section_number: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), content: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), language_level: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), word_count: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), generated_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), generation_date: faker.helpers.arrayElement([faker.date.past().toISOString().split('T')[0], undefined])})), undefined])},})

export const getGetV1AdminBackendStorySectionsIdResponseMock = (): StorySectionWithQuestions => ({...{id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), story_id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), section_number: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), content: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), language_level: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), word_count: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), generated_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), generation_date: faker.helpers.arrayElement([faker.date.past().toISOString().split('T')[0], undefined])},...{questions: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), section_id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), question_text: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), options: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => (faker.string.alpha({length: {min: 10, max: 20}}))), undefined]), correct_answer_index: faker.helpers.arrayElement([faker.number.int({min: 0, max: 3}), undefined]), explanation: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), created_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined])})), undefined])},})

export const getPostV1QuizChatStreamResponseMock = (): string => (faker.word.sample())

export const getGetV1DailyQuestionsDateResponseMock = (overrideResponse: Partial< DailyQuestionsResponse > = {}): DailyQuestionsResponse => ({date: faker.date.past().toISOString().split('T')[0], questions: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.number.int({min: undefined, max: undefined}), user_id: faker.number.int({min: undefined, max: undefined}), question_id: faker.number.int({min: undefined, max: undefined}), assignment_date: faker.date.past().toISOString().split('T')[0], is_completed: faker.datatype.boolean(), completed_at: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), created_at: faker.string.alpha({length: {min: 10, max: 20}}), user_answer_index: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), null]), undefined]), submitted_at: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), user_shown_count: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), user_total_responses: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), user_correct_count: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), user_incorrect_count: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), question: {id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), language: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), level: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), type: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(QuestionType)), undefined]), status: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(QuestionStatus)), undefined]), difficulty_score: faker.helpers.arrayElement([faker.number.float({min: undefined, max: undefined, fractionDigits: 2}), undefined]), explanation: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), content: faker.helpers.arrayElement([{question: faker.string.alpha({length: {min: 1, max: 1000}}), options: Array.from({ length: faker.number.int({ min: 4, max: 10 }) }, (_, i) => i + 1).map(() => (faker.string.alpha({length: {min: 1, max: 500}}))), sentence: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 2000}}), undefined]), passage: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 5000}}), undefined]), hint: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 500}}), undefined]), topic: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 200}}), undefined])}, undefined]), created_at: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), correct_count: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), incorrect_count: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), total_responses: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), user_count: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), correct_answer: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), reporters: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), topic_category: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), grammar_focus: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), vocabulary_domain: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), scenario: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), style_modifier: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), difficulty_modifier: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), time_context: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), confidence_level: faker.helpers.arrayElement([faker.number.int({min: 1, max: 5}), undefined])}})), ...overrideResponse})

export const getPostV1DailyQuestionsDateCompleteQuestionIdResponseMock = (overrideResponse: Partial< SuccessResponse > = {}): SuccessResponse => ({success: faker.datatype.boolean(), message: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 500}}), undefined]), ...overrideResponse})

export const getDeleteV1DailyQuestionsDateCompleteQuestionIdResponseMock = (overrideResponse: Partial< SuccessResponse > = {}): SuccessResponse => ({success: faker.datatype.boolean(), message: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 500}}), undefined]), ...overrideResponse})

export const getGetV1DailyDatesResponseMock = (overrideResponse: Partial< DailyDatesResponse > = {}): DailyDatesResponse => ({dates: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => (faker.date.past().toISOString().split('T')[0])), ...overrideResponse})

export const getPostV1DailyQuestionsDateAnswerQuestionIdResponseMock = (): DailyAnswerResponse => ({...{is_correct: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), user_answer: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), user_answer_index: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), explanation: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), next_difficulty: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), correct_answer_index: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined])},...{is_completed: faker.helpers.arrayElement([faker.datatype.boolean(), undefined])},})

export const getGetV1DailyProgressDateResponseMock = (overrideResponse: Partial< DailyProgress > = {}): DailyProgress => ({date: faker.date.past().toISOString().split('T')[0], completed: faker.number.int({min: undefined, max: undefined}), total: faker.number.int({min: undefined, max: undefined}), ...overrideResponse})

export const getGetV1DailyHistoryQuestionIdResponseMock = (overrideResponse: Partial< DailyQuestionHistoryResponse > = {}): DailyQuestionHistoryResponse => ({history: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({assignment_date: faker.string.alpha({length: {min: 10, max: 20}}), is_completed: faker.datatype.boolean(), is_correct: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), submitted_at: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined])})), ...overrideResponse})

export const getGetV1WordOfDayDateResponseMock = (overrideResponse: Partial< WordOfTheDayDisplay > = {}): WordOfTheDayDisplay => ({date: faker.date.past().toISOString().split('T')[0], word: faker.string.alpha({length: {min: 10, max: 20}}), translation: faker.string.alpha({length: {min: 10, max: 20}}), sentence: faker.string.alpha({length: {min: 10, max: 20}}), source_type: faker.helpers.arrayElement(['vocabulary_question','snippet'] as const), source_id: faker.number.int({min: undefined, max: undefined}), language: faker.string.alpha({length: {min: 10, max: 20}}), level: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), context: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), explanation: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), topic_category: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), ...overrideResponse})

export const getGetV1WordOfDayResponseMock = (overrideResponse: Partial< WordOfTheDayDisplay > = {}): WordOfTheDayDisplay => ({date: faker.date.past().toISOString().split('T')[0], word: faker.string.alpha({length: {min: 10, max: 20}}), translation: faker.string.alpha({length: {min: 10, max: 20}}), sentence: faker.string.alpha({length: {min: 10, max: 20}}), source_type: faker.helpers.arrayElement(['vocabulary_question','snippet'] as const), source_id: faker.number.int({min: undefined, max: undefined}), language: faker.string.alpha({length: {min: 10, max: 20}}), level: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), context: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), explanation: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), topic_category: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), ...overrideResponse})

export const getGetV1WordOfDayEmbedResponseMock = (): string => (faker.word.sample())

export const getGetV1WordOfDayDateEmbedResponseMock = (): string => (faker.word.sample())

export const getGetV1WordOfDayHistoryResponseMock = (overrideResponse: Partial< WordOfDayHistoryResponse > = {}): WordOfDayHistoryResponse => ({words: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({date: faker.date.past().toISOString().split('T')[0], word: faker.string.alpha({length: {min: 10, max: 20}}), translation: faker.string.alpha({length: {min: 10, max: 20}}), sentence: faker.string.alpha({length: {min: 10, max: 20}}), source_type: faker.helpers.arrayElement(['vocabulary_question','snippet'] as const), source_id: faker.number.int({min: undefined, max: undefined}), language: faker.string.alpha({length: {min: 10, max: 20}}), level: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), context: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), explanation: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), topic_category: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined])})), count: faker.number.int({min: undefined, max: undefined}), ...overrideResponse})

export const getPostV1StoryResponseMock = (overrideResponse: Partial< Story > = {}): Story => ({id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), user_id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), title: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), language: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), subject: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), author_style: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), time_period: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), genre: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), tone: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), character_names: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), custom_instructions: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), section_length_override: faker.helpers.arrayElement([faker.helpers.arrayElement(['short','medium','long'] as const), undefined]), status: faker.helpers.arrayElement([faker.helpers.arrayElement(['active','archived','completed'] as const), undefined]), auto_generation_paused: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), last_section_generated_at: faker.helpers.arrayElement([faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), undefined]), created_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), updated_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), extra_generations_today: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined}), undefined]), ...overrideResponse})

export const getGetV1StoryResponseMock = (): Story[] => (Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), user_id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), title: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), language: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), subject: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), author_style: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), time_period: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), genre: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), tone: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), character_names: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), custom_instructions: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), section_length_override: faker.helpers.arrayElement([faker.helpers.arrayElement(['short','medium','long'] as const), undefined]), status: faker.helpers.arrayElement([faker.helpers.arrayElement(['active','archived','completed'] as const), undefined]), auto_generation_paused: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), last_section_generated_at: faker.helpers.arrayElement([faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), undefined]), created_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), updated_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), extra_generations_today: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined}), undefined])})))

export const getGetV1StoryCurrentResponseMock = (overrideResponse: Partial< StoryWithSections | GeneratingResponse > = {}): StoryWithSections | GeneratingResponse => (faker.helpers.arrayElement([{...{id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), user_id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), title: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), language: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), subject: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), author_style: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), time_period: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), genre: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), tone: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), character_names: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), custom_instructions: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), section_length_override: faker.helpers.arrayElement([faker.helpers.arrayElement(['short','medium','long'] as const), undefined]), status: faker.helpers.arrayElement([faker.helpers.arrayElement(['active','archived','completed'] as const), undefined]), auto_generation_paused: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), last_section_generated_at: faker.helpers.arrayElement([faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), undefined]), created_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), updated_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), extra_generations_today: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined}), undefined])},...{sections: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), story_id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), section_number: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), content: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), language_level: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), word_count: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), generated_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), generation_date: faker.helpers.arrayElement([faker.date.past().toISOString().split('T')[0], undefined])})), undefined])},}, {status: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 100}}), undefined]), message: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 500}}), undefined]), ai_model: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), api_key: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), ...overrideResponse}]))

export const getGetV1StoryIdResponseMock = (): StoryWithSections => ({...{id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), user_id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), title: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), language: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), subject: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), author_style: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), time_period: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), genre: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), tone: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), character_names: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), custom_instructions: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), section_length_override: faker.helpers.arrayElement([faker.helpers.arrayElement(['short','medium','long'] as const), undefined]), status: faker.helpers.arrayElement([faker.helpers.arrayElement(['active','archived','completed'] as const), undefined]), auto_generation_paused: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), last_section_generated_at: faker.helpers.arrayElement([faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), undefined]), created_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), updated_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), extra_generations_today: faker.helpers.arrayElement([faker.number.int({min: 0, max: undefined}), undefined])},...{sections: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), story_id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), section_number: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), content: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), language_level: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), word_count: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), generated_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), generation_date: faker.helpers.arrayElement([faker.date.past().toISOString().split('T')[0], undefined])})), undefined])},})

export const getPostV1StoryIdGenerateResponseMock = (overrideResponse: Partial< StorySection > = {}): StorySection => ({id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), story_id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), section_number: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), content: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), language_level: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), word_count: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), generated_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), generation_date: faker.helpers.arrayElement([faker.date.past().toISOString().split('T')[0], undefined]), ...overrideResponse})

export const getPostV1StoryIdToggleAutoGenerationResponseMock = (overrideResponse: Partial< ToggleAutoGenerationResponse > = {}): ToggleAutoGenerationResponse => ({message: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), auto_generation_paused: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), ...overrideResponse})

export const getGetV1StorySectionIdResponseMock = (): StorySectionWithQuestions => ({...{id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), story_id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), section_number: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), content: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), language_level: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), word_count: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), generated_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), generation_date: faker.helpers.arrayElement([faker.date.past().toISOString().split('T')[0], undefined])},...{questions: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), section_id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), question_text: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), options: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => (faker.string.alpha({length: {min: 10, max: 20}}))), undefined]), correct_answer_index: faker.helpers.arrayElement([faker.number.int({min: 0, max: 3}), undefined]), explanation: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), created_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined])})), undefined])},})

export const getGetV1StoryIdExportResponseMock = (): Blob => (new Blob(faker.helpers.arrayElements(faker.word.words(10).split(' '))))

export const getGetV1PreferencesLearningResponseMock = (overrideResponse: Partial< UserLearningPreferences > = {}): UserLearningPreferences => ({focus_on_weak_areas: faker.datatype.boolean(), fresh_question_ratio: faker.number.float({min: 0, max: 1, fractionDigits: 2}), known_question_penalty: faker.number.float({min: 0, max: 1, fractionDigits: 2}), review_interval_days: faker.number.int({min: 1, max: 60}), weak_area_boost: faker.number.float({min: 1, max: 5, fractionDigits: 2}), daily_reminder_enabled: faker.datatype.boolean(), tts_voice: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), daily_goal: faker.helpers.arrayElement([faker.number.int({min: 1, max: undefined}), undefined]), ...overrideResponse})

export const getPutV1PreferencesLearningResponseMock = (overrideResponse: Partial< UserLearningPreferences > = {}): UserLearningPreferences => ({focus_on_weak_areas: faker.datatype.boolean(), fresh_question_ratio: faker.number.float({min: 0, max: 1, fractionDigits: 2}), known_question_penalty: faker.number.float({min: 0, max: 1, fractionDigits: 2}), review_interval_days: faker.number.int({min: 1, max: 60}), weak_area_boost: faker.number.float({min: 1, max: 5, fractionDigits: 2}), daily_reminder_enabled: faker.datatype.boolean(), tts_voice: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), daily_goal: faker.helpers.arrayElement([faker.number.int({min: 1, max: undefined}), undefined]), ...overrideResponse})

export const getGetV1VersionResponseServiceVersionMock = (overrideResponse: Partial<ServiceVersion> = {}): ServiceVersion => ({...{service: faker.string.alpha({length: {min: 10, max: 50}}), version: faker.string.alpha({length: {min: 10, max: 100}}), commit: faker.string.alpha({length: {min: 10, max: 50}}), buildTime: faker.string.alpha({length: {min: 10, max: 100}})}, ...overrideResponse});

export const getGetV1VersionResponseMock = (overrideResponse: Partial< AggregatedVersion > = {}): AggregatedVersion => ({backend: {service: faker.string.alpha({length: {min: 10, max: 50}}), version: faker.string.alpha({length: {min: 10, max: 100}}), commit: faker.string.alpha({length: {min: 10, max: 50}}), buildTime: faker.string.alpha({length: {min: 10, max: 100}})}, worker: faker.helpers.arrayElement([{...getGetV1VersionResponseServiceVersionMock()},{error: faker.string.alpha({length: {min: 10, max: 20}})},]), ...overrideResponse})

export const getGetHealthResponseMock = (overrideResponse: Partial< HealthStatusResponse > = {}): HealthStatusResponse => ({status: faker.helpers.arrayElement(['ok'] as const), service: faker.string.alpha({length: {min: 10, max: 20}}), ...overrideResponse})

export const getGetV1AdminWorkerDailyUsersUserIdQuestionsDateResponseMock = (overrideResponse: Partial< AdminDailyQuestionsResponse > = {}): AdminDailyQuestionsResponse => ({questions: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.number.int({min: undefined, max: undefined}), user_id: faker.number.int({min: undefined, max: undefined}), question_id: faker.number.int({min: undefined, max: undefined}), assignment_date: faker.date.past().toISOString().split('T')[0], is_completed: faker.datatype.boolean(), completed_at: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), created_at: faker.string.alpha({length: {min: 10, max: 20}}), user_answer_index: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), null]), undefined]), submitted_at: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), user_shown_count: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), user_total_responses: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), user_correct_count: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), user_incorrect_count: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), question: {id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), language: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), level: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), type: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(QuestionType)), undefined]), status: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(QuestionStatus)), undefined]), difficulty_score: faker.helpers.arrayElement([faker.number.float({min: undefined, max: undefined, fractionDigits: 2}), undefined]), explanation: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), content: faker.helpers.arrayElement([{question: faker.string.alpha({length: {min: 1, max: 1000}}), options: Array.from({ length: faker.number.int({ min: 4, max: 10 }) }, (_, i) => i + 1).map(() => (faker.string.alpha({length: {min: 1, max: 500}}))), sentence: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 2000}}), undefined]), passage: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 5000}}), undefined]), hint: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 500}}), undefined]), topic: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 200}}), undefined])}, undefined]), created_at: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), correct_count: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), incorrect_count: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), total_responses: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), user_count: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), correct_answer: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), reporters: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), topic_category: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), grammar_focus: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), vocabulary_domain: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), scenario: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), style_modifier: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), difficulty_modifier: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), time_context: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), confidence_level: faker.helpers.arrayElement([faker.number.int({min: 1, max: 5}), undefined])}})), ...overrideResponse})

export const getPostV1AdminWorkerDailyUsersUserIdQuestionsDateRegenerateResponseMock = (overrideResponse: Partial< SuccessResponse > = {}): SuccessResponse => ({success: faker.datatype.boolean(), message: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 500}}), undefined]), ...overrideResponse})

export const getGetV1AdminBackendFeedbackResponseMock = (overrideResponse: Partial< FeedbackListResponse > = {}): FeedbackListResponse => ({items: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.number.int({min: undefined, max: undefined}), user_id: faker.number.int({min: undefined, max: undefined}), feedback_text: faker.string.alpha({length: {min: 10, max: 5000}}), feedback_type: faker.helpers.arrayElement(['bug','feature_request','general','improvement'] as const), context_data: faker.helpers.arrayElement([{}, undefined]), screenshot_data: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), screenshot_url: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), status: faker.helpers.arrayElement(['new','in_progress','resolved','dismissed'] as const), admin_notes: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), assigned_to_user_id: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), null]), undefined]), resolved_at: faker.helpers.arrayElement([faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), undefined]), resolved_by_user_id: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), null]), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`})), total: faker.number.int({min: 0, max: undefined}), page: faker.number.int({min: 1, max: undefined}), page_size: faker.number.int({min: 1, max: undefined}), ...overrideResponse})

export const getDeleteV1AdminBackendFeedbackResponseMock = (overrideResponse: Partial< BulkDeleteResponse > = {}): BulkDeleteResponse => ({deleted_count: faker.number.int({min: undefined, max: undefined}), ...overrideResponse})

export const getGetV1AdminBackendFeedbackIdResponseMock = (overrideResponse: Partial< FeedbackReport > = {}): FeedbackReport => ({id: faker.number.int({min: undefined, max: undefined}), user_id: faker.number.int({min: undefined, max: undefined}), feedback_text: faker.string.alpha({length: {min: 10, max: 5000}}), feedback_type: faker.helpers.arrayElement(['bug','feature_request','general','improvement'] as const), context_data: faker.helpers.arrayElement([{}, undefined]), screenshot_data: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), screenshot_url: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), status: faker.helpers.arrayElement(['new','in_progress','resolved','dismissed'] as const), admin_notes: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), assigned_to_user_id: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), null]), undefined]), resolved_at: faker.helpers.arrayElement([faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), undefined]), resolved_by_user_id: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), null]), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, ...overrideResponse})

export const getPatchV1AdminBackendFeedbackIdResponseMock = (overrideResponse: Partial< FeedbackReport > = {}): FeedbackReport => ({id: faker.number.int({min: undefined, max: undefined}), user_id: faker.number.int({min: undefined, max: undefined}), feedback_text: faker.string.alpha({length: {min: 10, max: 5000}}), feedback_type: faker.helpers.arrayElement(['bug','feature_request','general','improvement'] as const), context_data: faker.helpers.arrayElement([{}, undefined]), screenshot_data: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), screenshot_url: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), status: faker.helpers.arrayElement(['new','in_progress','resolved','dismissed'] as const), admin_notes: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), assigned_to_user_id: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), null]), undefined]), resolved_at: faker.helpers.arrayElement([faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), undefined]), resolved_by_user_id: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), null]), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, ...overrideResponse})

export const getPostV1AdminBackendFeedbackIdLinearIssueResponseMock = (overrideResponse: Partial< CreateLinearIssueResponse > = {}): CreateLinearIssueResponse => ({issue_id: faker.string.alpha({length: {min: 10, max: 20}}), issue_url: faker.internet.url(), title: faker.string.alpha({length: {min: 10, max: 20}}), ...overrideResponse})

export const getPostV1ApiKeysResponseMock = (overrideResponse: Partial< CreateAPIKeyResponse > = {}): CreateAPIKeyResponse => ({id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), key_name: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), key: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), key_prefix: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), permission_level: faker.helpers.arrayElement([faker.helpers.arrayElement(['readonly','full'] as const), undefined]), created_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), message: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), ...overrideResponse})

export const getGetV1ApiKeysResponseMock = (overrideResponse: Partial< APIKeysListResponse > = {}): APIKeysListResponse => ({api_keys: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), key_name: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), key_prefix: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), permission_level: faker.helpers.arrayElement([faker.helpers.arrayElement(['readonly','full'] as const), undefined]), last_used_at: faker.helpers.arrayElement([faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), undefined]), created_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), updated_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined])})), undefined]), count: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), ...overrideResponse})

export const getDeleteV1ApiKeysIdResponseMock = (overrideResponse: Partial< DeleteAPIKeyResponse > = {}): DeleteAPIKeyResponse => ({success: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), message: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), ...overrideResponse})

export const getGetV1ApiKeysTestReadResponseMock = (overrideResponse: Partial< APIKeyTestResponse > = {}): APIKeyTestResponse => ({ok: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), user_id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), username: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), permission_level: faker.helpers.arrayElement([faker.helpers.arrayElement(['readonly','full'] as const), undefined]), api_key_id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), method: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), ...overrideResponse})

export const getPostV1ApiKeysTestWriteResponseMock = (overrideResponse: Partial< APIKeyTestResponse > = {}): APIKeyTestResponse => ({ok: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), user_id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), username: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), permission_level: faker.helpers.arrayElement([faker.helpers.arrayElement(['readonly','full'] as const), undefined]), api_key_id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), method: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), ...overrideResponse})

export const getPostV1TranslateResponseMock = (overrideResponse: Partial< TranslateResponse > = {}): TranslateResponse => ({translated_text: faker.string.alpha({length: {min: 10, max: 20}}), source_language: faker.string.alpha({length: {min: 10, max: 20}}), target_language: faker.string.alpha({length: {min: 10, max: 20}}), confidence: faker.helpers.arrayElement([faker.number.float({min: 0, max: 1, fractionDigits: 2}), undefined]), ...overrideResponse})

export const getPostV1TranslationPracticeGenerateResponseMock = (overrideResponse: Partial< TranslationPracticeSentenceResponse > = {}): TranslationPracticeSentenceResponse => ({id: faker.number.int({min: undefined, max: undefined}), sentence_text: faker.string.alpha({length: {min: 10, max: 20}}), source_language: faker.string.alpha({length: {min: 10, max: 20}}), target_language: faker.string.alpha({length: {min: 10, max: 20}}), language_level: faker.string.alpha({length: {min: 10, max: 20}}), source_type: faker.string.alpha({length: {min: 10, max: 20}}), source_id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), topic: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, ...overrideResponse})

export const getGetV1TranslationPracticeSentenceResponseMock = (overrideResponse: Partial< TranslationPracticeSentenceResponse > = {}): TranslationPracticeSentenceResponse => ({id: faker.number.int({min: undefined, max: undefined}), sentence_text: faker.string.alpha({length: {min: 10, max: 20}}), source_language: faker.string.alpha({length: {min: 10, max: 20}}), target_language: faker.string.alpha({length: {min: 10, max: 20}}), language_level: faker.string.alpha({length: {min: 10, max: 20}}), source_type: faker.string.alpha({length: {min: 10, max: 20}}), source_id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), topic: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, ...overrideResponse})

export const getPostV1TranslationPracticeSubmitResponseMock = (overrideResponse: Partial< TranslationPracticeSessionResponse > = {}): TranslationPracticeSessionResponse => ({id: faker.number.int({min: undefined, max: undefined}), sentence_id: faker.number.int({min: undefined, max: undefined}), original_sentence: faker.string.alpha({length: {min: 10, max: 20}}), user_translation: faker.string.alpha({length: {min: 10, max: 20}}), translation_direction: faker.string.alpha({length: {min: 10, max: 20}}), ai_feedback: faker.string.alpha({length: {min: 10, max: 20}}), ai_score: faker.helpers.arrayElement([faker.number.float({min: 0, max: 5, fractionDigits: 2}), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, ...overrideResponse})

export const getGetV1TranslationPracticeHistoryResponseMock = (overrideResponse: Partial< TranslationPracticeHistoryResponse > = {}): TranslationPracticeHistoryResponse => ({sessions: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.number.int({min: undefined, max: undefined}), sentence_id: faker.number.int({min: undefined, max: undefined}), original_sentence: faker.string.alpha({length: {min: 10, max: 20}}), user_translation: faker.string.alpha({length: {min: 10, max: 20}}), translation_direction: faker.string.alpha({length: {min: 10, max: 20}}), ai_feedback: faker.string.alpha({length: {min: 10, max: 20}}), ai_score: faker.helpers.arrayElement([faker.number.float({min: 0, max: 5, fractionDigits: 2}), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`})), total: faker.number.int({min: 0, max: undefined}), limit: faker.number.int({min: 1, max: undefined}), offset: faker.number.int({min: 0, max: undefined}), ...overrideResponse})

export const getGetV1TranslationPracticeStatsResponseMock = (overrideResponse: Partial< TranslationPracticeStatsResponse > = {}): TranslationPracticeStatsResponse => ({total_sessions: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), average_score: faker.helpers.arrayElement([faker.number.float({min: undefined, max: undefined, fractionDigits: 2}), undefined]), min_score: faker.helpers.arrayElement([faker.number.float({min: undefined, max: undefined, fractionDigits: 2}), undefined]), max_score: faker.helpers.arrayElement([faker.number.float({min: undefined, max: undefined, fractionDigits: 2}), undefined]), excellent_count: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), good_count: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), needs_improvement_count: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), ...overrideResponse})

export const getPostV1AudioSpeechResponseMock = (overrideResponse: Partial< TTSResponse > = {}): TTSResponse => ({type: faker.helpers.arrayElement([faker.helpers.arrayElement(['audio','usage','error'] as const), undefined]), audio: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), usage: faker.helpers.arrayElement([{input_tokens: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), output_tokens: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), total_tokens: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined])}, undefined]), error: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), ...overrideResponse})

export const getPostV1AudioSpeechInitResponseMock = (overrideResponse: Partial< TTSStreamInitResponse > = {}): TTSStreamInitResponse => ({stream_id: faker.string.alpha({length: {min: 10, max: 20}}), token: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), undefined]), ...overrideResponse})

export const getGetV1AudioSpeechStreamStreamIdResponseMock = (): Blob => (new Blob(faker.helpers.arrayElements(faker.word.words(10).split(' '))))


export const getPostV1AuthLoginMockHandler = (overrideResponse?: LoginResponse | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<LoginResponse> | LoginResponse), options?: RequestHandlerOptions) => {
  return http.post('*/v1/auth/login', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPostV1AuthLoginResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getPostV1AuthLogoutMockHandler = (overrideResponse?: SuccessResponse | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<SuccessResponse> | SuccessResponse), options?: RequestHandlerOptions) => {
  return http.post('*/v1/auth/logout', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPostV1AuthLogoutResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetV1AuthStatusMockHandler = (overrideResponse?: AuthStatusResponse | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<AuthStatusResponse> | AuthStatusResponse), options?: RequestHandlerOptions) => {
  return http.get('*/v1/auth/status', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1AuthStatusResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetV1AuthCheckMockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<void> | void), options?: RequestHandlerOptions) => {
  return http.get('*/v1/auth/check', async (info) => {await delay(1000);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 204,
        
      })
  }, options)
}

export const getPostV1AuthSignupMockHandler = (overrideResponse?: SuccessResponse | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<SuccessResponse> | SuccessResponse), options?: RequestHandlerOptions) => {
  return http.post('*/v1/auth/signup', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPostV1AuthSignupResponseMock()),
      { status: 201,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetV1AuthSignupStatusMockHandler = (overrideResponse?: SignupStatusResponse | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<SignupStatusResponse> | SignupStatusResponse), options?: RequestHandlerOptions) => {
  return http.get('*/v1/auth/signup/status', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1AuthSignupStatusResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetV1AuthGoogleLoginMockHandler = (overrideResponse?: GoogleOAuthLoginResponse | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<GoogleOAuthLoginResponse> | GoogleOAuthLoginResponse), options?: RequestHandlerOptions) => {
  return http.get('*/v1/auth/google/login', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1AuthGoogleLoginResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetV1AuthGoogleCallbackMockHandler = (overrideResponse?: LoginResponse | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<LoginResponse> | LoginResponse), options?: RequestHandlerOptions) => {
  return http.get('*/v1/auth/google/callback', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1AuthGoogleCallbackResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetV1QuizQuestionMockHandler = (overrideResponse?: Question | GeneratingResponse | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<Question | GeneratingResponse> | Question | GeneratingResponse), options?: RequestHandlerOptions) => {
  return http.get('*/v1/quiz/question', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1QuizQuestionResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetV1QuizQuestionIdMockHandler = (overrideResponse?: Question | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<Question> | Question), options?: RequestHandlerOptions) => {
  return http.get('*/v1/quiz/question/:id', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1QuizQuestionIdResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getPostV1QuizAnswerMockHandler = (overrideResponse?: AnswerResponse | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<AnswerResponse> | AnswerResponse), options?: RequestHandlerOptions) => {
  return http.post('*/v1/quiz/answer', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPostV1QuizAnswerResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetV1QuizProgressMockHandler = (overrideResponse?: UserProgress | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<UserProgress> | UserProgress), options?: RequestHandlerOptions) => {
  return http.get('*/v1/quiz/progress', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1QuizProgressResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetV1QuizAiTokenUsageMockHandler = (overrideResponse?: UserUsageStats[] | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<UserUsageStats[]> | UserUsageStats[]), options?: RequestHandlerOptions) => {
  return http.get('*/v1/quiz/ai-token-usage', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1QuizAiTokenUsageResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetV1QuizAiTokenUsageDailyMockHandler = (overrideResponse?: UserUsageStatsDaily[] | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<UserUsageStatsDaily[]> | UserUsageStatsDaily[]), options?: RequestHandlerOptions) => {
  return http.get('*/v1/quiz/ai-token-usage/daily', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1QuizAiTokenUsageDailyResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetV1QuizAiTokenUsageHourlyMockHandler = (overrideResponse?: UserUsageStatsHourly[] | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<UserUsageStatsHourly[]> | UserUsageStatsHourly[]), options?: RequestHandlerOptions) => {
  return http.get('*/v1/quiz/ai-token-usage/hourly', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1QuizAiTokenUsageHourlyResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getPostV1QuizQuestionIdReportMockHandler = (overrideResponse?: SuccessResponse | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<SuccessResponse> | SuccessResponse), options?: RequestHandlerOptions) => {
  return http.post('*/v1/quiz/question/:id/report', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPostV1QuizQuestionIdReportResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getPostV1QuizQuestionIdMarkKnownMockHandler = (overrideResponse?: SuccessResponse | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<SuccessResponse> | SuccessResponse), options?: RequestHandlerOptions) => {
  return http.post('*/v1/quiz/question/:id/mark-known', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPostV1QuizQuestionIdMarkKnownResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetV1QuizWorkerStatusMockHandler = (overrideResponse?: WorkerStatusResponse | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<WorkerStatusResponse> | WorkerStatusResponse), options?: RequestHandlerOptions) => {
  return http.get('*/v1/quiz/worker-status', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1QuizWorkerStatusResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getPutV1SettingsMockHandler = (overrideResponse?: SuccessResponse | ((info: Parameters<Parameters<typeof http.put>[1]>[0]) => Promise<SuccessResponse> | SuccessResponse), options?: RequestHandlerOptions) => {
  return http.put('*/v1/settings', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPutV1SettingsResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetV1SettingsAiProvidersMockHandler = (overrideResponse?: AIProviders | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<AIProviders> | AIProviders), options?: RequestHandlerOptions) => {
  return http.get('*/v1/settings/ai-providers', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1SettingsAiProvidersResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getPostV1SettingsTestAiMockHandler = (overrideResponse?: SuccessResponse | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<SuccessResponse> | SuccessResponse), options?: RequestHandlerOptions) => {
  return http.post('*/v1/settings/test-ai', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPostV1SettingsTestAiResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getPostV1SettingsTestEmailMockHandler = (overrideResponse?: SuccessResponse | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<SuccessResponse> | SuccessResponse), options?: RequestHandlerOptions) => {
  return http.post('*/v1/settings/test-email', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPostV1SettingsTestEmailResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getPutV1SettingsWordOfDayEmailMockHandler = (overrideResponse?: SuccessResponse | ((info: Parameters<Parameters<typeof http.put>[1]>[0]) => Promise<SuccessResponse> | SuccessResponse), options?: RequestHandlerOptions) => {
  return http.put('*/v1/settings/word-of-day-email', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPutV1SettingsWordOfDayEmailResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetV1SettingsLevelsMockHandler = (overrideResponse?: LevelsResponse | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<LevelsResponse> | LevelsResponse), options?: RequestHandlerOptions) => {
  return http.get('*/v1/settings/levels', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1SettingsLevelsResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetV1SettingsLanguagesMockHandler = (overrideResponse?: LanguagesResponse | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<LanguagesResponse> | LanguagesResponse), options?: RequestHandlerOptions) => {
  return http.get('*/v1/settings/languages', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1SettingsLanguagesResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetV1SettingsApiKeyProviderMockHandler = (overrideResponse?: APIKeyAvailabilityResponse | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<APIKeyAvailabilityResponse> | APIKeyAvailabilityResponse), options?: RequestHandlerOptions) => {
  return http.get('*/v1/settings/api-key/:provider', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1SettingsApiKeyProviderResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getPostV1AiConversationsMockHandler = (overrideResponse?: Conversation | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<Conversation> | Conversation), options?: RequestHandlerOptions) => {
  return http.post('*/v1/ai/conversations', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPostV1AiConversationsResponseMock()),
      { status: 201,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetV1AiConversationsMockHandler = (overrideResponse?: ConversationsListResponse | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<ConversationsListResponse> | ConversationsListResponse), options?: RequestHandlerOptions) => {
  return http.get('*/v1/ai/conversations', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1AiConversationsResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetV1AiConversationsIdMockHandler = (overrideResponse?: Conversation | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<Conversation> | Conversation), options?: RequestHandlerOptions) => {
  return http.get('*/v1/ai/conversations/:id', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1AiConversationsIdResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getPutV1AiConversationsIdMockHandler = (overrideResponse?: Conversation | ((info: Parameters<Parameters<typeof http.put>[1]>[0]) => Promise<Conversation> | Conversation), options?: RequestHandlerOptions) => {
  return http.put('*/v1/ai/conversations/:id', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPutV1AiConversationsIdResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getDeleteV1AiConversationsIdMockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.delete>[1]>[0]) => Promise<void> | void), options?: RequestHandlerOptions) => {
  return http.delete('*/v1/ai/conversations/:id', async (info) => {await delay(1000);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 204,
        
      })
  }, options)
}

export const getPostV1AiConversationsConversationIdMessagesMockHandler = (overrideResponse?: ChatMessage | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<ChatMessage> | ChatMessage), options?: RequestHandlerOptions) => {
  return http.post('*/v1/ai/conversations/:conversationId/messages', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPostV1AiConversationsConversationIdMessagesResponseMock()),
      { status: 201,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetV1AiSearchMockHandler = (overrideResponse?: ConversationSearchResponse | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<ConversationSearchResponse> | ConversationSearchResponse), options?: RequestHandlerOptions) => {
  return http.get('*/v1/ai/search', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1AiSearchResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getPutV1AiConversationsBookmarkMockHandler = (overrideResponse?: BookmarkStatusResponse | ((info: Parameters<Parameters<typeof http.put>[1]>[0]) => Promise<BookmarkStatusResponse> | BookmarkStatusResponse), options?: RequestHandlerOptions) => {
  return http.put('*/v1/ai/conversations/bookmark', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPutV1AiConversationsBookmarkResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetV1AiBookmarksMockHandler = (overrideResponse?: ChatBookmarksResponse | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<ChatBookmarksResponse> | ChatBookmarksResponse), options?: RequestHandlerOptions) => {
  return http.get('*/v1/ai/bookmarks', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1AiBookmarksResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getPostV1SnippetsMockHandler = (overrideResponse?: Snippet | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<Snippet> | Snippet), options?: RequestHandlerOptions) => {
  return http.post('*/v1/snippets', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPostV1SnippetsResponseMock()),
      { status: 201,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetV1SnippetsMockHandler = (overrideResponse?: SnippetList | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<SnippetList> | SnippetList), options?: RequestHandlerOptions) => {
  return http.get('*/v1/snippets', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1SnippetsResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetV1SnippetsSearchMockHandler = (overrideResponse?: SnippetList | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<SnippetList> | SnippetList), options?: RequestHandlerOptions) => {
  return http.get('*/v1/snippets/search', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1SnippetsSearchResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetV1SnippetsByQuestionQuestionIdMockHandler = (overrideResponse?: SnippetsResponse | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<SnippetsResponse> | SnippetsResponse), options?: RequestHandlerOptions) => {
  return http.get('*/v1/snippets/by-question/:questionId', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1SnippetsByQuestionQuestionIdResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetV1SnippetsBySectionSectionIdMockHandler = (overrideResponse?: SnippetsResponse | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<SnippetsResponse> | SnippetsResponse), options?: RequestHandlerOptions) => {
  return http.get('*/v1/snippets/by-section/:sectionId', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1SnippetsBySectionSectionIdResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetV1SnippetsByStoryStoryIdMockHandler = (overrideResponse?: SnippetsResponse | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<SnippetsResponse> | SnippetsResponse), options?: RequestHandlerOptions) => {
  return http.get('*/v1/snippets/by-story/:storyId', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1SnippetsByStoryStoryIdResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetV1SnippetsIdMockHandler = (overrideResponse?: Snippet | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<Snippet> | Snippet), options?: RequestHandlerOptions) => {
  return http.get('*/v1/snippets/:id', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1SnippetsIdResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getPutV1SnippetsIdMockHandler = (overrideResponse?: Snippet | ((info: Parameters<Parameters<typeof http.put>[1]>[0]) => Promise<Snippet> | Snippet), options?: RequestHandlerOptions) => {
  return http.put('*/v1/snippets/:id', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPutV1SnippetsIdResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getDeleteV1SnippetsIdMockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.delete>[1]>[0]) => Promise<void> | void), options?: RequestHandlerOptions) => {
  return http.delete('*/v1/snippets/:id', async (info) => {await delay(1000);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 204,
        
      })
  }, options)
}

export const getPutV1UserzProfileMockHandler = (overrideResponse?: UserProfileMessageResponse | ((info: Parameters<Parameters<typeof http.put>[1]>[0]) => Promise<UserProfileMessageResponse> | UserProfileMessageResponse), options?: RequestHandlerOptions) => {
  return http.put('*/v1/userz/profile', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPutV1UserzProfileResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getPostV1FeedbackMockHandler = (overrideResponse?: FeedbackReport | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<FeedbackReport> | FeedbackReport), options?: RequestHandlerOptions) => {
  return http.post('*/v1/feedback', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPostV1FeedbackResponseMock()),
      { status: 201,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetV1AdminBackendMockHandler = (overrideResponse?: string | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<string> | string), options?: RequestHandlerOptions) => {
  return http.get('*/v1/admin/backend', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1AdminBackendResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetV1AdminBackendUserzMockHandler = (overrideResponse?: AdminUsersResponse | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<AdminUsersResponse> | AdminUsersResponse), options?: RequestHandlerOptions) => {
  return http.get('*/v1/admin/backend/userz', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1AdminBackendUserzResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getPostV1AdminBackendUserzMockHandler = (overrideResponse?: UserProfileMessageResponse | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<UserProfileMessageResponse> | UserProfileMessageResponse), options?: RequestHandlerOptions) => {
  return http.post('*/v1/admin/backend/userz', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPostV1AdminBackendUserzResponseMock()),
      { status: 201,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getPostV1SettingsClearStoriesMockHandler = (overrideResponse?: SuccessResponse | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<SuccessResponse> | SuccessResponse), options?: RequestHandlerOptions) => {
  return http.post('*/v1/settings/clear-stories', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPostV1SettingsClearStoriesResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getPostV1SettingsResetAccountMockHandler = (overrideResponse?: SuccessResponse | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<SuccessResponse> | SuccessResponse), options?: RequestHandlerOptions) => {
  return http.post('*/v1/settings/reset-account', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPostV1SettingsResetAccountResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getPostV1SettingsClearAiChatsMockHandler = (overrideResponse?: SuccessResponse | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<SuccessResponse> | SuccessResponse), options?: RequestHandlerOptions) => {
  return http.post('*/v1/settings/clear-ai-chats', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPostV1SettingsClearAiChatsResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getPostV1SettingsClearTranslationPracticeHistoryMockHandler = (overrideResponse?: SuccessResponse | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<SuccessResponse> | SuccessResponse), options?: RequestHandlerOptions) => {
  return http.post('*/v1/settings/clear-translation-practice-history', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPostV1SettingsClearTranslationPracticeHistoryResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetV1AdminBackendUserzPaginatedMockHandler = (overrideResponse?: AdminUsersPaginatedResponse | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<AdminUsersPaginatedResponse> | AdminUsersPaginatedResponse), options?: RequestHandlerOptions) => {
  return http.get('*/v1/admin/backend/userz/paginated', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1AdminBackendUserzPaginatedResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getPutV1AdminBackendUserzIdMockHandler = (overrideResponse?: UserProfileMessageResponse | ((info: Parameters<Parameters<typeof http.put>[1]>[0]) => Promise<UserProfileMessageResponse> | UserProfileMessageResponse), options?: RequestHandlerOptions) => {
  return http.put('*/v1/admin/backend/userz/:id', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPutV1AdminBackendUserzIdResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getDeleteV1AdminBackendUserzIdMockHandler = (overrideResponse?: MessageResponse | ((info: Parameters<Parameters<typeof http.delete>[1]>[0]) => Promise<MessageResponse> | MessageResponse), options?: RequestHandlerOptions) => {
  return http.delete('*/v1/admin/backend/userz/:id', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getDeleteV1AdminBackendUserzIdResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getPostV1AdminBackendUserzIdResetPasswordMockHandler = (overrideResponse?: MessageResponse | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<MessageResponse> | MessageResponse), options?: RequestHandlerOptions) => {
  return http.post('*/v1/admin/backend/userz/:id/reset-password', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPostV1AdminBackendUserzIdResetPasswordResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetV1AdminBackendRolesMockHandler = (overrideResponse?: AdminRolesResponse | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<AdminRolesResponse> | AdminRolesResponse), options?: RequestHandlerOptions) => {
  return http.get('*/v1/admin/backend/roles', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1AdminBackendRolesResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetV1AdminBackendUserzIdRolesMockHandler = (overrideResponse?: AdminRolesResponse | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<AdminRolesResponse> | AdminRolesResponse), options?: RequestHandlerOptions) => {
  return http.get('*/v1/admin/backend/userz/:id/roles', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1AdminBackendUserzIdRolesResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getPostV1AdminBackendUserzIdRolesMockHandler = (overrideResponse?: MessageResponse | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<MessageResponse> | MessageResponse), options?: RequestHandlerOptions) => {
  return http.post('*/v1/admin/backend/userz/:id/roles', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPostV1AdminBackendUserzIdRolesResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getDeleteV1AdminBackendUserzIdRolesRoleIdMockHandler = (overrideResponse?: MessageResponse | ((info: Parameters<Parameters<typeof http.delete>[1]>[0]) => Promise<MessageResponse> | MessageResponse), options?: RequestHandlerOptions) => {
  return http.delete('*/v1/admin/backend/userz/:id/roles/:roleId', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getDeleteV1AdminBackendUserzIdRolesRoleIdResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetV1AdminBackendDashboardMockHandler = (overrideResponse?: DashboardResponse | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<DashboardResponse> | DashboardResponse), options?: RequestHandlerOptions) => {
  return http.get('*/v1/admin/backend/dashboard', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1AdminBackendDashboardResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetV1AdminBackendAiConcurrencyMockHandler = (overrideResponse?: AIConcurrencyStats | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<AIConcurrencyStats> | AIConcurrencyStats), options?: RequestHandlerOptions) => {
  return http.get('*/v1/admin/backend/ai-concurrency', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1AdminBackendAiConcurrencyResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetV1AdminWorkerStatusMockHandler = (overrideResponse?: WorkerStatus | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<WorkerStatus> | WorkerStatus), options?: RequestHandlerOptions) => {
  return http.get('*/v1/admin/worker/status', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1AdminWorkerStatusResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetV1AdminWorkerDetailsMockHandler = (overrideResponse?: WorkerDetailsResponse | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<WorkerDetailsResponse> | WorkerDetailsResponse), options?: RequestHandlerOptions) => {
  return http.get('*/v1/admin/worker/details', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1AdminWorkerDetailsResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getPostV1AdminWorkerPauseMockHandler = (overrideResponse?: MessageResponse | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<MessageResponse> | MessageResponse), options?: RequestHandlerOptions) => {
  return http.post('*/v1/admin/worker/pause', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPostV1AdminWorkerPauseResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getPostV1AdminWorkerResumeMockHandler = (overrideResponse?: MessageResponse | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<MessageResponse> | MessageResponse), options?: RequestHandlerOptions) => {
  return http.post('*/v1/admin/worker/resume', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPostV1AdminWorkerResumeResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getPostV1AdminWorkerTriggerMockHandler = (overrideResponse?: MessageResponse | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<MessageResponse> | MessageResponse), options?: RequestHandlerOptions) => {
  return http.post('*/v1/admin/worker/trigger', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPostV1AdminWorkerTriggerResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetV1AdminWorkerLogsMockHandler = (overrideResponse?: WorkerLogsResponse | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<WorkerLogsResponse> | WorkerLogsResponse), options?: RequestHandlerOptions) => {
  return http.get('*/v1/admin/worker/logs', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1AdminWorkerLogsResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetV1AdminWorkerAiConcurrencyMockHandler = (overrideResponse?: WorkerAIConcurrencyStats | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<WorkerAIConcurrencyStats> | WorkerAIConcurrencyStats), options?: RequestHandlerOptions) => {
  return http.get('*/v1/admin/worker/ai-concurrency', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1AdminWorkerAiConcurrencyResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetV1AdminWorkerUsersMockHandler = (overrideResponse?: WorkerUserListResponse | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<WorkerUserListResponse> | WorkerUserListResponse), options?: RequestHandlerOptions) => {
  return http.get('*/v1/admin/worker/users', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1AdminWorkerUsersResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getPostV1AdminWorkerUsersPauseMockHandler = (overrideResponse?: MessageResponse | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<MessageResponse> | MessageResponse), options?: RequestHandlerOptions) => {
  return http.post('*/v1/admin/worker/users/pause', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPostV1AdminWorkerUsersPauseResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getPostV1AdminWorkerUsersResumeMockHandler = (overrideResponse?: MessageResponse | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<MessageResponse> | MessageResponse), options?: RequestHandlerOptions) => {
  return http.post('*/v1/admin/worker/users/resume', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPostV1AdminWorkerUsersResumeResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetV1AdminWorkerAnalyticsPriorityScoresMockHandler = (overrideResponse?: PriorityAnalytics | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<PriorityAnalytics> | PriorityAnalytics), options?: RequestHandlerOptions) => {
  return http.get('*/v1/admin/worker/analytics/priority-scores', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1AdminWorkerAnalyticsPriorityScoresResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetV1AdminWorkerAnalyticsUserPerformanceMockHandler = (overrideResponse?: UserPerformanceAnalytics | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<UserPerformanceAnalytics> | UserPerformanceAnalytics), options?: RequestHandlerOptions) => {
  return http.get('*/v1/admin/worker/analytics/user-performance', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1AdminWorkerAnalyticsUserPerformanceResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetV1AdminWorkerAnalyticsGenerationIntelligenceMockHandler = (overrideResponse?: GenerationIntelligence | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<GenerationIntelligence> | GenerationIntelligence), options?: RequestHandlerOptions) => {
  return http.get('*/v1/admin/worker/analytics/generation-intelligence', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1AdminWorkerAnalyticsGenerationIntelligenceResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetV1AdminWorkerAnalyticsSystemHealthMockHandler = (overrideResponse?: SystemHealthAnalytics | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<SystemHealthAnalytics> | SystemHealthAnalytics), options?: RequestHandlerOptions) => {
  return http.get('*/v1/admin/worker/analytics/system-health', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1AdminWorkerAnalyticsSystemHealthResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetV1AdminWorkerNotificationsStatsMockHandler = (overrideResponse?: NotificationStats | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<NotificationStats> | NotificationStats), options?: RequestHandlerOptions) => {
  return http.get('*/v1/admin/worker/notifications/stats', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1AdminWorkerNotificationsStatsResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetV1AdminWorkerNotificationsErrorsMockHandler = (overrideResponse?: WorkerNotificationErrorsResponse | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<WorkerNotificationErrorsResponse> | WorkerNotificationErrorsResponse), options?: RequestHandlerOptions) => {
  return http.get('*/v1/admin/worker/notifications/errors', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1AdminWorkerNotificationsErrorsResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetV1AdminWorkerNotificationsSentMockHandler = (overrideResponse?: WorkerNotificationSentResponse | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<WorkerNotificationSentResponse> | WorkerNotificationSentResponse), options?: RequestHandlerOptions) => {
  return http.get('*/v1/admin/worker/notifications/sent', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1AdminWorkerNotificationsSentResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getPostV1AdminWorkerNotificationsForceSendMockHandler = (overrideResponse?: ForceSendNotificationResponse | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<ForceSendNotificationResponse> | ForceSendNotificationResponse), options?: RequestHandlerOptions) => {
  return http.post('*/v1/admin/worker/notifications/force-send', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPostV1AdminWorkerNotificationsForceSendResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetV1AdminBackendQuestionsMockHandler = (overrideResponse?: AdminQuestionsResponse | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<AdminQuestionsResponse> | AdminQuestionsResponse), options?: RequestHandlerOptions) => {
  return http.get('*/v1/admin/backend/questions', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1AdminBackendQuestionsResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetV1AdminBackendQuestionsPaginatedMockHandler = (overrideResponse?: AdminQuestionsResponse | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<AdminQuestionsResponse> | AdminQuestionsResponse), options?: RequestHandlerOptions) => {
  return http.get('*/v1/admin/backend/questions/paginated', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1AdminBackendQuestionsPaginatedResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetV1AdminBackendQuestionsIdMockHandler = (overrideResponse?: Question | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<Question> | Question), options?: RequestHandlerOptions) => {
  return http.get('*/v1/admin/backend/questions/:id', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1AdminBackendQuestionsIdResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getPutV1AdminBackendQuestionsIdMockHandler = (overrideResponse?: MessageResponse | ((info: Parameters<Parameters<typeof http.put>[1]>[0]) => Promise<MessageResponse> | MessageResponse), options?: RequestHandlerOptions) => {
  return http.put('*/v1/admin/backend/questions/:id', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPutV1AdminBackendQuestionsIdResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getDeleteV1AdminBackendQuestionsIdMockHandler = (overrideResponse?: MessageResponse | ((info: Parameters<Parameters<typeof http.delete>[1]>[0]) => Promise<MessageResponse> | MessageResponse), options?: RequestHandlerOptions) => {
  return http.delete('*/v1/admin/backend/questions/:id', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getDeleteV1AdminBackendQuestionsIdResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetV1AdminBackendQuestionsIdUsersMockHandler = (overrideResponse?: QuestionAssignedUsersResponse | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<QuestionAssignedUsersResponse> | QuestionAssignedUsersResponse), options?: RequestHandlerOptions) => {
  return http.get('*/v1/admin/backend/questions/:id/users', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1AdminBackendQuestionsIdUsersResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getPostV1AdminBackendQuestionsIdAssignUsersMockHandler = (overrideResponse?: MessageResponse | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<MessageResponse> | MessageResponse), options?: RequestHandlerOptions) => {
  return http.post('*/v1/admin/backend/questions/:id/assign-users', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPostV1AdminBackendQuestionsIdAssignUsersResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getPostV1AdminBackendQuestionsIdUnassignUsersMockHandler = (overrideResponse?: MessageResponse | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<MessageResponse> | MessageResponse), options?: RequestHandlerOptions) => {
  return http.post('*/v1/admin/backend/questions/:id/unassign-users', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPostV1AdminBackendQuestionsIdUnassignUsersResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getPostV1AdminBackendQuestionsIdFixMockHandler = (overrideResponse?: MessageResponse | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<MessageResponse> | MessageResponse), options?: RequestHandlerOptions) => {
  return http.post('*/v1/admin/backend/questions/:id/fix', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPostV1AdminBackendQuestionsIdFixResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getPostV1AdminBackendQuestionsIdAiFixMockHandler = (overrideResponse?: AIFixResponse | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<AIFixResponse> | AIFixResponse), options?: RequestHandlerOptions) => {
  return http.post('*/v1/admin/backend/questions/:id/ai-fix', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPostV1AdminBackendQuestionsIdAiFixResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getPostV1AdminBackendClearUserDataMockHandler = (overrideResponse?: MessageResponse | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<MessageResponse> | MessageResponse), options?: RequestHandlerOptions) => {
  return http.post('*/v1/admin/backend/clear-user-data', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPostV1AdminBackendClearUserDataResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getPostV1AdminBackendClearDatabaseMockHandler = (overrideResponse?: MessageResponse | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<MessageResponse> | MessageResponse), options?: RequestHandlerOptions) => {
  return http.post('*/v1/admin/backend/clear-database', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPostV1AdminBackendClearDatabaseResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getPostV1AdminBackendUserzIdClearMockHandler = (overrideResponse?: MessageResponse | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<MessageResponse> | MessageResponse), options?: RequestHandlerOptions) => {
  return http.post('*/v1/admin/backend/userz/:id/clear', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPostV1AdminBackendUserzIdClearResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetV1AdminBackendUsageStatsMockHandler = (overrideResponse?: UsageStatsResponse | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<UsageStatsResponse> | UsageStatsResponse), options?: RequestHandlerOptions) => {
  return http.get('*/v1/admin/backend/usage-stats', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1AdminBackendUsageStatsResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetV1AdminBackendUsageStatsServiceMockHandler = (overrideResponse?: ServiceUsageStatsResponse | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<ServiceUsageStatsResponse> | ServiceUsageStatsResponse), options?: RequestHandlerOptions) => {
  return http.get('*/v1/admin/backend/usage-stats/:service', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1AdminBackendUsageStatsServiceResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetV1AdminBackendReportedQuestionsMockHandler = (overrideResponse?: AdminReportedQuestionsResponse | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<AdminReportedQuestionsResponse> | AdminReportedQuestionsResponse), options?: RequestHandlerOptions) => {
  return http.get('*/v1/admin/backend/reported-questions', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1AdminBackendReportedQuestionsResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetV1AdminBackendStoriesMockHandler = (overrideResponse?: AdminStoriesResponse | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<AdminStoriesResponse> | AdminStoriesResponse), options?: RequestHandlerOptions) => {
  return http.get('*/v1/admin/backend/stories', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1AdminBackendStoriesResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetV1AdminBackendStoriesIdMockHandler = (overrideResponse?: StoryWithSections | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<StoryWithSections> | StoryWithSections), options?: RequestHandlerOptions) => {
  return http.get('*/v1/admin/backend/stories/:id', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1AdminBackendStoriesIdResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getDeleteV1AdminBackendStoriesIdMockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.delete>[1]>[0]) => Promise<void> | void), options?: RequestHandlerOptions) => {
  return http.delete('*/v1/admin/backend/stories/:id', async (info) => {await delay(1000);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 200,
        
      })
  }, options)
}

export const getGetV1AdminBackendStorySectionsIdMockHandler = (overrideResponse?: StorySectionWithQuestions | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<StorySectionWithQuestions> | StorySectionWithQuestions), options?: RequestHandlerOptions) => {
  return http.get('*/v1/admin/backend/story-sections/:id', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1AdminBackendStorySectionsIdResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getPostV1QuizChatStreamMockHandler = (overrideResponse?: string | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<string> | string), options?: RequestHandlerOptions) => {
  return http.post('*/v1/quiz/chat/stream', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPostV1QuizChatStreamResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetV1DailyQuestionsDateMockHandler = (overrideResponse?: DailyQuestionsResponse | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<DailyQuestionsResponse> | DailyQuestionsResponse), options?: RequestHandlerOptions) => {
  return http.get('*/v1/daily/questions/:date', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1DailyQuestionsDateResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getPostV1DailyQuestionsDateCompleteQuestionIdMockHandler = (overrideResponse?: SuccessResponse | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<SuccessResponse> | SuccessResponse), options?: RequestHandlerOptions) => {
  return http.post('*/v1/daily/questions/:date/complete/:questionId', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPostV1DailyQuestionsDateCompleteQuestionIdResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getDeleteV1DailyQuestionsDateCompleteQuestionIdMockHandler = (overrideResponse?: SuccessResponse | ((info: Parameters<Parameters<typeof http.delete>[1]>[0]) => Promise<SuccessResponse> | SuccessResponse), options?: RequestHandlerOptions) => {
  return http.delete('*/v1/daily/questions/:date/complete/:questionId', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getDeleteV1DailyQuestionsDateCompleteQuestionIdResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetV1DailyDatesMockHandler = (overrideResponse?: DailyDatesResponse | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<DailyDatesResponse> | DailyDatesResponse), options?: RequestHandlerOptions) => {
  return http.get('*/v1/daily/dates', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1DailyDatesResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getPostV1DailyQuestionsDateAnswerQuestionIdMockHandler = (overrideResponse?: DailyAnswerResponse | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<DailyAnswerResponse> | DailyAnswerResponse), options?: RequestHandlerOptions) => {
  return http.post('*/v1/daily/questions/:date/answer/:questionId', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPostV1DailyQuestionsDateAnswerQuestionIdResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetV1DailyProgressDateMockHandler = (overrideResponse?: DailyProgress | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<DailyProgress> | DailyProgress), options?: RequestHandlerOptions) => {
  return http.get('*/v1/daily/progress/:date', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1DailyProgressDateResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetV1DailyHistoryQuestionIdMockHandler = (overrideResponse?: DailyQuestionHistoryResponse | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<DailyQuestionHistoryResponse> | DailyQuestionHistoryResponse), options?: RequestHandlerOptions) => {
  return http.get('*/v1/daily/history/:questionId', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1DailyHistoryQuestionIdResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetV1WordOfDayDateMockHandler = (overrideResponse?: WordOfTheDayDisplay | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<WordOfTheDayDisplay> | WordOfTheDayDisplay), options?: RequestHandlerOptions) => {
  return http.get('*/v1/word-of-day/:date', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1WordOfDayDateResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetV1WordOfDayMockHandler = (overrideResponse?: WordOfTheDayDisplay | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<WordOfTheDayDisplay> | WordOfTheDayDisplay), options?: RequestHandlerOptions) => {
  return http.get('*/v1/word-of-day', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1WordOfDayResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetV1WordOfDayEmbedMockHandler = (overrideResponse?: string | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<string> | string), options?: RequestHandlerOptions) => {
  return http.get('*/v1/word-of-day/embed', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1WordOfDayEmbedResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetV1WordOfDayDateEmbedMockHandler = (overrideResponse?: string | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<string> | string), options?: RequestHandlerOptions) => {
  return http.get('*/v1/word-of-day/:date/embed', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1WordOfDayDateEmbedResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetV1WordOfDayHistoryMockHandler = (overrideResponse?: WordOfDayHistoryResponse | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<WordOfDayHistoryResponse> | WordOfDayHistoryResponse), options?: RequestHandlerOptions) => {
  return http.get('*/v1/word-of-day/history', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1WordOfDayHistoryResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getPostV1StoryMockHandler = (overrideResponse?: Story | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<Story> | Story), options?: RequestHandlerOptions) => {
  return http.post('*/v1/story', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPostV1StoryResponseMock()),
      { status: 201,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetV1StoryMockHandler = (overrideResponse?: Story[] | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<Story[]> | Story[]), options?: RequestHandlerOptions) => {
  return http.get('*/v1/story', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1StoryResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetV1StoryCurrentMockHandler = (overrideResponse?: StoryWithSections | GeneratingResponse | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<StoryWithSections | GeneratingResponse> | StoryWithSections | GeneratingResponse), options?: RequestHandlerOptions) => {
  return http.get('*/v1/story/current', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1StoryCurrentResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetV1StoryIdMockHandler = (overrideResponse?: StoryWithSections | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<StoryWithSections> | StoryWithSections), options?: RequestHandlerOptions) => {
  return http.get('*/v1/story/:id', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1StoryIdResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getDeleteV1StoryIdMockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.delete>[1]>[0]) => Promise<void> | void), options?: RequestHandlerOptions) => {
  return http.delete('*/v1/story/:id', async (info) => {await delay(1000);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 204,
        
      })
  }, options)
}

export const getPostV1StoryIdGenerateMockHandler = (overrideResponse?: StorySection | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<StorySection> | StorySection), options?: RequestHandlerOptions) => {
  return http.post('*/v1/story/:id/generate', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPostV1StoryIdGenerateResponseMock()),
      { status: 201,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getPostV1StoryIdArchiveMockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<void> | void), options?: RequestHandlerOptions) => {
  return http.post('*/v1/story/:id/archive', async (info) => {await delay(1000);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 200,
        
      })
  }, options)
}

export const getPostV1StoryIdCompleteMockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<void> | void), options?: RequestHandlerOptions) => {
  return http.post('*/v1/story/:id/complete', async (info) => {await delay(1000);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 200,
        
      })
  }, options)
}

export const getPostV1StoryIdSetCurrentMockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<void> | void), options?: RequestHandlerOptions) => {
  return http.post('*/v1/story/:id/set-current', async (info) => {await delay(1000);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 200,
        
      })
  }, options)
}

export const getPostV1StoryIdToggleAutoGenerationMockHandler = (overrideResponse?: ToggleAutoGenerationResponse | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<ToggleAutoGenerationResponse> | ToggleAutoGenerationResponse), options?: RequestHandlerOptions) => {
  return http.post('*/v1/story/:id/toggle-auto-generation', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPostV1StoryIdToggleAutoGenerationResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetV1StorySectionIdMockHandler = (overrideResponse?: StorySectionWithQuestions | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<StorySectionWithQuestions> | StorySectionWithQuestions), options?: RequestHandlerOptions) => {
  return http.get('*/v1/story/section/:id', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1StorySectionIdResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetV1StoryIdExportMockHandler = (overrideResponse?: Blob | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<Blob> | Blob), options?: RequestHandlerOptions) => {
  return http.get('*/v1/story/:id/export', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1StoryIdExportResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetV1PreferencesLearningMockHandler = (overrideResponse?: UserLearningPreferences | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<UserLearningPreferences> | UserLearningPreferences), options?: RequestHandlerOptions) => {
  return http.get('*/v1/preferences/learning', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1PreferencesLearningResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getPutV1PreferencesLearningMockHandler = (overrideResponse?: UserLearningPreferences | ((info: Parameters<Parameters<typeof http.put>[1]>[0]) => Promise<UserLearningPreferences> | UserLearningPreferences), options?: RequestHandlerOptions) => {
  return http.put('*/v1/preferences/learning', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPutV1PreferencesLearningResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetV1VersionMockHandler = (overrideResponse?: AggregatedVersion | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<AggregatedVersion> | AggregatedVersion), options?: RequestHandlerOptions) => {
  return http.get('*/v1/version', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1VersionResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetHealthMockHandler = (overrideResponse?: HealthStatusResponse | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<HealthStatusResponse> | HealthStatusResponse), options?: RequestHandlerOptions) => {
  return http.get('*/health', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetHealthResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetV1AdminWorkerDailyUsersUserIdQuestionsDateMockHandler = (overrideResponse?: AdminDailyQuestionsResponse | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<AdminDailyQuestionsResponse> | AdminDailyQuestionsResponse), options?: RequestHandlerOptions) => {
  return http.get('*/v1/admin/worker/daily/users/:userId/questions/:date', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1AdminWorkerDailyUsersUserIdQuestionsDateResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getPostV1AdminWorkerDailyUsersUserIdQuestionsDateRegenerateMockHandler = (overrideResponse?: SuccessResponse | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<SuccessResponse> | SuccessResponse), options?: RequestHandlerOptions) => {
  return http.post('*/v1/admin/worker/daily/users/:userId/questions/:date/regenerate', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPostV1AdminWorkerDailyUsersUserIdQuestionsDateRegenerateResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetV1AdminBackendFeedbackMockHandler = (overrideResponse?: FeedbackListResponse | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<FeedbackListResponse> | FeedbackListResponse), options?: RequestHandlerOptions) => {
  return http.get('*/v1/admin/backend/feedback', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1AdminBackendFeedbackResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getDeleteV1AdminBackendFeedbackMockHandler = (overrideResponse?: BulkDeleteResponse | ((info: Parameters<Parameters<typeof http.delete>[1]>[0]) => Promise<BulkDeleteResponse> | BulkDeleteResponse), options?: RequestHandlerOptions) => {
  return http.delete('*/v1/admin/backend/feedback', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getDeleteV1AdminBackendFeedbackResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetV1AdminBackendFeedbackIdMockHandler = (overrideResponse?: FeedbackReport | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<FeedbackReport> | FeedbackReport), options?: RequestHandlerOptions) => {
  return http.get('*/v1/admin/backend/feedback/:id', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1AdminBackendFeedbackIdResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getPatchV1AdminBackendFeedbackIdMockHandler = (overrideResponse?: FeedbackReport | ((info: Parameters<Parameters<typeof http.patch>[1]>[0]) => Promise<FeedbackReport> | FeedbackReport), options?: RequestHandlerOptions) => {
  return http.patch('*/v1/admin/backend/feedback/:id', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPatchV1AdminBackendFeedbackIdResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getDeleteV1AdminBackendFeedbackIdMockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.delete>[1]>[0]) => Promise<void> | void), options?: RequestHandlerOptions) => {
  return http.delete('*/v1/admin/backend/feedback/:id', async (info) => {await delay(1000);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 204,
        
      })
  }, options)
}

export const getPostV1AdminBackendFeedbackIdLinearIssueMockHandler = (overrideResponse?: CreateLinearIssueResponse | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<CreateLinearIssueResponse> | CreateLinearIssueResponse), options?: RequestHandlerOptions) => {
  return http.post('*/v1/admin/backend/feedback/:id/linear-issue', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPostV1AdminBackendFeedbackIdLinearIssueResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getPostV1ApiKeysMockHandler = (overrideResponse?: CreateAPIKeyResponse | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<CreateAPIKeyResponse> | CreateAPIKeyResponse), options?: RequestHandlerOptions) => {
  return http.post('*/v1/api-keys', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPostV1ApiKeysResponseMock()),
      { status: 201,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetV1ApiKeysMockHandler = (overrideResponse?: APIKeysListResponse | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<APIKeysListResponse> | APIKeysListResponse), options?: RequestHandlerOptions) => {
  return http.get('*/v1/api-keys', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1ApiKeysResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getDeleteV1ApiKeysIdMockHandler = (overrideResponse?: DeleteAPIKeyResponse | ((info: Parameters<Parameters<typeof http.delete>[1]>[0]) => Promise<DeleteAPIKeyResponse> | DeleteAPIKeyResponse), options?: RequestHandlerOptions) => {
  return http.delete('*/v1/api-keys/:id', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getDeleteV1ApiKeysIdResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetV1ApiKeysTestReadMockHandler = (overrideResponse?: APIKeyTestResponse | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<APIKeyTestResponse> | APIKeyTestResponse), options?: RequestHandlerOptions) => {
  return http.get('*/v1/api-keys/test-read', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1ApiKeysTestReadResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getPostV1ApiKeysTestWriteMockHandler = (overrideResponse?: APIKeyTestResponse | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<APIKeyTestResponse> | APIKeyTestResponse), options?: RequestHandlerOptions) => {
  return http.post('*/v1/api-keys/test-write', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPostV1ApiKeysTestWriteResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getPostV1TranslateMockHandler = (overrideResponse?: TranslateResponse | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<TranslateResponse> | TranslateResponse), options?: RequestHandlerOptions) => {
  return http.post('*/v1/translate', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPostV1TranslateResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getPostV1TranslationPracticeGenerateMockHandler = (overrideResponse?: TranslationPracticeSentenceResponse | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<TranslationPracticeSentenceResponse> | TranslationPracticeSentenceResponse), options?: RequestHandlerOptions) => {
  return http.post('*/v1/translation-practice/generate', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPostV1TranslationPracticeGenerateResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetV1TranslationPracticeSentenceMockHandler = (overrideResponse?: TranslationPracticeSentenceResponse | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<TranslationPracticeSentenceResponse> | TranslationPracticeSentenceResponse), options?: RequestHandlerOptions) => {
  return http.get('*/v1/translation-practice/sentence', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1TranslationPracticeSentenceResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getPostV1TranslationPracticeSubmitMockHandler = (overrideResponse?: TranslationPracticeSessionResponse | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<TranslationPracticeSessionResponse> | TranslationPracticeSessionResponse), options?: RequestHandlerOptions) => {
  return http.post('*/v1/translation-practice/submit', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPostV1TranslationPracticeSubmitResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetV1TranslationPracticeHistoryMockHandler = (overrideResponse?: TranslationPracticeHistoryResponse | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<TranslationPracticeHistoryResponse> | TranslationPracticeHistoryResponse), options?: RequestHandlerOptions) => {
  return http.get('*/v1/translation-practice/history', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1TranslationPracticeHistoryResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetV1TranslationPracticeStatsMockHandler = (overrideResponse?: TranslationPracticeStatsResponse | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<TranslationPracticeStatsResponse> | TranslationPracticeStatsResponse), options?: RequestHandlerOptions) => {
  return http.get('*/v1/translation-practice/stats', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1TranslationPracticeStatsResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getPostV1AudioSpeechMockHandler = (overrideResponse?: TTSResponse | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<TTSResponse> | TTSResponse), options?: RequestHandlerOptions) => {
  return http.post('*/v1/audio/speech', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPostV1AudioSpeechResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getPostV1AudioSpeechInitMockHandler = (overrideResponse?: TTSStreamInitResponse | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<TTSStreamInitResponse> | TTSStreamInitResponse), options?: RequestHandlerOptions) => {
  return http.post('*/v1/audio/speech/init', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPostV1AudioSpeechInitResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetV1AudioSpeechStreamStreamIdMockHandler = (overrideResponse?: Blob | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<Blob> | Blob), options?: RequestHandlerOptions) => {
  return http.get('*/v1/audio/speech/stream/:streamId', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetV1AudioSpeechStreamStreamIdResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}
export const getQuizApplicationAPIMock = () => [
  getPostV1AuthLoginMockHandler(),
  getPostV1AuthLogoutMockHandler(),
  getGetV1AuthStatusMockHandler(),
  getGetV1AuthCheckMockHandler(),
  getPostV1AuthSignupMockHandler(),
  getGetV1AuthSignupStatusMockHandler(),
  getGetV1AuthGoogleLoginMockHandler(),
  getGetV1AuthGoogleCallbackMockHandler(),
  getGetV1QuizQuestionMockHandler(),
  getGetV1QuizQuestionIdMockHandler(),
  getPostV1QuizAnswerMockHandler(),
  getGetV1QuizProgressMockHandler(),
  getGetV1QuizAiTokenUsageMockHandler(),
  getGetV1QuizAiTokenUsageDailyMockHandler(),
  getGetV1QuizAiTokenUsageHourlyMockHandler(),
  getPostV1QuizQuestionIdReportMockHandler(),
  getPostV1QuizQuestionIdMarkKnownMockHandler(),
  getGetV1QuizWorkerStatusMockHandler(),
  getPutV1SettingsMockHandler(),
  getGetV1SettingsAiProvidersMockHandler(),
  getPostV1SettingsTestAiMockHandler(),
  getPostV1SettingsTestEmailMockHandler(),
  getPutV1SettingsWordOfDayEmailMockHandler(),
  getGetV1SettingsLevelsMockHandler(),
  getGetV1SettingsLanguagesMockHandler(),
  getGetV1SettingsApiKeyProviderMockHandler(),
  getPostV1AiConversationsMockHandler(),
  getGetV1AiConversationsMockHandler(),
  getGetV1AiConversationsIdMockHandler(),
  getPutV1AiConversationsIdMockHandler(),
  getDeleteV1AiConversationsIdMockHandler(),
  getPostV1AiConversationsConversationIdMessagesMockHandler(),
  getGetV1AiSearchMockHandler(),
  getPutV1AiConversationsBookmarkMockHandler(),
  getGetV1AiBookmarksMockHandler(),
  getPostV1SnippetsMockHandler(),
  getGetV1SnippetsMockHandler(),
  getGetV1SnippetsSearchMockHandler(),
  getGetV1SnippetsByQuestionQuestionIdMockHandler(),
  getGetV1SnippetsBySectionSectionIdMockHandler(),
  getGetV1SnippetsByStoryStoryIdMockHandler(),
  getGetV1SnippetsIdMockHandler(),
  getPutV1SnippetsIdMockHandler(),
  getDeleteV1SnippetsIdMockHandler(),
  getPutV1UserzProfileMockHandler(),
  getPostV1FeedbackMockHandler(),
  getGetV1AdminBackendMockHandler(),
  getGetV1AdminBackendUserzMockHandler(),
  getPostV1AdminBackendUserzMockHandler(),
  getPostV1SettingsClearStoriesMockHandler(),
  getPostV1SettingsResetAccountMockHandler(),
  getPostV1SettingsClearAiChatsMockHandler(),
  getPostV1SettingsClearTranslationPracticeHistoryMockHandler(),
  getGetV1AdminBackendUserzPaginatedMockHandler(),
  getPutV1AdminBackendUserzIdMockHandler(),
  getDeleteV1AdminBackendUserzIdMockHandler(),
  getPostV1AdminBackendUserzIdResetPasswordMockHandler(),
  getGetV1AdminBackendRolesMockHandler(),
  getGetV1AdminBackendUserzIdRolesMockHandler(),
  getPostV1AdminBackendUserzIdRolesMockHandler(),
  getDeleteV1AdminBackendUserzIdRolesRoleIdMockHandler(),
  getGetV1AdminBackendDashboardMockHandler(),
  getGetV1AdminBackendAiConcurrencyMockHandler(),
  getGetV1AdminWorkerStatusMockHandler(),
  getGetV1AdminWorkerDetailsMockHandler(),
  getPostV1AdminWorkerPauseMockHandler(),
  getPostV1AdminWorkerResumeMockHandler(),
  getPostV1AdminWorkerTriggerMockHandler(),
  getGetV1AdminWorkerLogsMockHandler(),
  getGetV1AdminWorkerAiConcurrencyMockHandler(),
  getGetV1AdminWorkerUsersMockHandler(),
  getPostV1AdminWorkerUsersPauseMockHandler(),
  getPostV1AdminWorkerUsersResumeMockHandler(),
  getGetV1AdminWorkerAnalyticsPriorityScoresMockHandler(),
  getGetV1AdminWorkerAnalyticsUserPerformanceMockHandler(),
  getGetV1AdminWorkerAnalyticsGenerationIntelligenceMockHandler(),
  getGetV1AdminWorkerAnalyticsSystemHealthMockHandler(),
  getGetV1AdminWorkerNotificationsStatsMockHandler(),
  getGetV1AdminWorkerNotificationsErrorsMockHandler(),
  getGetV1AdminWorkerNotificationsSentMockHandler(),
  getPostV1AdminWorkerNotificationsForceSendMockHandler(),
  getGetV1AdminBackendQuestionsMockHandler(),
  getGetV1AdminBackendQuestionsPaginatedMockHandler(),
  getGetV1AdminBackendQuestionsIdMockHandler(),
  getPutV1AdminBackendQuestionsIdMockHandler(),
  getDeleteV1AdminBackendQuestionsIdMockHandler(),
  getGetV1AdminBackendQuestionsIdUsersMockHandler(),
  getPostV1AdminBackendQuestionsIdAssignUsersMockHandler(),
  getPostV1AdminBackendQuestionsIdUnassignUsersMockHandler(),
  getPostV1AdminBackendQuestionsIdFixMockHandler(),
  getPostV1AdminBackendQuestionsIdAiFixMockHandler(),
  getPostV1AdminBackendClearUserDataMockHandler(),
  getPostV1AdminBackendClearDatabaseMockHandler(),
  getPostV1AdminBackendUserzIdClearMockHandler(),
  getGetV1AdminBackendUsageStatsMockHandler(),
  getGetV1AdminBackendUsageStatsServiceMockHandler(),
  getGetV1AdminBackendReportedQuestionsMockHandler(),
  getGetV1AdminBackendStoriesMockHandler(),
  getGetV1AdminBackendStoriesIdMockHandler(),
  getDeleteV1AdminBackendStoriesIdMockHandler(),
  getGetV1AdminBackendStorySectionsIdMockHandler(),
  getPostV1QuizChatStreamMockHandler(),
  getGetV1DailyQuestionsDateMockHandler(),
  getPostV1DailyQuestionsDateCompleteQuestionIdMockHandler(),
  getDeleteV1DailyQuestionsDateCompleteQuestionIdMockHandler(),
  getGetV1DailyDatesMockHandler(),
  getPostV1DailyQuestionsDateAnswerQuestionIdMockHandler(),
  getGetV1DailyProgressDateMockHandler(),
  getGetV1DailyHistoryQuestionIdMockHandler(),
  getGetV1WordOfDayDateMockHandler(),
  getGetV1WordOfDayMockHandler(),
  getGetV1WordOfDayEmbedMockHandler(),
  getGetV1WordOfDayDateEmbedMockHandler(),
  getGetV1WordOfDayHistoryMockHandler(),
  getPostV1StoryMockHandler(),
  getGetV1StoryMockHandler(),
  getGetV1StoryCurrentMockHandler(),
  getGetV1StoryIdMockHandler(),
  getDeleteV1StoryIdMockHandler(),
  getPostV1StoryIdGenerateMockHandler(),
  getPostV1StoryIdArchiveMockHandler(),
  getPostV1StoryIdCompleteMockHandler(),
  getPostV1StoryIdSetCurrentMockHandler(),
  getPostV1StoryIdToggleAutoGenerationMockHandler(),
  getGetV1StorySectionIdMockHandler(),
  getGetV1StoryIdExportMockHandler(),
  getGetV1PreferencesLearningMockHandler(),
  getPutV1PreferencesLearningMockHandler(),
  getGetV1VersionMockHandler(),
  getGetHealthMockHandler(),
  getGetV1AdminWorkerDailyUsersUserIdQuestionsDateMockHandler(),
  getPostV1AdminWorkerDailyUsersUserIdQuestionsDateRegenerateMockHandler(),
  getGetV1AdminBackendFeedbackMockHandler(),
  getDeleteV1AdminBackendFeedbackMockHandler(),
  getGetV1AdminBackendFeedbackIdMockHandler(),
  getPatchV1AdminBackendFeedbackIdMockHandler(),
  getDeleteV1AdminBackendFeedbackIdMockHandler(),
  getPostV1AdminBackendFeedbackIdLinearIssueMockHandler(),
  getPostV1ApiKeysMockHandler(),
  getGetV1ApiKeysMockHandler(),
  getDeleteV1ApiKeysIdMockHandler(),
  getGetV1ApiKeysTestReadMockHandler(),
  getPostV1ApiKeysTestWriteMockHandler(),
  getPostV1TranslateMockHandler(),
  getPostV1TranslationPracticeGenerateMockHandler(),
  getGetV1TranslationPracticeSentenceMockHandler(),
  getPostV1TranslationPracticeSubmitMockHandler(),
  getGetV1TranslationPracticeHistoryMockHandler(),
  getGetV1TranslationPracticeStatsMockHandler(),
  getPostV1AudioSpeechMockHandler(),
  getPostV1AudioSpeechInitMockHandler(),
  getGetV1AudioSpeechStreamStreamIdMockHandler()
]
